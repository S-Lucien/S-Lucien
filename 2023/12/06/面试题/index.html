<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>面试总结 | RippleSu's Blog</title><meta name="author" content="RippleSu"><meta name="copyright" content="RippleSu"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Java基础 Java特点：  面向对象 跨平台（Write once，run anywhere）：在程序运行前，Java源代码（.java）需要经过编译器编译成字节码（.class）。在程序运行时，JVM负责将字节码翻译成特定平台下的机器码并运行，也就是说，只要在不同的平台上安装对应的JVM，就可以运行字节码文件。 编译与解释并存   JVM、JDK、JRE  Java 虚拟机（JVM）是运行">
<meta property="og:type" content="article">
<meta property="og:title" content="面试总结">
<meta property="og:url" content="http://blog.ripplesu.top/2023/12/06/%E9%9D%A2%E8%AF%95%E9%A2%98/index.html">
<meta property="og:site_name" content="RippleSu&#39;s Blog">
<meta property="og:description" content="Java基础 Java特点：  面向对象 跨平台（Write once，run anywhere）：在程序运行前，Java源代码（.java）需要经过编译器编译成字节码（.class）。在程序运行时，JVM负责将字节码翻译成特定平台下的机器码并运行，也就是说，只要在不同的平台上安装对应的JVM，就可以运行字节码文件。 编译与解释并存   JVM、JDK、JRE  Java 虚拟机（JVM）是运行">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://img.ripplesu.top/random?dir=cover&%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93&type=cover">
<meta property="article:published_time" content="2023-12-06T14:22:04.000Z">
<meta property="article:modified_time" content="2023-12-06T14:54:40.399Z">
<meta property="article:author" content="RippleSu">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://img.ripplesu.top/random?dir=cover&%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93&type=cover"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://blog.ripplesu.top/2023/12/06/%E9%9D%A2%E8%AF%95%E9%A2%98/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: RippleSu","link":"链接: ","source":"来源: RippleSu's Blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '面试总结',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-12-06 22:54:40'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.0.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (false) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="http://121.41.55.70:9000/image-lib/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">17</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">19</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('http://img.ripplesu.top/random?dir=wallpaper')"><nav id="nav"><span id="blog-info"><a href="/" title="RippleSu's Blog"><span class="site-name">RippleSu's Blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">面试总结</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-12-06T14:22:04.000Z" title="发表于 2023-12-06 22:22:04">2023-12-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-12-06T14:54:40.399Z" title="更新于 2023-12-06 22:54:40">2023-12-06</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/">学习总结</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">142.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>453分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="面试总结"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h2><ul>
<li><p>Java特点：</p>
<ul>
<li>面向对象</li>
<li>跨平台（Write once，run anywhere）：在程序运行前，Java源代码（.java）需要经过编译器编译成字节码（.class）。在程序运行时，JVM负责将字节码翻译成特定平台下的机器码并运行，也就是说，只要在不同的平台上安装对应的JVM，就可以运行字节码文件。</li>
<li>编译与解释并存</li>
</ul>
</li>
<li><p>JVM、JDK、JRE</p>
<ul>
<li>Java 虚拟机（JVM）是运行 Java 字节码的虚拟机，负责将字节码翻译成特定平台下的机器码并运行。平台相关，针对不同系统有特定实现（Windows，Linux，macOS）</li>
<li>JRE（Java Runtime Environment） 是 Java 运行时环境，它包含运行已编译 Java 程序所需的所有内容，主要包括 Java 虚拟机（JVM）、Java 基础类库（Class Library）。</li>
<li>JDK（Java Development Kit），它是功能齐全的 Java SDK（软件开发工具包），是提供给开发者使用的，能够创建和编译 Java 程序。他包含了 JRE，同时还包含了编译 java 源码的编译器 javac 以及一些其他工具比如 javadoc（文档注释工具）、jdb（调试器）等等。</li>
</ul>
</li>
<li><p>基本数据类型</p>
<p><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="https://s2.loli.net/2023/05/14/c4yYReJ1ijFkErd.png" alt="image-20230514151139442"></p>
<ul>
<li><p>char能不能存中文？</p>
<p>UTF-8 中文3字节，所以不能；Unicode中文2字节</p>
</li>
</ul>
</li>
<li><p>基本类型和引用类型区别</p>
<ol>
<li>基本数据类型是直接将值存储在栈(stack)中的，而引用数据类型在栈中存储的是一个地址，这个地址指向堆(heap)中的实际数据。</li>
<li>基本数据类型有8种：byte、short、int、long、float、double、char、boolean，而引用数据类型有类(class)、接口(interface)、数组(array)、枚举(enum)等。</li>
<li>基本数据类型的默认值是0或false，而引用数据类型的默认值是null。</li>
<li><em>java是值传递；</em>值传递是指在调用方法时将实际参数拷贝一份传递到方法中，这样在方法中如果对参数进行修改，将不会影响到实际参数；当传的是基本类型时，传的是值的拷贝，对拷贝变量的修改不影响原变量；当传的是引用类型时，传的是<strong>引用地址的拷贝</strong>，但是拷贝的地址和真实地址指向的都是同一个真实数据，因此可以修改原变量中的值。</li>
</ol>
</li>
<li><p>为什么要有包装类型</p>
<p>Java中一切皆对象，但八种基本数据类型不具有对象的性质，在某些场合不能使用基本类型，比如集合中存放的都是Object。为了解决这些问题，就需要为每个基本数据类型都定义一个对应的引用类型，也就是包装类。</p>
</li>
<li><p>自动拆箱装箱</p>
<p>java帮助我们自动完成基本数据类型与对应包装类型的转换，也就是说可以把一个基本类型的数据直接赋值给对应的包装类型，可以把一个包装类型的对象直接赋值给对应的基本类型。</p>
<p>优点：简化了基本类型变量和包装类对象之间的转换过程。</p>
<p>缺点：频繁拆装箱影响性能；包装类的值可能是null，拆箱导致NullPointerException</p>
<p>原理：包装类的valueOf进行装箱，xxxValue进行拆箱</p>
<ul>
<li><code>Integer i = 10</code> 等价于 <code>Integer i = Integer.valueOf(10)</code></li>
<li><code>int n = i</code> 等价于 <code>int n = i.intValue()</code></li>
</ul>
<p><strong>int和Integer比较，Integer自动拆箱</strong></p>
<blockquote>
<p>parseInt返回的是int基础类型，valueOf返回的是Integer包装类型</p>
</blockquote>
</li>
<li><p>包装类型的缓存机制</p>
<p>Java 基本数据类型的包装类型的大部分都用到了缓存机制来提升性能。Byte,Short,Integer,Long 这 4 种包装类默认创建了数值 [-128，127] 的相应类型的缓存数据，Character 创建了数值在 [0,127] 范围的缓存数据，Boolean 直接返回 True or False。  </p>
<p>范围内的值会<strong>复用缓存中的对象</strong>，因此包装类需要用equals比较而不能用&#x3D;&#x3D;。</p>
</li>
<li><p>修饰符</p>
<p><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="https://s2.loli.net/2023/07/11/a2fDtpAxnvXBFRY.png" alt="Java修饰符"></p>
</li>
<li><p>重载和重写</p>
<ul>
<li><p>重载指同一个类内（或父子类间，子类可以重载父类非私有方法）<strong>同名不同参数</strong>的方法，与返回值与修饰符无关。</p>
</li>
<li><p>重写指子类覆盖从父类继承来的方法。子类重写的方法必须和父类被重写的方法具有<strong>相同的方法名称和参数列表</strong>。</p>
<ul>
<li><p>子类方法抛出的<strong>异常不能大于</strong>（不能是该异常父类）父类被重写方法的异常。</p>
</li>
<li><p>子类重写的方法的<strong>返回值类型不能大于</strong>父类被重写的方法的返回值类型。</p>
<ul>
<li>父类重写的方法的返回值类型是基本数据类型，子类被重写的方法的返回值类型必须是<strong>相同的基本数据类型</strong>。</li>
</ul>
</li>
<li><p>子类重写的方法使用的<strong>访问权限不能小于</strong>父类被重写的方法的访问权限。</p>
<ul>
<li>子类不能重写父类中声明为 private 权限的方法。</li>
</ul>
</li>
<li><p>构造方法不能重写：构造方法无法被继承</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>接口和抽象类的区别</p>
<ul>
<li>一个类可以实现多个接口，但只能继承一个抽象类。</li>
<li>接口主要定义了规范，对类的行为进行约束；抽象类用于继承以实现代码复用。</li>
<li>接口中的所有成员变量 为<code>public static final</code>， 不能被修改且必须有初始值。抽象类可以有普通成员变量。</li>
<li>java8前接口只能定义抽象方法，抽象类既可以定义抽象方法，也可以实现方法。（java8接口新增default方法和static方法）（默认都是public修饰。在以往开发中,接口只要增加了方法，所有实现类必须实现该方法，否则编译不通过。而default修饰的接口方法，实现类可以不做任何实现，默认调用接口的default方法。）</li>
<li>接口不含构造器。抽象类里可以包含构造器。</li>
<li>共同点：都不能被实例化；都可以有抽象方法，且子类必须实现抽象方法。</li>
<li><em>接口嵌套在类中时，可以定义为private</em>，private接口只能在当前类中使用；同理抽象类也可以。</li>
</ul>
</li>
<li><p>浅拷贝、深拷贝、引用拷贝</p>
<p><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="https://s2.loli.net/2023/05/15/jc58xepytqurDd3.png" alt="image-20230515170320389"></p>
<p>浅拷贝：在堆上创建一个新的对象，如果原对象内部的属性有引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。</p>
</li>
<li><p>强软弱虚引用</p>
</li>
</ul>
<h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><ul>
<li><p>Object类常用方法</p>
<ul>
<li>Class&lt;?&gt; getClass()：返回该对象的运行时类。</li>
<li>boolean equals(Object obj)：判断指定对象与该对象是否相等。</li>
<li>int hashCode()：返回该对象的hashCode值，HashMap等哈希表中会用到。在默认情况下，Object类的hashCode()方法根据该对象的地址来计算。但很多类都重写了Object类的hashCode()方法，不再根据地址来计算其hashCode()方法值。</li>
<li>String toString()：返回该对象的字符串表示，当程序使用System.out.println()方法输出一个对象，或者把某个对象和字符串进行连接运算时，系统会自动调用该对象的toString()方法返回该对象的字符串表示。Object类的toString()方法返回 运行时类名@十六进制hashCode值 格式的字符串，但很多类都重写了Object类的toString()方法，用于返回可以表述该对象信息的字符串。</li>
</ul>
<p>另外，Object类还提供了wait()、notify()、notifyAll()这几个方法，通过这几个方法可以控制线程的暂停和运行。Object类还提供了一个clone()方法，可以得到一个当前对象的副本，默认为浅拷贝。还有finalize方法，finalize方法的调用存在不确定性，也就是说，程序无法确定finalize方法何时会被调用。当一个对象没有引用的时候，对象的垃圾回收器会调用finalize方法。</p>
</li>
<li><p>notify和notifyAll</p>
<p>notify()和notifyAll()方法都必须在同步代码块中调用，并且必须包含在synchronized块中，且必须是该对象的监视器对象才能够调用。而且只有在获取了锁之后才能调用，否则会抛出IllegalMonitorStateException异常。</p>
<p>notify()方法只会唤醒等待队列中的<strong>一个</strong>线程，并使其与其他线程竞争获取锁，这可能会导致某些线程无法被唤醒或者一直处于等待状态。</p>
<p>notifyAll()方法则会唤醒等待队列中的<strong>所有</strong>线程，并使它们竞争获取锁，这样可以使所有线程都有机会获取锁并进入运行状态，从而避免了一些线程一直处于等待状态。</p>
</li>
<li><p>&#x3D;&#x3D;和equals</p>
<p>&#x3D;&#x3D;运算符：</p>
<ul>
<li>作用于基本数据类型时，是比较两个数值是否相等；</li>
<li>作用于引用数据类型时，是比较两个对象的内存地址是否相同，即判断它们是否为同一个对象；</li>
</ul>
<p>equals()方法：</p>
<ul>
<li>没有重写时，Object默认以 &#x3D;&#x3D; 来实现，即比较两个对象的内存地址是否相同；</li>
<li>进行重写后，一般会按照对象的内容来进行比较，若两个对象内容相同则认为对象相等，否则认为对象不等。</li>
</ul>
</li>
<li><p>为什么重写 equals() 时必须重写 hashCode() 方法</p>
<ul>
<li><strong>如果两个对象相等，则它们必须有相同的哈希码</strong>。</li>
<li><strong>如果两个对象有相同的哈希码，则它们未必相等</strong>。</li>
</ul>
<p>hashcode与equals都是用来比较对象是否相等。hashcode帮助我们在散列表中快速找到元素的位置、判断元素是否相等。</p>
<p>以<code>HashMap</code>为例，执行put时，先通过 key 的 <code>hashcode</code> 经过hash方法处理过后得到 hash 值，然后通过 <code>(数组长度 - 1) &amp; hash</code> 判断当前元素存放的位置，如果对应位置为空，则直接放入；存在元素的话，就先判断该元素与要存入的元素的 hash 值是否相等，再用’&#x3D;&#x3D;’或equals()判断key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</p>
<p><strong>如果重写 <code>equals()</code> 时没有重写 <code>hashCode()</code> 方法的话，就可能会导致 <code>equals</code> 方法判断是相等的两个key，<code>hashCode</code> 值却不相等。HashMap在判断key是否相等时是先用hash值（int）进行比较，hash值不等就判断两个key不等。而hash值是通过hashcode计算得到的。所以在使用<code>HashMap</code>时就可能出现key相同但散列位置不同，也就是出现重复的key</strong>。</p>
<p>以<code>HashSet</code>为例，当你把对象加入 <code>HashSet</code> 时，<code>HashSet</code> 会先计算对象的 <code>hashCode</code> 值来判断对象加入的位置，同时也会与其他已经加入的对象的 <code>hashCode</code> 值作比较，如果没有相符的 <code>hashCode</code>，<code>HashSet</code> 会假设对象没有重复出现。但是如果发现有相同 <code>hashCode</code> 值的对象，这时会调用 <code>equals()</code> 方法来检查 <code>hashCode</code> 相等的对象是否真的相同。如果两者相同，<code>HashSet</code> 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置（在 JDK1.8 中，<code>HashSet</code>的<code>add()</code>方法只是简单的调用了<code>HashMap</code>的<code>put()</code>方法，并且判断了一下返回值以确保是否有重复元素。）。这样我们就大大减少了 <code>equals</code> 的次数，相应就大大提高了执行速度。</p>
</li>
</ul>
<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><ul>
<li><p>String常用方法</p>
<ul>
<li>char charAt(int index)：返回指定索引处的字符；</li>
<li>String substring(int beginIndex, int endIndex)：从此字符串中截取出一部分子字符串；</li>
<li>String[] split(String regex)：以指定的规则将此字符串分割成数组；</li>
<li>String trim()：删除字符串前导和后置的空格；</li>
<li>int indexOf(String str)：返回子串在此字符串首次出现的索引；</li>
<li>toLowerCase、toUpperCase</li>
</ul>
</li>
<li><p>String为什么不可变（immutable）</p>
<ul>
<li>保存字符串的数组被 <code>final</code> 修饰，初始化后就不可变</li>
<li><code>final</code>可以保证整个数组的引用地址不可变，但数组内的元素是可变的。而数组同时也用private修饰，并且String类没有修改数组的方法。</li>
<li><code>String</code> 类被 <code>final</code> 修饰导致其不能被继承，进而避免了子类破坏 <code>String</code> 不可变。</li>
</ul>
<p>不可变的好处：</p>
<p>\1. 字符串不可变性：由于String类是final的，因此它的值不能被修改，这就保证了字符串的不可变性。这是Java中的一项重要特性，因为它可以使得字符串常量池更有效率地管理和重用字符串对象。</p>
<p>\2. 安全性：由于字符串是不可变的，因此可以避免由于在多个线程中修改字符串而导致的同步问题。这意味着在并发环境中使用字符串时不需要额外的同步措施，从而提高了应用程序的安全性。</p>
<p>\3. 优化性能：由于字符串是不可变的，因此它们可以被缓存和重用（相同对象只需要拷贝地址。如果是可变的，修改一个对象将影响所有对象），这可以显著提高Java应用程序的性能。例如，Java的字符串常量池会缓存相同的字符串对象，从而避免了创建大量重复的字符串对象。</p>
<p>\4. 没有子类：由于String类是final的，因此不能被其他类继承，这可以防止其他类覆盖String类的方法并引入潜在的问题。这可以提高代码的稳定性和可靠性。</p>
</li>
<li><p>String、StringBuilder、StringBuffer</p>
<ul>
<li>首先String不可变，另外两个可变。Java9之前（9之后为byte[]）都用字符数组存放字符串，但String中用private final修饰，且没有提供修改字符串的方法。<code>StringBuilder</code> 与 <code>StringBuffer</code> 都继承自 <code>AbstractStringBuilder</code> 类，在 <code>AbstractStringBuilder</code> 中也是使用字符数组保存字符串，不过没有使用 <code>final</code> 和 <code>private</code> 关键字修饰，并且 <code>AbstractStringBuilder</code> 类还提供了很多修改字符串的方法比如 <code>append</code> 、<code>insert</code>等方法。</li>
<li>从线程安全角度讲，<code>String</code> 中的字符数组是不可变的，因此是线程安全。StringBuffer线程安全（通过synchronize），StringBuilder不是，因此性能略高。</li>
</ul>
</li>
<li><p>字符串拼接</p>
<ul>
<li>运算符：如果拼接的都是字符串直接量，则适合使用 + 运算符实现拼接；<ul>
<li>如果拼接的都是字符串直接量，则在编译时编译器会将其直接优化为一个完整的字符串（常量折叠），所以效率非常的高。</li>
<li>如果拼接的字符串中包含变量，则在编译时编译器采用StringBuilder对其进行优化，即自动创建StringBuilder实例并调用其append()方法，将这些字符串拼接在一起，效率也很高。但如果这个拼接操作是在循环中进行的，那么每次循环编译器都会创建一个StringBuilder实例，再去拼接字符串，相当于执行了 new StringBuilder().append(str)，所以此时效率很低。</li>
</ul>
</li>
<li>StringBuilder：如果拼接的字符串中包含变量，并不要求线程安全，则适合使用StringBuilder；+ </li>
<li>StringBuffer：如果拼接的字符串中包含变量，并且要求线程安全，则适合使用StringBuffer；</li>
<li>String类的concat方法：如果只是对两个字符串进行拼接，并且包含变量，则适合使用concat方法；<ul>
<li>先创建一个足以容纳待拼接的两个字符串的字节数组，然后先后将两个字符串拼到这个数组里，最后将此数组转换为字符串。</li>
</ul>
</li>
</ul>
</li>
<li><p>字符串反转？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;str&quot;</span>);</span><br><span class="line">sb.reverse();</span><br></pre></td></tr></table></figure>
</li>
<li><p>String s1 &#x3D; new String(“abc”);这句话创建了几个字符串对象？</p>
<ul>
<li><p>如果字符串常量池中不存在字符串对象“abc”，那么会在堆中创建 2 个字符串对象“abc”，其中一个放入常量池，另一个是常量池中那个的引用。</p>
</li>
<li><p>如果字符串常量池中已存在字符串对象“abc”，就复用常量池中已有的”abc”，将其引用赋值给变量s1。</p>
</li>
</ul>
</li>
<li><p>String s&#x3D;”a”+”b”+”c”+”d”;创建了几个对象？</p>
<p>一个。编译期常量折叠优化。</p>
</li>
<li><p>String的equals方法是怎么比的？</p>
<ol>
<li>先用双等号比较，如果内存地址相等即返回true</li>
<li>比较两个字符串长度，长度不等，返回false</li>
<li>如果长度相等，依次比较字符串中的每个字符是否相等</li>
</ol>
</li>
</ul>
<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><ul>
<li><p>介绍一下异常</p>
<p>异常包括Error和Exception，他们都继承自Throwable（类）。</p>
<p>Error是错误，常见error包括StackOverflow、OutOfMemory等，这种错误将导致程序终止，通常程序无法处理这些错误，因此不建议使用catch块来捕获Error对象（可以捕获），也无须在其throws子句中声明该方法可能抛出Error及其任何子类。</p>
<p>Exception是程序可以处理的异常，它分为Checked异常和Unchecked异常两大类。RuntimeException类及其子类都是Unchecked异常，常见的包括空指针异常、算术异常、数组越界异常等等，这类异常不处理也可以通过编译。而Checked异常都可以被处理，如果程序没有显式处理Checked异常，该程序在编译时就会发生错误，无法通过编译。这类异常主要包括IOException、SQLException、ClassNotFoundException等。</p>
</li>
<li><p>finally</p>
<ul>
<li>不管try块中的代码是否出现异常，也不管哪一个catch块被执行，甚至在try块或catch块中执行了return语句，finally块总会被执行。除非在finally执行前使用 System.exit(); 来退出虚拟机，或finally执行前线程就终止了。</li>
<li>一旦在finally块中使用了return、throw语句，将会导致try块、catch块中的return、throw语句失效。</li>
<li>假如try中有异常抛出，则会去执行catch块，再去执行finally块；假如没有catch 块，可以直接执行finally 块，方法就以抛出异常的方式结束，而finally 后的内容也不会被执行，所以catch 和 finally 不能同时省略。</li>
</ul>
</li>
</ul>
<h3 id="static-final"><a href="#static-final" class="headerlink" title="static&#x2F;final"></a>static&#x2F;final</h3><p>以static修饰的成员就是类成员，它属于整个类，而不属于单个实例对象；类成员不能访问实例成员；static修饰的类可以被继承。</p>
<ul>
<li>静态方法为什么不能调用非静态成员</li>
</ul>
<p>​		静态方法是属于类的，在<strong>类加载</strong>的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，需要通过类的实例对象去访问。在类的非静态成员不存在的时候静态方法就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。</p>
<ul>
<li><p>静态内部类</p>
<p>如果使用static来修饰一个内部类，则这个内部类就属于外部类本身，而不属于外部类的某个对象。外部类的上一级程序单元是包，所以不可使用static修饰。</p>
<p>静态内部类的创建不依赖于外部类的实例，因此它<strong>可以像普通类一样被创建和使用</strong></p>
<p>静态内部类的优点是：</p>
<ol>
<li>它可以隐藏实现细节，仅在外部类内部使用，提高代码的封装性；</li>
<li>它可以作为外部类的静态成员，对外部类的成员进行封装，提高代码的可读性和可维护性；</li>
<li>它可以在不创建外部类实例的情况下创建内部类实例，减少对象的创建和内存开销；</li>
</ol>
<p>静态内部类需满足如下规则：</p>
<ol>
<li><p>静态内部类可以包含静态成员，也可以包含非静态成员；</p>
</li>
<li><p>静态内部类不能访问外部类的实例成员，只能访问它的静态成员；</p>
</li>
<li><p>外部类的所有方法、初始化块都能访问其内部定义的静态内部类；</p>
</li>
<li><p>在外部类的外部，也可以实例化静态内部类，语法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">外部类.内部类 变量名 = <span class="keyword">new</span> 外部类.内部类构造方法();</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>静态初始化块</p>
<p>静态初始化块也被称为<strong>类初始化块</strong>，也属于类的静态成员，同样需要遵循静态成员不能访问非静态成员的规则，因此静态初始化块不能访问非静态成员，包括不能访问实例变量和实例方法</p>
<p>与普通初始化块类似的是，系统在类初始化阶段执行静态初始化块时，不仅会执行本类的静态初始化块，而且还会一直上溯到 java.lang.Object 类(如果它包含静态初始化块)，先执行 java .lang.Object类的静态初始化块(如果有)，然后执行其父类的静态初始化块……最后才执行该类的静态初始化块，经过这个过程，才完成了该类的初始化过程。</p>
</li>
<li><p>Java程序初始化顺序：</p>
<ol>
<li>父类的静态代码块</li>
<li>子类的静态代码块</li>
<li>父类的普通代码块</li>
<li>父类的构造方法</li>
<li>子类的普通代码块</li>
<li>子类的构造方法</li>
</ol>
</li>
<li><p>static和final</p>
<p>static关键字可以修饰<strong>成员</strong>变量、成员方法、初始化块、内部类，被static修饰的成员是类的成员，它属于类、不属于单个对象。以下是static修饰这4种成员时表现出的特征：</p>
<ul>
<li><p>类变量：被static修饰的成员变量叫类变量（静态变量）。类变量属于类，它随类的信息存储在方法区，并不随对象存储在堆中，类变量可以通过类名来访问，也可以通过对象名来访问，但建议通过类名访问它。</p>
</li>
<li><p>类方法：被static修饰的成员方法叫类方法（静态方法）。类方法属于类，可以通过类名访问，也可以通过对象名访问，建议通过类名访问它。</p>
<blockquote>
<p>问题：静态方法中的++i有线程安全问题吗</p>
<p>访问静态方法不会自动加锁，所以仍会有线程安全问题。</p>
</blockquote>
</li>
<li><p>静态块：被static修饰的初始化块叫静态初始化块。静态块属于类，它在类加载的时候被隐式调用一次，之后便不会被调用了。</p>
</li>
<li><p>静态内部类：被static修饰的内部类叫静态内部类。静态内部类可以包含静态成员，也可以包含非静态成员。静态内部类不能访问外部类的实例成员，只能访问外部类的静态成员。外部类的所有方法、初始化块都能访问其内部定义的静态内部类。</p>
<p>注：内部类是懒加载，即使用时才加载</p>
</li>
</ul>
<p>final关键字可以修饰类、方法、变量（成员、局部），以下是final修饰这3种目标时表现出的特征：</p>
<ul>
<li><p>final类：final关键字修饰的类不可以被继承。</p>
</li>
<li><p>final方法：final关键字修饰的方法不可以被重写。</p>
</li>
<li><p>final变量：final关键字修饰的变量，一旦获得了初始值，就不可以被修改。</p>
</li>
<li><p>变量分为成员变量、局部变量。</p>
<p>final修饰成员变量：</p>
<ul>
<li>类变量：可以在声明变量时指定初始值，也可以在静态初始化块中指定初始值；</li>
<li>实例变量：可以在<strong>声明</strong>变量时指定初始值，也可以在<strong>初始化块</strong>或<strong>构造方法</strong>中指定初始值；</li>
</ul>
<p>final修饰局部变量：</p>
<ul>
<li>可以在声明变量时指定初始值，也可以在后面的代码中指定初始值。</li>
</ul>
<p><em>注意：被 final 修饰的任何形式的变量，一旦获得了初始值，就不可以被修改！</em></p>
</li>
</ul>
</li>
</ul>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><ul>
<li><p>说说对泛型的理解</p>
<p>就是指在类定义时不指定类中的属性或方法参数的具体类型，而是在实例化时再进行类型的定义。</p>
<p>java引入泛型前，当需要从集合中获取元素时，只知道它是Object，而不知道具体的类型，因此取出元素后通常需要进行强制类型转换；但在转换时很可能发生ClassCastException，因为集合中可能放入了其他类型的元素。</p>
<p>引入泛型后，集合内只能存对应类型的对象，取出元素时就不需要手动进行类型转换。也可以避免把其他类型放入集合导致强制类型转换时引发ClassCastException。</p>
</li>
<li><p>泛型（类型）擦除</p>
<p>Java的泛型其实是伪泛型，在编译的阶段，会进行泛型擦除。简单来说，就是编译时，就将其替换成具体的类型。替换的规则是，替换为声明该泛型形参时指定的第一个上限类型，没有指定就设置成Object。</p>
<p>Java的泛型使用”擦除”实现，是为了兼容老版本的Java编译器和虚拟机，因为泛型的实现需要改变Java的类文件格式。</p>
</li>
<li><p>java泛型<code>&lt;T&gt;</code>和<code>&lt;?&gt;</code>区别</p>
<p>在Java中，泛型是一种参数化类型的机制，用于在编译时提供类型安全和代码复用。泛型有两种常见的使用方式：使用尖括号和类型参数（如<code>&lt;T&gt;</code>）定义泛型类型，或者使用通配符（如<code>&lt;?&gt;</code>）表示未知类型。</p>
<ol>
<li><code>&lt;T&gt;</code> 泛型类型参数：<ul>
<li><code>&lt;T&gt;</code> 是一种泛型类型参数的定义方式，<code>T</code> 是一个占位符，表示可以在使用泛型时指定的具体类型。</li>
<li>使用 <code>&lt;T&gt;</code> 可以创建泛型类、泛型方法或泛型接口，以便在实例化或调用时指定具体的类型。</li>
<li>例如，<code>List&lt;T&gt;</code> 表示一个可以存储任意类型的列表，<code>T</code> 在实例化时可以被具体的类型替代，如 <code>List&lt;Integer&gt;</code> 或 <code>List&lt;String&gt;</code>。</li>
</ul>
</li>
<li><code>&lt;?&gt;</code> 通配符：<ul>
<li><code>&lt;?&gt;</code> 是一种通配符类型，表示未知类型，常用于泛型方法的参数、泛型类的成员变量或通配符限定。</li>
<li><code>&lt;?&gt;</code> 表示可以接受任意类型的参数，但在方法内部无法对其进行修改或获取具体类型信息。</li>
<li>例如，<code>List&lt;?&gt;</code> 表示一个未知类型的列表，可以接受任何类型的元素。</li>
</ul>
</li>
</ol>
<p>区别：</p>
<ul>
<li><code>&lt;T&gt;</code> 是一个具体的类型参数，可以在实例化或调用时指定具体的类型，提供了更严格的类型检查和更灵活的代码复用。</li>
<li><code>&lt;?&gt;</code> 是一个通配符，表示未知类型，可以接受任意类型的参数，但在方法内部无法对其进行修改或获取具体类型信息，提供了更大的灵活性和泛化能力。</li>
</ul>
<p>需要注意的是，<code>&lt;T&gt;</code> 和 <code>&lt;?&gt;</code> 可以在不同的上下文中使用，并且还有其他通配符的形式，如<code>&lt;? extends T&gt;</code> 和 <code>&lt;? super T&gt;</code>，用于更精确地限定泛型类型的范围。具体使用哪种形式取决于你的需求和上下文。</p>
</li>
</ul>
<h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p>反射就是在运行时可以获取任意一个类的信息，创建类的实例、访问类的方法、访问实例对象的属性等等。</p>
<ul>
<li><p>优点：</p>
<ul>
<li><p>运行期判断类型，动态加载类，提高代码灵活度。</p>
</li>
<li><p>提高代码复用率，比如动态代理就是用了反射实现</p>
</li>
<li><p>可以在运行时获取任意一个类的方法，属性，并且还能通过反射动态调用</p>
</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li><p><strong>性能开销</strong>：相比于直接调用方法或访问字段，使用反射机制进行方法调用和字段访问通常会导致性能开销增加。这是因为反射需要在运行时进行动态查找和解析，而不是直接通过编译时的静态绑定进行优化。因此，使用反射可能会导致程序的执行速度变慢。</p>
</li>
<li><p><strong>安全性问题</strong>：反射机制可以绕过访问控制符（例如 private、protected），并访问和修改对象的私有成员。这可能会破坏封装性和安全性，导致不可预料的行为。如果不小心使用反射机制，可能会引入安全漏洞。</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><strong>代码可读性降低</strong>：反射机制可以使代码更加复杂和难以理解。由于反射是在运行时进行动态操作，代码的逻辑和结构可能变得更加难以捉摸。这会增加代码维护的难度，并且可能导致代码的可读性降低。<ul>
<li><strong>编译时检查的缺失</strong>：使用反射时，一些编译时的错误只能在运行时才能被发现。例如，如果在反射调用方法时传递了错误的参数类型，只有在运行时才会抛出异常。这使得调试和排查问题变得更加困难。</li>
</ul>
</li>
</ul>
<ul>
<li><p>应用场景：</p>
<ul>
<li>使用JDBC时，如果要创建数据库的连接，则需要先通过反射机制（Class.forName()）加载数据库的驱动程序；</li>
<li>多数框架都支持注解&#x2F;XML配置，从配置中解析出来的类是字符串，需要利用反射机制实例化；</li>
<li>面向切面编程（AOP）的实现方案，是在程序运行时创建目标对象的代理类，这必须由反射机制来实现。</li>
</ul>
</li>
<li><p>Field 类：提供有关类的属性信息，以及对它的动态访问权限。它是一个封装反射类的属性的类。</p>
<p>Constructor 类：提供有关类的构造方法的信息，以及对它的动态访问权限。它是一个封装反射类的构造方法的类。 </p>
<p>Method 类：提供关于类的方法的信息，包括抽象方法。它是用来封装反射类方法的一个类。</p>
<p>Class 类：表示正在运行的 Java 应用程序中的类的实例。</p>
<p>Object 类：Object 是所有 Java 类的父类。所有对象都默认实现了 Object 类的方法。</p>
</li>
<li><p>调用步骤</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.反射得到类对象</span></span><br><span class="line">Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="comment">// 2.得到方法</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clazz.getDeclaredMethod(<span class="string">&quot;method&quot;</span>);</span><br><span class="line"><span class="comment">// 设置私有方法可访问</span></span><br><span class="line">method.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="comment">// 执行私有方法</span></span><br><span class="line">method.invoke(clazz.getDeclaredConstructor().newInstance());</span><br><span class="line"><span class="comment">// 执行静态方法</span></span><br><span class="line">staticMethod.invoke(clazz);</span><br><span class="line"><span class="comment">// 得到属性</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="comment">// 设置私有属性可访问</span></span><br><span class="line">field.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="comment">// 得到属性值</span></span><br><span class="line"><span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> (<span class="type">int</span>) field.get(clazz.getDeclaredConstructor().newInstance());</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><ul>
<li>序列化机制可以将对象转换成字节流，这些字节流可以保存在磁盘上，也可以在网络中传输，并允许程序将这些字节流再次恢复成原来的对象。作用：保证对象的完整性和可传递性，可以跨平台、跨语言传递对象。</li>
<li>若对象要支持序列化机制，则它的类需要实现Serializable接口，该接口是一个标记接口，它没有提供任何方法，只是标明该类是可以序列化的，Java的很多类已经实现了Serializable接口，如包装类、String、Date等。</li>
<li>若要实现序列化，则需要使用对象流ObjectInputStream和ObjectOutputStream。其中，在序列化时需要调用ObjectOutputStream对象的writeObject()方法，以输出对象序列。在反序列化时需要调用ObjectInputStream对象的readObject()方法，将对象序列恢复为对象。</li>
<li>被transient修饰的数据不能进行序列化</li>
<li><code>static</code> 变量因为不属于任何对象(Object)，所以无论有没有 <code>transient</code> 关键字修饰，均不会被序列化。</li>
<li><code>serialVersionUID</code> 起版本控制的作用。反序列化时，会检查 <code>serialVersionUID</code> 是否和当前类的 <code>serialVersionUID</code> 一致。如果 <code>serialVersionUID</code> 不一致则会抛出 <code>InvalidClassException</code> 异常。</li>
<li>其他序列化工具？<ul>
<li>JSON：简单直观，可读性好，但性能一般较差</li>
<li>Protobuf：支持多种语言诸如C++、Java以及Python语言，二进制存储</li>
<li>Kryo：只支持Java，二进制存储</li>
</ul>
</li>
</ul>
<h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><p>本质上是一个继承了Annotation接口的特殊接口，可以看作是一种特殊的注释，主要用于修饰类、方法或者变量，提供某些信息供程序在编译或者运行时使用。</p>
<ul>
<li><p>5个元注解</p>
<ul>
<li>@ Retention用来定义该注解在哪一个级别可用，在源代码中(SOURCE)、类文件中(CLASS)或者运行时(RUNTIME)。</li>
<li>@Documented：生成文档信息的时候保留注解</li>
<li>@Target：用于描述注解的使用范围</li>
<li>@Inherited：说明子类可以继承父类中的该注解</li>
<li>@Repeatable 表示注解可以重复使用。</li>
</ul>
</li>
<li><p>注解作用</p>
<p>注解可以提供一些额外的信息，这些信息可以给编译器，使得编译器在编译过程中可以对代码进行检查或处理。例如，@Override注解用于指示方法应该覆盖父类中的方法，如果没有正确覆盖，编译器会产生警告或错误；也可以在运行时被读取和处理，从而改变程序的行为。</p>
</li>
<li><p>注解的解析方法有哪几种？</p>
<p>注解只有被解析之后才会生效，常见的解析方法有两种：</p>
<ul>
<li><strong>编译期直接扫描</strong>：编译器在编译 Java 代码的时候扫描对应的注解并处理，比如某个方法使用<code>@Override</code> 注解，编译器在编译的时候就会检测当前的方法是否重写了父类对应的方法。</li>
<li><strong>运行期通过反射处理</strong>：像框架中自带的注解(比如 Spring 框架的 <code>@Value</code>、<code>@Component</code>)都是通过反射来进行处理的。</li>
</ul>
</li>
</ul>
<h3 id="语法糖"><a href="#语法糖" class="headerlink" title="语法糖"></a>语法糖</h3><ul>
<li>switch支持String与枚举</li>
<li>for-each</li>
<li>try-with-resource</li>
<li>自动拆装箱</li>
</ul>
<h3 id="其他常见问题"><a href="#其他常见问题" class="headerlink" title="其他常见问题"></a>其他常见问题</h3><ul>
<li><p>创建对象的方式？</p>
<p>new、序列化和反序列化、</p>
<p>反射：通过Class.forName获取类对象，然后调用它的newInstance方法</p>
<p>克隆：调用Object的clone方法（需要实现cloneable接口）</p>
</li>
<li><p>浮点数精度怎么解决</p>
<p>BigDecimal：底层用BigInteger存数值，用int值scale存小数位数</p>
</li>
</ul>
<h3 id="Java8特性"><a href="#Java8特性" class="headerlink" title="Java8特性"></a>Java8特性</h3><h4 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 返回一个串行流</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">default</span> Stream&lt;E&gt; <span class="title function_">stream</span><span class="params">()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 返回一个并行流</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">default</span> Stream&lt;E&gt; <span class="title function_">parallelStream</span><span class="params">()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 返回T的流</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title function_">of</span><span class="params">(T t)</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 返回其元素是指定值的顺序流。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title function_">of</span><span class="params">(T... values)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Arrays.stream(values);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 过滤，返回由与给定predicate匹配的该流的元素组成的流</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Stream&lt;T&gt; <span class="title function_">filter</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> T&gt; predicate)</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 此流的所有元素是否与提供的predicate匹配。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">allMatch</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> T&gt; predicate)</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 此流任意元素是否有与提供的predicate匹配。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">anyMatch</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> T&gt; predicate)</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 使用 Collector对此流的元素进行归纳</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&lt;R, A&gt; R <span class="title function_">collect</span><span class="params">(Collector&lt;? <span class="built_in">super</span> T, A, R&gt; collector)</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回此流中的元素数。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">count</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 返回由该流的不同元素（根据 Object.equals(Object) ）组成的流。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Stream&lt;T&gt; <span class="title function_">distinct</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 遍历</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">forEach</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; action)</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 用于获取指定数量的流，截短长度不能超过 maxSize 。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Stream&lt;T&gt; <span class="title function_">limit</span><span class="params">(<span class="type">long</span> maxSize)</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 用于映射每个元素到对应的结果</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&lt;R&gt; Stream&lt;R&gt; <span class="title function_">map</span><span class="params">(Function&lt;? <span class="built_in">super</span> T, ? extends R&gt; mapper)</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* flatMap()简单来说就是将多个stream流合并成一个stream</span></span><br><span class="line"><span class="comment">List&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;();</span></span><br><span class="line"><span class="comment">List&lt;Integer&gt; collect = lists.stream().flatMap(item -&gt;  item.stream().filter(Objects::nonNull))</span></span><br><span class="line"><span class="comment">                .collect(Collectors.toList());</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 根据提供的 Comparator进行排序。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Stream&lt;T&gt; <span class="title function_">sorted</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> T&gt; comparator)</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 在丢弃流的第一个 n元素后，返回由该流的 n元素组成的流。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Stream&lt;T&gt; <span class="title function_">skip</span><span class="params">(<span class="type">long</span> n)</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 返回一个包含此流的元素的数组。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Object[] toArray();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 使用提供的 generator函数返回一个包含此流的元素的数组，以分配返回的数组，以及分区执行或调整大小可能需要的任何其他数组。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&lt;A&gt; A[] toArray(IntFunction&lt;A[]&gt; generator);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 合并流</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Stream&lt;T&gt; <span class="title function_">concat</span><span class="params">(Stream&lt;? extends T&gt; a, Stream&lt;? extends T&gt; b)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Java-IO"><a href="#Java-IO" class="headerlink" title="Java IO"></a>Java IO</h2><h3 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h3><p>IO 即 <code>Input/Output</code>，输入和输出。数据输入到计算机内存的过程即输入，反之输出到外部存储（比如数据库，文件，远程主机）的过程即输出。数据传输过程类似于水流，因此称为 IO 流。IO 流在 Java 中分为输入流和输出流，而根据数据的处理方式又分为字节流和字符流。</p>
<p>Java IO 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。</p>
<ul>
<li><code>InputStream</code>&#x2F;<code>Reader</code>: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li>
<li><code>OutputStream</code>&#x2F;<code>Writer</code>: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</li>
</ul>
<h4 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h4><h5 id="InputStream（字节输入流）"><a href="#InputStream（字节输入流）" class="headerlink" title="InputStream（字节输入流）"></a>InputStream（字节输入流）</h5><p><code>InputStream</code>用于从源头（通常是文件）读取数据（字节信息）到内存中，<code>java.io.InputStream</code>抽象类是所有字节输入流的父类。</p>
<p><code>InputStream</code> 常用方法：</p>
<ul>
<li><code>read()</code>：返回输入流中下一个字节的数据。返回的值介于 0 到 255 之间。如果未读取任何字节，则代码返回 <code>-1</code> ，表示文件结束。</li>
<li><code>read(byte b[ ])</code> : 从输入流中读取一些字节存储到数组 <code>b</code> 中。如果数组 <code>b</code> 的长度为零，则不读取。如果没有可用字节读取，返回 <code>-1</code>。如果有可用字节读取，则最多读取的字节数最多等于 <code>b.length</code> ， 返回读取的字节数。这个方法等价于 <code>read(b, 0, b.length)</code>。</li>
<li><code>read(byte b[], int off, int len)</code>：在<code>read(byte b[ ])</code> 方法的基础上增加了 <code>off</code> 参数（偏移量）和 <code>len</code> 参数（要读取的最大字节数）。</li>
<li><code>skip(long n)</code>：忽略输入流中的 n 个字节 ,返回实际忽略的字节数。</li>
<li><code>available()</code>：返回输入流中可以读取的字节数。</li>
<li><code>close()</code>：关闭输入流释放相关的系统资源。</li>
</ul>
<p><code>FileInputStream</code> 是一个比较常用的字节输入流对象，可直接指定文件路径，可以直接读取单字节数据，也可以读取至字节数组中。通常会配合 <code>BufferedInputStream</code>来使用。</p>
<p>像下面这段代码在我们的项目中就比较常见，我们通过 <code>readAllBytes()</code> 读取输入流所有字节并将其直接赋值给一个 <code>String</code> 对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新建一个 BufferedInputStream 对象</span></span><br><span class="line"><span class="type">BufferedInputStream</span> <span class="variable">bufferedInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;input.txt&quot;</span>));</span><br><span class="line"><span class="comment">// 读取文件的内容并复制到 String 对象中</span></span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bufferedInputStream.readAllBytes());</span><br><span class="line">System.out.println(result);</span><br></pre></td></tr></table></figure>

<p><code>DataInputStream</code> 用于读取指定类型数据，不能单独使用，必须结合其它流，比如 <code>FileInputStream</code> 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;input.txt&quot;</span>);</span><br><span class="line"><span class="comment">//必须将fileInputStream作为构造参数才能使用</span></span><br><span class="line"><span class="type">DataInputStream</span> <span class="variable">dataInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(fileInputStream);</span><br><span class="line"><span class="comment">//可以读取任意具体的类型数据</span></span><br><span class="line">dataInputStream.readBoolean();</span><br><span class="line">dataInputStream.readInt();</span><br><span class="line">dataInputStream.readUTF();</span><br></pre></td></tr></table></figure>

<p><code>ObjectInputStream</code> 用于从输入流中读取 Java 对象（反序列化），<code>ObjectOutputStream</code> 用于将对象写入到输出流(序列化)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ObjectInputStream</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;object.data&quot;</span>));</span><br><span class="line"><span class="type">MyClass</span> <span class="variable">object</span> <span class="operator">=</span> (MyClass) input.readObject();</span><br><span class="line">input.close();</span><br></pre></td></tr></table></figure>

<p>另外，用于序列化和反序列化的类必须实现 <code>Serializable</code> 接口，对象中如果有属性不想被序列化，使用 <code>transient</code> 修饰。</p>
<h5 id="OutputStream"><a href="#OutputStream" class="headerlink" title="OutputStream"></a>OutputStream</h5><p><code>OutputStream</code> 常用方法：</p>
<ul>
<li><code>write(int b)</code>：将特定字节写入输出流。</li>
<li><code>write(byte b[ ])</code> : 将数组<code>b</code> 写入到输出流，等价于 <code>write(b, 0, b.length)</code> 。</li>
<li><code>write(byte[] b, int off, int len)</code> : 在<code>write(byte b[ ])</code> 方法的基础上增加了 <code>off</code> 参数（偏移量）和 <code>len</code> 参数（要读取的最大字节数）。</li>
<li><code>flush()</code>：刷新此输出流并强制写出所有缓冲的输出字节。</li>
<li><code>close()</code>：关闭输出流释放相关的系统资源。</li>
</ul>
<p><code>FileOutputStream</code> 是最常用的字节输出流对象，可直接指定文件路径，可以直接输出单字节数据，也可以输出指定的字节数组。</p>
<p><code>FileOutputStream</code> 代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">FileOutputStream</span> <span class="variable">output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;output.txt&quot;</span>)) &#123;</span><br><span class="line">    <span class="type">byte</span>[] array = <span class="string">&quot;JavaGuide&quot;</span>.getBytes();</span><br><span class="line">    output.write(array);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h4><p>不管是文件读写还是网络发送接收，信息的最小存储单元都是字节。 <strong>那为什么 I&#x2F;O 流操作要分为字节流操作和字符流操作呢？</strong></p>
<p>个人认为主要有两点原因：</p>
<ul>
<li>字符流是由 Java 虚拟机将字节转换得到的，这个过程还算是比较耗时。</li>
<li>如果我们不知道编码类型就很容易出现乱码问题。</li>
</ul>
<p>乱码问题这个很容易就可以复现，我们只需要将上面提到的 <code>FileInputStream</code> 代码示例中的 <code>input.txt</code> 文件内容改为中文即可，原代码不需要改动。</p>
<p>因此，I&#x2F;O 流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。如果音频文件、图片等媒体文件用字节流比较好，如果涉及到字符的话使用字符流比较好。</p>
<p>字符流默认采用的是 <code>Unicode</code> 编码，我们可以通过构造方法自定义编码。顺便分享一下之前遇到的笔试题：常用字符编码所占字节数？<code>utf8</code> :英文占 1 字节，中文占 3 字节，<code>unicode</code>：任何字符都占 2 个字节，<code>gbk</code>：英文占 1 字节，中文占 2 字节。</p>
<h5 id="Reader（字符输入流）"><a href="#Reader（字符输入流）" class="headerlink" title="Reader（字符输入流）"></a>Reader（字符输入流）</h5><p><code>Reader</code>用于从源头（通常是文件）读取数据（字符信息）到内存中，<code>java.io.Reader</code>抽象类是所有字符输入流的父类。</p>
<p><code>Reader</code> 用于读取文本， <code>InputStream</code> 用于读取原始字节。</p>
<p><code>Reader</code> 常用方法：</p>
<ul>
<li><code>read()</code> : 从输入流读取一个字符。</li>
<li><code>read(char[] cbuf)</code> : 从输入流中读取一些字符，并将它们存储到字符数组 <code>cbuf</code>中，等价于 <code>read(cbuf, 0, cbuf.length)</code> 。</li>
<li><code>read(char[] cbuf, int off, int len)</code>：在<code>read(char[] cbuf)</code> 方法的基础上增加了 <code>off</code> 参数（偏移量）和 <code>len</code> 参数（要读取的最大字符数）。</li>
<li><code>skip(long n)</code>：忽略输入流中的 n 个字符 ,返回实际忽略的字符数。</li>
<li><code>close()</code> : 关闭输入流并释放相关的系统资源。</li>
</ul>
<p><code>InputStreamReader</code> 是字节流转换为字符流的桥梁，其子类 <code>FileReader</code> 是基于该基础上的封装，可以直接操作字符文件。</p>
<h5 id="Writer（字符输出流）"><a href="#Writer（字符输出流）" class="headerlink" title="Writer（字符输出流）"></a>Writer（字符输出流）</h5><p><code>Writer</code>用于将数据（字符信息）写入到目的地（通常是文件），<code>java.io.Writer</code>抽象类是所有字符输出流的父类。</p>
<p><code>Writer</code> 常用方法：</p>
<ul>
<li><code>write(int c)</code> : 写入单个字符。</li>
<li><code>write(char[] cbuf)</code>：写入字符数组 <code>cbuf</code>，等价于<code>write(cbuf, 0, cbuf.length)</code>。</li>
<li><code>write(char[] cbuf, int off, int len)</code>：在<code>write(char[] cbuf)</code> 方法的基础上增加了 <code>off</code> 参数（偏移量）和 <code>len</code> 参数（要读取的最大字符数）。</li>
<li><code>write(String str)</code>：写入字符串，等价于 <code>write(str, 0, str.length())</code> 。</li>
<li><code>write(String str, int off, int len)</code>：在<code>write(String str)</code> 方法的基础上增加了 <code>off</code> 参数（偏移量）和 <code>len</code> 参数（要读取的最大字符数）。</li>
<li><code>append(CharSequence csq)</code>：将指定的字符序列附加到指定的 <code>Writer</code> 对象并返回该 <code>Writer</code> 对象。</li>
<li><code>append(char c)</code>：将指定的字符附加到指定的 <code>Writer</code> 对象并返回该 <code>Writer</code> 对象。</li>
<li><code>flush()</code>：刷新此输出流并强制写出所有缓冲的输出字符。</li>
<li><code>close()</code>:关闭输出流释放相关的系统资源。</li>
</ul>
<p><code>OutputStreamWriter</code> 是字符流转换为字节流的桥梁，其子类 <code>FileWriter</code> 是基于该基础上的封装，可以直接将字符写入到文件。</p>
<ul>
<li><p>FileInputStream 和 FileWriter 读取文件时中文乱码问题</p>
<p>可能原因：读取本地磁盘中的文件是GBK编码，而读取的方式是UTF-8。文件是UTF-8编码，但是读取文件的类java文件是GBK方式，也会导致乱码。<br>解决方法：使用InputStreamReader 中带编码方式参数的构造器创建对象读取文件数据 （InputStreamReader的使用可以查看api文档或者百度案例）</p>
</li>
<li><p>javaIO流文件写出出现乱码是什么原因，怎么处理？</p>
<p>原因可能是<em>系统向目标文件写入时所使用的编码与目标文件自身的编码不同</em>。</p>
<p>解决办法：FileWriter构造时指定编码。</p>
<p>FileWriter的构造函数可以接受一个charset参数，以指定编码格式。常见的编码格式包括UTF-8、GB2312、GBK、ISO8859-1等等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">   <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> <span class="string">&quot;testEncoding.txt&quot;</span>;</span><br><span class="line">   <span class="type">String</span> <span class="variable">charset</span> <span class="operator">=</span> <span class="string">&quot;UTF-8&quot;</span>;</span><br><span class="line">   <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="string">&quot;中文字符测试&quot;</span>;</span><br><span class="line">   <span class="comment">//指定编码格式UTF-8</span></span><br><span class="line">   <span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(fileName, Charset.forName(charset));</span><br><span class="line">   fw.write(content);</span><br><span class="line">   fw.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="字节缓冲流"><a href="#字节缓冲流" class="headerlink" title="字节缓冲流"></a>字节缓冲流</h4><p>IO 操作是很消耗性能的，缓冲流将数据加载至缓冲区，一次性读取&#x2F;写入多个字节，从而避免频繁的 IO 操作，提高流的传输效率。</p>
<p>字节缓冲流这里采用了装饰器模式来增强 <code>InputStream</code> 和<code>OutputStream</code>子类对象的功能。</p>
<p>举个例子，我们可以通过 <code>BufferedInputStream</code>（字节缓冲输入流）来增强 <code>FileInputStream</code> 的功能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新建一个 BufferedInputStream 对象</span></span><br><span class="line"><span class="type">BufferedInputStream</span> <span class="variable">bufferedInputStream</span> <span class="operator">=</span> </span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;input.txt&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>字节流和字节缓冲流的性能差别主要体现在我们使用两者的时候都是调用 <code>write(int b)</code> 和 <code>read()</code> 这两个一次只读取一个字节的方法的时候。由于字节缓冲流内部有缓冲区（字节数组），因此，字节缓冲流会先将读取到的字节存放在缓存区，大幅减少 IO 次数，提高读取效率。</p>
<ul>
<li><p>BufferedInputStream（字节缓冲输入流）</p>
<p><code>BufferedInputStream</code> 从源头（通常是文件）读取数据（字节信息）到内存的过程中不会一个字节一个字节的读取，而是会先将读取到的字节存放在缓存区，并从内部缓冲区中单独读取字节。这样大幅减少了 IO 次数，提高了读取效率。</p>
<p><code>BufferedInputStream</code> 内部维护了一个缓冲区，这个缓冲区实际就是一个字节数组。</p>
</li>
<li><p>BufferedOutputStream（字节缓冲输出流）</p>
</li>
</ul>
<h4 id="字符缓冲流"><a href="#字符缓冲流" class="headerlink" title="字符缓冲流"></a>字符缓冲流</h4><p><code>BufferedReader</code> （字符缓冲输入流）和 <code>BufferedWriter</code>（字符缓冲输出流）类似于 <code>BufferedInputStream</code>（字节缓冲输入流）和<code>BufferedOutputStream</code>（字节缓冲输入流），内部都维护了一个字节数组作为缓冲区。不过，前者主要是用来操作字符信息。</p>
<h3 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h3><h4 id="BIO、NIO、AIO"><a href="#BIO、NIO、AIO" class="headerlink" title="BIO、NIO、AIO"></a>BIO、NIO、AIO</h4><ul>
<li><p>BIO (Blocking I&#x2F;O)<br>BIO 属于同步阻塞 IO 模型 。同步阻塞 IO 模型中，应用程序发起 read 调用后，会一直阻塞，直到内核把数据拷贝到用户空间。</p>
<p><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="https://s2.loli.net/2023/06/20/W9VrPBbg2ynItu4.png" alt="BIO"></p>
</li>
<li><p>NIO</p>
<p>同步非阻塞 IO 模型中，应用程序会一直发起 read 调用，等待数据从内核空间拷贝到用户空间的这段时间里，线程依然是阻塞的，直到在内核把数据拷贝到用户空间。</p>
<p><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="https://s2.loli.net/2023/06/20/QbVluM5sAS39i7x.png" alt="NIO"></p>
<p>相比于同步阻塞 IO 模型，同步非阻塞 IO 模型确实有了很大改进。通过轮询操作，避免了一直阻塞。</p>
<p>但是，这种 IO 模型同样存在问题：<strong>应用程序不断进行 I&#x2F;O 系统调用轮询数据是否已经准备好的过程是十分消耗 CPU 资源的。</strong></p>
<p>这个时候，<strong>I&#x2F;O 多路复用模型</strong> 就上场了。</p>
<p><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="https://s2.loli.net/2023/06/20/OB1C3IZyfLFPH7j.png" alt="IO多路复用"></p>
<p>IO 多路复用模型中，线程首先发起 select 调用，询问内核数据是否准备就绪，等内核把数据准备好了，用户线程再发起 read 调用。read 调用的过程（数据从内核空间 -&gt; 用户空间）还是阻塞的。</p>
<blockquote>
<p>目前支持 IO 多路复用的系统调用，有 select，epoll 等等。select 系统调用，目前几乎在所有的操作系统上都有支持。</p>
<ul>
<li><strong>select 调用</strong>：内核提供的系统调用，它支持一次查询多个系统调用的可用状态。几乎所有的操作系统都支持。</li>
<li><strong>epoll 调用</strong>：linux 2.6 内核，属于 select 调用的增强版本，优化了 IO 的执行效率。</li>
</ul>
</blockquote>
<p><strong>IO 多路复用模型，通过减少无效的系统调用，减少了对 CPU 资源的消耗。</strong></p>
<p>Java 中的 NIO ，有一个非常重要的<strong>选择器 ( Selector )</strong> 的概念，也可以被称为 <strong>多路复用器</strong>。通过它，只需要一个线程便可以管理多个客户端连接。当客户端数据到了之后，才会为其服务。</p>
</li>
<li><h3 id="AIO-Asynchronous-I-O"><a href="#AIO-Asynchronous-I-O" class="headerlink" title="AIO (Asynchronous I&#x2F;O)"></a>AIO (Asynchronous I&#x2F;O)</h3><p>AIO 也就是 NIO 2。Java 7 中引入了 NIO 的改进版 NIO 2,它是异步 IO 模型。</p>
<p>异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。</p>
<p><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="https://s2.loli.net/2023/06/20/RImdJGl8gLwtTED.png" alt="AIO"></p>
</li>
</ul>
<h2 id="Java集合"><a href="#Java集合" class="headerlink" title="Java集合"></a>Java集合</h2><p>Java 集合，主要是由两大接口派生而来：一个是 <code>Collection</code>接口，主要用于存放单一元素，包括<code>List</code>、<code>Set</code> 和 <code>Queue</code>；另一个是 <code>Map</code> 接口，主要用于存放键值对。</p>
<p><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="https://s2.loli.net/2023/05/18/4EYwlI8PfNuHiMZ.png" alt="Java 集合框架概览"></p>
<p><code>List</code>: 存储的元素是有序的、可重复的。</p>
<p><code>Set</code>: 存储的元素是无序的（有有序的实现类）、不可重复的。</p>
<p><code>Queue</code>: 按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。</p>
<p><code>Map</code>: 使用键值对（key-value）存储，key 是无序的、不可重复的，value 是无序的、可重复的。</p>
<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><ul>
<li><code>ArrayList</code>：<code>Object[]</code> 数组，无参构造初始化时是一个空数组，第一次插入元素时创建大小为10的数组，超出限制时会增加50%的容量，并且数据以 System.arraycopy() 复制到新的数组。</li>
<li><code>Vector</code>：<code>Object[]</code> 数组</li>
<li><code>LinkedList</code>：<strong>双向</strong>链表</li>
</ul>
<h4 id="ArrayList-和-Array（数组）的区别？"><a href="#ArrayList-和-Array（数组）的区别？" class="headerlink" title="ArrayList 和 Array（数组）的区别？"></a>ArrayList 和 Array（数组）的区别？</h4><p><code>ArrayList</code> 内部基于动态数组实现，比 <code>Array</code>（静态数组） 使用起来更加灵活：</p>
<ul>
<li><code>ArrayList</code>会根据实际存储的元素动态地扩容或缩容，而 <code>Array</code> 被创建之后就不能改变它的长度了。</li>
<li><code>ArrayList</code> 允许你使用泛型来确保类型安全，<code>Array</code> 则不可以。</li>
<li><code>ArrayList</code> 中只能存储对象。对于基本类型数据，需要使用其对应的包装类（如 Integer、Double 等）。<code>Array</code> 可以直接存储基本类型数据，也可以存储对象。</li>
<li><code>ArrayList</code> 支持插入、删除、遍历等常见操作，并且提供了丰富的 API 操作方法，比如 <code>add()</code>、<code>remove()</code>等。<code>Array</code> 只是一个固定长度的数组，只能按照下标访问其中的元素，不具备动态添加、删除元素的能力。</li>
<li><code>ArrayList</code>创建时不需要指定大小，而<code>Array</code>创建时必须指定大小。</li>
</ul>
<h4 id="ArrayList-插入和删除元素的时间复杂度？"><a href="#ArrayList-插入和删除元素的时间复杂度？" class="headerlink" title="ArrayList 插入和删除元素的时间复杂度？"></a>ArrayList 插入和删除元素的时间复杂度？</h4><ul>
<li>头部插入&#x2F;删除：由于需要将所有元素都依次向后&#x2F;前移动一个位置，因此时间复杂度是 O(n)。</li>
<li>尾部插入：当 <code>ArrayList</code> 的容量未达到极限时，往列表末尾插入元素的时间复杂度是 O(1)，因为它只需要在数组末尾添加一个元素即可；当容量已达到极限并且需要扩容时，则需要执行一次 O(n) 的操作将原数组复制到新的更大的数组中，然后再执行 O(1) 的操作添加元素。</li>
<li>尾部删除：当删除的元素位于列表末尾时，时间复杂度为 O(1)。</li>
<li>指定位置插入&#x2F;删除：需要将目标位置之后的所有元素都向后&#x2F;前移动一个位置，这个过程需要移动平均 n&#x2F;2 个元素，因此时间复杂度为 O(n)。</li>
</ul>
<h4 id="LinkedList-插入和删除元素的时间复杂度？"><a href="#LinkedList-插入和删除元素的时间复杂度？" class="headerlink" title="LinkedList 插入和删除元素的时间复杂度？"></a>LinkedList 插入和删除元素的时间复杂度？</h4><ul>
<li>头部插入&#x2F;删除：只需要修改头结点的指针即可完成插入&#x2F;删除操作，因此时间复杂度为 O(1)。</li>
<li>尾部插入&#x2F;删除：只需要修改尾结点的指针即可完成插入&#x2F;删除操作，因此时间复杂度为 O(1)。</li>
<li>指定位置插入&#x2F;删除：需要先移动到指定位置，再修改指定节点的指针完成插入&#x2F;删除，因此需要移动平均 n&#x2F;2 个元素，时间复杂度为 O(n)。</li>
</ul>
<h4 id="LinkedList-为什么不能实现-RandomAccess-接口？"><a href="#LinkedList-为什么不能实现-RandomAccess-接口？" class="headerlink" title="LinkedList 为什么不能实现 RandomAccess 接口？"></a>LinkedList 为什么不能实现 RandomAccess 接口？</h4><p><code>RandomAccess</code> 是一个标记接口，用来表明实现该接口的类支持随机访问（即可以通过索引快速访问元素）。由于 <code>LinkedList</code> 底层数据结构是链表，内存地址不连续，只能通过指针来定位，不支持随机快速访问，所以不能实现 <code>RandomAccess</code> 接口</p>
<h4 id="ArrayList-与-LinkedList-区别"><a href="#ArrayList-与-LinkedList-区别" class="headerlink" title="ArrayList 与 LinkedList 区别?"></a>ArrayList 与 LinkedList 区别?</h4><ul>
<li><p><code>ArrayList</code> 底层使用的是 <strong><code>Object</code> 数组</strong>；而<code>LinkedList</code> 底层使用的是 <strong>双向链表</strong> 数据结构</p>
</li>
<li><p>那么在插入和删除时：</p>
<ul>
<li><code>ArrayList</code> 除了在尾部追加或删除元素复杂度为O(1)，其他位置都是O(n)，因为需要执行后移或前移操作（插入元素可能还需要扩容，然后拷贝元素）。</li>
<li>而<code>LinkedList</code> 在头尾插入或者删除元素时间复杂度都是 O(1)，如果是要在中间的指定位置插入和删除元素的话， 时间复杂度为 O(n) ，因为需要先定位到指定位置再插入和删除。</li>
</ul>
</li>
<li><p><strong>从随机访问的角度来说：</strong> <code>ArrayList</code>（实现了 <code>RandomAccess</code> 接口） 可以通过元素的下标快速获取对应位置的元素对象(对应于<code>get(int index)</code>方法)。 而<code>LinkedList</code> 因为是链表，地址空间不连续，故不支持。</p>
</li>
<li><p><strong>从内存空间占用：</strong><code>LinkedList</code>空间占用一般更大，因为每个节点都需要存前驱和后继两个引用； <code>ArrayList</code> 的空间浪费主要体现在在 list 列表的结尾会预留一定的容量空间。</p>
</li>
<li><p>插入海量数据，谁快？</p>
<p><strong>如果头插选linkedlist（ArrayList需要移动大量元素）,如果中间和尾部插入要选Arraylist（数组越大，每次扩容扩充的容量越大，扩容对性能影响越小）</strong></p>
</li>
</ul>
<h4 id="谈谈CopyOnWriteArrayList的原理"><a href="#谈谈CopyOnWriteArrayList的原理" class="headerlink" title="谈谈CopyOnWriteArrayList的原理"></a>谈谈CopyOnWriteArrayList的原理</h4><p>ArrayList进行add时不加锁。CopyOnWriteArrayList是Java并发包里提供的并发类，简单来说它就是一个<strong>线程安全且读操作无锁</strong>的ArrayList。正如其名字一样，在<strong>写操作时会复制一份新的List，在新的List上完成写操作，然后再将原引用指向新的List</strong>。这样就保证了写操作的线程安全。</p>
<ul>
<li>优点：读操作性能很高，因为无需任何同步措施，比较适用于读多写少的并发场景。在遍历传统的List时，若中途有别的线程对其进行修改，则会抛出ConcurrentModificationException异常。而CopyOnWriteArrayList由于其”读写分离”的思想，遍历和修改操作分别作用在不同的List容器，所以在使用迭代器进行遍历时候，也就不会抛出ConcurrentModificationException异常了。</li>
<li>缺点：一是内存占用问题，毕竟每次执行写操作都要将原容器拷贝一份，数据量大时，对内存压力较大，可能会引起频繁GC。二是无法保证实时性，Vector对于读写操作均加锁同步，可以保证读和写的强一致性。而CopyOnWriteArrayList由于其实现策略的原因，写和读分别作用在新老不同容器上，在写操作执行过程中，读不会阻塞但读取到的却是老容器的数据。</li>
</ul>
<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>HashSet是基于HashMap实现的，默认构造函数是构建一个初始容量为16，负载因子为0.75 的HashMap。它封装了一个 HashMap 对象来存储所有的集合元素，所有放入 HashSet 中的集合元素实际上由 HashMap 的 key 来保存，而 HashMap 的 value 则存储了一个 PRESENT，它是一个静态的 Object 对象。</p>
<h4 id="比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同"><a href="#比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同" class="headerlink" title="比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同"></a>比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同</h4><ul>
<li><code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 都是 <code>Set</code> 接口的实现类，都能保证元素唯一，并且都不是线程安全的。</li>
<li><code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 的主要区别在于底层数据结构不同。<code>HashSet</code> 的底层数据结构是哈希表（基于 <code>HashMap</code> 实现）。<code>LinkedHashSet</code> 的底层数据结构是链表和哈希表，元素的插入和取出顺序满足 FIFO。<code>TreeSet</code> 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序。</li>
<li>底层数据结构不同又导致这三者的应用场景不同。<code>HashSet</code> 用于不需要保证元素插入和取出顺序的场景，<code>LinkedHashSet</code> 用于保证元素的插入和取出顺序满足 FIFO 的场景，<code>TreeSet</code> 用于支持对元素自定义排序规则的场景</li>
</ul>
<h4 id="定制排序"><a href="#定制排序" class="headerlink" title="定制排序"></a>定制排序</h4><ul>
<li><p>重写CompareTo</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Person&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * T重写compareTo方法实现按年龄来排序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Person o)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.age - o.getAge();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>重写Compare</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(arrayList, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> o1 - o2;<span class="comment">//o1 &gt; o2，则o2排在o1前，即降序</span></span><br><span class="line">        <span class="comment">// return o2.compareTo(o1);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><h4 id="ArrayDeque-与-LinkedList-的区别"><a href="#ArrayDeque-与-LinkedList-的区别" class="headerlink" title="ArrayDeque 与 LinkedList 的区别"></a>ArrayDeque 与 LinkedList 的区别</h4><p><code>ArrayDeque</code> 和 <code>LinkedList</code> 都实现了 <code>Deque</code> 接口，两者都具有队列的功能，但两者有什么区别呢？</p>
<ul>
<li><code>ArrayDeque</code> 是基于可变长的数组和双指针来实现，而 <code>LinkedList</code> 则通过链表来实现。</li>
<li><code>ArrayDeque</code> 不支持存储 <code>NULL</code> 数据，但 <code>LinkedList</code> 支持。</li>
<li><code>ArrayDeque</code> 插入时可能存在扩容过程, 不过均摊后的插入操作依然为 O(1)。虽然 <code>LinkedList</code> 不需要扩容，但是每次插入数据时均需要申请新的堆空间，均摊性能相比更慢。</li>
</ul>
<p>从性能的角度上，选用 <code>ArrayDeque</code> 来实现队列要比 <code>LinkedList</code> 更好。</p>
<h4 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h4><p><code>BlockingQueue</code> （阻塞队列）是一个接口，继承自 <code>Queue</code>。<code>BlockingQueue</code>阻塞的原因是其支持当队列没有元素时一直阻塞，直到有元素；还支持如果队列已满，一直等到队列可以放入新元素时再放入。</p>
<p><code>BlockingQueue</code> 常用于生产者-消费者模型中，生产者线程会向队列中添加数据，而消费者线程会从队列中取出数据进行处理。</p>
<p>常见实现类：</p>
<ul>
<li><p><code>ArrayBlockingQueue</code>：使用数组实现的有界阻塞队列。</p>
</li>
<li><p><code>LinkedBlockingQueue</code>：使用单向链表实现的可选有界阻塞队列。</p>
</li>
</ul>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><h4 id="HashMap底层实现"><a href="#HashMap底层实现" class="headerlink" title="HashMap底层实现"></a>HashMap底层实现</h4><p>JDK1.8 之前 <code>HashMap</code> 底层是 <strong>数组，用拉链法解决Hash冲突</strong>。HashMap是懒加载的，第一次执行put时，会进行第一次扩容，初始化大小默认为16。put时，先把 key 的 <code>hashcode</code> 经过hash方法处理过后得到 hash 值，然后通过 <code>(n - 1) &amp; hash</code> 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果对应位置为空，则直接放入；存在元素的话，就先判断该元素的key与要存入的元素的 key的hash 值是否相等，相等再用&#x3D;&#x3D;或equals判断两个key是否相同，如果相同就直接覆盖，不相同就通过拉链法解决冲突。</p>
<p>因为链表查询复杂度是O（n），JDK1.8后引入红黑树（红黑树就是为了解决二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构）。</p>
<p>当链表长度大于等于阈值（默认为 8），先判断数组长度是否小于64，如是则执行一次扩容，否则将链表转化为红黑树。当树的节点数小于6的时候，红黑树又会退化成链表。</p>
<p>当HashMap的元素个数大于数组长度*负载因子的时候，也会执行扩容。负载因子默认是0.75，主要是时间和空间的权衡。如果负载因子太大，虽然空间利用率高了，但hash碰撞的可能性也高了，查询效率也就低了；负载因子太小，空间利用率就低了。</p>
<p>扩容时，会把数组容量扩充到原来两倍。扩容时将原hash表数据全部重新计算hash值，重新分配位置。之所以按2的幂次扩容，主要是为了让元素分布更加均匀，减少Hash冲突。因为HashMap计算数组下标时用“ <code>(n - 1) &amp; hash</code>”（n 代表数组长度），若数组长度为2的幂次，其二进制表示为全1，与运算只有二者都为1的时候其运算结果才是1，如果n-1的二进制表示其中一位是0，那么对应位的与运算结果只能是0，也就是说数组中一定会有无法散列到的位置。</p>
<ul>
<li><p>哈希冲突</p>
<p>开放寻址法：当遇到哈希冲突时，需要使用一种探测技术来寻找下一个可用的哈希槽。最简单的探测技术是线性探测，即从发生冲突的槽开始，逐一扫描直到找到一个空闲槽。</p>
<p>开放寻址法查找过程如下：</p>
<ul>
<li>计算关键字的哈希值</li>
<li>从哈希槽的位置开始查找，如果该位置存储的关键字与目标关键字相同，则找到了对应数据</li>
<li>如果该位置存储的关键字不是目标关键字，则按照相应的探测方式继续查找</li>
<li>如果查找到最后一个哈希槽仍未找到目标数据，则说明目标数据不存在于哈希表中</li>
</ul>
<p>为什么不用开放寻址？</p>
<p>元素较多时，可能连续冲突</p>
</li>
</ul>
<h4 id="为什么用红黑树"><a href="#为什么用红黑树" class="headerlink" title="为什么用红黑树"></a>为什么用红黑树</h4><p>红黑树是近似平衡的二叉树，不像AVL树，AVL 树是严格的平衡树，上述的最短路径与最长路径的差不能超过 1，AVL 允许的差值小；在进行大量插入和删除操作时，会频繁地进行平衡调整，严重降低效率；但查询时AVL略快于红黑树。</p>
<p>B&#x2F;B+树更矮胖，适用于数据存储在磁盘上的场景，如索引，可以减少磁盘IO次数。如果数据在内存中，查询性能低于红黑树，且在数据量不是很多的情况下，数据都会“挤在”一个结点里面。这个时候遍历效率就退化成了链表。</p>
<ul>
<li><p>为什么不用二叉查找树？</p>
<p>（1）若左子树不空，则左子树上所有结点的值均小于它的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%A0%B9%E7%BB%93%E7%82%B9/9795570?fromModule=lemma_inlink">根结点</a>的值；</p>
<p>（2）若右<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%AD%90%E6%A0%91/1624505?fromModule=lemma_inlink">子树</a>不空，则右子树上所有结点的值均大于它的根结点的值；</p>
<p>（3）左、右子树也分别为二叉查找（排序）树；</p>
<p>缺点：不保持平衡，可能退化为链表</p>
<p>红黑树介于AVL树和二叉查找树之间，是近似平衡的二叉树，既可以避免退化成链表，又不需要频繁进行平衡性调整，性能相对较好</p>
</li>
</ul>
<ul>
<li><p>为什么不用跳表？</p>
<p>HashMap 的 各个Entry 之间并没有内在的排序关系。跳表需要元素之间存在排序关系，否则就无法跳跃查找</p>
<p>Java中也有跳表的应用：ConcurrentSkipListMap，是一个有序的map，可以看做是TreeMap的并发实现</p>
</li>
</ul>
<h4 id="树化阈值为什么是8"><a href="#树化阈值为什么是8" class="headerlink" title="树化阈值为什么是8"></a>树化阈值为什么是8</h4><p>如果 hashCode 分布良好，也就是 hash 计算的结果离散好的话，那么红黑树这种形式是很少会被用到的，因为各个值都均匀分布，很少出现链表很长的情况。在理想情况下，链表长度符合泊松分布，各个长度的命中概率依次递减，<strong>当长度为 8 的时候，概率仅为 0.00000006</strong>。这是一个小于千万分之一的概率，通常我们的 Map 里面是不会存储这么多的数据的，所以通常情况下，并不会发生从链表向红黑树的转换。</p>
<blockquote>
<p>在链表长度为6时，从红黑树退化为链表。因为红黑树的平衡维护成本较高，数据量小时性能还不如链表</p>
</blockquote>
<h4 id="Hash方法的作用"><a href="#Hash方法的作用" class="headerlink" title="Hash方法的作用"></a>Hash方法的作用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HashMap的数组默认长度是16，因为大多数情况来说数组长度都不会太大，所以影响 h &amp; (length-1)计算结果的主要因素就是h的低位数据。比如只有当数组长度length大于2^16即大于65536的时候，h的高16位才会对 h &amp; (length-1)的计算结果产生影响，所以在HashMap中我们也主要对h的低16位进行优化（异或运算结果等于1和0的概率是一样的），也就是让h的低16位的数据尽量分散，上面的 (h &#x3D; key.hashCode()) ^ (h &gt;&gt;&gt; 16)算法也是基于这个目的而设计的。</p>
<h4 id="HashMap的put流程"><a href="#HashMap的put流程" class="headerlink" title="HashMap的put流程"></a>HashMap的put流程</h4><ol>
<li><p>首次扩容：</p>
<p>先判断数组是否为空（懒加载，初始为空），若数组为空则进行第一次扩容（resize，初始化大小为16）；</p>
</li>
<li><p>计算索引：</p>
<p>通过hash算法，根据key的hashcode计算得到hash值，再用hash &amp; (数组长度 - 1)计算得到数据下标，即键值对在数组中的位置；</p>
</li>
<li><p>插入数据：</p>
<ul>
<li>如果当前位置元素为空，则直接插入数据；</li>
<li>如果当前位置元素非空，且key已存在（hash值相等并且 &#x3D;&#x3D; || equals），则直接覆盖其value；</li>
<li>如果当前位置元素非空，且key不存在，则将数据链到链表末端；</li>
<li>若链表长度达到8，先判断数组长度是否小于64，如是则执行resize扩容，否则将链表转化为红黑树</li>
</ul>
</li>
<li><p>再次扩容</p>
<p>如果数组中元素个数（size）超过threshold，则再次进行扩容操作。</p>
</li>
</ol>
<h4 id="HashMap的get流程"><a href="#HashMap的get流程" class="headerlink" title="HashMap的get流程"></a>HashMap的get流程</h4><p>步骤1：首先对传入值keya进行hash运算，依然是高位和地位进行^运算，得到的hash值和n-1进行&amp;运算，最终得到索引值</p>
<ul>
<li>为什么用&amp;？ 效果与%n一致，但更高效</li>
</ul>
<p>步骤2：首先判断该数组是否为空，是否长度为0，当前索引位置的第一个元素是否为null，满足任意一个条件返回null，结束</p>
<p>步骤3：将传入值key的hash值与当前索引位第一个元素的hash值进行比较，一样则继续比较是否为相同引用（&#x3D;&#x3D;），或者equals是否相等，若相等，返回其value,结束。</p>
<p>步骤4：不相等的话，会出现两种可能性，如果当前索引位置后面还有元素，则可能在后面，如果没有元素了，直接退出，返回null，结束。</p>
<p>步骤5：当前索引位置不止1个元素的情况下，首先判断，当前索引位置的第一个节点是否为树节点，如果是树节点，在红黑树里面进行遍历。</p>
<p>步骤6：如果不是树节点，那么就是链表，在while中进行遍历，判断当前元素是否传入值相等，不等则循环到链表的最后一个元素为止。相等则返回该value.</p>
<h4 id="HashMap长度为什么是2的幂次"><a href="#HashMap长度为什么是2的幂次" class="headerlink" title="HashMap长度为什么是2的幂次"></a>HashMap长度为什么是2的幂次</h4><p>HashMap计算数组下标时用“ <code>(n - 1) &amp; hash</code>”（n 代表数组长度），若数组长度为2的幂次，其二进制表示为全1，与运算只有二者都为1的时候其运算结果才是1，如果n-1的二进制表示其中一位是0，那么对应位的与运算结果只能是0，也就是说数组中一定会有无法散列到的位置。所以为了尽量使数据分布更加均匀，减少Hash碰撞，hashmap的长度最好是2的幂次。</p>
<p>注：如果初始化容量不是2的幂次，会设置为<strong>大于</strong>这个数的最近的2的幂次</p>
<h4 id="HashMap为什么线程不安全"><a href="#HashMap为什么线程不安全" class="headerlink" title="HashMap为什么线程不安全"></a>HashMap为什么线程不安全</h4><ul>
<li><p>并发put操作有数据覆盖的风险。	</p>
<p>两个线程 1,2 同时进行 put 操作，hash 函数计算出的插入下标是相同的，并且对应位置为空。假设当前线程 1 执行完哈希冲突判断后，由于时间片耗尽而回到就绪态。而后线程 2 获得时间片先完成了插入操作。随后，线程 1 获得时间片，由于之前已经进行过 hash 碰撞的判断，所有此时会直接进行插入，这就导致线程 2 插入的数据被线程 1 覆盖了</p>
</li>
<li><p>JDK1.8前，扩容时有死循环的风险（简单来说，头插法在并发情况下rehash时可能导致环形链表）。</p>
<p>JDK1.7 及之前版本的 <code>HashMap</code> 在多线程环境下扩容操作可能存在死循环问题，这是由于当一个桶位中有多个元素需要进行扩容时，多个线程同时对链表进行操作，头插法可能会导致链表中的节点指向错误的位置，从而形成一个<strong>环形链表</strong>，进而使得查询元素的操作陷入死循环无法结束。</p>
<p>为了解决这个问题，JDK1.8 版本的 HashMap 采用了<strong>尾插法</strong>而不是头插法来避免链表倒置，使得插入的节点永远都是放在链表的末尾，避免了链表中的环形结构。但是还是不建议在多线程下使用 <code>HashMap</code>，因为多线程下使用 <code>HashMap</code> 还是会存在数据覆盖的问题。并发环境下，推荐使用 <code>ConcurrentHashMap</code> 。</p>
</li>
</ul>
<h4 id="HashMap遍历"><a href="#HashMap遍历" class="headerlink" title="HashMap遍历"></a>HashMap遍历</h4><p>HashMap <strong>遍历从大的方向来说，可分为以下 4 类</strong>：</p>
<ol>
<li><p>迭代器（Iterator）方式遍历（可以动态的删除元素）；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">*<span class="comment">// 创建并赋值 HashMap*</span></span><br><span class="line">Map&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">*<span class="comment">// 遍历*</span></span><br><span class="line">Iterator&lt;Integer&gt; iterator = map.keySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">  <span class="type">Integer</span> <span class="variable">key</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">  System.out.println(key);</span><br><span class="line">  System.out.println(map.get(key));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>For Each 方式遍历（keySet，性能较差）；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">*<span class="comment">// 遍历*</span></span><br><span class="line"><span class="keyword">for</span> (Integer key : map.keySet()) &#123;</span><br><span class="line">  System.out.println(key);</span><br><span class="line">  System.out.println(map.get(key));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Lambda 表达式遍历（JDK 1.8+）;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">map.forEach((key, value) -&gt; &#123;</span><br><span class="line">            System.out.println(key);</span><br><span class="line">            System.out.println(value);</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>Streams API 遍历（JDK 1.8+）（entrySet性能较好）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">map.entrySet().stream().forEach((entry) -&gt; &#123;</span><br><span class="line">           System.out.println(entry.getKey());</span><br><span class="line">           System.out.println(entry.getValue());</span><br><span class="line">       &#125;);</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="HashMap扩容（rehash）机制"><a href="#HashMap扩容（rehash）机制" class="headerlink" title="HashMap扩容（rehash）机制"></a>HashMap扩容（rehash）机制</h4><ol>
<li>如果数组为空，则进行首次扩容。数组的初始容量为16（懒加载），每次扩容变为原来2倍，一是为了提高性能使用足够大的数组，二是为了能使用位运算代替取模预算。</li>
<li>数组是否需要扩充是通过负载因子判断的，插入元素后，如果元素个数 &gt; 数组容量 * 负载因子时，就会扩充数组容量为原来两倍，将原hash表数据全部重新计算hash值（<em>JDK1.8中不需要重新计算 hash，只需要看看原来的 hash 值新增的那个 bit 是 1 还是 0 就可以了（旧值和新值按位与），是 0 的话索引没变，是 1 的话索引变成 “原位置 + 旧容量” ）</em>，重新分配位置。负载因子可由构造器传入。我们也可以设置大于1的负载因子，这样数组就不会扩充，牺牲性能，节省内存。</li>
<li>为了解决碰撞，数组中的元素是单向链表类型。当链表长度到达一个阈值时（8），先判断数组长度是否小于64，如是则执行resize来扩容，否则将链表转化为红黑树以提高性能。而当链表长度缩小到另一个阈值时（6），又会将红黑树转换回单向链表提高性能。</li>
</ol>
<p>具体流程：</p>
<p>①：先生成新数组；</p>
<p>②：遍历老数组中的每个位置上的链表或红黑树；</p>
<p>③：如果是链表，则直接将链表中的每个元素重新计算下标，并添加到新数组中去；</p>
<p>④：如果是红黑树，则先遍历红黑树，先计算出红黑树中每个元素对应在新数组中的下标位置；</p>
<p>a：统计每个下标位置的元素个数；</p>
<p>b：如果该位置下的元素个数超过了8，则生成一个新的红黑树，并将根节点添加到新数组的对应位置；</p>
<p>c：如果该位置下的元素个数没有超过8，那么则生成一个链表，并将链表的头节点添加到新数组的对应位置；</p>
<p>⑤：所有元素转移完了之后，将新数组赋值给HashMap对象的table属性。</p>
<p>刁钻问题：多线程环境，扩容时插入元素是放在旧的table还是新的table？</p>
<p>个人认为都有可能</p>
<h4 id="负载因子为什么是0-75"><a href="#负载因子为什么是0-75" class="headerlink" title="负载因子为什么是0.75"></a>负载因子为什么是0.75</h4><p>负载因子主要用来判断数组是否需要扩充，如果当前元素个数大于数组容量*负载因子时，就会扩充数组。源码注释中写了0.75提供了一个好的时空开销之间的权衡。如果负载因子太大，虽然空间利用率高了，但hash碰撞的可能性也高了，查询效率也就低了；负载因子太小，空间利用率就低了。</p>
<h4 id="HashMap-和-Hashtable-的区别"><a href="#HashMap-和-Hashtable-的区别" class="headerlink" title="HashMap 和 Hashtable 的区别"></a>HashMap 和 Hashtable 的区别</h4><ul>
<li><strong>线程安全：</strong> <code>HashMap</code> 是非线程安全的，<code>Hashtable</code> 是线程安全的,因为 <code>Hashtable</code> 内部的方法基本都经过<code>synchronized</code> 修饰。因为线程安全的问题，<code>HashMap</code> 要比 <code>Hashtable</code> 效率高一点。</li>
<li><strong>对 Null key 和 Null value 的支持：</strong> <code>HashMap</code> 可以存储 null 的 key（hash值为0） 和 value；Hashtable 不允许有 null 键和 null 值，否则会抛出 <code>NullPointerException</code>。</li>
<li><strong>初始容量大小和每次扩充容量大小的不同：</strong> ① 创建时如果不指定容量初始值，<code>HashMap</code> 默认的初始化大小为<strong>16</strong>。之后每次扩充，容量变为原来的 <strong>2 倍</strong>。<code>Hashtable</code> 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。② 创建时如果给定了容量初始值，<code>HashMap</code> 会将其扩充为 2 的幂次方大小。也就是说 <code>HashMap</code> 总是使用 2 的幂作为哈希表的大小； <code>Hashtable</code> 会直接使用你给定的大小。</li>
<li><strong>底层数据结构：</strong> JDK1.8 以后的 <code>HashMap</code> 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）时，将链表转化为红黑树（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树），以减少搜索时间。<code>Hashtable</code> 没有这样的机制。</li>
</ul>
<h4 id="ConcurrentHashMap-和-Hashtable-的区别"><a href="#ConcurrentHashMap-和-Hashtable-的区别" class="headerlink" title="ConcurrentHashMap 和 Hashtable 的区别"></a>ConcurrentHashMap 和 Hashtable 的区别</h4><p><code>ConcurrentHashMap</code> 和 <code>Hashtable</code> 的区别主要体现在实现线程安全的方式上不同。</p>
<ul>
<li><strong>底层数据结构：</strong> <code>Hashtable</code> 和 JDK1.8 之前的 <code>HashMap</code> 的底层数据结构类似都是采用 <strong>数组+链表</strong> 的形式。<code>ConcurrentHashMap</code>在JDK1.8 采用的数据结构跟 <code>HashMap</code> 的结构一样，数组+链表&#x2F;红黑树。</li>
<li>实现线程安全的方式（重要）：<ul>
<li>在 JDK1.7 的时候，<code>ConcurrentHashMap</code> 对整个桶数组进行了分割分段(<code>Segment</code>，分段锁)，每一把锁只锁容器其中一部分数据（下面有示意图），多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。</li>
<li>到了 JDK1.8 的时候，<code>ConcurrentHashMap</code> 已经摒弃了 <code>Segment</code> 的概念，而是直接用 <code>Node</code> 数组+链表+红黑树的数据结构来实现，并发控制使用 <code>synchronized</code> 和 CAS 来操作。（JDK1.6 以后 <code>synchronized</code> 锁做了很多优化） 整个看起来就像是优化过且线程安全的 <code>HashMap</code>，虽然在 JDK1.8 中还能看到 <code>Segment</code> 的数据结构，但是已经简化了属性，只是为了兼容旧版本；</li>
<li><strong><code>Hashtable</code>(同一把锁)</strong> :使用 <code>synchronized</code> 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</li>
</ul>
</li>
</ul>
<h4 id="ConcurrentHashMap-和-Hashtable-为什么不能存null？"><a href="#ConcurrentHashMap-和-Hashtable-为什么不能存null？" class="headerlink" title="ConcurrentHashMap 和 Hashtable 为什么不能存null？"></a>ConcurrentHashMap 和 Hashtable 为什么不能存null？</h4><p>多线程情况下可能产生歧义。</p>
<p>如果map.get(key)返回值是null，可能有两种情况：①key本身就不存在；②key存在，但value是null</p>
<p>对于HashMap，可以用contains方法判断key是否存在，不需要考虑多线程场景的问题。</p>
<p>但对于ConcurrentHashMap，在用contains方法判断key是否存在时，可能原本key不存在，但正好有其他线程插入了key并且value为null，导致contains方法返回true。也就是说没办法通过contains方法判断get返回值为null的原因。作为一个线程安全的集合，不能容忍这种情况（ConcurrentHashMap作者Doug lea说的。如果是null会抛空指针异常）。</p>
<h4 id="JDK-1-7-和-JDK-1-8-的-ConcurrentHashMap-实现有什么不同？"><a href="#JDK-1-7-和-JDK-1-8-的-ConcurrentHashMap-实现有什么不同？" class="headerlink" title="JDK 1.7 和 JDK 1.8 的 ConcurrentHashMap 实现有什么不同？"></a>JDK 1.7 和 JDK 1.8 的 ConcurrentHashMap 实现有什么不同？</h4><ul>
<li><strong>线程安全实现方式</strong>：JDK 1.7 采用 <code>Segment</code> 分段锁来保证安全，<code>segment</code>数组默认大小16，即默认并发度为16. <code>Segment</code> 是继承自 <code>ReentrantLock</code>。JDK1.8 放弃了 <code>Segment</code> 分段锁的设计，采用 <code>Node + CAS + synchronized</code> 保证线程安全，锁粒度更细，<code>synchronized</code> 只锁定当前链表或红黑二叉树的首节点。</li>
<li><strong>Hash 碰撞解决方法</strong> : JDK 1.7 采用拉链法，JDK1.8 采用拉链法结合红黑树（链表长度超过一定阈值时，将链表转换为红黑树）。</li>
<li><strong>并发度</strong>：JDK 1.7 最大并发度是 Segment 的个数，默认是 16。JDK 1.8 最大并发度是 Node 数组的大小，并发度更大。</li>
</ul>
<h4 id="说一说你对LinkedHashMap的理解"><a href="#说一说你对LinkedHashMap的理解" class="headerlink" title="说一说你对LinkedHashMap的理解"></a>说一说你对LinkedHashMap的理解</h4><p>LinkedHashMap继承于HashMap，它在HashMap的基础上，通过双向链表来维护key-value对的顺序（其实只需要考虑key的顺序），让迭代顺序与key-value对的插入顺序保持一致。</p>
<p>LinkedHashMap可以避免对HashMap、Hashtable里的key-value对进行排序（只要插入key-value对时保持顺序即可），同时又可避免使用TreeMap所增加的成本。</p>
<p>LinkedHashMap需要维护元素的插入顺序，因此性能略低于HashMap的性能。但因为它以链表来维护内部顺序，所以在迭代访问Map里的全部元素时将有较好的性能。</p>
<h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h3 id="内存结构（运行时数据区）"><a href="#内存结构（运行时数据区）" class="headerlink" title="内存结构（运行时数据区）"></a>内存结构（运行时数据区）</h3><ul>
<li><p>方法区</p>
<p>属于共享内存区域，存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。<strong>运行时常量池</strong>，属于方法区的一部分，用于存放<strong>编译期生成的各种字面量和符号引用</strong>。</p>
<p>JDK1.8之前，Hotspot虚拟机对方法区的实现叫做永久代，1.8之后改为元空间。二者区别主要在于<strong>永久代是在JVM虚拟机中分配内存，而元空间则是在本地内存（本机）中分配的</strong>。很多类是在运行期间加载的，它们所占用的空间完全不可控，所以改为使用本地内存，避免对JVM内存的影响。根据《Java虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出OutOfMemoryError异常。</p>
</li>
<li><p>堆</p>
<p>线程共享，主要是存放对象实例和数组。如果在Java堆中没有内存完成实例分配，并且堆也无法再扩展时，Java虚拟机将会抛出OutOfMemoryError异常。</p>
<p>JDK1.7 之前，字符串常量池存放在永久代。JDK1.7 字符串常量池（StringTable，可以简单理解为一个固定大小的<code>HashTable</code>）从永久代移动了 Java 堆中。</p>
<p>PS：实际上写入时并不完全共享，JVM会为线程在堆上划分一块专属的分配缓冲区来提高对象分配效率。详见：TLAB</p>
</li>
<li><p>虚拟机栈</p>
<p>线程私有，方法执行的过程就是一个个栈帧从入栈到出栈的过程。每个方法在执行时都会创建一个栈帧(Stack Frame)用于存储局部变量表、操作数栈、动态链接、方法出口、<strong>程序计数器</strong>等信息。如果线程入栈的栈帧超过限制就会抛出StackOverFlowError，如果支持动态扩展，那么扩展时申请内存失败则抛出OutOfMemoryError。</p>
</li>
<li><p>本地方法栈</p>
<p>和虚拟机栈的功能类似，区别是作用于Native方法。</p>
</li>
<li><p>程序计数器</p>
<p>线程私有，记录着当前线程所执行的字节码的行号。其作用主要是多线程场景下，记录线程中指令的执行位置。以便被挂起的线程再次被激活时，CPU能从其挂起前执行的位置继续执行。唯一一个在 Java 虚拟机规范中没有规定任何 OutOfMemoryError 情况的区域。注意：如果线程执行的是个java方法，那么计数器记录虚拟机字节码指令的地址。如果为native（底层方法），那么计数器为空。</p>
</li>
</ul>
<h3 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h3><p>从原理聊JVM：染色标记和垃圾回收算法<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/dvDYRi9SONhfItIafLnsYw">https://mp.weixin.qq.com/s/dvDYRi9SONhfItIafLnsYw</a></p>
<h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><p><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="https://s2.loli.net/2023/06/12/4lBUQHu9t2RLKYb.png" alt="强软弱虚"></p>
<p><strong>1．强引用（StrongReference）</strong></p>
<p>以前我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，那就类似于<strong>必不可少的生活用品</strong>，垃圾回收器绝不会回收它。当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。</p>
<p><strong>2．软引用（SoftReference）</strong></p>
<p>如果一个对象只具有软引用，那就类似于<strong>可有可无的生活用品</strong>。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。</p>
<p>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA 虚拟机就会把这个软引用加入到与之关联的引用队列中。</p>
<p><strong>3．弱引用（WeakReference）</strong></p>
<p>如果一个对象只具有弱引用，那就类似于<strong>可有可无的生活用品</strong>。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。</p>
<p>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p>
<p><strong>4．虚引用（PhantomReference）</strong></p>
<p>“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。</p>
<p><strong>虚引用主要用来跟踪对象被垃圾回收的活动</strong>。</p>
<p><strong>虚引用与软引用和弱引用的一个区别在于：</strong> 虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</p>
<p>特别注意，在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为<strong>软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生</strong>。</p>
<p>finalize</p>
<p>当一个对象没有引用的时候，对象的垃圾回收器会调用finalize方法。</p>
<ul>
<li>当对象被回收时，系统自动调用该对象的finalize方法，子类可以重写该方法，做一些释放资源的操作。</li>
<li>什么时候被回收：当某个对象没有任何引用时，jvm就认为这个对象是一个垃圾对象，就会使用垃圾回收机制来销毁该对象，在销毁对象前，会先调用finalize方法。</li>
</ul>
<p>垃圾回收机制的调用，是由系统来决定(有自己的GC算法)，也可以通过System.gc()主动触发垃圾回收机制。</p>
<h4 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h4><ul>
<li><p>方法区溢出场景</p>
<ul>
<li><p>spring、mybatis都采用动态代理，会在运行时动态生成大量代理类</p>
</li>
<li><p>当应用程序频繁地使用反射进行类的动态加载、方法的调用和字段的访问时，会导致方法区不断增加新的类定义和相关信息，从而消耗掉方法区的内存。</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>一个线程OOM后，其他线程还能执行吗</p>
<p>当一个线程OOM时，它通常是因为它的JVM Stack或堆已经用尽了可用内存。这意味着该线程将无法继续执行，并将抛出OutOfMemoryError异常。<strong>但是，这不会影响其他线程的运行，因为每个线程都有自己的JVM Stack和堆。</strong></p>
</li>
</ul>
<h4 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h4><ul>
<li>场景<ul>
<li>资源未关闭或释放导致内存泄露。常见的资源类有网络连接，数据库连接以及 IO 流</li>
<li>ThreadLocal</li>
</ul>
</li>
</ul>
<h3 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h3><p>类从被加载到虚拟机内存中开始到卸载出内存为止，它的整个生命周期可以简单概括为 7 个阶段：：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）。其中，验证、准备和解析这三个阶段可以统称为连接（Linking）</p>
<h4 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h4><p>系统加载 Class 类型的文件主要三步：<strong>加载-&gt;连接-&gt;初始化</strong>。连接过程又可分为三步：<strong>验证-&gt;准备-&gt;解析</strong>。</p>
<h2 id="并发编程（JUC）"><a href="#并发编程（JUC）" class="headerlink" title="并发编程（JUC）"></a>并发编程（JUC）</h2><h3 id="并发编程三个重要特性"><a href="#并发编程三个重要特性" class="headerlink" title="并发编程三个重要特性"></a>并发编程三个重要特性</h3><p>腾讯技术：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/sU_P9CHnNlxnLPf2UdstRg">https://mp.weixin.qq.com/s/sU_P9CHnNlxnLPf2UdstRg</a></p>
<p>JMM：Java定义的一组规范，用以屏蔽操作系统内存模型的差异，主要</p>
<p>定义了共享变量的访问方式，围绕原子性、可见性、有序性来解决并发编程中的线程安全问题。</p>
<ul>
<li><p>原子性</p>
<p><strong>一次操作或者多次操作，要么所有的操作全部都得到执行并且不会受到任何因素的干扰而中断，要么都不执行</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;Thread&gt; ts = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">10000</span>; j++) &#123;</span><br><span class="line">                count += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        ts.add(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...start启动线程，join等待线程</span></span><br><span class="line">    <span class="keyword">assert</span> count == <span class="number">100</span> * <span class="number">10000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于 Java 这样的高级语言，一条语句最终会被转换成多条 CPU 指令完成，例如上面代码中的 count+&#x3D;1，至少需要三条 CPU 指令：</p>
<p>1）指令 1：把变量 count 从内存加载到 CPU 的寄存器；</p>
<p>2）指令 2：在寄存器中执行+1 操作；</p>
<p>3）指令 3：将结果写入内存（缓存机制导致可能写入的是处理器缓存而不是内存）。</p>
<p>Java 语言提供了大量的原子操作类，来实现对应的 CAS 操作。比如 AtomicBoolean，AtomicInteger，AtomicLong 等。CAS 虽然很高效解决了原子操作，但是 CAS 也存在一些问题，比如 ABA 问题，循环时间长开销大，只能保障一个共享变量的原子操作。</p>
<p>在 Java 中，可以借助<code>synchronized</code>、各种 <code>Lock</code> 以及各种原子类实现原子性。</p>
<p><code>synchronized</code> 和各种 <code>Lock</code> 可以保证任一时刻只有一个线程访问该代码块，因此可以保障原子性。各种原子类是利用 CAS (compare and swap) 操作（可能也会用到 <code>volatile</code>或者<code>final</code>关键字）来保证原子操作。</p>
</li>
<li><p>可见性</p>
<p><strong>当一个线程对共享变量进行了修改，那么另外的线程都是立即可以看到修改后的最新值</strong>。</p>
<p>由于处理器和内存的速度差距太大。为了提高处理速度，处理器不直接和内存进行通信，而是先将系统内存的数据读到内部缓存（L1，L2 或其他）后再进行操作。基于局部性原理，处理器在读取内存数据时，是一块块地读取，每一小块数据也叫缓存行（cache line）。当<strong>处理器操作完数据，也不直接写回内存，而且先写入缓存中，并将当前缓存标记为脏（dirty）。等到当前缓存被替换时，才将数据写回内存</strong>。这个过程叫写回策略（write-back）。</p>
<p>要达到可见性，需要处理器及时回写共享变量最新值到内存，也需要其他处理器及时从内存中读取到共享变量最新值。因此也可以说只要满足上述两个条件。那么就可以保证对共享变量的操作，在并发情况下是线程安全的。在 Java 语言中，是通过 volatile 关键字实现。volatile 关键字并不是 Java 语言的特产，古老的 C 语言里也有，它最原始的意义就是禁用 CPU 缓存。</p>
<p>在 Java 中，可以借助<code>synchronized</code>、<code>volatile</code> 以及各种 <code>Lock</code> 实现可见性。</p>
<p>如果我们将变量声明为 <code>volatile</code> ，每次修改变量都将当前处理器缓存行的数据写回到系统内存，每次使用它都到主存中进行读取。</p>
</li>
<li><p>有序性</p>
<p>重排序是指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段。重排序需要遵守两点：</p>
<p>1）数据依赖性：如果两个操作之间存在数据依赖，那么编译器和处理器不能调整它们的顺序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写后读</span></span><br><span class="line">a = <span class="number">1</span>;</span><br><span class="line">b = a;</span><br><span class="line"><span class="comment">// 写后写</span></span><br><span class="line">a = <span class="number">1</span>;</span><br><span class="line">a = <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 读后写</span></span><br><span class="line">a = b;</span><br><span class="line">b = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>上面 3 种情况，编译器和处理器不能调整它们的顺序，否则将会造成程序语义的改变。</p>
<p>2）as-if-serial 语义：即给程序一个顺序执行的假象。即经过重排序的执行结果要与顺序执行的结果保持一致。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span>;</span><br><span class="line">b = <span class="number">2</span>;</span><br><span class="line">c = a * b;</span><br></pre></td></tr></table></figure>

<p>如上对变量 a 的赋值和对变量 b 的赋值，不存在数据依赖关系。因此对变量 a 和 b 重排序不会影响变量 c 的结果。</p>
<p>但数据依赖性和 as-if-serial 语义<strong>只保证单个处理器中执行的指令序列和单个线程中执行的操作</strong>，并不考虑多处理器和多线程之间的数据依赖情况。因此在<strong>多线程程序中，对存在数据依赖的操作重排序，可能会改变程序的执行结果</strong>。因此要避免程序的错误的执行，便是需要禁止这种编译和处理器优化导致的重排序。</p>
<p>这种方式叫做<strong>内存屏障</strong>（memory barriers）。内存屏障是一组处理器指令，用户实现对内存操作的顺序限制。以我们日常接触的 X86_64 架构来说，读读（loadload）、读写（loadstore）以及写写（storestore）内存屏障是空操作（no-op），只有写读（storeload）内存屏障会被替换成具体指令。</p>
<p>在 Java 语言中，内存屏障通过 <strong>volatile</strong> 关键字实现，<strong>禁止被它修饰的变量发生指令重排序操作</strong>：</p>
<p>1）不允许 volatile 字段写操作之前的内存访问被重排序至其之后。</p>
<p>2）不允许 volatile 字段读操作之后的内存访问被重排序至其之前。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  变量a，b通过volatile修饰</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> a, b;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> x, y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        a = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 编译器插入storeload内存屏障指令</span></span><br><span class="line">        <span class="comment">// 1）禁止代码和指令重排序</span></span><br><span class="line">        <span class="comment">// 2）强制刷新变量a的最新值到内存</span></span><br><span class="line">        x = b;</span><br><span class="line">        <span class="comment">// 1）强制从内存中读取变量b的最新值</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        b = <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 编译器插入storeload内存屏障指令</span></span><br><span class="line">        <span class="comment">// 1）禁止代码和指令重排序</span></span><br><span class="line">        <span class="comment">// 2）强制刷新变量b的最新值到内存</span></span><br><span class="line">        y = a;</span><br><span class="line">        <span class="comment">// 1）强制从内存中读取变量a的最新值</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// ...start启动线程，join等待线程</span></span><br><span class="line">    <span class="keyword">assert</span> x == <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">assert</span> y == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>举例：单例模式的双重校验锁</p>
<ul>
<li><h3 id="指令重排序"><a href="#指令重排序" class="headerlink" title="指令重排序"></a>指令重排序</h3><p>为了提升执行速度&#x2F;性能，计算机在执行程序代码的时候，会对指令进行重排序。</p>
<p><strong>什么是指令重排序？</strong> 简单来说就是系统在执行代码的时候并不一定是按照你写的代码的顺序依次执行。</p>
<p>常见的指令重排序有下面 2 种情况：</p>
<ul>
<li><strong>编译器优化重排</strong>：编译器（包括 JVM、JIT 编译器等）在不改变单线程程序语义的前提下，重新安排语句的执行顺序。</li>
<li><strong>指令并行重排</strong>：现代处理器采用了指令级并行技术(Instruction-Level Parallelism，ILP)来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</li>
</ul>
<p>另外，内存系统也会有“重排序”，但又不是真正意义上的重排序。在 JMM 里表现为主存和本地内存的内容可能不一致，进而导致程序在多线程下执行可能出现问题。</p>
<p>Java 源代码会经历 <strong>编译器优化重排 —&gt; 指令并行重排 —&gt; 内存系统重排</strong> 的过程，最终才变成操作系统可执行的指令序列。</p>
<p><strong>指令重排序可以保证串行语义一致，但是没有义务保证多线程间的语义也一致</strong> ，所以在多线程下，指令重排序可能会导致一些问题。</p>
<p>编译器和处理器的指令重排序的处理方式不一样。对于编译器，通过禁止特定类型的编译器重排序的方式来禁止重排序。对于处理器，通过插入内存屏障（Memory Barrier，或有时叫做内存栅栏，Memory Fence）的方式来禁止特定类型的处理器重排序。指令并行重排和内存系统重排都属于是处理器级别的指令重排序。</p>
<blockquote>
<p>内存屏障（Memory Barrier，或有时叫做内存栅栏，Memory Fence）是一种 CPU 指令，用来禁止处理器指令发生重排序（像屏障一样），从而保障指令执行的有序性。另外，为了达到屏障的效果，它也会使处理器写入、读取值之前，将主内存的值写入高速缓存，清空无效队列，从而保障变量的可见性。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="ThreadLocal（java-lang）"><a href="#ThreadLocal（java-lang）" class="headerlink" title="ThreadLocal（java.lang）"></a>ThreadLocal（java.lang）</h3><blockquote>
<p><code>ThreadLocal</code>可以看做是线程私有的变量存储容器，如果你创建了一个<code>ThreadLocal</code>变量，那么访问这个变量的每个线程都会有这个变量的本地副本，如果需要修改<code>ThreadLocal</code> 中存储的变量的值,并不会影响其他的线程，所以可以用来解决线程内参数传递或共享变量的线程安全问题。</p>
<p>原理：<code>ThreadLocal</code>类中有一个静态内部类<code>ThreadLocalMap</code>，<strong>可以存储以<code>ThreadLocal</code>为 key ，Object 对象为 value 的键值对。</strong></p>
<p><strong>Thread类中有一个ThreadLocalMap类型的成员变量<code>threadLocals</code>(<code>ThreadLocal.ThreadLocalMap threadLocals = null;</code> )，默认情况下是 null。</strong>当线程第一次调用 <code>ThreadLocal</code> 类的 <code>set</code>或<code>get</code>方法时才会创建它。调用这两个方法的时候，实际上调用的是线程内<code>ThreadLocalMap</code>类成员对应的 <code>get()</code>、<code>set()</code>方法。<strong>也就是说最终的变量是放在了当前线程的 <code>ThreadLocalMap</code> 中，并不是存在 <code>ThreadLocal</code> 上，<code>ThreadLocal</code> 可以理解为只是<code>ThreadLocalMap</code>的封装，传递了变量值。</strong></p>
<p>内存泄漏问题：</p>
<p><code>ThreadLocalMap</code> 中使用的 key 为 <code>ThreadLocal</code> 的弱引用，而 value 是强引用。所以，如果 <code>ThreadLocal</code> 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。</p>
<p>这样一来，<code>ThreadLocalMap</code> 中就会出现 key 为 null 的 Entry（键值对）。假如我们不做任何措施的话，value 永远无法被 GC 回收，这个时候就可能会产生内存泄露。<code>ThreadLocalMap</code> 实现中已经考虑了这种情况，在调用 <code>set()</code>、<code>get()</code>方法的时候，会清理掉 key 为 null 的记录。使用完 <code>ThreadLocal</code>方法后最好手动调用<code>remove()</code>方法。</p>
</blockquote>
<p>通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。<strong>如果想实现每一个线程都有自己的专属本地变量该如何解决呢？</strong></p>
<p>JDK 中自带的<code>ThreadLocal</code>类正是为了解决这样的问题。 <strong><code>ThreadLocal</code>类主要解决的就是让每个线程绑定自己的值，可以将<code>ThreadLocal</code>类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据。</strong></p>
<p><code>ThreadLocal</code>是线程私有的变量存储容器，如果你创建了一个<code>ThreadLocal</code>变量，那么访问这个变量的每个线程都会有这个变量的本地副本，<code>ThreadLocal</code> 对象存储的值发生改变时,并不会影响其他的线程，可以用来解决线程内参数传递或共享变量的线程安全问题（比synchronize高效，空间换时间）。他们可以使用 <code>get()</code> 和 <code>set()</code> 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。</p>
<h4 id="ThreadLocal原理"><a href="#ThreadLocal原理" class="headerlink" title="ThreadLocal原理"></a>ThreadLocal原理</h4><p><code>ThreadLocal</code>类的静态内部类<code>ThreadLocalMap</code>，<strong>可以存储以<code>ThreadLocal</code>为 key ，Object 对象为 value 的键值对。</strong></p>
<p><strong>Thread类中有一个ThreadLocalMap类型的成员变量<code>threadLocals</code>(<code>ThreadLocal.ThreadLocalMap threadLocals = null;</code> )，默认情况下是 null。</strong>当线程第一次调用 <code>ThreadLocal</code> 类的 <code>set</code>或<code>get</code>方法时才会创建它。调用这两个方法的时候，实际上调用的是<code>ThreadLocalMap</code>类对应的 <code>get()</code>、<code>set()</code>方法。<strong>也就是说最终的变量是放在了当前线程的 <code>ThreadLocalMap</code> 中，并不是存在 <code>ThreadLocal</code> 上，<code>ThreadLocal</code> 可以理解为只是<code>ThreadLocalMap</code>的封装，传递了变量值。</strong></p>
<ul>
<li><p>内存泄漏？</p>
<p>由于<code>ThreadLocalMap</code>的中key是弱引用，而Value是强引用。这就导致了一个问题，<code>ThreadLocal</code>在没有外部对象强引用时，发生GC时弱引用Key会被回收，而Value不会回收，从而Entry里面的元素出现<code>&lt;null,value&gt;</code>的情况。如果持有ThreadLocalMap的线程一直持续运行（比如线程池场景），那么这个Entry对象中的value就有可能一直得不到回收，这样可能会导致内存泄露。<code>ThreadLocalMap</code> 实现中已经考虑了这种情况，在调用 <code>set()</code>、<code>get()</code>方法的时候，会清理掉 key 为 null 的记录。使用完 <code>ThreadLocal</code>方法后最好手动调用<code>remove()</code>方法。</p>
<blockquote>
<p>为什么用弱引用？为什么不用强引用</p>
</blockquote>
<p>若使用强引用类型，则threadlocal的引用链为：Thread -&gt; ThreadLocal.ThreadLocalMap -&gt; Entry[] -&gt; Entry -&gt; key（threadLocal对象）和value；在这种场景下，只要这个线程还在运行（如线程池场景），若不调用remove方法，则该对象及关联的所有强引用对象都不会被垃圾回收器回收。</p>
</li>
</ul>
<ul>
<li><p>众所周知，在java中SimpleDateFormat有线程安全问题，为了安全地使用SimpleDateFormat，除了1）创建SimpleDateFormat局部变量；和2）加同步锁 两种方案外，我们还可以使用3）ThreadLocal的方案。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 使用 ThreadLocal 定义一个全局的 SimpleDateFormat</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;SimpleDateFormat&gt; simpleDateFormatThreadLocal = <span class="keyword">new</span></span><br><span class="line"><span class="title class_">ThreadLocal</span>&lt;SimpleDateFormat&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> SimpleDateFormat <span class="title function_">initialValue</span><span class="params">()</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 用法</span></span><br><span class="line"><span class="type">String</span> <span class="variable">dateString</span> <span class="operator">=</span> simpleDateFormatThreadLocal.get().format(calendar.getTime());</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>最佳实践</p>
</blockquote>
<ul>
<li><p>ThreadLocal变量建议使用static进行修饰</p>
<p>若使用static关键字进行修饰，则一个线程仅对应一个线程变量；否则，threadlocal语义变为perThread-perInstance，容易引发内存泄漏.</p>
<p>我们在使用ThreadLocal时，通常期望的语义是perThread，若不使用static进行修饰，则语义变为perThread-perInstance；在线程池场景下，若不用static进行修饰，创建的线程相关实例可能会达到 M * N个（其中M为线程数，N为对应类的实例数）</p>
</li>
<li><p>ThreadLocal变量值初始化和清理建议成对出现</p>
<p>如果不执行清理操作，则可能会出现：</p>
<p>1）内存泄漏：由于ThreadLocalMap的中key是弱引用，而Value是强引用。这就导致了一个问题，ThreadLocal在没有外部对象强引用时，发生GC时弱引用Key会被回收，而Value不会回收，从而Entry里面的元素出现&lt;null,value&gt;的情况。如果创建ThreadLocal的线程一直持续运行，那么这个Entry对象中的value就有可能一直得不到回收，这样可能会导致内存泄露。</p>
<p>2）脏数据：由于线程复用，在用户1请求时，可能保存了业务数据在ThreadLocal中，若不清理，则用户2的请求进来时，可能会读到用户1的数据。</p>
<p>建议使用try…finally 进行清理</p>
</li>
</ul>
<h3 id="Synchronize"><a href="#Synchronize" class="headerlink" title="Synchronize"></a>Synchronize</h3><p><code>synchronized</code> 是 Java 中的一个关键字，翻译成中文是同步的意思，主要解决的是多个线程之间访问资源的同步性，可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。</p>
<p>在 Java 早期版本中，<code>synchronized</code> 属于 <strong>重量级锁</strong>，效率低下。这是因为监视器锁（monitor）是依赖于底层的操作系统的 <code>Mutex Lock</code> 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高。</p>
<p>不过，在 Java 6 之后， <code>synchronized</code> 引入了大量的优化如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销，这些优化让 <code>synchronized</code> 锁的效率提升了很多。</p>
<p><code>synchronized</code> 关键字的使用方式主要有下面 3 种：</p>
<ol>
<li><p>修饰实例方法：给<strong>当前对象实例</strong>加锁，进入同步代码前要获得 <strong>当前对象实例的锁</strong> 。</p>
</li>
<li><p>修饰静态方法：给当前类加锁，会作用于类的所有对象实例 ，进入同步代码前要获得 <strong>当前 class 的锁</strong>。</p>
</li>
<li><p>修饰代码块</p>
<p>对括号里指定的对象&#x2F;类加锁：</p>
<ul>
<li><code>synchronized(object)</code> 表示进入同步代码库前要获得 <strong>给定对象的锁</strong>。一般对什么对象加锁？多线程共享、需要保证线程安全对象</li>
<li><code>synchronized(类.class)</code> 表示进入同步代码前要获得 <strong>给定 Class 的锁</strong></li>
</ul>
</li>
</ol>
<h4 id="synchronized可以修饰静态方法和静态代码块吗？"><a href="#synchronized可以修饰静态方法和静态代码块吗？" class="headerlink" title="synchronized可以修饰静态方法和静态代码块吗？"></a>synchronized可以修饰静态方法和静态代码块吗？</h4><p>synchronized可以修饰静态方法，但不能修饰静态代码块。</p>
<p>当修饰静态方法时，监视器锁（monitor）便是对象的Class实例，因为Class数据存在于永久代，因此静态方法锁相当于该类的一个全局锁。</p>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><h5 id="同步语句块"><a href="#同步语句块" class="headerlink" title="同步语句块"></a>同步语句块</h5><p><strong><code>synchronized（this、object、class）</code> 同步语句块的实现使用的是 <code>monitorenter</code> 和 <code>monitorexit</code> 指令，其中 <code>monitorenter</code> 指令指向同步代码块的开始位置，<code>monitorexit</code> 指令则指明同步代码块的结束位置。</strong></p>
<p>上面的<em>字节码</em>中包含一个 <code>monitorenter</code> 指令以及两个 <code>monitorexit</code> 指令，这是为了保证锁在同步代码块代码正常执行以及出现异常的这两种情况下都能被正确释放。</p>
<p>当执行 <code>monitorenter</code> 指令时，线程试图获取锁也就是获取 <strong>对象监视器 <code>monitor</code></strong> 的持有权。</p>
<blockquote>
<p>在 Java 虚拟机(HotSpot)中，Monitor 是基于 C++实现的，由<a target="_blank" rel="noopener" href="https://github.com/openjdk-mirror/jdk7u-hotspot/blob/50bdefc3afe944ca74c3093e7448d6b889cd20d1/src/share/vm/runtime/objectMonitor.cpp">ObjectMonitor</a>实现的。每个对象中都内置了一个 <code>ObjectMonitor</code>对象。</p>
<p>另外，<code>wait/notify</code>等方法也依赖于<code>monitor</code>对象，这就是为什么只有在同步的块或者方法中才能调用<code>wait/notify</code>等方法，否则会抛出<code>java.lang.IllegalMonitorStateException</code>的异常的原因。</p>
</blockquote>
<p>在执行<code>monitorenter</code>时，会尝试获取对象的monitor，如果monitor的计数器为 0 则表示锁可以被获取，获取后将锁计数器设为 1 也就是加 1。</p>
<p>对象锁的的拥有者线程才可以执行 <code>monitorexit</code> 指令来释放锁。在执行 <code>monitorexit</code> 指令后，将锁计数器设为 0，表明锁被释放，其他线程可以尝试获取锁。</p>
<p>如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。</p>
<h5 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h5><p><code>synchronized</code> 修饰的方法并没有 <code>monitorenter</code> 指令和 <code>monitorexit</code> 指令，取得代之的确实是 <code>ACC_SYNCHRONIZED</code> 标识，该标识指明了该方法是一个同步方法。JVM 通过该 <code>ACC_SYNCHRONIZED</code> 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。</p>
<p>如果是实例方法，JVM 会尝试获取实例对象的锁。如果是静态方法，JVM 会尝试获取当前 class 的锁（每个类只有一个class对象）。</p>
<h5 id="Synchronize保证的特性"><a href="#Synchronize保证的特性" class="headerlink" title="Synchronize保证的特性"></a>Synchronize保证的特性</h5><p>1.原子性：synchronized依靠两个字节码指令monitorenter和monitorexit，可以保证被synchronized修饰的代码在同一时间只能被一个线程访问。</p>
<p>2.可见性：JMM（Java内存模型）规定，内存主要分为主内存和工作内存两种，每个线程拥有不同的工作内存,线程工作时会从主内存中拷贝一份变量到工作内存中。代码执行后，有时工作内存中的变量无法及时刷新到主内存中,或者工作内存无法及时获取主内存的最新值,导致共享变量在不同线程间处于不可见性,由此JMM对synchronized做了2条规定：</p>
<p>线程加锁时，先清空工作内存中的变量值，从主内存中重新获取最新值到工作内存中。</p>
<p>线程解锁前，必须把变量的最新值刷新到主内存中。</p>
<p>3.有序性：有时候编译器和处理器为了提升代码效率,会进行指令重排序,但是as-if-serial规定无论怎么重排序,单线程程序的执行结果都不能被改变,而synchronized保证了被修饰的程序在同一时间内只能被同一线程访问，所以其也算是保证了有序性,但synchronized实际上并不是禁止了被修饰的代码指令重排序。</p>
<h4 id="四种状态"><a href="#四种状态" class="headerlink" title="四种状态"></a>四种状态</h4><p>锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。</p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/2yxexZUr5MWdMZ02GCSwdA">https://mp.weixin.qq.com/s/2yxexZUr5MWdMZ02GCSwdA</a></p>
<p>首先明确早期jdk1.2效率非常低。那时候syn就是重量级锁，申请锁必须要经过操作系统老大kernel进行<strong>系统调用</strong>，入队进行排序操作，操作完之后再返回给用户态。</p>
<p>内核态：用户态如果要做一些比较危险的操作直接访问硬件，很容易把硬件搞死（格式化，访问网卡，访问内存干掉、）操作系统为了系统安全分成两层，用户态和内核态 。申请锁资源的时候用户态要向操作系统老大内核态申请。Jdk1.2的时候用户需要跟内核态申请锁，然后内核态还会给用户态。这个过程是非常消耗时间的，导致早期效率特别低。有些jvm就可以处理的为什么还交给操作系统做去呢？能不能把jvm就可以完成的锁操作拉取出来提升效率，所以也就有了锁优化。</p>
<ol>
<li><strong>无锁状态</strong>：当对象没有被锁定时，处于无锁状态。任何线程都可以访问该对象。</li>
<li><strong>偏向锁状态</strong>：当只有一个线程访问对象时，该对象处于偏向锁状态。偏向锁可以减少无竞争情况下的同步操作的开销。</li>
<li><strong>轻量级锁状态</strong>：当有多个线程竞争访问同一个对象时，对象会从偏向锁升级为轻量级锁状态。轻量级锁使用CAS（Compare and Swap）操作来避免真正的互斥操作。</li>
<li><strong>重量级锁状态</strong>：当多个线程竞争访问同一个对象的时候，如果轻量级锁获取不到，对象会膨胀为重量级锁状态。在重量级锁状态下，使用操作系统的互斥量来实现线程的同步。</li>
</ol>
<h3 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h3><p>synchronize和lock区别？</p>
<ul>
<li>synchronized是Java内置的关键字。Lock是J.U.C包下的接口，有很多实现类</li>
<li>Lock可以自主地去决定什么时候加锁，什么时候释放锁。Lock比synchronized在使用上相对来说要更加灵活一些。只需要调用lock()和unlock()这两个方法就可以了。需要注意的是，为了避免死锁，一般我们unlock()方法写在finally块中。</li>
<li>lock可以让等待锁的线程响应中断。当一个线程通过lockInterruptibly()方法获取锁时，其他等待锁的线程可以响应中断（thread.interrupt()，设置中断标志）。当两个线程同时通过lock.lockInterruptibly()获取某个锁时，假若此时线程A获取到了锁，而线程B只有等待，那么对线程B调用threadB.interrupt()方法能够中断线程B的等待过程。而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断；</li>
<li>lock有非阻塞的竞争锁的方法trylock()，这个方法可以通过返回true或者fasle来告诉当前线程是否获取到锁。而synchronized却无法办到。</li>
<li>性能比较：在资源竞争不是很激烈的情况下，Synchronized的性能要优于ReetrantLock，但是在资源竞争很激烈的情况下，Synchronized的性能会下降几十倍，但是ReetrantLock的性能能维持常态；</li>
</ul>
<h4 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h4><p>如果一个系统中<strong>读多写少</strong>，可以考虑使用读写锁（ReadWriteLock）来提高系统的并发性能。</p>
<p>读写锁是一种特殊的锁，它允许多个线程同时读共享数据，但只允许一个线程写共享数据。在读写锁中，读操作不会阻塞其他读操作，只有写操作会阻塞所有读操作和写操作。这样可以提高系统的并发性能，减少写操作的竞争。</p>
<p>在 Java 中，可以使用 ReentrantReadWriteLock 类来实现读写锁。ReentrantReadWriteLock 类有两个锁：读锁和写锁。读锁是共享锁，写锁是独占锁。多个线程可以同时获取读锁，但只有一个线程可以获取写锁。当一个线程获取写锁时，其他线程无法获取读锁或写锁，直到写锁被释放。</p>
<h3 id="进程、线程、协程"><a href="#进程、线程、协程" class="headerlink" title="进程、线程、协程"></a>进程、线程、协程</h3><p><strong>进程</strong></p>
<p><strong>进程是系统资源分配的最小单位</strong>。是的，系统由一个个程序，也就是进程组成的，一般情况下，分为文本区域、数据区域和堆栈区域。</p>
<p>文本区域存储处理器执行的代码(机器码)，通常来说，这是一个只读区域，防止运行的程序被意外修改。</p>
<p>数据区域存储所有的变量和动态分配的内存，又细分为初始化的数据区(所有初始化的全局、静态、常量，以及外部变量)和为初始化的数据区(初始化为0的全局变量和静态变量)，初始化的变量最初保存在文本区，程序启动后被拷贝到初始化的数据区。</p>
<p>堆栈区域存储着活动过程调用的指令和本地变量，在地址空间里，栈区紧连着堆区，他们的增长方向相反，内存是线性的，所以我们代码放在低地址的地方，由低向高增长，栈区大小不可预测，随开随用，因此放在高地址的地方，由高向低增长。当堆和栈指针重合的时候，意味着内存耗尽，造成内存溢出。</p>
<p>进程的创建和销毁都是相对于系统资源，非常消耗资源，是一种比较昂贵的操作。进程为了自身能得到运行，必须要抢占式的争夺CPU。对于单核CPU来说，在同一时间只能执行一个进程的代码，所以在单核CPU上实现多进程，是通过CPU快速的切换不同进程，看上去就像是多个进程在同时进行。</p>
<p>由于进程间是隔离的，各自拥有自己的内存内存资源，相比于线程的共同共享内存来说，相对安全，不同进程之间的数据只能通过 IPC(Inter-Process Communication) 进行通信共享。</p>
<ul>
<li><p>进程通信方式？</p>
<p>操作系统进程通信的方式有以下几种：</p>
<ol>
<li>管道（Pipe）：管道是一种半双工的通信方式，它可以在两个进程之间传递数据。管道可以是匿名的，也可以是命名的。匿名管道只能在有亲缘关系的进程之间使用，而命名管道可以在任何进程之间使用。</li>
<li>共享内存（Shared Memory）：共享内存是一种高效的进程通信方式，它允许多个进程访问同一块物理内存。共享内存通常用于需要频繁交换大量数据的进程之间的通信。</li>
<li>信号量（Semaphore）：信号量是一种计数器，用于控制多个进程对共享资源的访问。信号量可以用于进程同步和互斥。</li>
<li>消息队列（Message Queue）：消息队列是一种消息传递机制，它允许一个进程向另一个进程发送消息。消息队列通常用于进程之间的异步通信。</li>
<li>套接字（Socket）：套接字是一种网络通信方式，它允许不同主机之间的进程进行通信。套接字通常用于进程之间的跨主机通信。</li>
</ol>
</li>
</ul>
<p><strong>线程</strong></p>
<p><strong>线程是CPU调度的最小单位</strong>。如果进程是一个容器，线程就是运行在容器里面的程序，线程是属于进程的，<strong>同个进程的多个线程共享进程的内存地址空间</strong>。</p>
<p>线程间的通信可以直接通过全局变量进行通信，所以相对来说，线程间通信是不太安全的，因此引入了各种锁的场景。当一个线程崩溃了,会导致整个进程也崩溃了,即其他线程也挂了, 但多进程而不会,一个进程挂了，另一个进程依然照样运行。</p>
<p>在多核操作系统中，默认进程内只有一个线程，所以对多进程的处理就像是一个进程一个核心。</p>
<p><strong>协程</strong></p>
<p>协程是属于线程的，又称微线程，纤程，英文名Coroutine。举个例子，在执行函数A时，我希望随时中断去执行函数B，然后中断B的执行，切换回来执行A。这就是协程的作用，由调用者自由切换。这个切换过程并不是等同于函数调用，因为它没有调用语句。执行方式与多线程类似，但是协程只有一个线程执行。</p>
<p>协程的优点是执行效率非常高，因为协程的切换由程序自身控制，不需要切换线程，即没有切换线程的开销。同时，由于只有一个线程，不存在冲突问题，不需要依赖锁(加锁与释放锁存在很多资源消耗)。</p>
<p>协程主要的使用场景在于<strong>处理IO密集型程序</strong>，解决效率问题，不适用于CPU密集型程序的处理。然而实际场景中这两种场景非常多，如果要充分发挥CPU利用率，可以结合多进程+协程的方式。</p>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong>资源，但每个线程有自己的<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong>，所以创建线程、线程切换的开销比进程小。</p>
<ul>
<li><p>JVM程序计数器为什么私有？</p>
<p>程序计数器用来存储指向下一条指令的地址。如果程序计数器是线程私有的，那么每个线程都有自己独立的程序计数器，线程切换时只需要保存和恢复当前线程的程序计数器的值，可以保证线程执行字节码指令时不会相互干扰，从而保证程序的正确性。</p>
</li>
</ul>
<ul>
<li><p>什么是线程上下文切换?</p>
<p>线程在执行过程中会有自己的运行条件和状态（也称上下文），比如上文所说到过的程序计数器，栈信息等。当出现如下情况的时候，线程会从占用 CPU 状态中退出。</p>
<ul>
<li><p>主动让出 CPU，比如调用了 <code>sleep()</code>, <code>wait()</code> 等。</p>
</li>
<li><p>时间片用完，因为操作系统要防止一个线程或者进程长时间占用 CPU 导致其他线程或者进程饿死。</p>
</li>
<li><p>调用了阻塞类型的系统中断，比如请求 IO，线程被阻塞。</p>
</li>
<li><p>被终止或结束运行</p>
<p>这其中前三种都会发生线程切换，线程切换意味着需要保存当前线程的上下文，留待线程下次占用 CPU 的时候恢复现场。并加载下一个将要占用 CPU 的线程上下文。这就是所谓的 <strong>上下文切换</strong>。</p>
<p>上下文切换是现代操作系统的基本功能，因其每次需要保存信息恢复信息，这将会占用 CPU，内存等系统资源进行处理，也就意味着效率会有一定损耗，如果频繁切换就会造成整体效率低下。</p>
</li>
</ul>
</li>
<li><p>为什么要使用多线程?</p>
<p>提高并发执行程度、线程占用内存小、线程调度切换开销小</p>
<ul>
<li><p><strong>从计算机底层来说：</strong> 线程可以比作是轻量级的进程，是程序执行的最小单位,线程间的<strong>切换和调度的成本远远小于进程</strong>。另外，多核 CPU 时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。</p>
</li>
<li><p>多核时代多线程主要是为了<strong>提高进程利用多核 CPU 的能力</strong>。举个例子：假如我们要计算一个复杂的任务，我们只用一个线程的话，不论系统有几个 CPU 核心，都只会有一个 CPU 核心被利用到。而创建多个线程，这些线程可以被映射到底层多个 CPU 上执行，在任务中的多个线程没有资源竞争的情况下，任务执行的效率会有显著性的提高，约等于（单核时执行时间&#x2F;CPU 核心数）</p>
</li>
</ul>
<p>个人理解：CPU负载低时最大程度发挥CPU效能。高并发时本身cpu负载高，多线程没啥提升。</p>
<p><strong>异步改同步：小于10ms 的不使用多线程</strong></p>
<p>高并发的场景下线程太多，线程调度时间得不到保障，一次任务需要多个 CPU 时间片，下一次调度的时间无法得到保障。</p>
<ul>
<li><p>为什么不用多进程？</p>
<p>线程可以共享进程资源，内存占用小，线程切换的开销小。</p>
<p>但多进程也有应用，比如Chrome浏览器每个页面都是一个进程，主要优点是一个页面崩了不会影响其他页面。以前IE浏览器就是多线程，一个页面崩了整个浏览器都崩了。</p>
</li>
</ul>
</li>
<li><p>如何理解线程安全</p>
<p>同个进程的多个线程共享进程的内存地址空间，多个线程并发访问某个共享数据，可以保证数据的正确性，不会出现意料之外的结果。</p>
<p>例如两个线程同时对某个值为0的int变量执行100次自加（非原子，读、改、写回）操作，预期值为200，但实际可能不是200，这既是线程不安全的情况。</p>
</li>
<li><p>死锁</p>
<p>例如两个线程互相占有对方所需要的资源，同时又申请对方所占有的资源，这两个线程就会互相等待而进入死锁状态。</p>
<p>死锁的四个必要条件：</p>
<ol>
<li>互斥：该资源任意一个时刻只由一个线程占用。</li>
<li>请求与保持：一个线程因请求资源而阻塞时，不释放已获得的资源。</li>
<li>不可抢占：不能强行占有其他线程拥有的资源。线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</li>
<li>循环等待:若干线程之间形成一种头尾相接的循环等待资源关系。</li>
</ol>
<p><strong>如何预防死锁？</strong> 破坏死锁的产生的必要条件即可：</p>
<ol>
<li><strong>破坏请求与保持条件</strong>：一次性申请所有的资源。</li>
<li><strong>破坏不剥夺条件</strong>：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</li>
<li><strong>破坏循环等待条件</strong>：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</li>
</ol>
<p><strong>如何避免死锁？</strong></p>
<p>避免死锁就是在资源分配时，借助于算法（比如银行家算法）对资源分配进行计算评估，使其进入安全状态。</p>
<p><strong>Java程序死锁怎么办？</strong></p>
<ul>
<li>jps列出所有正在运行中的 Java 虚拟机进程；然后使用<strong>jstack</strong>工具可以检测出程序中的死锁情况，并打印出死锁的线程堆栈信息。这可以帮助我们了解死锁的原因，从而找出解决方案。</li>
<li>使用 <code>java.lang.management</code> 中 <code>ThreadMXBean</code> 类的 <code>findDeadlockedThreads()</code> 方法得到死锁的线程id数组，通过<code>getThreadInfo()</code>方法获取线程信息。</li>
</ul>
<p>最简单解决：通过<code>Thread.getThreadById()</code>方法获取线程，然后调用<code>interrupt()</code>方法终止线程</p>
</li>
<li><p>wait和sleep区别</p>
<p><strong>共同点</strong>：两者都可以暂停线程的执行</p>
<ol>
<li>sleep()是Thread类中的静态方法，而wait()是Object类中的成员方法；</li>
<li>sleep()可以在任何地方使用，而wait()只能在同步方法或同步代码块（synchronize）中使用（依赖于对象的监视器锁），否则运行时会抛IllegalMonitorStateException；</li>
<li>sleep()不会释放锁（synchronize），而wait()会释放锁，并需要通过notify()&#x2F;notifyAll()重新获取锁。</li>
<li>sleep 方法必须要传递一个超时时间的参数，且过了超时时间之后，线程会自动唤醒。而 wait 方法可以不传递任何参数，不传递任何参数时表示永久休眠，直到另一个线程调用了 notify 或 notifyAll 之后，休眠的线程才能被唤醒。也就是说 <strong>sleep 方法具有主动唤醒功能，而不传递任何参数的 wait 方法只能被动的被唤醒</strong>。</li>
</ol>
</li>
</ul>
<h4 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h4><blockquote>
<p>Java中的线程状态分为6种。首先，线程创建后会处于NEW状态，调用start()后进入RUNNABLE状态。RUNNABLE状态又分为READY和RUNNING（操作系统中的就绪和运行态）。RUNNABLE状态执行Object.wait()方法会进入WAITING状态，表示该线程需要等待其他线程做出一些特定动作，例如Object.notify()；RUNNABLE状态执行了Thread.sleep()就会进入TIMED_WAITING，相当于在WAITING状态的基础上增加了超时限制，在超时时间结束后，线程将会返回到 RUNNABLE 状态。RUNNABLE状态执行到synchronize语句块，而没有获取到锁，就会进入BLOCKED状态，获取到锁之后又回到RUNNABLE状态。最后，线程执行结束（run()）或线程抛出一个未捕获的Exception或Error，就进入TERMINATE状态，表示已经运行完成。</p>
</blockquote>
<p>NEW: 初始状态，线程被创建出来但没有被调用 <code>start()</code> 。</p>
<p>RUNNABLE: 运行状态，线程被调用了 <code>start()</code>等待运行的状态。</p>
<ul>
<li><strong>为什么 JVM 没有区分就绪和运行这两种状态呢？</strong> （摘自：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/56494969/answer/154053599">Java 线程运行怎么有第六种状态？ - Dawell 的回答open in new window</a> ） 现在的时分（time-sharing）多任务（multi-task）操作系统架构通常都是用所谓的“时间分片（time quantum or time slice）”方式进行抢占式（preemptive）轮转调度（round-robin 式）。这个时间分片通常是很小的，一个线程一次最多只能在 CPU 上运行比如 10-20ms 的时间（此时处于 running 状态），也即大概只有 0.01 秒这一量级，时间片用后就要被切换下来放入调度队列的末尾等待再次调度。（也即回到 ready 状态）。线程切换的如此之快，区分这两种状态就没什么意义了。</li>
</ul>
<p>BLOCKED：阻塞状态，需要等待锁释放。</p>
<p>WAITING：等待状态，表示该线程需要等待其他线程做出一些特定动作（通知或中断）。</p>
<p>TIME_WAITING：超时等待状态，可以在指定的时间后自行返回而不是像 WAITING 那样一直等待。</p>
<p>TERMINATED：终止状态，表示该线程已经运行完毕。</p>
<p><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="https://s2.loli.net/2023/06/02/zrSyQnW6hRdiAsg.png" alt="Java 线程状态变迁图"></p>
<p>线程创建之后它将处于 <strong>NEW（新建）</strong> 状态，调用 <code>start()</code> 方法后开始运行，线程这时候处于 <strong>READY（可运行）</strong> 状态。可运行状态的线程获得了 CPU 时间片（timeslice）后就处于 <strong>RUNNING（运行）</strong> 状态。</p>
<p>当线程执行 <code>wait()</code>方法之后，线程进入 <strong>WAITING（等待）</strong> 状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态（wait()方法可以让当前线程释放对象锁并进入阻塞状态。notify()方法用于唤醒一个正在等待相应对象锁的线程，使其进入就绪队列）。</p>
<p><strong>TIMED_WAITING(超时等待)</strong> 状态相当于在等待状态的基础上增加了超时限制，比如通过 <code>sleep（long millis）</code>方法或 <code>wait（long millis）</code>方法可以将线程置于 TIMED_WAITING 状态。当超时时间结束后，线程将会返回到 RUNNABLE 状态。</p>
<p>当线程进入 <code>synchronized</code> 方法&#x2F;块或者调用 <code>wait</code> 后（被 <code>notify</code>）重新进入 <code>synchronized</code> 方法&#x2F;块，但是锁被其它线程占有，这个时候线程就会进入 <strong>BLOCKED（阻塞）</strong> 状态。</p>
<p>线程在执行完了 <code>run()</code>方法之后将会进入到 <strong>TERMINATED（终止）</strong> 状态</p>
<h4 id="线程创建方式"><a href="#线程创建方式" class="headerlink" title="线程创建方式"></a>线程创建方式</h4><p>创建线程有四种方式，分别是继承Thread类、实现Runnable接口、实现Callable接口、线程池。</p>
<ul>
<li><p>通过<strong>继承Thread类</strong>来创建并启动线程的步骤如下：</p>
<ol>
<li>定义Thread类的子类，并<strong>重写该类的run()方法</strong>，该run()方法将作为线程执行体。</li>
<li><strong>创建Thread子类的实例（或new Thread，使用匿名内部类，并重写run方法）</strong>，即创建了线程对象。</li>
<li><strong>调用线程对象的start()方法来启动该线程</strong>。</li>
</ol>
</li>
<li><p>通过<strong>实现Runnable接口</strong>来创建并启动线程的步骤如下：</p>
<ol>
<li><p>定义Runnable接口的实现类，<strong>并实现该接口的run()方法</strong>，该run()方法将作为线程执行体。</p>
</li>
<li><p><strong>创建Runnable实现类的实例，并将其作为Thread构造方法的target来创建Thread对象</strong>，Thread对象为线程对象。</p>
</li>
<li><p>调用线程对象的start()方法来启动该线程。</p>
</li>
</ol>
</li>
<li><p>通过<strong>实现Callable接口</strong>来创建并启动线程的步骤如下：</p>
<ol>
<li><p>创建Callable接口的实现类，<strong>并实现call()方法</strong>，该call()方法将作为线程执行体，且该call()方法有返回值。然后再创建Callable实现类的实例。</p>
</li>
<li><p><strong>使用FutureTask类来包装Callable对象</strong>，该FutureTask对象封装了该Callable对象的call()方法的返回值。</p>
</li>
<li><p>使用FutureTask对象<strong>作为Thread构造方法的target</strong>创建并调用start启动新线程。</p>
</li>
<li><p>调用FutureTask对象的get()方法来获得子线程执行结束后的返回值。</p>
</li>
</ol>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">T</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;我是继承Thread的任务&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">R</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;我是实现Runnable的任务&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        log.info(<span class="string">&quot;我是实现Callable的任务&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动继承Thread类的任务</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">T</span>().start();</span><br><span class="line"><span class="comment">// 启动继承Thread匿名内部类的任务 可用lambda优化</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    log.info(<span class="string">&quot;我是Thread匿名内部类的任务&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  启动实现Runnable接口的任务</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">R</span>()).start();</span><br><span class="line"><span class="comment">//  启动实现Runnable匿名实现类的任务</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;我是Runnable匿名内部类的任务&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="comment">//  启动实现Runnable的lambda简化后的任务</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; log.info(<span class="string">&quot;我是Runnable的lambda简化后的任务&quot;</span>)).start();</span><br><span class="line"><span class="comment">// 启动实现了Callable接口的任务 结合FutureTask 可以获取线程执行的结果</span></span><br><span class="line">FutureTask&lt;String&gt; target = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">C</span>());</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(target).start();</span><br><span class="line">log.info(target.get());</span><br></pre></td></tr></table></figure>

<p>采用实现Runnable、Callable接口的方式创建多线程的优缺点：</p>
<ul>
<li>线程类只是实现了Runnable接口或Callable接口，还可以继承其他类。</li>
<li>在这种方式下，<strong>多个线程可以共享同一个target对象，所以非常适合多个相同线程来处理同一份资源的情况</strong>，从而可以将CPU、代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。</li>
<li>劣势是，编程稍稍复杂，如果需要访问当前线程，则必须使用Thread.currentThread()方法。</li>
<li>区别：Callable接口里定义的方法有返回值，可以抛出异常；Runnable接口没有返回值，实现类中run方法的异常必须在内部处理，不能抛出</li>
</ul>
<p>采用继承Thread类的方式创建多线程的优缺点：</p>
<ul>
<li>劣势是，Java是单继承，线程类继承了Thread类就不能再继承其他父类。</li>
<li>优势是，编写简单，如果需要访问当前线程，则无须使用Thread.currentThread()方法，直接使用this即可获得当前线程。</li>
</ul>
<h5 id="start和run"><a href="#start和run" class="headerlink" title="start和run"></a>start和run</h5><p>start()会导致run()方法被调用，run()方法中的内容称为<strong>线程体</strong>，它就是这个线程需要执行的工作。</p>
<p>用<strong>start()来启动线程</strong>，实现了真正意义上的启动线程，此时会出现<strong>异步执行</strong>的效果，即在线程的创建和启动中所述的随机性。 </p>
<p>run方法是Thread类的一个普通方法，如果使用<strong>run()来启动线程</strong>，就不是异步执行了，而是<strong>同步执行</strong>，不会达到使用线程的意义。</p>
<p>注：一个线程只能调用一次start()方法,第二次调用会抛出IllegalThreadStateException。</p>
<h5 id="终止线程"><a href="#终止线程" class="headerlink" title="终止线程"></a>终止线程</h5><p>interrupt、interrupted和isInterrupted。</p>
<p>interrupt是给线程<strong>设置中断标志（并不会真正的停止线程）</strong>；interrupted是检测中断并清除中断状态；isInterrupted只检测中断。还有重要的一点就是interrupted是类方法，作用于当前线程，interrupt和isInterrupted作用于此线程，即代码中调用此方法的实例所代表的线程。</p>
<p>interrupt就是中断的方法，它的工作流程如下：</p>
<ul>
<li>如果当前线程实例在调用Object类的wait（），wait（long）或wait（long，int）方法或join（），join（long），join（long，int）方法，或者在该实例中调用了Thread.sleep（long）或Thread.sleep（long，int）方法，并且正在阻塞状态中时，则其中断状态将被清除，并将收到InterruptedException。</li>
<li>如果此线程在InterruptibleChannel上的I&#x2F;O操作中处于被阻塞状态，则该channel将被关闭，该线程的中断状态将被设置为true，并且该线程将收到java.nio.channels.ClosedByInterruptException异常。</li>
<li>如果此线程在java.nio.channels.Selector中处于被被阻塞状态，则将设置该线程的中断状态为true，并且它将立即从select操作中返回。</li>
<li>如果上面的情况都不成立，则设置中断状态为true。</li>
</ul>
<p>stop：强行终止，不推荐</p>
<h4 id="Fork-Join"><a href="#Fork-Join" class="headerlink" title="Fork&#x2F;Join"></a>Fork&#x2F;Join</h4><p>Java提供Fork&#x2F;Join框架用于并行执行任务，核心的思想就是将一个大任务切分成多个小任务，然后汇总每个小任务的执行结果得到这个大任务的最终结果。</p>
<ol>
<li><p>分割任务Fork：把大任务分割成子任务，如果分割的子任务还是很大，可以继续分割</p>
</li>
<li><p>执行结果并合并结果Join：分割的子任务被存储在双端队列中，然后启动线程分别从双端队列获取任务执行。子任务执行完的结果都统一存储在一个队列中，启动一个线程从队列中拿数据，然后合并这些数据。</p>
</li>
</ol>
<p>Fork &#x2F; Join框架使用两个类完成上面两件事：</p>
<ol>
<li><p>ForkJoinTask：要使用ForkJoin框架就首先需要创建一个ForkJoin任务。它提供在任务中执行fork() （让task异步执行）和 join()（让task同步执行，可以获取返回值）操作的机制，我们通常只需要继承他的子类即可，Fork&#x2F;Join框架提供了以下两个子类：</p>
<p>RecursiveTask：用于没有返回结果的任务。</p>
<p>RecursiveAction：用于有返回结果的任务</p>
</li>
<li><p>ForkJoinPool：就是用来执行 <code>ForkJoinTask</code> 的线程池</p>
</li>
</ol>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p><a target="_blank" rel="noopener" href="https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html">Java线程池实现原理及其在美团业务中的实践</a></p>
<p>池化思想典型应用：</p>
<ol>
<li>内存池(Memory Pooling)：预先申请内存，提升申请内存速度，减少内存碎片。</li>
<li>连接池(Connection Pooling)：预先申请数据库连接，提升申请连接的速度，降低系统的开销。</li>
<li>实例池(Object Pooling)：循环使用对象，减少资源在初始化和释放时的昂贵损耗。</li>
</ol>
<p>线程池就是管理一系列线程的资源池。当有任务要处理时，可以直接从线程池中获取线程来处理，处理完之后线程并不会立即被销毁，而是归还给线程池等待下一个任务。</p>
<ul>
<li><p>为什么要用线程池</p>
<ul>
<li>Java中的每个线程都对应于操作系统中的一个线程（Windows、Linux），创建或销毁一个线程的时间开销是比较高的，因为它涉及与操作系统交互（系统调用、核心态转换）；使用线程池可以重复利用已创建好的线程，<strong>降低线程创建和销毁所消耗的时间以及系统资源开销</strong>；</li>
<li>1个线程默认占1M内存，如果无限制的创建，并发高的时候会占用大量内存资源，有内存耗尽的风险；线程数量太多，大量线程可能会同时在争取 CPU 资源，这样会导致频繁的上下文切换（时间片耗尽让出CPU），影响了整体执行效率。使用线程池可以统一地分配和监控线程，限制线程的数量。</li>
<li><strong>降低资源消耗</strong>：通过池化技术重复利用已创建的线程，降低线程创建和销毁造成的损耗。</li>
<li><strong>提高响应速度</strong>：任务到达时，无需等待线程创建即可立即执行。</li>
<li><strong>提高线程的可管理性</strong>：线程是稀缺资源，如果无限制创建，不仅会消耗系统资源，还会因为线程的不合理分布导致资源调度失衡，降低系统的稳定性。使用线程池可以进行统一的分配、调优和监控。</li>
<li><strong>提供更多更强大的功能</strong>：线程池具备可拓展性，允许开发人员向其中增加更多的功能。比如延时定时线程池ScheduledThreadPoolExecutor，就允许任务延期执行或定期执行。</li>
</ul>
<p>线程池解决的问题：</p>
<p>线程池解决的核心问题就是资源管理问题。在并发环境下，系统不能够确定在任意时刻中，有多少任务需要执行，有多少资源需要投入。这种不确定性将带来以下若干问题：</p>
<ol>
<li>频繁申请&#x2F;销毁资源和调度资源，将带来额外的消耗，可能会非常巨大。</li>
<li>对资源无限申请缺少抑制手段，易引发系统资源耗尽的风险。</li>
<li>系统无法合理管理内部的资源分布，会降低系统的稳定性。</li>
</ol>
</li>
<li><p>提交任务<strong>execute、submit</strong>：</p>
<ol>
<li>execute只能提交Runnable类型的任务，没有返回值，而submit既能提交Runnable类型任务也能提交Callable类型任务，返回Future类型。</li>
<li>遇到未检查异常时，execute方法提交的任务异常是直接抛出的，而submit方法会将该异常包装在一个ExecutionException中并重新抛出，当调用FutureTask的get方法时，才会抛出异常。</li>
</ol>
</li>
</ul>
<h4 id="如何创建线程池"><a href="#如何创建线程池" class="headerlink" title="如何创建线程池"></a>如何创建线程池</h4><ul>
<li><p><strong>通过<code>ThreadPoolExecutor</code>构造函数来创建</strong>（推荐，让写的同学更加明确线程池的运行规则，规避资源耗尽的风险）</p>
</li>
<li><p>通过Executors（JDK内置的实现）</p>
<p><strong><code>FixedThreadPool</code><strong>：该方法返回一个</strong>固定线程数量</strong>的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。</p>
<p><strong><code>SingleThreadExecutor</code>：</strong> 该方法返回一个<strong>只有一个线程</strong>的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。</p>
<p><strong><code>CachedThreadPool</code>：</strong> 该方法返回一个创建一个具有缓存功能的线程池，<strong>可根据实际情况调整线程数量</strong>。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。</p>
<p>**<code>ScheduledThreadPool</code>**：该方法创建具有指定线程数（corePoolSize）的线程池，在给定的延迟后运行任务或者定期执行任务。</p>
</li>
</ul>
<h4 id="为什么不推荐使用内置线程池（阿里Java开发手册）"><a href="#为什么不推荐使用内置线程池（阿里Java开发手册）" class="headerlink" title="为什么不推荐使用内置线程池（阿里Java开发手册）"></a>为什么不推荐使用内置线程池（阿里Java开发手册）</h4><ul>
<li><p>**<code>FixedThreadPool</code> 和 <code>SingleThreadExecutor</code>**：任务队列（workQueue）使用的是无界的 <code>LinkedBlockingQueue</code>，允许的最大长度为 <code>Integer.MAX_VALUE</code>, 可能堆积大量的请求，从而导致 OOM。</p>
</li>
<li><p><code>CachedThreadPool</code>和 <code>ScheduledThreadPool</code>:  允许的创建线程数量（maximumPoolSize）为Integer.MAX_VALUE，可能会创建大量的线程，从而导致OOM。</p>
</li>
</ul>
<h4 id="线程池参数（可通过set方法动态修改）"><a href="#线程池参数（可通过set方法动态修改）" class="headerlink" title="线程池参数（可通过set方法动态修改）"></a>线程池参数（可通过set方法动态修改）</h4><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&mid=2651751537&idx=1&sn=c50a434302cc06797828782970da190e&scene=21#wechat_redirect">Java线程池实现原理及其在美团业务中的实践</a></p>
<p><strong><code>ThreadPoolExecutor</code> 3 个核心参数：</strong></p>
<ul>
<li><strong><code>corePoolSize</code> :</strong> 任务队列未达到队列容量时，最大可以同时运行的线程数量。</li>
<li><strong><code>maximumPoolSize</code> :</strong> 任务队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。不能小于核心线程数。线程数太多，会影响其他功能的执行。</li>
<li><strong><code>workQueue</code>:</strong> 新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</li>
</ul>
<blockquote>
<p>为什么是核心&#x2F;缺一不可？</p>
<p>从线程池的处理流程说起：</p>
<p><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="https://s2.loli.net/2023/06/02/o4xg2qp6U9yYW87.png" alt="线程池处理流程"></p>
<ol>
<li><p>新来一个任务，首先检测线程池运行状态，如果不是RUNNING，则直接拒绝，线程池要保证在RUNNING的状态下执行任务</p>
</li>
<li><p>如果<strong>当前运行的线程数小于核心线程数</strong>，那么就会新建一个线程来执行任务。</p>
</li>
<li><p>如果当前运行的线程数等于或大于核心线程数，但是小于最大线程数，那么就把该任务放入到任务队列里等待执行。</p>
</li>
<li><p>如果向任务队列投放任务失败（任务队列已经满了），但是当前运行的线程数是小于最大线程数的，就新建一个线程来执行任务。</p>
</li>
<li><p>如果当前运行的线程数已经等同于最大线程数了，就按拒绝策略处理（默认抛异常AbortPolicy）。</p>
</li>
</ol>
</blockquote>
<p><code>ThreadPoolExecutor</code>其他常见参数 :</p>
<ul>
<li><strong><code>keepAliveTime</code></strong>:线程池中的线程数量大于 <code>corePoolSize</code> 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 <code>keepAliveTime</code>才会被回收销毁；</li>
<li><strong><code>unit</code></strong> : <code>keepAliveTime</code> 参数的时间单位。</li>
<li><strong><code>threadFactory</code></strong> :executor 创建新线程的时候会用到。</li>
<li><strong><code>handler</code></strong> :饱和策略。</li>
</ul>
<h4 id="如何设定线程池大小"><a href="#如何设定线程池大小" class="headerlink" title="如何设定线程池大小"></a>如何设定线程池大小</h4><p><strong>CPU 密集型任务(N+1)：</strong> 这种任务消耗的主要是 CPU 资源，可以将线程数设置为 N（CPU 核心数）+1，通常能实现最优的效率。比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。CPU 的每个核心工作基本都是满负荷的，如果设置了过多的线程，每个线程都想去利用 CPU 资源来执行自己的任务，这就会造成不必要的上下文切换，此时线程数的增多并没有让性能提升，反而由于线程数量过多会导致性能下降。</p>
<p><strong>I&#x2F;O 密集型任务(2N)：</strong> 这种任务应用起来，系统会用大部分的时间来处理 I&#x2F;O 交互，而线程在处理 I&#x2F;O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用。因此在 I&#x2F;O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 2N。</p>
<p>以下来自《Java并发编程实战》：</p>
<p><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="http://img.ripplesu.top/blog/Typora/image-20230924113351761.png" alt="线程池最优大小计算公式"></p>
<h4 id="饱和-拒绝策略"><a href="#饱和-拒绝策略" class="headerlink" title="饱和&#x2F;拒绝策略"></a>饱和&#x2F;拒绝策略</h4><p><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="https://s2.loli.net/2023/06/02/ZxfLp8bmOjro7nM.png" alt="图片"></p>
<h4 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h4><p>不同的线程池会选用不同的阻塞队列，我们可以结合内置线程池来分析。</p>
<ul>
<li>容量为 <code>Integer.MAX_VALUE</code> 的 <code>LinkedBlockingQueue</code>（无界队列）：<code>FixedThreadPool</code> 和 <code>SingleThreadExector</code> 。由于队列永远不会被放满，因此<code>FixedThreadPool</code>最多只能创建核心线程数的线程。</li>
<li><code>SynchronousQueue</code>（同步队列）：<code>CachedThreadPool</code> 。<code>SynchronousQueue</code> 没有容量，不存储元素，目的是保证对于提交的任务，如果有空闲线程，则使用空闲线程来处理；否则新建一个线程来处理任务。也就是说，<code>CachedThreadPool</code> 的最大线程数是 <code>Integer.MAX_VALUE</code> ，可以理解为线程数是可以无限扩展的，可能会创建大量线程，从而导致 OOM。</li>
<li><code>DelayedWorkQueue</code>（延迟阻塞队列）：<code>ScheduledThreadPool</code> 和 <code>SingleThreadScheduledExecutor</code> 。<code>DelayedWorkQueue</code> 的内部元素并不是按照放入的时间排序，而是会按照延迟的时间长短对任务进行排序，内部采用的是“堆”的数据结构，可以保证每次出队的任务都是当前队列中执行时间最靠前的。<code>DelayedWorkQueue</code> 添加元素满了之后会自动扩容原来容量的 1&#x2F;2，即永远不会阻塞，最大扩容可达 <code>Integer.MAX_VALUE</code>，所以最多只能创建核心线程数的线程。</li>
</ul>
<p><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="https://s2.loli.net/2023/07/10/sZaWld4pr2wmAQg.png" alt="阻塞队列"></p>
<h4 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h4><p><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="https://s2.loli.net/2023/06/02/IBxuikaj82Qzrc6.png" alt="图片"></p>
<p>生命周期转换：</p>
<p><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="https://s2.loli.net/2023/06/02/l3gLmiW9RwTUsG4.png" alt="图片"></p>
<h4 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h4><ul>
<li><p>corePoolSize&#x3D;0会怎么样</p>
<p>在1.6版本之后，如果corePoolSize&#x3D;0，提交任务时如果线程池为空，则会立即创建一个线程来执行任务（先排队再获取）；如果提交任务的时候，线程池不为空，则先在等待队列中排队，只有队列满了才会创建新线程。</p>
</li>
<li><p>线程池被创建后里面有线程吗？如果没有的话，你知道有什么方法对线程池进行预热吗？</p>
<p>线程池被创建后如果没有任务过来，里面是不会有线程的。如果需要预热的话可以调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prestartAllCoreThreads、prestartCoreThreads（一个）</span><br></pre></td></tr></table></figure>
</li>
<li><p>核心线程数会被回收吗？需要什么设置？</p>
<p>核心线程数默认是不会被回收的，如果需要回收核心线程数，需要调用下面的方法：</p>
<p>allowCoreThreadTimeOut 该值默认为 false。</p>
</li>
<li><p><strong>怎么进行异常处理</strong></p>
<p>很多代码的写法，我们都习惯按照常见范式去编写，而没有去思考为什么。比如：</p>
<ul>
<li><p>如果我们使用execute()提交任务，我们一般要在Runable任务的代码加上try-catch进行异常处理。</p>
</li>
<li><p>如果我们使用submit()提交任务，我们一般要在主线程中，对Future.get()进行try-catch进行异常处理。</p>
</li>
</ul>
</li>
<li><p>线程池原理</p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/6fXHJGQJOyA8Q0KgBYqb4w">https://mp.weixin.qq.com/s/6fXHJGQJOyA8Q0KgBYqb4w</a></p>
<p><a target="_blank" rel="noopener" href="https://pdai.tech/md/java/thread/java-thread-x-juc-executor-ThreadPoolExecutor.html#threadpoolexecutor%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3">JUC线程池: ThreadPoolExecutor详解 | Java 全栈知识体系 (pdai.tech)</a></p>
</li>
<li><p>优雅关闭</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">shutdownThreadPool</span><span class="params">(ExecutorService executor, Logger logger)</span> &#123;</span><br><span class="line">    <span class="comment">// 调用 shutdown()方法后线程池会在执行完正在执行的任务和队列中等待的任务后才彻底关闭</span></span><br><span class="line">    <span class="comment">// 调用 shutdown()方法后如果还有新的任务被提交，线程池则会根据拒绝策略直接拒绝后续新提交的任务。</span></span><br><span class="line">    executor.shutdown();</span><br><span class="line">    <span class="type">int</span> <span class="variable">retry</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">while</span> (retry &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        retry--;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (executor.awaitTermination(<span class="number">100</span>, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            executor.shutdownNow();</span><br><span class="line">            Thread.interrupted();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger != <span class="literal">null</span>) &#123;</span><br><span class="line">                logger.error(<span class="string">&quot;ThreadPoolManager shutdown executor has error : &quot;</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    executor.shutdownNow();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>动态线程池</p>
<p>美团文章：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/baYuX8aCwQ9PP6k7TDl2Ww">https://mp.weixin.qq.com/s/baYuX8aCwQ9PP6k7TDl2Ww</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/opengoofy/hippo4j">https://github.com/opengoofy/hippo4j</a></p>
</li>
</ul>
<h3 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h3><p><code>Future</code> 类是异步思想的典型运用，主要用在一些需要执行耗时任务的场景，避免程序一直原地等待耗时任务执行完成，执行效率太低。具体来说是这样的：当我们执行某一耗时的任务时，可以将这个耗时任务交给一个子线程去异步执行，同时我们可以干点其他事情，不用傻傻等待耗时任务执行完成。等我们的事情干完后，我们再通过 <code>Future</code> 类获取到耗时任务的执行结果。这样一来，程序的执行效率就明显提高了。</p>
<p>这其实就是多线程中经典的 <strong>Future 模式</strong>，你可以将其看作是一种设计模式，核心思想是异步调用，主要用在多线程领域，并非 Java 语言独有。</p>
<p>在 Java 中，<code>Future</code> 类只是一个泛型接口，位于 <code>java.util.concurrent</code> 包下，其中定义了 5 个方法，主要包括下面这 4 个功能：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// V 代表了Future执行的任务返回值的类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Future</span>&lt;V&gt; &#123;</span><br><span class="line">    <span class="comment">// 取消任务执行</span></span><br><span class="line">    <span class="comment">// 成功取消返回 true，否则返回 false</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">cancel</span><span class="params">(<span class="type">boolean</span> mayInterruptIfRunning)</span>;</span><br><span class="line">    <span class="comment">// 判断任务是否被取消</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isCancelled</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 判断任务是否已经执行完成</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isDone</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 获取任务执行结果</span></span><br><span class="line">    V <span class="title function_">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException;</span><br><span class="line">    <span class="comment">// 指定时间内没有返回计算结果就抛出 TimeOutException 异常</span></span><br><span class="line">    V <span class="title function_">get</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutExceptio</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单理解就是：我有一个任务，提交给了 <code>Future</code> 来处理。任务执行期间我自己可以去做任何想做的事情。并且，在这期间我还可以取消任务以及获取任务的执行状态。一段时间之后，我就可以 <code>Future</code> 那里直接取出任务执行结果。</p>
<h4 id="Callable-和-Future-有什么关系？"><a href="#Callable-和-Future-有什么关系？" class="headerlink" title="Callable 和 Future 有什么关系？"></a>Callable 和 Future 有什么关系？</h4><p>我们可以通过 <code>FutureTask</code> 来理解 <code>Callable</code> 和 <code>Future</code> 之间的关系。</p>
<p><code>FutureTask</code> 提供了 <code>Future</code> 接口的基本实现，常用来封装 <code>Callable</code> 和 <code>Runnable</code>，具有取消任务、查看任务是否执行完成以及获取任务执行结果的方法。<code>ExecutorService.submit()</code> 方法返回的其实就是 <code>Future</code> 的实现类 <code>FutureTask</code> 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Callable&lt;T&gt; task)</span>;</span><br><span class="line">Future&lt;?&gt; submit(Runnable task);</span><br></pre></td></tr></table></figure>

<p><code>FutureTask</code> 不光实现了 <code>Future</code>接口，还实现了<code>Runnable</code> 接口，因此可以作为任务直接被线程执行。</p>
<p><code>FutureTask</code> 有两个构造函数，可传入 <code>Callable</code> 或者 <code>Runnable</code> 对象。实际上，传入 <code>Runnable</code> 对象也会在方法内部转换为<code>Callable</code> 对象。</p>
<p><code>FutureTask</code>相当于对<code>Callable</code> 进行了封装，管理着任务执行的情况，存储了 <code>Callable</code> 的 <code>call</code> 方法的任务执行结果。</p>
<h4 id="CompletableFuture-类有什么用？"><a href="#CompletableFuture-类有什么用？" class="headerlink" title="CompletableFuture 类有什么用？"></a>CompletableFuture 类有什么用？</h4><p>美团：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/GQGidprakfticYnbVYVYGQ">https://mp.weixin.qq.com/s/GQGidprakfticYnbVYVYGQ</a></p>
<p>CompletableFuture是由Java 8引入的，在Java8之前我们一般通过Future实现异步。</p>
<ul>
<li>Future用于表示异步计算的结果，只能通过<strong>阻塞（get方法）或者轮询（isDone）</strong>的方式获取结果，而且不支持设置回调方法，Java 8之前若要设置回调一般会使用guava的ListenableFuture，回调的引入又会导致臭名昭著的回调地狱（由于每次异步操作都需要有一个回调函数来执行就绪后的后续逻辑，因此当遇上各个异步操作之前有先后关系时，势必就要回调套回调。当业务代码一复杂，回调套回调写多了，造成代码难以阅读和调试，就成了所谓的回调地狱。）。</li>
<li>CompletableFuture对Future进行了扩展，可以通过设置回调的方式处理计算结果，同时也支持组合操作，支持进一步的编排，同时一定程度解决了回调地狱的问题。还提供了函数式编程、异步任务编排组合（可以将多个异步任务串联起来，组成一个完整的链式调用）等能力。</li>
<li>Future要捕获异常只能通过get方法，completableFuture可以通过exceptionally回调处理异常</li>
</ul>
<h5 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h5><p><code>CompletableFuture</code> 同时实现了 <code>Future</code> 和 <code>CompletionStage</code> 接口。<code>CompletionStage</code> 接口描述了一个异步计算的阶段。Future表示异步计算的结果，CompletionStage用于表示异步执行过程中的一个步骤（Stage），这个步骤可能是由另外一个CompletionStage触发的，随着当前步骤的完成，也可能会触发其他一系列CompletionStage的执行。从而我们可以根据实际业务对这些步骤进行多样化的编排组合，CompletionStage接口正是定义了这样的能力，我们可以通过其提供的thenAppy、thenCompose等函数式编程方法来组合编排这些步骤。</p>
<p>默认使用ForkJoinPool.commonPool（进程公共线程池CommonPool的大小是CPU核数-1，如果是IO密集的应用，线程数可能成为瓶颈）；</p>
<p>类似观察者模式：每个CompletableFuture都可以被看作一个被观察者，其内部有一个Completion类型的链表成员变量stack，用来存储注册到其中的所有观察者。当被观察者执行完成后会弹栈stack属性，依次通知注册到其中的观察者。</p>
<h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><p>CompletableFuture实现了CompletionStage接口，通过丰富的回调方法，支持各种组合操作，每种组合场景都有同步和异步两种方法。</p>
<p>同步方法（即不带Async后缀的方法）有两种情况。</p>
<ul>
<li>如果注册时被依赖的操作<strong>已经执行完成</strong>，则直接由<strong>当前线程</strong>执行。</li>
<li>如果注册时被依赖的操作<strong>还未执行完</strong>，则由<strong>回调线程</strong>执行。</li>
</ul>
<p>异步方法（即带Async后缀的方法）：可以选择是否传递线程池参数Executor运行在指定线程池中；当不传递Executor时，会使用ForkJoinPool中的共用线程池CommonPool（CommonPool的大小是CPU核数-1，如果是IO密集的应用，线程数可能成为瓶颈）。</p>
<h3 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h3><p>AQS 的全称为 <code>AbstractQueuedSynchronizer</code> ，翻译过来的意思就是抽象队列同步器。这个类在 <code>java.util.concurrent.locks</code> 包下面。</p>
<p>AQS 就是一个抽象类，主要用来构建锁和同步器。</p>
<p>AQS 为构建锁和同步器提供了一些通用功能的实现，因此，使用 AQS 能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的 <code>ReentrantLock</code>，<code>Semaphore</code>，其他的诸如 <code>ReentrantReadWriteLock</code>，<code>SynchronousQueue</code>等等皆是基于 AQS 的。</p>
<h4 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h4><p><code>CountDownLatch</code> 允许 <code>count</code> 个线程阻塞在一个地方，直至所有线程的任务都执行完毕。</p>
<p><code>CountDownLatch</code> 是一次性的，计数器的值只能在构造方法中初始化一次，之后没有任何机制再次对其设置值，当 <code>CountDownLatch</code> 使用完毕后，它不能再次被使用。</p>
<ul>
<li><p>原理</p>
<p><code>CountDownLatch</code> 是共享锁的一种实现,它默认构造 AQS 的 <code>state</code> 值为 <code>count</code>。当线程使用 <code>countDown()</code> 方法时,其实使用了<code>tryReleaseShared</code>方法以 CAS 的操作来减少 <code>state</code>,直至 <code>state</code> 为 0 。当调用 <code>await()</code> 方法的时候，如果 <code>state</code> 不为 0，那就证明任务还没有执行完毕，<code>await()</code> 方法就会一直阻塞，也就是说 <code>await()</code> 方法之后的语句不会被执行。然后，<code>CountDownLatch</code> 会自旋 CAS 判断 <code>state == 0</code>，如果 <code>state == 0</code> 的话，就会释放所有等待的线程，<code>await()</code> 方法之后的语句得到执行。</p>
</li>
<li><p>应用场景</p>
<p>例如：我们要读取处理 6 个文件，这 6 个任务都是没有执行顺序依赖的任务，但是我们需要返回给用户的时候将这几个文件的处理的结果进行统计整理。</p>
<p>为此我们定义了一个线程池和 count 为 6 的<code>CountDownLatch</code>对象 。使用线程池处理读取任务，每一个线程处理完之后就调用countDownLatch.countDown()使count-1;，调用<code>CountDownLatch</code>对象的 <code>await()</code>方法，直到所有文件读取完之后，才会接着执行后面的逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理文件的数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadCount</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 创建一个具有固定线程数量的线程池对象（推荐使用构造方法创建）</span></span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(threadCount);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadnum</span> <span class="operator">=</span> i;</span><br><span class="line">        threadPool.execute(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//处理文件的业务操作</span></span><br><span class="line">                <span class="comment">//......</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//表示一个文件已经被完成</span></span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    countDownLatch.await();</span><br><span class="line">    threadPool.shutdown();</span><br><span class="line">    System.out.println(<span class="string">&quot;finish&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a><strong>CyclicBarrier</strong></h4><p>CyclicBarrier 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。</p>
<p>这个屏障之所以用循环修饰，是因为在所有的线程释放彼此之后，这个屏障是可以重新使用的（reset()方法重置屏障点），这一点与CountDownLatch不同。</p>
<p>CyclicBarrier是一种同步机制允许一组线程相互等待，等到所有线程都到达一个屏障点才退出await方法，它没有直接实现AQS而是借助ReentrantLock来实现的同步机制。它是<strong>可循环使用的，而CountDownLatch是一次性的</strong>，另外它体现的语义也跟CountDownLatch不同，CountDownLatch减少计数到达条件采用的是release方式，而CyclicBarrier走向屏障点（await）采用的是Acquire方式，Acquire是会阻塞的，这也实现了CyclicBarrier的另外一个特点，<strong>只要有一个线程中断那么屏障点就被打破，所有线程都将被唤醒</strong>（CyclicBarrier自己负责这部分实现，不是由AQS调度的），这样也避免了因为一个线程中断引起永远不能到达屏障点而导致其他线程一直等待。屏障点被打破的CyclicBarrier将不可再使用（会抛出BrokenBarrierException）除非执行reset操作。</p>
<ul>
<li>CountDownLatch：一个或者多个线程，等待其他多个线程完成某件事情之后才能执行；</li>
<li>CyclicBarrier：多个线程互相等待，直到到达同一个同步点，再继续一起执行。</li>
</ul>
<h3 id="Java中乐观锁和悲观锁的区别"><a href="#Java中乐观锁和悲观锁的区别" class="headerlink" title="Java中乐观锁和悲观锁的区别"></a>Java中乐观锁和悲观锁的区别</h3><p>悲观锁：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。Java中悲观锁是通过synchronized关键字或Lock接口来实现的。</p>
<p>乐观锁：顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据。乐观锁适用于多读的应用类型，这样可以提高吞吐量。在JDK1.5 中新增 java.util.concurrent (J.U.C)就是建立在CAS之上的。相对于对于 synchronized 这种阻塞算法，CAS是非阻塞算法的一种常见实现。所以J.U.C在性能上有了很大的提升。但是，如果冲突频繁发生（写占比非常多的情况），会频繁失败和重试，这样同样会非常影响性能，导致 CPU 飙升。</p>
<ul>
<li>悲观锁通常多用于写比较多的情况下（多写场景，竞争激烈），这样可以避免频繁失败和重试影响性能，悲观锁的开销是固定的。不过，如果乐观锁解决了频繁失败和重试这个问题的话（比如<code>LongAdder</code>），也是可以考虑使用乐观锁的，要视实际情况而定。</li>
<li>乐观锁通常多于写比较少的情况下（多读场景，竞争较少），这样可以避免频繁加锁影响性能。不过，乐观锁主要针对的对象是单个共享变量（参考<code>java.util.concurrent.atomic</code>包下面的原子变量类）。</li>
</ul>
<h4 id="如何实现乐观锁？"><a href="#如何实现乐观锁？" class="headerlink" title="如何实现乐观锁？"></a>如何实现乐观锁？</h4><p>乐观锁一般会使用版本号机制或 CAS 算法实现，CAS 算法相对来说更多一些，这里需要格外注意。</p>
<h5 id="版本号机制"><a href="#版本号机制" class="headerlink" title="版本号机制"></a>版本号机制</h5><p>一般是在数据表中加上一个数据版本号 <code>version</code> 字段，表示数据被修改的次数。当数据被修改时，<code>version</code> 值会加一。当线程 A 要更新数据值时，在读取数据的同时也会读取 <code>version</code> 值，在提交更新时，若刚才读取到的 version 值为当前数据库中的 <code>version</code> 值相等（where version&#x3D;oldVersion）时才更新，否则重试更新操作，直到更新成功。</p>
<h5 id="CAS-算法"><a href="#CAS-算法" class="headerlink" title="CAS 算法"></a>CAS 算法</h5><p>CAS 的全称是 <strong>Compare And Swap（比较与交换）</strong> ，用于实现乐观锁，被广泛应用于各大框架中。CAS 的思想很简单，就是用一个预期值和要更新的变量值进行比较，两值相等才会进行更新。</p>
<p>CAS 是一个<strong>原子操作</strong>，底层依赖于一条 CPU 的原子指令。</p>
<blockquote>
<p><strong>原子操作</strong> 即最小不可拆分的操作，也就是说操作一旦开始，就不能被打断，直到操作完成。</p>
</blockquote>
<p>CAS 涉及到三个操作数：</p>
<ul>
<li><strong>V</strong>：要更新的变量值(Var)</li>
<li><strong>E</strong>：预期值(Expected)</li>
<li><strong>N</strong>：拟写入的新值(New)</li>
</ul>
<p>当且仅当 V 的值等于 E 时，CAS 通过原子方式用新值 N 来更新 V 的值。如果不等，说明已经有其它线程更新了 V，则当前线程放弃更新。当多个线程同时使用 CAS 操作一个变量时，只有一个会胜出，并成功更新，其余均会失败，但失败的线程并不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作。</p>
<ul>
<li><p>ABA 问题</p>
<p>如果一个变量 V 初次读取的时候是 A 值，并且在准备赋值的时候检查到它仍然是 A 值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回 A，那 CAS 操作就会误认为它从来没有被修改过。这个问题被称为 CAS 操作的 <strong>“ABA”问题。</strong></p>
<p>ABA 问题的解决思路是在变量前面追加上<strong>版本号或者时间戳</strong>。JDK 1.5 以后的 <code>AtomicStampedReference</code> 类就是用来解决 ABA 问题的，其中的 <code>compareAndSet()</code> 方法就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p>
</li>
<li><p>循环时间长开销大</p>
<p>CAS 经常会用到<strong>自旋</strong>操作来进行重试（CAS基于硬件实现，不需要进入核心态，不需要切换线程），也就是不成功就一直循环执行直到成功。如果长时间不成功，会给 CPU 带来非常大的执行开销。</p>
<p>如果 JVM 能支持处理器提供的 pause 指令那么效率会有一定的提升，pause 指令有两个作用：</p>
<ol>
<li>可以延迟流水线执行指令，使 CPU 不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。</li>
<li>可以避免在退出循环的时候因内存顺序冲而引起 CPU 流水线被清空，从而提高 CPU 的执行效率。</li>
</ol>
</li>
<li><p>只能保证一个共享变量的原子操作</p>
<p>CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效。但是从 JDK 1.5 开始，提供了<code>AtomicReference</code>类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作.所以我们可以使用锁或者利用<code>AtomicReference</code>类把多个共享变量合并成一个共享变量来操作。</p>
</li>
</ul>
<h3 id="相关面试题"><a href="#相关面试题" class="headerlink" title="相关面试题"></a>相关面试题</h3><h4 id="线程交替打印"><a href="#线程交替打印" class="headerlink" title="线程交替打印"></a>线程交替打印</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 交替打印ABC</span></span><br><span class="line"><span class="type">char</span>[] abc = <span class="string">&quot;ABC&quot;</span>.toCharArray();</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="built_in">this</span>::printABC).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="built_in">this</span>::printABC).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="built_in">this</span>::printABC).start();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printABC</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (i)&#123;</span><br><span class="line">        <span class="keyword">while</span> (count &lt; <span class="number">5</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">                System.out.println(abc[i++]);</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">3</span>) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    i = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印0-100</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="built_in">this</span>::print).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="built_in">this</span>::print).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="built_in">this</span>::print).start();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (i)&#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">            System.out.println(i++);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="死锁例子"><a href="#死锁例子" class="headerlink" title="死锁例子"></a>死锁例子</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadlockExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">lock1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">lock2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span>(lock1) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Thread 1 acquired lock 1&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">                    <span class="keyword">synchronized</span>(lock2) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;Thread 1 acquired lock 2&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span>(lock2) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Thread 2 acquired lock 2&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">                    <span class="keyword">synchronized</span>(lock1) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;Thread 2 acquired lock 1&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><ul>
<li><p>怎么理解面向对象</p>
<p>面向对象就是把现实中客观存在的事物看做一个对象，然后将对象中共有的数据和行为抽象为软件中的类。面向对象的思维更注重解决问题的过程中需要有哪些参与者，每个参与者各自负责什么事情，参与者之间如何协作；而面向过程的思维方式更注重解决问题的步骤，自顶向下顺序执行。</p>
</li>
<li><p>面向对象三大特征</p>
<ul>
<li><p>封装</p>
<p>封装就是把事物的属性和行为包装到对象中，通过可以被外界访问的方法有选择性（通过访问修饰符）的暴露对象的数据和功能。</p>
<p>目的：</p>
<ul>
<li>隐藏类的实现细节</li>
<li>让使用者只能通过事先预定的方法来访问数据，限制对成员变量的不合理访问</li>
</ul>
</li>
<li><p>继承</p>
<p>继承是实现软件复用的重要手段。不同类型对象间存在共同点，可以这些共同点抽取出来封装在父类中，当子类继承父类后，将直接获得父类的属性和方法。</p>
<ul>
<li><p>为什么Java只能单继承</p>
<p>Java中一个类只能有一个直接的父类。多继承容易产生混淆。比如，两个父类中包含相同的方法时，子类在调用该方法时就会迷惑（需要额外机制解决）。</p>
<p>单一继承模型可以使类的层次结构更加清晰和简洁，易于理解和使用。如果允许多重继承，类的继承层次将变得复杂和难以理解，同时也会增加代码的维护难度和复杂性。</p>
</li>
<li><p>接口为什么多继承</p>
<p>接口中的方法都是抽象方法，没有具体实现，因此不会混淆。</p>
</li>
</ul>
</li>
<li><p>多态</p>
<p>对象在执行同一个方法时，可能表现出多种行为特征。最常见的就是子类对象可以直接赋给父类变量，父类变量运行时就可以表现出子类的行为特征</p>
<p>常见例子：List list &#x3D; new ArrayList&lt;&gt;();</p>
<p>优点：灵活，解耦（不依赖于某个具体的子类）</p>
<blockquote>
<p>Java中多态怎么实现？</p>
</blockquote>
<p>重载式多态,也叫编译时多态。编译时多态是静态的,主要是指方法的重载,它是根据参数列表来区分不同的方法，编译后变成两个不同方法。</p>
<p>Java中运行时多态性的实现方式是通过<strong>方法重写</strong>和<strong>向上转型</strong>（Upcasting）来实现的。</p>
<ul>
<li><p>方法重写是指子类覆盖父类的方法，并且方法名、参数列表和返回值类型都相同。或实现抽象类&#x2F;接口的某些抽象方法。</p>
</li>
<li><p>向上转型则是指将一个子类对象赋给一个父类引用，从而使得这个对象能够以父类的形式来被访问。</p>
<p>设计程序时，我们可以将参数的类型定义为父类型。在调用程序时，则可以根据实际情况，传入子类的实例。</p>
<p><strong>向上转型</strong>是安全的。但是缺点是：一旦向上转型，子类会<strong>丢失</strong>的子类的扩展方法</p>
<blockquote>
<p>向下转型：父类对象赋给子类引用，需要强转</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="SOLID原则"><a href="#SOLID原则" class="headerlink" title="SOLID原则"></a>SOLID原则</h3><ul>
<li><p>单一责任原则<br>指的是一个类或者一个方法只做一件事。如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化就可能对其他职责产生影响。</p>
</li>
<li><p>开放封闭原则——核心，即其他原则都是开闭原则的手段和工具<br>对扩展开放，对修改关闭。需求改变时，尽可能少地改变软件实体源代码（类、接口、方法等），通过扩展功能使其满足新的需求。例如接口，需求变动时只需增加一个新的实现类，无需修改原有接口。</p>
<p>提高复用性（复用接口或抽象类中的定义和代码）和可维护性（需求变动只需修改具体实现类）</p>
</li>
<li><p>里氏替换原则<br>所有基类出现的地方都可以用派生类替换而不会程序产生错误。子类可以扩展父类的功能，但不能改变父类原有的功能。</p>
</li>
<li><p>接口隔离原则<br>类不应该依赖不需要的接口。如果类被强迫依赖于他们不需要的接口，当这些接口发生改变时，他们也不得不跟着改变。</p>
</li>
<li><p>依赖倒置原则<br>高层模块不应该依赖低层模块，双方应该依赖抽象。抽象不应该依赖细节，而细节应该依赖抽象。遵循依赖倒置原则可以使高层模块与低层模块解耦，避免当低层模块需要替换或者修改时对高层模块的影响。</p>
<p><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="https://s2.loli.net/2023/05/28/dfm4WClIv9Kiwq2.png" alt="依赖倒置"></p>
</li>
</ul>
<h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><p>设计模式，是面向对象设计中常见问题的典型解决方案。模式并不是一段特定的代码， 而是前人根据实践验证的解决特定问题的一般性概念。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性、程序的重用性。</p>
<ul>
<li>创建型模式，共五种：<strong>工厂方法模式、抽象工厂模式</strong>、<strong>单例模式</strong>、建造者模式、原型模式。</li>
</ul>
<ul>
<li><p>结构型模式，共七种：适配器模式、装饰器模式、<strong>代理模式</strong>、外观模式、桥接模式、组合模式、享元模式。</p>
</li>
<li><p>行为型模式，共十一种：<strong>策略模式</strong>、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</p>
</li>
</ul>
<p>适当的使用设计模式，让我们的代码更加简洁、易读、可扩展。</p>
<p>设计模式（Design Pattern）是一套被反复使用、多人知晓、分类编目、代码设计经验的总结。使用设计模式可以带来如下益处。</p>
<ul>
<li>简洁。比如单例模式，减少多实例创建维护的成本，获取实例只需要一个 Get 函数。</li>
<li>易读。业界经验，多人知晓。如果告知他人自己使用了相应的设计模式实现某个功能，那么他人便大概知晓了你的实现细节，更加容易读懂你的代码。</li>
<li>可扩展。设计模式不仅能简洁我们的代码，还可以增加代码的可扩展性。比如 Go 推崇的 Option 模式，既避免了书写不同参数版本的函数，又达到了无限扩增函数参数的效果，增加了函数扩展性。</li>
</ul>
<h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><p><strong>单例模式</strong>是一种创建型设计模式， 可以保证一个类只有一个实例， 并提供一个访问该实例的方法。</p>
<p>所有单例的实现都包含以下两个相同的步骤：</p>
<ul>
<li>将默认构造函数设为私有， 防止其他对象使用<code>new</code>来获得单例类的实例。</li>
<li>新建一个对外开放的静态方法作为构造和获取单例对象的函数。</li>
</ul>
<p><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="https://s2.loli.net/2023/06/11/38jOeamYTL2GiVo.png" alt="image-20230611190600016"></p>
<p>具体而言，在Java中单例模式一般有五种实现：</p>
<ul>
<li><p>饿汉式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 优点：线程安全,不加锁，调用效率高</span></span><br><span class="line"><span class="comment">// 缺点：类初始化时,会立即加载该对象（可能浪费内存）；</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();  </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span> <span class="params">()</span>&#123;&#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;  </span><br><span class="line">    	<span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>懒汉式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非线程安全，懒加载</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;  </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span> <span class="params">()</span>&#123;&#125;  </span><br><span class="line">    <span class="comment">// 如果加了锁，性能差，只要有一个线程执行getInstance，其他线程只能等待</span></span><br><span class="line">    <span class="comment">// 为什么不用volatile？锁住了整个方法，无线程安全问题</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">static</span> <span class="params">(<span class="keyword">synchronized</span>)</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;  </span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>双重校验锁（DCL）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 懒加载，线程安全，性能较上一种好（锁粒度小）；但实现复杂</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;  </span><br><span class="line">    <span class="comment">// volatile变量  保证可见性、禁止指令重排序</span></span><br><span class="line">    <span class="comment">/* singleton = new Singleton() 并非是一个原子操作，在 JVM 中上述语句至少做了以下这 3 件事：</span></span><br><span class="line"><span class="comment">                    第一步是给 singleton 分配内存空间；</span></span><br><span class="line"><span class="comment">                    第二步开始调用 Singleton 的构造函数等，来初始化 singleton；</span></span><br><span class="line"><span class="comment">                    第三步将 singleton 对象指向分配的内存空间（执行完这步 singleton 就不是 null 了）。</span></span><br><span class="line"><span class="comment">                    由于JVM具有指令重排的特性，执行的顺序可能是1-&gt;3-&gt;2,</span></span><br><span class="line"><span class="comment">                    指令重排在单线程下不会有线程安全问题，但在多线程环境下，会导致一个线程获得还没有初始化的实例。</span></span><br><span class="line"><span class="comment">                    例如线程T1执行1、3，此时线程T2调用getSingleton()方法后发现singleton不为空,因此返回singleton,但此时singleton 还未被实例化</span></span><br><span class="line"><span class="comment">                    使用volatile关键字可以禁止指令重排序，保证在多线程环境下能正常运行*/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;  </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span> <span class="params">()</span>&#123;&#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getSingleton</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="comment">// 如果已经实例化，则无需等待</span></span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;  </span><br><span class="line">            <span class="comment">// 假设有两个线程T1和T2，都进行完第一次判空了，且都阻塞在此位置</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;  </span><br><span class="line">                <span class="comment">// 如果这里不判空T1和T2都会创建singleton实例，这就违背了单例模式设计的初衷</span></span><br><span class="line">                <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;  </span><br><span class="line">                    singleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>() </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> singleton;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>静态内部类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 与DCL效果一致，静态内部类使用时才加载，线程安全</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;  </span><br><span class="line">    <span class="comment">// 外部类加载时并不会立即加载内部类，只有当getInstance()方法第一次被调用时，才会去加载SingletonHolder类，初始化INSTANCE。具体与JVM类加载机制有关</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123;  </span><br><span class="line">    	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span> <span class="params">()</span>&#123;&#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>枚举</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程安全，实现简单，非懒加载</span></span><br><span class="line"><span class="comment">// JVM会保证枚举对象的唯一性、不存在线程安全问题，在很多书和文章中都强烈推荐将该方法作为单例模式的最佳实现方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">doSomeThing</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// Do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用方法</span></span><br><span class="line">Singleton.INSTANCE.doSomething();</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h4><p>结构型设计模式的一种。思想是通过代理控制对目标对象的访问，在不改变目标类方法的代码的情况下对目标类的方法进行增强，比如在这个调用目标方法前后增加一些非核心业务逻辑的处理或添加新的功能。</p>
<p><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="https://s2.loli.net/2023/06/12/SIsu3PbTZxirLYO.png" alt="代理模式类图"></p>
<p>应用场景：Spring AOP、日志打印、访问控制、异常处理等</p>
<ul>
<li><p>静态代理</p>
<p>程序员自己写代理类。所谓静态也就是代理关系在编译期间就已经确定了，运行前代理类的字节码文件就已经存在。</p>
<p>缺点：每个需要代理的对象都需要自己重复编写代理。</p>
</li>
<li><p>动态代理</p>
<p>代理类在程序运行时创建的代理方式被成为动态代理。</p>
<ul>
<li><p>JDK动态代理：只能代理接口，故目标类必须实现接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;保存数据方法&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每次生成动态代理类对象时,实现了InvocationHandler接口的调用处理器对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InvocationHandlerImpl</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 这目标类对象，用来调用具体的业务方法</span></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过构造函数传入目标对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">InvocationHandlerImpl</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 动态生成代理类对象,Proxy.newProxyInstance</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回代理类的实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">newProxyInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">                <span class="comment">//指定代理对象的类加载器</span></span><br><span class="line">                target.getClass().getClassLoader(),</span><br><span class="line">                <span class="comment">//代理对象需要实现的接口，可以同时指定多个接口</span></span><br><span class="line">                target.getClass().getInterfaces(),</span><br><span class="line">                <span class="comment">//方法调用的实际处理者，代理对象的方法调用都会转发到这里</span></span><br><span class="line">                <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//动态代理实际运行的代理方法</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用开始处理&quot;</span>);</span><br><span class="line">        <span class="comment">//下面invoke()方法是以反射的方式来创建对象，第一个参数是要创建的对象，第二个是构成方法的参数，由第二个参数来决定创建对象使用哪个构造方法</span></span><br><span class="line">		<span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;调用结束处理&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 被代理对象</span></span><br><span class="line">        <span class="type">UserDao</span> <span class="variable">userDaoImpl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>();</span><br><span class="line">        <span class="type">InvocationHandlerImpl</span> <span class="variable">invocationHandlerImpl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvocationHandlerImpl</span>(userDaoImpl);</span><br><span class="line"></span><br><span class="line">        <span class="type">UserDao</span> <span class="variable">newProxyInstance</span> <span class="operator">=</span> </span><br><span class="line">            (UserDao) invocationHandlerImpl.newProxyInstance();</span><br><span class="line">        newProxyInstance.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>为什么只能代理接口？</p>
<p>JDK动态代理会在程序运行期动态生成代理类，这个代理类会继承java.lang.reflect.Proxy类，同时实现被代理类的接口。由于Java只支持单继承，所以不支持代理类。</p>
</li>
</ul>
</li>
<li><p>CGLIB动态代理：代理类去继承目标类（final类不能代理），然后重写其中目标类的方法</p>
<p>需要导入第三方框架的jar包。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 被代理类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;保存数据方法&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cglib.proxy.MethodProxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代理主要类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CglibProxy</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">    * CGLIB 增强类对象，代理类对象是由 Enhancer 类创建的，</span></span><br><span class="line"><span class="comment">    * Enhancer 是 CGLIB 的字节码增强器，可以很方便的对类进行拓展</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">public</span>  Object <span class="title function_">newProxyInstance</span><span class="params">(Class&lt;?&gt; c)</span> &#123;</span><br><span class="line">       <span class="comment">// 设置产生的代理对象的父类,增强类型</span></span><br><span class="line">       enhancer.setSuperclass(c);</span><br><span class="line">       <span class="comment">// 定义代理逻辑对象为当前对象，要求当前对象实现 MethodInterceptor 接口</span></span><br><span class="line">       enhancer.setCallback(<span class="built_in">this</span>);</span><br><span class="line">       <span class="comment">// 使用默认无参数的构造函数创建目标对象,这是一个前提,被代理的类要提供无参构造方法</span></span><br><span class="line">       <span class="keyword">return</span> enhancer.create();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//代理实际方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;开启代理&quot;</span>);</span><br><span class="line">		<span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> proxy.invoke(obj, args);</span><br><span class="line">		System.out.println(<span class="string">&quot;关闭代理&quot;</span>);</span><br><span class="line">		<span class="comment">// 返回代理对象</span></span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainCglibProxy</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">CglibProxy</span> <span class="variable">cglibProxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CglibProxy</span>();</span><br><span class="line">        <span class="type">UserDao</span> <span class="variable">userDao</span> <span class="operator">=</span> </span><br><span class="line">            (UserDao) cglibProxy.getInstance(UserDao.class);</span><br><span class="line">        userDao.save();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h4><blockquote>
<p>话术</p>
<p>工厂模式就是通过工厂类来实例化对象。它适合用来创建复杂对象，对外隐藏实现细节。</p>
<p>工厂模式一般可以分为简单工厂、工厂方法和抽象工厂三种。</p>
<p>简单工厂模式不属于GOF的23种经典设计模式，相当于一种编程习惯。它主要包含一个抽象产品类、若干个具体产品类和一个具体工厂类。具体工厂类中提供了创建产品的方法，通过方法中传入的参数来判断要创建哪种产品的实例。如果后续需求变动，例如增加了产品的种类，就需要修改工厂类的代码，不符合开闭原则。</p>
<p>工厂方法模式，在简单工厂模式基础上增加了一个抽象工厂。抽象工厂不负责具体产品的创建，只提供一个用于创建产品的接口，把具体的创建工作交给子类完成。当增加新的具体产品类时只需要新增对应的抽象工厂的子类，并实现创建具体产品的方法，无须对抽象工厂进行任何修改，满足开闭原则；</p>
<p>抽象工厂模式与工厂方法类似，区别是</p>
<ul>
<li>工厂方法模式只有一个抽象产品类，而抽象工厂模式有多个。</li>
<li>工厂方法模式的具体工厂类只能创建一个具体产品类的实例，而抽象工厂模式可以创建多个。</li>
<li>工厂方法是由子类自行决定实例化那个类，而抽象工厂是自己决定实例化哪个类。</li>
</ul>
</blockquote>
<p>通过工厂类来实例化对象。适合用来创建复杂对象，对外隐藏实现细节。</p>
<ul>
<li><p>简单工厂：非GoF23种之一，是一种编程习惯</p>
<p>简单工厂模式包含如下三种角色：</p>
<ul>
<li>抽象产品：定义了产品的规范，描述了产品的主要特性和功能。</li>
<li>具体产品：实现或者继承抽象产品的子类。</li>
<li>具体工厂：提供了创建产品的方法，使用者通过该方法来获取产品。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 在工厂方法中根据类型创建不同的具体对象</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleCoffeeFactory</span> &#123;</span><br><span class="line">	<span class="comment">// 根据type判断类型，实例化并返回对应对象</span></span><br><span class="line">    <span class="keyword">public</span> Coffee <span class="title function_">createCoffee</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        <span class="type">Coffee</span> <span class="variable">coffee</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;americano&quot;</span>.equals(type)) &#123;</span><br><span class="line">            coffee = <span class="keyword">new</span> <span class="title class_">AmericanoCoffee</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;latte&quot;</span>.equals(type)) &#123;</span><br><span class="line">            coffee = <span class="keyword">new</span> <span class="title class_">LatteCoffee</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> coffee;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>缺点：不遵循开闭原则，每增加一个新的产品就需要修改代码。</p>
</li>
<li><p>工厂方法模式</p>
<p>它的核心结构有四个角色，分别是抽象工厂、具体工厂、抽象产品、具体产品。</p>
<p>四个角色：</p>
<ul>
<li>抽象工厂（Abstract Factory）：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法来创建产品。允许子类决定实例化对象的类型。</li>
<li>具体工厂（ConcreteFactory）：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。</li>
<li>抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能。</li>
<li>具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。</li>
</ul>
<p>一个抽象产品类，可以派生出多个具体产品类。一个抽象工厂类，可以派生出多个具体工厂类。</p>
<p><strong>每个具体工厂类只能创建一个具体产品类的实例</strong>。</p>
<p>优点：增加新的类时只需要添加对应的具体工厂类，无须对原工厂进行任何修改，满足开闭原则；</p>
<p>缺点：每增加一个类就要增加一个对应的具体工厂类，增加了系统的复杂度。</p>
<p><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="https://s2.loli.net/2023/05/28/sENRAtVWPmhypY9.png" alt="image-20230528152217369"></p>
</li>
<li><p>抽象工厂</p>
<p><strong>多个抽象产品类，每个抽象产品类可以派生出多个具体产品类</strong>。一个抽象工厂类，可以派生出多个具体工厂类。<br><strong>每个具体工厂类可以创建多个具体产品类的实例</strong>。</p>
<p><strong>与工厂方法区别</strong>：</p>
<ul>
<li>工厂方法模式只有一个抽象产品类，而抽象工厂模式有多个。</li>
<li>工厂方法模式的具体工厂类只能创建一个具体产品类的实例，而抽象工厂模式可以创建多个。</li>
<li>工厂方法是由子类自行决定实例化那个类，而抽象工厂是自己决定实例化哪个类。</li>
</ul>
<p>抽象工厂模式的主要角色如下：</p>
<ul>
<li>抽象工厂（Abstract Factory）：提供了创建产品的接口，它包含多个创建产品的方法，可以创建多个不同等级的产品。</li>
<li>具体工厂（Concrete Factory）：主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建。</li>
<li>抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。</li>
<li>具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它 同具体工厂之间是多对一的关系。</li>
</ul>
<p><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="https://s2.loli.net/2023/05/28/FkgBex4KvX8AQVj.png" alt="image-20230528153749597"></p>
</li>
</ul>
<h4 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h4><p><a target="_blank" rel="noopener" href="https://refactoringguru.cn/design-patterns/decorator">https://refactoringguru.cn/design-patterns/decorator</a></p>
<p>在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式，它属于对象结构型模式。</p>
<ul>
<li><p>为什么要用装饰器模式？</p>
<p>通常情况下，扩展一个类的功能会使用继承方式来实现。但继承有如下缺点：</p>
<ul>
<li><p>继承是静态的。 你无法在运行时更改已有对象的行为， 只能使用由不同子类创建的对象来替代当前的整个对象。</p>
</li>
<li><p>子类只能有一个父类。 大部分编程语言不允许一个类同时继承多个类的行为。</p>
</li>
</ul>
<p>随着扩展功能的增多，子类会很膨胀。</p>
<p>通过装饰器模式，可以在程序运行时动态给被装饰对象增加功能，比使用继承更加灵活。</p>
</li>
</ul>
<p>装饰器模式主要包含以下角色。</p>
<ol>
<li>抽象构件（Component）角色：定义一个抽象接口以规范准备接收附加责任的对象。</li>
<li>具体构件（ConcreteComponent）角色：实现抽象构件，通过装饰角色为其添加一些职责。</li>
<li>抽象装饰（Decorator）角色：继承抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能。</li>
<li>具体装饰（ConcreteDecorator）角色：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。</li>
</ol>
<p><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="https://s2.loli.net/2023/05/22/6s1YednO5AMTtQi.png" alt="image-20230522160320463"></p>
<p>代理模式与装饰器模式的区别：</p>
<ul>
<li>代理：偏重因自己无法完成或自己无需关心，需要他人干涉事件流程，更多的是对对象的控制，通过代理对象来控制对原对象的访问。</li>
<li>装饰：通过层层嵌套来完成对原功能的拓展，扩展后的对象仍是是对象本身。</li>
</ul>
<h4 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h4><p><strong>策略模式</strong>是一种行为设计模式，<em>把具体的算法实现从业务逻辑（if - else）中剥离出来，成为一系列独立算法类，使得它们可以相互替换（继承自同一个父类）</em>。即可在运行时动态选择算法。</p>
<p><strong>使用场景：</strong> 1、如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。 2、一个系统需要动态地在几种算法中选择一种。</p>
<p>例如：旅行的出游方式，选择骑自行车、坐汽车，每一种旅行方式都是一个策略</p>
<p><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="https://s2.loli.net/2023/05/28/EuGqMwxPIbYydmF.png" alt="image-20230528182345483"></p>
<h4 id="模板方法"><a href="#模板方法" class="headerlink" title="模板方法"></a>模板方法</h4><p>模板方法模式建议将复杂方法分解为一系列步骤， 然后将这些步骤改写为小方法， 最后在 “模板方法” 中依次调用这些方法。 步骤可以是 <code>抽象</code>的， 也可以有一些默认的实现。 为了能够使用算法， 客户端需要自行提供子类并实现所有的抽象步骤。 如有必要还需重写一些步骤 （但这一步中不包括模板方法自身）。</p>
<p>适用场景：</p>
<p> 当你只希望客户端扩展某个特定算法步骤， 而不是整个算法或其结构时， 可使用模板方法模式。</p>
<p> 当多个类的算法除一些细微不同之外几乎完全一样时， 你可使用该模式。 但其后果就是， 只要算法发生变化， 你就可能需要修改所有的类。</p>
<p><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="https://s2.loli.net/2023/08/04/67o1xEV9PDkuTBS.png" alt="模板方法设计模式的结构"></p>
<h4 id="责任链"><a href="#责任链" class="headerlink" title="责任链"></a>责任链</h4><p>过滤器</p>
<h3 id="内聚、耦合"><a href="#内聚、耦合" class="headerlink" title="内聚、耦合"></a>内聚、耦合</h3><ul>
<li><p>内聚</p>
<p>度量模块内部各个元素彼此结合的紧密程度，信息隐藏和局部化概念的自然扩展。</p>
<p>最高的内聚：</p>
<ul>
<li>功能内聚：模块内所有处理元素属于同一整体，完成一个单一的功能</li>
</ul>
</li>
<li><p>耦合</p>
<p>软件结构内<strong>不同模块</strong>之间互联程序的度量。取决于模块接口的复杂程度、通过接口的数据等。</p>
<p>最低：</p>
<ul>
<li><p>完全独立（不可能）</p>
</li>
<li><p>数据耦合（通过参数交换信息，交换的信息只是数据。至少必须存在）</p>
</li>
</ul>
</li>
</ul>
<ul>
<li>内聚与耦合<ul>
<li>二者密切相关，高内聚往往低耦合</li>
<li>内聚更重要</li>
</ul>
</li>
</ul>
<h2 id="MySQL数据库"><a href="#MySQL数据库" class="headerlink" title="MySQL数据库"></a>MySQL数据库</h2><h3 id="数据库基础"><a href="#数据库基础" class="headerlink" title="数据库基础"></a>数据库基础</h3><ul>
<li><p>数据库设计</p>
<p>需求分析、概念结构设计（E-R图）、逻辑结构设计（关系模式）、物理结构设计（表）</p>
</li>
</ul>
<ul>
<li><p>DML、DDL、DCL</p>
<p>1、DML（data manipulation language）</p>
<p>有SELECT、UPDATE、INSERT、DELETE，就像它的名字一样，这4条命令是用来对数据库里的数据进行操作的语言。</p>
<p>2、DDL（data definition language）</p>
<p>DDL比DML要多，主要的命令有CREATE、ALTER、DROP等，DDL主要是用在定义或改变表（TABLE）的结构，数据类型，表之间的连接和约束等初始化工作上，他们大多在建立表时使用。</p>
<p>3、DCL（Data Control Language）</p>
<p>是数据库控制功能。是用来设置或更改数据库用户或角色权限的语句，包括（grant，deny，revoke等）语句。在默认状态下，只有sysadmin，dbcreator，db_owner或db_securityadmin等人员才有权力执行DCL。</p>
</li>
<li><p>三大范式</p>
<ul>
<li><p>1NF(第一范式)：属性不可再分。数据库表的每一列都是不可分割的基本数据项。关系型数据库中创建的表一定满足第一范式。</p>
</li>
<li><p>2NF(第二范式)：1NF 的基础之上，消除了非主属性对于主属性的部分函数依赖，即非主属性必须完全依赖于主属性。例如一张表存了（学号，课程号，成绩，课程名），（学号，课程号）-&gt;成绩，课程号-&gt;课程名，即课程名部分函数依赖于（学号，课程号）。</p>
</li>
<li><p>3NF(第三范式)：3NF 在 2NF 的基础之上，消除了非主属性对于主码的传递函数依赖 。比如在关系 R(学号 , 姓名, 学院号，学院名)中，学号 → 学院号，学院号 → 学院名，所以存在非主属性学院名对于学号的传递函数依赖。</p>
</li>
</ul>
</li>
<li><p>drop、delete 与 truncate 区别？</p>
<ul>
<li><code>drop</code>(丢弃数据): <code>drop table 表名</code> ，直接将表都删除掉，在删除表的时候使用。</li>
<li><code>truncate</code> (清空数据) : <code>truncate table 表名</code> ，只删除表中的数据（不清理索引），再插入数据的时候自增长 id 又从 1 开始，在清空表中数据的时候使用。</li>
<li><code>delete</code>（删除数据） : <code>delete from 表名 where 列名=值</code>，删除某一行的数据，如果不加 <code>where</code> 子句和<code>truncate table 表名</code>作用类似。</li>
</ul>
</li>
<li><p>表跟表是怎么关联的？</p>
<p>表与表之间常用的关联方式有两种：内连接、外连接，下面以MySQL为例来说明这两种连接方式。</p>
<p>内连接：内连接通过INNER JOIN来实现，它将返回两张表中满足连接条件的数据，<strong>不满足条件的数据不会查询出来</strong>。</p>
<p>外连接：外连接通过OUTER JOIN来实现，它会返回两张表中满足连接条件的数据，同时返回不满足连接条件的数据，但对应字段值为空。外连接有两种形式：左外连接（LEFT OUTER JOIN）、右外连接（RIGHT OUTER JOIN）。</p>
<ul>
<li>左外连接：可以简称为左连接（LEFT JOIN），它会返回左表中的所有记录和右表中满足连接条件的记录，右表没有则对应字段为空。</li>
<li>右外连接：可以简称为右连接（RIGHT JOIN），它会返回右表中的所有记录和左表中满足连接条件的记录，左表没有则对应字段为空。</li>
</ul>
<p>另：全连接：按照关联字段取出两个表中的记录，保留左右两表中所有的记录，不满足连接条件的均被置为null。mysql用union</p>
<p>除此之外，还有一种常见的连接方式：等值连接。这种连接是通过WHERE子句中的条件，将两张表连接在一起，它的实际效果等同于内连接。</p>
<ul>
<li><p>一对多关联：这种关联形式最为常见，一般是两张表具有主从关系，并且以主表的主键关联从表的外键来实现这种关联关系。另外，以从表的角度来看，它们是具有多对一关系的，所以不再赘述多对一关联了。</p>
</li>
<li><p>多对多关联：这种关联关系比较复杂，如果两张表具有多对多的关系，那么它们之间需要有一张中间表来作为衔接，以实现这种关联关系。这个中间表要设计两列，分别存储那两张表的主键。因此，这两张表中的任何一方，都与中间表形成了一对多关系，从而在这个中间表上建立起了多对多关系。</p>
</li>
<li><p>自关联：自关联就是一张表自己与自己相关联，为了避免表名的冲突，需要在关联时通过别名将它们当做两张表来看待。一般在表中数据具有层级（树状）时，可以采用自关联一次性查询出多层级的数据。</p>
</li>
</ul>
<blockquote>
<p>两张不相关的表join结果（不带条件join）？ 笛卡尔积 </p>
</blockquote>
</li>
<li><p>SQL注入</p>
<p>SQL注入的原理是将SQL代码伪装到输入参数中，传递到服务器解析并执行。</p>
<p>如何解决SQL注入</p>
<ol>
<li><p>严格的参数校验</p>
<p>参数校验就没得说了，在一些不该有特殊字符的参数中提前进行特殊字符校验即可。</p>
</li>
<li><p>SQL预编译</p>
<p>JDBC的preparedStatement，不仅提升性能，而且防止SQL注入。</p>
</li>
</ol>
</li>
</ul>
<ul>
<li><p>Union和Union All：取结果的并集</p>
<p>UNION 会把两个结果集的所有数据放到临时表中后再进行去重操作，同时进行默认规则的排序；</p>
<p>UNION ALL 不会再对结果集进行去重操作，不进行排序；</p>
</li>
<li><p>count(列名)和count(*)</p>
<p>count(*&#x2F;1)会统计值为NULL的行，而count(列名)不会统计此列为NULL值的行。</p>
</li>
</ul>
<ul>
<li><p>自增ID与UUID的比较</p>
<ol>
<li><p>自增ID是有序的，而UUID是随机的。如果主键是有序的，mysql可以具有更好的性能</p>
</li>
<li><p>自增ID所需的存储空间比UUID要小</p>
</li>
<li><p>由于自增ID比UUID更加简单，因此生成自增ID的生成速度也比UUID更快</p>
</li>
<li><p>自增ID与数据相关，主键会暴露出去的话，自增ID会显示当前表中的数据规模；而UUID则无此风险</p>
</li>
<li><p>自增ID在不同的数据库中可能重复，在分布式的环境下无法保证唯一。而UUID在分布式环境下也可以保证唯一（可能有极小概率不一致，但可以忽略）</p>
<p>具体而言，自增ID在性能上更有优势，而UUID则更加适应分布式场景</p>
</li>
</ol>
<ul>
<li><p>何时使用自增ID，何时使用UUID</p>
<p>如果数据量非常大需要分库，或者需要更好的安全性，那么使用UUID<br>对于非敏感数据或者数据量没有大需要分库，使用自增id能节省存储空间并获得更好的性能</p>
</li>
</ul>
</li>
<li><p>char和varchar</p>
<p>char是定长的，不足的部分用隐藏空格填充；varchar是不定长的，占用空间就是实际存储字符串长度，使用额外的1-2字节来存储值长度，列长度&lt;&#x3D;255使用1字节保存，其它情况使用2字节保存。</p>
<p>因为 char 类型长度固定，因此 char 的存取效率比 varchar 要快得多，方便程序的存储与查找。varchar每次修改数据要更新长度，效率略低。</p>
<p>如果分配给CHAR或VARCHAR列的值超过列的最大长度，则对值进行裁剪以使其适合。如果被裁掉的字符不是空格，则会产生一条警告。严格模式（sql_mode）下会报错。</p>
</li>
<li><p>on dupdate key update </p>
<p>语句基本功能是：<strong>根据主键id或唯一索引来判断</strong>表中是否存在记录，不存在就插入（影响行数1），有的话就更新（影响行数2）。</p>
<ol>
<li>相较于replace into（insert加强版，不存在时insert，存在时先delete后insert）虽然也能达到批量更新目的，但因为删除和添加需要重复维护索引，所以大批量比on duplicate key update 性能要差，小量可忽略，需使用者自行选择。</li>
</ol>
</li>
</ul>
<h3 id="sql执行顺序"><a href="#sql执行顺序" class="headerlink" title="sql执行顺序"></a>sql执行顺序</h3><p>MySQL 主要分为 Server 层和引擎层，Server 层主要包括连接器、查询缓存、分析器、优化器、执行器，</p>
<p>1）连接器负责客户端与 MySQL 服务器建立连接，和身份认证和权限相关的功能相关；</p>
<p>2）查询缓存（8.0 之后移除）；</p>
<p>3）分析器进行词法和语法解析；</p>
<p>词法分析，一条 SQL 语句有多个字符串组成，首先要提取关键字，比如 select，提出查询的表，提出字段名，提出查询条件等等。做完这些操作后，就会进入第二步。</p>
<p>语法分析，主要就是判断你输入的 sql 是否正确，是否符合 MySQL 的语法。</p>
<p>4）优化器选择索引，生成执行计划；优化器的作用就是它认为的最优的执行方案去执行（有时候可能也不是最优），比如多个索引的时候该如何选择索引，多表查询的时候如何选择关联顺序等。</p>
<p>5）执行器操作存储引擎，返回结果。</p>
<ul>
<li>关键词执行顺序<ol>
<li><strong>FROM</strong>：指定要查询的数据表。</li>
<li><strong>WHERE</strong>：对数据进行筛选，仅返回符合条件的行。</li>
<li><strong>GROUP BY</strong>：按照指定的列对数据进行分组。</li>
<li><strong>HAVING</strong>：对分组后的数据进行筛选。</li>
<li><strong>SELECT</strong>：选择要返回的列。</li>
<li><strong>ORDER BY</strong>：对结果集进行排序。</li>
<li><strong>LIMIT</strong>：限制返回的行数。</li>
</ol>
</li>
</ul>
<h3 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h3><ul>
<li><p>MyISAM 和 InnoDB 有什么区别？</p>
<p>最常用的引擎是InnoDB和MyISAM。MySQL 5.5 之前，MyISAM 引擎是 MySQL 的默认存储引擎。MySQL 5.5 版本之后，InnoDB 是 MySQL 的默认存储引擎。</p>
<ul>
<li><p>MyISAM 只有表级锁(table-level locking)，而 InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁。</p>
</li>
<li><p>MyISAM 不提供事务支持，但每次查询都是原子的。</p>
<p>InnoDB 提供事务支持，实现了 SQL 标准定义了四个隔离级别，具有提交(commit)和回滚(rollback)事务的能力。并且，InnoDB 默认使用的 REPEATABLE-READ（可重读）隔离级别是可以解决幻读问题发生的（基于 MVCC 和 Next-Key Lock）。</p>
</li>
<li><p>MyISAM 不支持外键，而 InnoDB 支持。</p>
</li>
<li><p>InnoDB 支持异常崩溃后的恢复，数据库重新启动的时候会保证数据库恢复到崩溃前的状态。这个恢复的过程依赖于 <code>redo log</code>。MyISAM不支持。</p>
</li>
<li><p>MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但InnoDB 引擎主键索引采用聚簇索引，索引和数据在同一个文件中存储（.idb），数据按照索引的顺序存放。MyISAM都是非聚集索引，索引文件和数据文件是分离的（.myd、.myi），索引文件的数据域存储指向数据文件的指针。</p>
</li>
<li><p>MyISAM 可以没有主键；如果表定义时没有显式指定主键，InnoDB会选择第一个不包含 NULL 值的唯一列作为聚簇索引的索引键，或为每一行生成一个ROWID，并以此作为主键。</p>
</li>
<li><p>（不重要）InnoDB可以更好地发挥CPU的性能，MyISAM效率与CPU核数无关；MyISAM存储表的总行数</p>
</li>
<li><p>什么时候用Myisam？</p>
<p>据说MyISAM查询比InnoDB快，所以适合读多写少，比如离线数据库。但我还没找到令我信服的说法。</p>
<p>可能是如下原因：由于innodb支持事务，所以会有mvvc的一个比较。这个过程会损耗性能；查询的时候，如果走了索引，而索引又不是主键索引，可能需要根据叶结点存的主键id回表，到聚簇索引树查，最后找到需要的数据。而myisam是非聚集索引，而且叶子节点存储的是磁盘地址，所以，查询的时候查到的最后结果不是聚簇索引树的key，而是会直接去查询磁盘</p>
</li>
</ul>
</li>
<li><p>行溢出后，MySQL 是怎么处理的？</p>
<p>MySQL 中磁盘和内存交互的基本单位是页，一个页的大小一般是 <code>16KB</code>，也就是 <code>16384字节</code>，而一个 varchar(n) 类型的列最多可以存储 <code>65532字节</code>，一些大对象如 TEXT、BLOB 可能存储更多的数据，这时一个页可能就存不了一条记录。这个时候就会<strong>发生行溢出，多的数据就会存到另外的「溢出页」中</strong>。</p>
<p>如果一个数据页存不了一条记录，InnoDB 存储引擎会自动将溢出的数据存放到「溢出页」中。在一般情况下，InnoDB 的数据都是存放在 「数据页」中。但是当发生行溢出时，溢出的数据会存放到「溢出页」中。</p>
<p>当发生行溢出时，在记录的真实数据处只会保存该列的一部分数据，而把剩余的数据放在「溢出页」中，然后真实数据处用 20 字节存储指向溢出页的地址，从而可以找到剩余数据所在的页。</p>
</li>
</ul>
<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><ul>
<li>说一说你对MySQL索引的理解</li>
</ul>
<p>索引是一个单独的、存储在磁盘上的按若干个列排序的存储结构，包含着索引列的值及对数据表里所有记录的引用指针。使用索引可以快速找出在某个或多个列中有一特定值的行，所有MySQL列类型都可以被索引，对相关列使用索引是提高查询操作速度的最佳途径。</p>
<p>索引是在存储引擎中实现的，因此，每种存储引擎的索引都不一定完全相同，并且每种存储引擎也不一定支持所有索引类型。</p>
<ul>
<li>索引的<strong>优点</strong>主要有以下几条：</li>
</ul>
<ol>
<li>通过创建唯一索引，可以保证数据库表中每一行数据的唯一性。</li>
<li>可以大大加快数据的查询速度，这也是创建索引的主要原因。</li>
<li>在实现数据的参考完整性方面，可以加速表和表之间的连接。</li>
<li>在使用分组和排序子句进行数据查询时，也可以显著减少查询中分组和排序的时间。</li>
</ol>
<ul>
<li>索引越多越好？</li>
</ul>
<p>增加索引也有许多不利的方面，主要表现在如下几个方面：</p>
<ol>
<li>创建索引和维护索引要耗费时间，并且随着数据量的增加所耗费的时间也会增加。</li>
<li>索引需要占磁盘空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果有大量的索引，索引文件可能比数据文件更快达到最大文件尺寸。</li>
</ol>
<ul>
<li><p>索引为什么可以加速查询</p>
<p>个人认为，查索引是一个慢慢细化范围的过程，类似于书的目录，先将整本书划分为若干个章节，每个章节又分为若干个小节。当你要查找某块内容的时候，会先通过章节确定一个大致的范围，再通过小节进一步细化范围，然后再从这个小节开始的页码一页一页翻，最后找到所要找的内容。如果没有目录，你就需要从头开始一页一页翻书，效率就比较低。</p>
</li>
</ul>
<h4 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h4><p>按「数据结构」分类：<strong>B+tree索引、Hash索引、Full-text索引</strong>、RTree 索引（仅支持 geometry 数据类型）。</p>
<p>按「物理存储」分类：<strong>聚簇索引（主键索引）、二级索引（辅助索引）</strong>。</p>
<p>按「字段特性」分类：<strong>主键索引、普通索引、唯一索引、前缀索引</strong>。</p>
<p>按「字段个数」分类：<strong>单列索引、联合索引</strong>。</p>
<ul>
<li><p><strong>主键索引（PRIMARY KEY）</strong>：一张数据表有只能有一个主键，并且主键不能为 null，不能重复。</p>
<p>在创建表时，InnoDB 存储引擎会根据不同的场景选择不同的列作为索引：</p>
<ul>
<li>如果有主键，默认会使用主键作为聚簇索引的索引键（key）；</li>
<li>如果没有主键，就选择第一个不包含 NULL 值的唯一列作为聚簇索引的索引键（key）；</li>
<li>在上面两个都没有的情况下，InnoDB 将自动生成一个隐式自增 rowid （6Byte）列作为聚簇索引的索引键（key）；</li>
</ul>
<p><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="https://s2.loli.net/2023/05/20/8DZ71S6AOcWJGdr.png" alt="主键索引"></p>
</li>
<li><p>二级索引（Secondary Index）又称为辅助索引，是因为二级索引的叶子节点存储的数据是主键。也就是说，通过二级索引，可以定位主键的位置；然后再通过主键索引中的 B+Tree 树查询到对应的叶子节点，然后获取整行数据。这个过程叫<strong>「回表」</strong>，也就是说要查两个 B+Tree 才能查到数据。</p>
<p><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="https://s2.loli.net/2023/05/20/y6RMZJboxuHQvWs.png" alt="二级索引"></p>
<ol>
<li><p><strong>普通索引(Index)<strong>：</strong>普通索引的唯一作用就是为了快速查询数据，一张表允许创建多个普通索引，并允许数据重复和 NULL。</strong></p>
</li>
<li><p><strong>唯一索引(Unique Key)<strong>：唯一索引也是一种约束。</strong>唯一索引的属性列不能出现重复的数据，但是允许数据为 NULL，一张表允许创建多个唯一索引。</strong> 建立唯一索引的目的大部分时候都是为了该属性列的数据的唯一性，而不是为了查询效率。</p>
<p>创建唯一索引使用 <strong>UNIQUE</strong> 关键字。</p>
</li>
<li><p>前缀索引(Prefix)：前缀索引只适用于<strong>字符串</strong>类型的数据。前缀索引是对文本的前几个字符创建索引，相比普通索引建立的数据更小， 因为只取前几个字符。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX index_name <span class="keyword">ON</span> table_name(column_name(length)); </span><br></pre></td></tr></table></figure>
</li>
<li><p>**全文索引(Full Text)**：全文索引主要是为了检索大文本数据中的关键字的信息，是目前搜索引擎数据库使用的一种技术。只有 <code>CHAR</code>、<code>VARCHAR</code> ，<code>TEXT</code> 列上可以创建全文索引。Mysql5.6 之前只有 MYISAM 引擎支持全文索引，5.6 之后 InnoDB 也支持了全文索引。</p>
<p>创建全文索引使用 <strong>FULLTEXT</strong> 关键字。</p>
</li>
</ol>
</li>
<li><p><strong>联合索引</strong>：多列值组成一个索引，专门用于组合搜索。叶子节点包含索引列的值以及指向对应行数据的指针</p>
<ul>
<li><p>最左匹配（左优先）原则</p>
<p>假设建立联合索引（product_no，name），示意图如下：</p>
<p><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="https://s2.loli.net/2023/05/21/3xOHME2SpwiYDrs.png" alt="联合索引"></p>
<p>可以看到，联合索引的非叶子节点用两个字段的值作为 B+Tree 的 key 值。当在联合索引查询数据时，先按 product_no 字段比较，在 product_no 相同的情况下再按 name 字段比较。</p>
<p>也就是说，联合索引查询的 B+Tree 是从左到右排序，先按 product_no 进行排序，然后再 product_no 相同的情况再按 name 字段排序。</p>
<p>因此，使用联合索引时，存在<strong>最左匹配原则</strong>，也就是按照最左优先的方式进行索引的匹配。在使用联合索引进行查询的时候，如果不遵循「最左匹配原则」，联合索引会失效，这样就无法利用到索引快速查询的特性了。</p>
<p>比如，如果创建了一个 <code>(a, b, c)</code> 联合索引，如果查询条件是以下这几种，就可以匹配上联合索引：</p>
<ul>
<li>where a&#x3D;1；</li>
<li>where a&#x3D;1 and b&#x3D;2 and c&#x3D;3；</li>
<li>where a&#x3D;1 and b&#x3D;2；</li>
</ul>
<p>需要注意的是，因为有查询优化器，所以 a 字段在 where 子句的顺序并不重要。</p>
<p>但是，如果查询条件是以下这几种，因为不符合最左匹配原则，所以就无法匹配上联合索引，联合索引就会失效:</p>
<ul>
<li>where b&#x3D;2；</li>
<li>where c&#x3D;3；</li>
<li>where b&#x3D;2 and c&#x3D;3；</li>
</ul>
<p>上面这些查询条件之所以会失效，是因为<code>(a, b, c)</code> 联合索引，是先按 a 排序，在 a 相同的情况再按 b 排序，在 b 相同的情况再按 c 排序。所以，<strong>b 和 c 是全局无序，局部相对有序的</strong>，这样在没有遵循最左匹配原则的情况下，是无法利用到索引的。</p>
<blockquote>
<p>注：联合索引遵循最左前缀匹配原则，mysql会一直匹配直到遇到范围查询（&lt;、&gt;、like、between）就停止匹配。等于和in可以乱序，mysql会自动优化顺序</p>
</blockquote>
</li>
<li><p>索引下推（ICP）</p>
<p>将部分上层（服务层）负责的事情，交给了下层（引擎层）去处理。</p>
<p>对于联合索引（a, b），在执行 <code>select * from table_name where a &gt; 1 and b = 2</code> 语句的时候（若条件为a&#x3D;1则extra为空，&gt;&#x3D;则为using where回表；也不一定，与具体数据有关）（**联合索引当遇到范围查询 (&gt;、&lt;) 就会停止匹配**，即只有a &gt; 1 能用索引）：</p>
<ul>
<li>在 MySQL 5.6 之前<ol>
<li><strong>首先</strong> MySQL 的 server 层调用存储引擎<strong>获取 a&gt;1 的第一条记录</strong>。</li>
<li>存储引擎找到 a&gt;1 的第一条记录后，在 B+Tree 的叶子结点中保存着主键 id，此时<strong>通过回表操作，去主键索引中找到该条记录的完整数据</strong>，并返回给 server 层。</li>
<li>server 层拿到数据之后，<strong>再判断该条记录的 b 是否为 2（以及其他where条件），如果 b &#x3D; 2，就把该条记录返回给客户端，如果 b!&#x3D;2，那就就丢弃该记录</strong>。</li>
<li>a 字段的存储是有序的，即 a&gt;1 的记录都是挨着的，而 B+Tree 的叶子结点之间通过双向链表关联，<strong>通过B+Tree叶结点链表的next指针找到下一条数据，重复回表</strong></li>
</ol>
</li>
<li>而 MySQL 5.6 引入的<strong>索引下推优化</strong>（index condition pushdown)， <strong>可以在联合索引遍历过程中，对联合索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数</strong>。即上述步骤2中判断a&gt;1后接着判断b是否&#x3D;2，如是再回表，将记录返回给server层，然后再判断其他where条件是否成立；否则接着判断下一条记录。</li>
</ul>
<p>当你的查询语句的执行计划里，出现了 Extra 为 <code>Using index condition</code>，那么说明使用了索引下推的优化</p>
</li>
</ul>
</li>
<li><p><strong>空间索引</strong>：对空间数据类型的字段建立的索引，MySQL中的空间数据类型有4种，分别是GEOMETRY、POINT、LINESTRING和POLYGON。MySQL使用<strong>SPATIAL</strong>关键字进行扩展，使得能够用创建正规索引类似的语法创建空间索引。创建空间索引的列，必须将其声明为<strong>NOT NULL</strong>，空间索引只能在存储引擎为MyISAM和InnoDB（MySQL8.0之后）的表中创建。</p>
</li>
</ul>
<ul>
<li><p>聚簇索引与非聚簇索引</p>
<ul>
<li><p>聚簇索引（Clustered Index）即索引结构和数据一起存放的索引，并不是一种单独的索引类型。InnoDB 中的主键索引就属于聚簇索引，该表的索引(B+树)的每个非叶子节点存储索引，叶子节点存储索引和索引对应的数据。</p>
<p><strong>优点</strong>：</p>
<ul>
<li><strong>查询速度非常快</strong>：聚簇索引的查询速度非常的快，因为整个 B+树本身就是一颗多叉平衡树，叶子节点也都是有序的，定位到索引的节点，就相当于定位到了数据。相比于非聚簇索引， 聚簇索引少了一次读取数据的 IO 操作。</li>
<li><strong>对排序查找和范围查找优化</strong>：聚簇索引对于主键的排序查找和范围查找速度非常快。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li><strong>依赖于有序的数据</strong>：因为 B+树是多路平衡树，如果索引的数据不是有序的，那么就需要在插入时排序。</li>
<li><strong>更新代价大</strong>：如果对索引列的数据被修改时，那么对应的索引也将会被修改，而且聚簇索引的叶子节点还存放着数据，修改代价肯定是较大的，所以对于主键索引来说，主键一般都是不可被修改的。</li>
</ul>
</li>
<li><p>非聚簇索引(Non-Clustered Index)即索引结构和数据分开存放的索引，并不是一种单独的索引类型。二级索引(辅助索引)就属于非聚簇索引。MySQL 的 MyISAM 引擎，不管主键还是非主键，使用的都是非聚簇索引。非聚簇索引的叶子节点并不一定存放数据的指针，因为二级索引的叶子节点就存放的是主键，根据主键再回表查数据。</p>
<p><strong>优点</strong>：</p>
<p>更新代价比聚簇索引要小 。非聚簇索引的更新代价就没有聚簇索引那么大了，非聚簇索引的叶子节点是不存放数据的</p>
<p><strong>缺点</strong>：</p>
<ul>
<li><strong>依赖于有序的数据</strong>：跟聚簇索引一样，非聚簇索引也依赖于有序的数据</li>
<li>**可能会二次查询(回表)**：这应该是非聚簇索引最大的缺点了。 当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询</li>
</ul>
</li>
<li><p><strong>非聚簇索引怎么避免回表&#x2F;一定会回表吗</strong></p>
<p>当查询的数据能在二级索引的 B+Tree 的叶子节点（存的数据是主键）里查询到，这时就不用再查主键索引查，例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 主键 <span class="keyword">from</span> table_name <span class="keyword">where</span> 索引列 <span class="operator">=</span> 条件</span><br></pre></td></tr></table></figure>

<p>这种在二级索引的 B+Tree 就能查询到结果的过程就叫作<strong>「覆盖索引」</strong>，也就是只需要查一个 B+Tree 就能找到数据.</p>
<p>或用户准备使用 SQL 查询name，而name字段正好建立了索引：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name <span class="keyword">from</span> table_name <span class="keyword">where</span> name <span class="operator">=</span> 条件</span><br></pre></td></tr></table></figure>

<p>那么这个索引的 key 本身就是 name，查到对应的 name 直接返回就行了，无需回表查询。</p>
<p>如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为 <strong>覆盖索引（Covering Index）</strong> 。如果需要查询的字段正好是索引的字段，那么根据该索引就可以查到数据，而无需回表查询。</p>
</li>
</ul>
<p><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="https://s2.loli.net/2023/05/20/Tf6VnlWvcoL3esK.png" alt="image-20230520221047487"></p>
</li>
</ul>
<h4 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h4><ul>
<li><p>适合建索引的情况</p>
<ul>
<li><p><strong>不为 NULL 的字段</strong>：索引字段的数据应该尽量不为 NULL，因为对于数据为 NULL 的字段，数据库较难优化，需要做额外处理。如果字段频繁被查询，但又避免不了为 NULL，建议使用 0,1,true,false 这样语义较为清晰的短值或短字符作为替代。</p>
</li>
<li><p><strong>被频繁查询的字段</strong>：我们创建索引的字段应该是查询操作非常频繁的字段。</p>
</li>
<li><p><strong>被作为条件查询的字段</strong>：被作为 WHERE 条件查询的字段，应该被考虑建立索引。</p>
</li>
<li><p><strong>频繁需要排序的字段</strong>：索引已经排序，这样查询可以利用索引的排序，加快排序查询时间。</p>
</li>
<li><p>用于分组的字段</p>
</li>
<li><p><strong>被经常频繁用于连接的字段</strong>：经常用于连接的字段可能是一些外键列，对于外键列并不一定要建立外键，只是说该列涉及到表与表的关系。对于频繁被连接查询的字段，可以考虑建立索引，提高多表连接查询的效率。</p>
</li>
</ul>
</li>
<li><p>高性能索引</p>
<p>1、独立的列：索引列不能是表达式的一部分；</p>
<p>2、选择区分度高的列作为索引；建组合索引的时候，区分度最高的在最左边。 </p>
<p>​	正例：如果where a&#x3D;? and b&#x3D;? ，a列的几乎接近于唯一值，那么只需要单建idx_a索引即 可。  </p>
<p>​	说明：存在非等号和等号混合判断条件时，在建索引时，请把等号条件的列前置。</p>
<p>​	如：where a&gt;?  and b&#x3D;? 那么即使a的区分度更高，也必须把b放在索引的最前列。</p>
<p>区分度公式：count(distinct col) &#x2F; count(*)</p>
<p>3、选择合适的索引列顺序：将选择性高的索引列放在最前列；</p>
<p>4、覆盖索引：查询的列均在索引中，不需要回查聚簇索引；</p>
<p>5、使用索引扫描来做排序;</p>
<p>6、在遵守最左前缀的原则下，尽量扩展索引，而不是创建索引。</p>
</li>
</ul>
<ul>
<li><p>前缀索引优化</p>
<p>对于一些比较长的文本字段，如果只看前几位就可以有比较高的区分度（索引选择性高：不重复的索引值（也称为基数）和数据表的记录总数的比值，取值范围在 <code>[0,1]</code> 之间），那么就适合建立前缀索引。可以减小索引文件大小，提高查询速度。</p>
</li>
<li><p>覆盖索引</p>
<p>覆盖索引是指 SQL 中所有查询字段(where,select,order by,group by 包含的字段)，在二级索引 B+Tree 的叶子节点上都能找得到的那些索引。从二级索引中就查询得到记录，而不需要通过聚簇索引查询获得，可以避免回表的操作。</p>
<p><strong>避免 InnoDB 表进行索引的二次查询:</strong> InnoDB 是以聚集索引的顺序来存储的，对于 InnoDB 来说，二级索引在叶子节点中所保存的是行的主键信息，如果是用二级索引查询数据的话，在查找到相应的键值后，还要通过主键进行二次查询才能获取我们真实所需要的数据。而在覆盖索引中，二级索引的键值中可以获取所有的数据，避免了对主键的二次查询 ，减少了 IO 操作，提升了查询效率。</p>
<p><strong>可以把随机 IO 变成顺序 IO 加快查询效率:</strong> 由于覆盖索引是按键值的顺序存储的，对于 IO 密集型的范围查找来说，对比随机从磁盘读取每一行的数据 IO 要少的多，因此利用覆盖索引在访问时也可以把磁盘的随机读取的 IO 转变成索引查找的顺序 IO。</p>
<ul>
<li><p>禁止使用select *</p>
<p><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="https://s2.loli.net/2023/06/02/Ft2MzYmDKV8rj6w.png" alt="image-20230602112750818"></p>
<p>另：无法使用覆盖索引</p>
<p>[以后面试官问你 为啥不建议使用Select *，请你大声回答他!_小目标青年的博客-CSDN博客](<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_35387940/article/details/125921218?ops_request_misc=&request_id=&biz_id=102&utm_term=select">https://blog.csdn.net/qq_35387940/article/details/125921218?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=select</a> *一定会回表吗&amp;utm_medium&#x3D;distribute.pc_search_result.none-task-blog-2<del>all</del>sobaiduweb~default-1-125921218.142^v47^control,201^v3^control_1&amp;spm&#x3D;1018.2226.3001.4187)</p>
</li>
</ul>
</li>
<li><p>主键最好是自增的</p>
<p><strong>如果我们使用自增主键</strong>，那么每次插入的新数据就会按顺序添加到当前索引节点的位置，不需要移动已有的数据，当页面写满，就会自动开辟一个新页面。因为每次<strong>插入一条新记录，都是追加操作，不需要重新移动数据</strong>，因此这种插入数据的方法效率非常高。</p>
<p><strong>如果我们使用非自增主键</strong>，由于每次插入主键的索引值都是随机的，因此每次插入新的数据时，就可能会插入到现有数据页中间的某个位置，这将不得不移动其它数据来满足新数据的插入，甚至需要从一个页面复制数据到另外一个页面（新开一个页），我们通常将这种情况称为<strong>页分裂</strong>。<strong>页分裂还有可能会造成大量的内存碎片，导致索引结构不紧凑，从而影响查询效率</strong>。</p>
<p>详情：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_47600880/article/details/122273377">https://blog.csdn.net/weixin_47600880/article/details/122273377</a></p>
</li>
<li><p>索引列最好not null</p>
<ul>
<li>第一原因：索引列存在 NULL 就会导致优化器在做索引选择的时候更加复杂，更加难以优化，因为可为 NULL 的列会使索引、索引统计和值比较都更复杂，比如进行索引统计时，count 会省略值为NULL 的行。</li>
<li>（了解）第二个原因：NULL 值是一个没意义的值，但是它会占用物理空间，所以会带来的存储空间的问题，因为 InnoDB 存储记录的时候，如果表中存在允许为 NULL 的字段，那么每行中<strong>至少会用 1 字节空间存储 NULL 值列表</strong>。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000039774659">https://segmentfault.com/a/1190000039774659</a></p>
</li>
</ul>
<ul>
<li><p>下列几种情况，是不适合创建索引的：</p>
<ul>
<li>频繁更新的字段不适合建立索引；</li>
</ul>
<ul>
<li><p>where条件中用不到的字段不适合建立索引；</p>
</li>
<li><p>数据比较少的表不需要建索引；</p>
</li>
<li><p>数据重复度高且分布比较均匀的的字段不适合建索引，例如性别、真假值（查询结果集超过总行数的某个比例，查询优化器就认为没必要走索引）；</p>
<blockquote>
<p>注：如果是联合索引，能用上覆盖索引、索引下推这些特性可以考虑。单列索引一般就不用考虑。</p>
</blockquote>
</li>
<li><p>参与列计算的列不适合建索引。</p>
</li>
</ul>
</li>
</ul>
<h4 id="避免索引失效"><a href="#避免索引失效" class="headerlink" title="避免索引失效"></a>避免索引失效</h4><p>索引失效的大致原因可以分为八类，这些场景通过查看执行计划都会发现产生type&#x3D;ALL或者type&#x3D;index的全表扫描。</p>
<ul>
<li><p><strong>左模糊匹配</strong>，如‘like %xx’</p>
<p>为什么右模糊匹配可以？</p>
<p>假设我们要查询 name 字段前缀为「苏」的数据，也就是 <code>name like &#39;苏%&#39;</code>，扫描索引的过程：</p>
<ul>
<li>首节点查询比较：苏这个字的拼音大小比首节点的第一个索引值中的刘字大，但是比首节点的第二个索引值中的周字小，所以选择去节点1的子节点3继续查询；</li>
<li>节点 3 查询比较：节点3的第一个索引值中的刘字的拼音大小比苏字小，所以继续看下一个索引值，发现节点2有与苏字前缀匹配的索引值，于是就往叶子节点查询，即叶子节点4；</li>
<li>节点 4 查询比较：节点4的第一个索引值的前缀符合苏字，于是就读取该行数据，接着继续往右匹配，直到匹配不到前缀为苏的索引值。</li>
</ul>
<p>如果使用 <code>name like &#39;%苏&#39;</code> 方式来查询，因为查询的结果可能是「苏苏、流苏」等之类的，不知道从哪个索引值开始比较，于是就只能通过全表扫描的方式来查询。</p>
</li>
<li><p>对索引字段使用<strong>函数</strong></p>
<p>有时候我们会用一些 MySQL 自带的函数来得到我们想要的结果，这时候要注意了，如果查询条件中对索引字段使用函数，就会导致索引失效。</p>
<p>比如下面这条语句查询条件中对 name 字段使用了 LENGTH 函数，执行计划中的 type&#x3D;ALL，代表了全表扫描：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span> name 为二级索引</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_user <span class="keyword">where</span> length(name)<span class="operator">=</span><span class="number">6</span>;</span><br></pre></td></tr></table></figure>

<p>MySQL 8.0 开始，索引特性增加了函数索引，即可以针对函数计算后的值建立一个索引，可解决上述问题。</p>
</li>
<li><p>对索引字段进行表达式<strong>计算</strong></p>
<p>比如，下面这条查询语句，执行计划中 type &#x3D; ALL，说明是通过全表扫描的方式查询数据的：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_user <span class="keyword">where</span> id <span class="operator">+</span> <span class="number">1</span> <span class="operator">=</span> <span class="number">10</span>;<span class="operator">/</span><span class="operator">/</span> 改成 id <span class="operator">=</span> <span class="number">10</span> <span class="operator">-</span> <span class="number">1</span> 就行 </span><br></pre></td></tr></table></figure>
</li>
<li><p>对索引字段进行隐式<strong>类型转换</strong></p>
<p>如果索引字段是字符串类型，但是在条件查询中，输入的参数是整型，就不会走索引。</p>
<p>反过来就可以，因为<strong>MySQL 在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较</strong></p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;两个参数都是字符串，会按照字符串来比较，不做类型转换。</span><br><span class="line">&gt;两个参数都是整数，按照整数来比较，不做类型转换。</span><br><span class="line">&gt;十六进制的值和非数字做比较时，会被当做二进制串。</span><br><span class="line">&gt;有一个参数是 TIMESTAMP 或 DATETIME，并且另外一个参数是常量，常量会被转换为 timestamp</span><br><span class="line">&gt;有一个参数是 decimal 类型，如果另外一个参数是 decimal 或者整数，会将整数转换为 decimal 后进行比较，如果另外一个参数是浮点数，则会把 decimal 转换为浮点数进行比较</span><br><span class="line">&gt;所有其他情况下，两个参数都会被转换为浮点数再进行比较</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>联合索引不遵循最左匹配原则（见索引分类联合索引部分）</p>
</li>
<li><p>where子句中的or</p>
<p>在 WHERE 子句中，or 的前后条件中有一个列没有索引，涉及的索引都不会被使用到</p>
</li>
<li><p>数据量少，MySQL可能觉得全表扫描更快</p>
</li>
<li><p>其他</p>
<p>不等于（&lt;&gt;、!&#x3D;）不走； is not null &#x2F;is null可能不走索引，也可以走索引，取决与null值多少</p>
</li>
</ul>
<h4 id="为什么用B-树"><a href="#为什么用B-树" class="headerlink" title="为什么用B+树"></a>为什么用B+树</h4><p>设计一个适合索引的数据结构，至少满足以下要求：</p>
<ul>
<li>能在尽可能少的磁盘的 I&#x2F;O 操作中完成查询工作；</li>
<li>要能高效地查询某一个记录，也要能高效地执行范围查找；</li>
</ul>
<p><strong>二叉树会随着插入的元素增多，而导致树的高度变高，这就意味着磁盘 I&#x2F;O 操作次数多，会影响整体数据查询的效率</strong>。</p>
<p>B树和B+树：</p>
<ol>
<li>B+树非叶子节点上是不存储数据的，仅存储键值，而B树节点中不仅存储键值，也会存储数据。InnoDB存储引擎中，每个节点都是一个数据页，每个页的大小默认为16KB，意味着B+树每个非叶结点能存储更多的键值，树就会更矮更胖。而磁盘IO以块为单位，每个块一般4kb（8个扇区，每个扇区512byte），InnoDB有磁盘预读的机制，每次磁盘IO会读取一整个页（4块）到内存里，所以树的高度很大程度决定了磁盘IO次数。树高较低的话，我们查找数据进行磁盘的IO次数有会再次减少，数据查询的效率也会更快。</li>
<li>B+树索引的所有数据均存储在叶子节点（所有索引都会在叶结点出现），而且数据是按照顺序排列的，叶结点间构成一个链表。那么B+树使得<strong>范围查找，排序查找，分组查找以及去重查找变得异常简单</strong>。而B树因为数据分散在各个节点，要实现范围查询需要通过中序遍历。 </li>
<li>B+树因为数据都在叶结点，所以是稳定logn复杂度。B树离根节点越近查询速度越快，平均略优于B+树</li>
</ol>
<ul>
<li>为什么不用Hash：<ul>
<li>Hash 索引等值查询性能较好，但不支持排序和范围查询（Hash 索引是根据 hash 算法来定位的，范围内的数据不连续）；</li>
<li>由于元素无序，可能导致磁盘的随机访问。B+树叶结点是有序的，可以顺序访问。</li>
<li>只能使用整个键来搜索行。（对于 B 树索引，可以使用键的任何最左前缀来查找行。对于like可以右模糊匹配）</li>
</ul>
</li>
</ul>
<p>InnoDB叶结点间为什么用双向链表（结点内单向）：</p>
<p>​	双向的好处是可以得心应手地处理倒序查询、&gt; &lt;，between and等’范围查询’的语法。</p>
<ul>
<li>为什么不用跳表？</li>
</ul>
<p>​	B+树三层可存储2kw数据。存储相同数据，跳表高度要高得多，即磁盘IO次数更多。</p>
<p>​	InnoDB一页16kb，假设非叶子节点掐头去尾可以存放15k的数据，而每一行有主键和页号组成，假设主键是bigint大小是8byte，，页号在源码叫FIL_PAGE_OFFSET，大小4byte(字节)，那么非叶子节点的一条数据就是12字节左右，15k&#x2F;12Byte &#x3D; 1280，也就是说x&#x3D;1280。</p>
<p>​	在来算一下y的值，叶子节点和非叶子节点数据接口是一样的，所以假设掐头去尾剩15k可以存放数据，而叶子节点存放的是真正的数据，假设一行数据占1kb， 那一个数据页能存放15行，也就是y&#x3D;15。</p>
<p>​	则三层B+树可以存1280 ^ (3 - 1) * 15 &#x3D; 24576000</p>
<p>为什么MongoDB用B-树？</p>
<p>MongoDB 从 3.2 开始就默认使用 WiredTiger 作为存储引擎，所以 MongoDB 内部存储的数据结构由 WiredTiger 决定。而 WiredTiger 官方文档明确说了底层用的 B+ 树，链接为 <a href="https://link.zhihu.com/?target=https://source.wiredtiger.com/10.0.0/tune_page_size_and_comp.html">WiredTiger: Tuning page size and compression</a></p>
<h4 id="MySQL优化器怎么选择索引"><a href="#MySQL优化器怎么选择索引" class="headerlink" title="MySQL优化器怎么选择索引"></a>MySQL优化器怎么选择索引</h4><ul>
<li><strong>索引选择性</strong>：索引选择性是指索引列的唯一值数量与记录总数的比率。优化器倾向于选择选择性高的索引，因为这样的索引可以更好地过滤出需要的数据，减少扫描的记录数量。</li>
<li><strong>覆盖索引</strong>：优化器会考虑是否可以使用覆盖索引来避免访问表的实际行数据。如果索引包含了查询所需的所有列，那么优化器可能会选择这个索引，因为它可以减少对表的访问次数。</li>
</ul>
<h3 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h3><h4 id="慢查询"><a href="#慢查询" class="headerlink" title="慢查询"></a>慢查询</h4><p><em>开启慢查询日志</em>：</p>
<p>MySQL中慢查询日志默认是关闭的，可以通过配置文件my.ini或者my.cnf中的log-slow-queries选项打开，也可以在MySQL服务启动的时候使用–log-slow-queries[&#x3D;file_name]启动慢查询日志。</p>
<p>启动慢查询日志时，需要在my.ini或者my.cnf文件中配置long_query_time选项指定记录阈值，如果某条查询语句的查询时间超过了这个值，这个查询过程将被记录到慢查询日志文件中。</p>
<p><em>分析慢查询日志</em>：</p>
<p>直接分析mysql慢查询日志，利用explain关键字可以模拟优化器执行SQL查询语句，来分析sql慢查询语句。</p>
<h4 id="MySQL执行计划"><a href="#MySQL执行计划" class="headerlink" title="MySQL执行计划"></a>MySQL执行计划</h4><p><strong>执行计划</strong> 是指一条 SQL 语句在经过 <strong>MySQL 查询优化器</strong> 的优化后，具体的执行方式。</p>
<p>MySQL 为我们提供了 <code>EXPLAIN</code> 命令，来获取执行计划的相关信息。</p>
<p>需要注意的是，<code>EXPLAIN</code> 语句并不会真的去执行相关的语句，而是通过查询优化器对语句进行分析，找出最优的查询方案，并显示对应的信息。<code>EXPLAIN</code> 执行计划支持 <code>SELECT</code>、<code>DELETE</code>、<code>INSERT</code>、<code>REPLACE</code> 以及 <code>UPDATE</code> 语句。</p>
<p>执行计划结果中共有 12 列，各列代表的含义总结如下表：</p>
<table>
<thead>
<tr>
<th><strong>列名</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>SELECT 查询的序列标识符</td>
</tr>
<tr>
<td>select_type</td>
<td>SELECT 关键字对应的查询类型</td>
</tr>
<tr>
<td>table</td>
<td>用到的表名</td>
</tr>
<tr>
<td>partitions</td>
<td>匹配的分区，对于未分区的表，值为 NULL</td>
</tr>
<tr>
<td>type</td>
<td>表的访问方法</td>
</tr>
<tr>
<td>possible_keys</td>
<td>可能用到的索引</td>
</tr>
<tr>
<td>key</td>
<td>实际用到的索引</td>
</tr>
<tr>
<td>key_len</td>
<td>所选索引的长度</td>
</tr>
<tr>
<td>ref</td>
<td>当使用索引等值查询时，与索引作比较的列或常量</td>
</tr>
<tr>
<td>rows</td>
<td>预计要读取的行数</td>
</tr>
<tr>
<td>filtered</td>
<td>按表条件过滤后，留存的记录数的百分比</td>
</tr>
<tr>
<td>Extra</td>
<td>附加信息</td>
</tr>
</tbody></table>
<ul>
<li><p>type</p>
<p>查询执行的类型，描述了查询是如何执行的。所有值的顺序从最优到最差排序为：system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL</p>
<p>常见的几种类型具体含义如下：</p>
<ul>
<li><strong>system</strong>：如果表使用的引擎对于表行数统计是精确的（如：MyISAM），且表中只有一行记录的情况下，访问方法是 system ，是 const 的一种特例。</li>
<li><strong>const</strong>：表中最多只有一行匹配的记录，一次查询就可以找到，常用于使用主键或唯一索引的所有字段作为查询条件。</li>
<li><strong>eq_ref</strong>：当连表查询时，前一张表的行在当前这张表中只有一行与之对应。是除了 system 与 const 之外最好的 join 方式，常用于使用主键或唯一索引的所有字段作为连表条件。</li>
<li><strong>ref</strong>：使用普通索引作为查询条件，查询结果可能找到多个符合条件的行。</li>
<li><strong>index_merge</strong>：当查询条件使用了多个索引时，表示开启了 Index Merge 优化，此时执行计划中的 key 列列出了使用到的索引。</li>
<li><strong>range</strong>：对索引列进行范围查询，执行计划中的 key 列表示哪个索引被使用了。</li>
<li><strong>index</strong>：查询遍历了整棵索引树，与 ALL 类似，只不过扫描的是索引，而索引一般在内存中，速度更快。</li>
<li><strong>ALL</strong>：全表扫描。</li>
</ul>
<p>SQL性能优化的目标：<strong>至少</strong>要达到 <strong>range</strong> 级别，要求是ref级别，如果可以是consts 最好。</p>
</li>
<li><p>extra</p>
<table>
<thead>
<tr>
<th>关键字</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>Using filesort</td>
<td>将用外部排序而不是按照索引顺序排列结果，数据较少时从内存排序，否则需要在磁盘完成排序，代价非常高，需要添加合适的索引。</td>
</tr>
<tr>
<td>Using temporary</td>
<td>需要创建一个临时表来存储结果，这通常发生在对没有索引的列进行GROUP BY时，或者ORDER BY里的列不都在索引里，需要添加合适的索引。</td>
</tr>
<tr>
<td>Using index</td>
<td>表示MySQL使用<strong>覆盖索引</strong>避免全表扫描，不需要再到表中进行二次查找数据，这是比较好的结果之一。注意不要和type中的index类型混淆。</td>
</tr>
<tr>
<td>Using where</td>
<td>通常是进行了全表&#x2F;全索引扫描后再用WHERE子句完成结果过滤，需要添加合适的索引。</td>
</tr>
<tr>
<td>Impossible WHERE</td>
<td>对Where子句判断的结果总是false而不能选择任何数据，例如where 1&#x3D;0，无需过多关注。</td>
</tr>
<tr>
<td>Select tables optimized away</td>
<td>使用某些聚合函数来访问存在索引的某个字段时，优化器会通过索引直接一次定位到所需要的数据行完成整个查询，例如MIN()\MAX()，这种也是比较好的结果之一。</td>
</tr>
<tr>
<td>Using index condition</td>
<td>在5.6版本后加入的新特性索引下推（Index Condition Pushdown）;来自MySQL文档：<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/explain.html"><code>EXPLAIN</code></a> output shows <code>Using index condition</code> in the <code>Extra</code> column when Index Condition Pushdown is used.</td>
</tr>
</tbody></table>
</li>
</ul>
<p>如何判断数据库的索引有没有生效？</p>
<p>可以使用<strong>EXPLAIN</strong>语句查看索引是否正在使用。<code>EXPLAIN</code> 并不会真的去执行相关的语句，而是通过 <strong>查询优化器</strong> 对语句进行分析，找出最优的查询方案，并显示对应的信息。如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> a <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>possible_keys</th>
<th>可能用到的索引</th>
</tr>
</thead>
<tbody><tr>
<td>key</td>
<td>实际用到的索引</td>
</tr>
</tbody></table>
<h4 id="常用SQL优化"><a href="#常用SQL优化" class="headerlink" title="常用SQL优化"></a>常用SQL优化</h4><ul>
<li><p>禁止使用 SELECT * 必须使用 SELECT &lt;字段列表&gt; 查询</p>
<ul>
<li><code>SELECT *</code> 消耗更多的 CPU 和 IO 以网络带宽资源</li>
<li><code>SELECT *</code> 无法使用覆盖索引，除非你给所有列建一个联合索引（明显不可能）</li>
<li><code>SELECT &lt;字段列表&gt;</code> 可减少表结构变更带来的影响</li>
</ul>
</li>
<li><p>避免使用子查询，可以把子查询优化为 join 操作（相关：sql查询时走了主键索引，但跨度很大）</p>
<p>通常子查询在 in 子句中，且子查询中为简单 SQL(不包含 union、group by、order by、limit 从句) 时,才可以把子查询转化为关联查询进行优化。</p>
<p><em>注：</em>IN操作肯定会走索引。不过，当IN的取值范围较大时，可能会导致索引失效，这时会走全表扫描。</p>
<p><strong>子查询性能差的原因：</strong> 执行子查询时，MySQL 需要为内层查询语句的查询结果建立一个<strong>临时表</strong> ，然后外层查询语句从临时表中查询记录。查询完毕后，再撤销这些临时表 。这样会消耗过多的 CPU 和 IO 资源，产生大量的慢查询。子查询的结果集存储的临时表，不论是内存临时表还是磁盘临时表都 <strong>不会存在索引</strong> ，所以查询性能会受到一定的影响。对于返回结果集比较大的子查询，其对查询性能的影响也就越大。</p>
<p>在 MySQL 中，可以使用连接（JOIN）查询来替代子查询。连接可以走索引：驱动表是走全表扫描，而被驱动表是走树搜索。MySQL会选择小表（参与join的字段数据量小）做驱动表（left join强制左表为驱动表）。</p>
<p>1.当使用left join时，左表是驱动表，右表是被驱动表<br>2.当使用right join时，右表时驱动表，左表是驱动表<br>3.当使用join时，mysql会选择数据量比较小的表作为驱动表，大表作为被驱动表</p>
<p>注意：<strong>EXPLAIN语句分析出来的第一行的表即是驱动表</strong></p>
<p>例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM student stu1</span><br><span class="line">    WHERE stu1.`stuno` IN (</span><br><span class="line">    SELECT monitor</span><br><span class="line">    FROM class c</span><br><span class="line">    WHERE monitor IS NOT NULL</span><br><span class="line">);</span><br><span class="line">SELECT stu1.* FROM student stu1 JOIN class c </span><br><span class="line">ON stu1.`stuno` = c.`monitor`</span><br><span class="line">WHERE c.`monitor` IS NOT NULL;</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p>在明显不会有重复值时使用 UNION ALL 而不是 UNION</p>
<ul>
<li>UNION 会把两个结果集的所有数据放到临时表中后再进行去重操作</li>
<li>UNION ALL 不会再对结果集进行去重操作</li>
</ul>
</li>
<li><p>select * from table limit 100000,10; 很慢如何优化</p>
<p>MySQL并不是跳过offset行，而是取offset+N行，然后返回放弃前offset行，返回 N 行，那当offset特别大的时候，效率就非常的低下。要么控制返回的总页数，要么对超过 特定阈值的页数进行SQL改写。</p>
<p>利用延迟关联或者子查询优化：</p>
<ul>
<li><p>延迟关联：先通过覆盖索引快速查出主键，通过主键关联原表（回表）查。</p>
<p>SELECT a.* FROM a, (select id from 表1 where 条件 LIMIT 100000,10 ) b where a.id&#x3D;b.id</p>
<p>SELECT a.* FROM a join (select id from 表1 where 条件 LIMIT 100000,10 ) b on a.id&#x3D;b.id</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>delete批量删除</p>
<p>delete语句的执行过程中，会对表中的所有数据行进行扫描，并对符合条件的数据行进行删除。在这个过程中，如果有其他事务正在对该表进行读取或修改操作，则当前事务将被阻塞，直到其他事务完成操作。</p>
<ol>
<li><p>delete from 表名where 条件limit 10000;</p>
<p>一次占用锁的时间比较长，可能导致其他客户端一致等待资源。</p>
</li>
<li><p>在一个连接中循环执行20次delete from表名limit 500;</p>
<p>分多次占用锁，串行化执行，不占有锁的间隙，其他客户端可以工作。</p>
</li>
</ol>
<ul>
<li>如果需要删除超大批量数据</li>
</ul>
<blockquote>
<p>1、先删除表中索引；<br>2、再删除需要删除的数据；<br>3、然后重新创建索引。</p>
</blockquote>
</li>
</ul>
<ul>
<li><p>超过三张表禁止join</p>
<p>三个表进行笛卡尔积计算会出现操作复杂度呈几何数增长，多个表JOIN时要确保被关联的字段有索引。</p>
<p>1、在内存中自己做关联，即先从数据库中把数据查出来之后，我们在代码中再进行二次查询，然后再进行关联。 </p>
<p>2、数据冗余，那就是把一些重要的数据在表中做冗余，这样就可以避免关联查询了。</p>
</li>
<li><p>如果有order by的场景，请注意利用索引的有序性。</p>
<p>order by 最后的字段是组合 索引的一部分，并且放在索引组合顺序的最后，避免出现file_sort的情况，影响查询性能。  </p>
<p>正例：where a&#x3D;? and b&#x3D;? order by c; 索引：a_b_c  </p>
<p>反例：索引中有范围查找，那么索引有序性无法利用，如：WHERE a&gt;10 ORDER BY b; 索引 a_b 无法排序。</p>
</li>
</ul>
<h5 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h5><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/XC8e5iuQtfsrEOERffEZ-Q">https://mp.weixin.qq.com/s/XC8e5iuQtfsrEOERffEZ-Q</a></p>
<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><ul>
<li><p>数据库事务</p>
<p>一组操作构成的逻辑单元，这些操作要么都执行，要么都不执行。</p>
<p>事务的ACID四个特性：</p>
<p><strong>原子性</strong>（<code>Atomicity</code>）：事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</p>
<p><strong>一致性</strong>（<code>Consistency</code>）：事务应确保数据库的状态从一个一致状态转变为另一个一致状态。一致状态的含义是数据库中的数据应满足完整性约束。例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的（<strong>用户自定义完整性</strong>）；</p>
<p><strong>隔离性</strong>（<code>Isolation</code>）：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。</p>
<p><strong>持久性</strong>（<code>Durability</code>）：一个事务被提交之后，它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</p>
</li>
<li><p>并发事务带来哪些问题</p>
<ul>
<li><p>脏读（读未提交）</p>
<p>一个事务读取数据并且对数据进行了修改，这个修改对其他事务来说是可见的，即使当前事务没有提交。这时另外一个事务读取了这个还未提交的数据，但第一个事务由于某些原因回滚，导致数据并没有被提交到数据库，那第二个事务读取到的就是脏数据，即脏读。</p>
</li>
<li><p>（了解）丢失修改（Lost to modify）</p>
<p>在一个事务读取一个数据时，另外一个事务也访问了该数据，在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。</p>
</li>
</ul>
<ul>
<li><p>不可重复读（Unrepeatable read）</p>
<p>在一个事务内多次读取同一个数据，但前后两次读到的数据不一样的情况。在第一个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不一致。</p>
</li>
<li><p>幻读（Phantom read）</p>
<p> 幻读指的是一个事务在前后两次执行同一个查询，但两次查询到的记录的数量不一致。就好像发生了幻觉一样，所以称为幻读。</p>
</li>
</ul>
<p>严重性：脏读 &gt; 不可重读 &gt; 幻读</p>
</li>
<li><p>事务隔离级别</p>
<p>SQL 标准定义了四个隔离级别：</p>
<ul>
<li>**READ-UNCOMMITTED(读未提交)**：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、不可重复读或幻读。</li>
<li>**READ-COMMITTED(读已提交)**：允许读取并发事务已经提交的数据，可以阻止脏读，但是不可重复读或幻读仍有可能发生。</li>
<li>**REPEATABLE-READ(可重复读)**：事务对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</li>
<li>**SERIALIZABLE(串行化)**：所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。InnoDB中对每个SELECT语句后自动加上LOCK IN SHARE MODE，即为每个读取操作加一个共享锁。</li>
</ul>
</li>
<li><p>MySQL默认的隔离级别</p>
<p>InnoDB 引擎的默认隔离级别是<strong>可重复读</strong>，它能在很大程度上避免幻读现象（并不是完全解决了），解决的方案有两种：</p>
<ul>
<li><p>针对<strong>快照读</strong>（一致性非锁定读，普通 select 语句，读取的是ReadView中的历史数据），是<strong>通过 MVCC （Multi-Version Concurrency Control ，多版本并发控制）方式解决了幻读</strong>。</p>
<p>快照读的情况下，如果读取的记录正在执行 UPDATE&#x2F;DELETE 操作，读取操作不会因此去等待记录上 X 锁的释放，而是会去读取行的一个快照。</p>
<p>RR 隔离级别只会在事务开启后的第一次查询生成 <code>Read View</code> ，并使用至事务提交。所以在生成 <code>Read View</code> 之后其它事务所做的更新、插入记录版本对当前事务并不可见，实现了可重复读和防止快照读下的 “幻读”。</p>
</li>
<li><p>针对<strong>当前读</strong>（一致性锁定读，加X锁或S锁，<code>select ... for update</code>、<code>insert</code>、<code>update</code>、<code>delete</code>、<code>select ... lock in share mode</code>，读取的总是最新数据），是<strong>通过 Next-Key Lock（记录锁record lock+间隙锁gap lock）方式解决了幻读</strong>。（行锁包含Next-Key Lock、Record Lock和Gap Lock）</p>
<p>通过记录锁可以锁住已经存在的行，通过间隙锁可以锁定某个范围中的间隙（范围内不存在的行），从而避免插入新行。当执行上述语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，（删除也会阻塞）所以就很好了避免幻读问题。</p>
</li>
</ul>
<ul>
<li><p>RR级别下，<strong>不能解决的幻读情况</strong>：<br>1、事务1 先快照读，事务2新增了一条数据并提交事务，事务1再当前读。<br>2、事务1 先快照读，事务2新增了一条数据并提交事务，事务1对事务2提交的数据进行了修改，事务1再次快照读。</p>
<p>情况1不用说了吧，很好理解。对于情况2， 事务1的更新操作不属于快照读，因此事务1的更新操作是可以生效的，而当前数据会记录最新修改的记录，最新修改的记录为当前事务自己，所以是能看到的。</p>
</li>
</ul>
<blockquote>
<p>MySQL为什么默认采用可重复读（Oracle默认采用读已提交）？</p>
<p>MySQL使用可重复读（Repeatable-Read）作为默认的存储引擎主要是因为老版本的MySQL二进制文件的各种只支持statement这一种格式，这种格式的二进制文件如果使用提交读（Read-Committed）作为默认的隔离级别会导致丢失更新的问题，所以MySQL使用了可重复读（Repeatable-Read）作为默认的存储引擎。如果把二进制文件的格式改成row,那也可以使用提交读（Read-Committed）作为隔离级别，可以提高数据库的并发性能。</p>
<p>MySQL binlog的三种工作模式（在MySQL 8.0中，二进制日志记录默认启用，默认使用基于行的格式。binlog_format从MySQL 8.0.34开始就被弃用，并将在MySQL的未来版本中删除。这意味着对除基于Row之外的日志记录格式的支持也将在未来的版本中删除）： </p>
<p>Row  简介：日志中会记录每一行数据被修改的情况，然后在slave端对相同的数据进行修改。 优点：能清楚的记录每一行数据修改的细节 缺点：数据量太大</p>
<p>Statement 简介：每一条被修改数据的sql都会记录到master的bin-log中，slave在复制的时候sql进程会解析成和原来master端执行过的相同的sql再次执行。在主从同步中一般是不建议用statement模式的，因为会有些语句不支持，比如语句中包含UUID函数，以及LOAD DATA IN FILE语句等 优点：解决了 Row level下的缺点，不需要记录每一行的数据变化，减少bin-log日志量，节约磁盘IO，提高新能 缺点：容易出现主从复制不一致</p>
<p>Mixed（混合模式） 简介：结合了Row level和Statement level的优点，同时binlog结构也更复杂。</p>
<p>文档位置：<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.1/en/replication-options-binary-log.html#sysvar_binlog_format">https://dev.mysql.com/doc/refman/8.1/en/replication-options-binary-log.html#sysvar_binlog_format</a></p>
</blockquote>
</li>
<li><p>可重复读怎么实现？</p>
<blockquote>
<p>基于MVCC实现。</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>MVCC就是多版本并发控制，其实说的是一条记录会有多个版本，每次修改记录都会增加一个新的版本，多个版本之间形成一条版本链。MVCC实现依赖于每行数据的隐藏列、基于undo log的版本链和ReadView。隐藏列中记录了最后一次修改数据行的事务id和指向undo log的指针，每条undo log又指向更早版本的undo log从而形成一条版本链。ReadView是数据库某个时刻的快照，记录了当时正在运行的事务相关的信息。</p>
<p>根据隐藏列中的事务id、ReadView中记录的信息以及可见性算法就可以得到对创建ReadView的事务可见的数据的版本。</p>
<p>在RR隔离级别下，只有事务中第一次查询前会创建一个ReadView，后面的查询都是基于这个ReadView，这就意味着事务中所有查询看到的数据版本都是一致的，除非事务本身修改了数据。这就实现了可重复读。</p>
<p>那么RC又如何实现？</p>
<p>RC隔离级别下，每次读取数据都会创建一个ReadView，所以可以看到最新的事务运行的情况，结合可见性算法就能看到其他事务提交的最新版本的数据。</p>
</blockquote>
<ul>
<li><p>InnoDB怎么实现MVCC</p>
<p>mvcc多版本并发控制，其实指的是一条记录会有多个版本，每次修改记录都会存储这条记录被修改之前的版本，多版本之间串联起来就形成了一条版本链。事务中有写操作只需增加一个新的版本，事务未提交前其他事务可以读取旧版本数据。这样不同时刻启动的事务<strong>不加锁</strong>就能读取数据，读写操作不会冲突。</p>
<p><code>MVCC</code> 的实现依赖于：<strong>隐藏列、undo log、Read View</strong>。在内部实现中，<code>InnoDB</code> 通过数据行的 <code>DB_TRX_ID</code> 和 <code>Read View</code> 来判断数据的可见性，如不可见，则通过数据行的 <code>DB_ROLL_PTR</code> 找到 <code>undo log</code> 中的历史版本。每个事务读到的数据版本可能是不一样的，在同一个事务中，用户只能看到该事务创建 <code>Read View</code> 之前已经提交的修改和该事务本身做的修改。</p>
<ul>
<li><p>隐藏列</p>
<p><code>InnoDB</code> 存储引擎为每行数据添加了三个隐藏列：</p>
<ul>
<li><code>DB_TRX_ID（6字节）</code>：表示最后一次插入或更新该行的<strong>事务 id</strong>。此外，<code>delete</code> 操作在内部被视为更新，只不过会在记录头 <code>Record header</code> 中的 <code>deleted_flag</code> 字段将其标记为已删除。</li>
<li><code>DB_ROLL_PTR（7字节）</code> <strong>回滚指针</strong>，指向该行的 <code>undo log</code> 。如果该行未被更新，则为空。</li>
<li><code>DB_ROW_ID（6字节）</code>：如果没有设置主键且该表没有唯一非空索引时，<code>InnoDB</code> 会使用该 id 来生成聚簇索引。</li>
</ul>
</li>
<li><p>基于undo log的版本链</p>
<p>每行数据的隐藏列中包含了指向undo log的指针，而每条undo log也会指向更早版本的undo log，从而形成一条版本链。</p>
</li>
<li><p>ReadView</p>
<p>在 <code>InnoDB</code> 存储引擎中，</p>
<ul>
<li>在 RC 隔离级别下的 <strong><code>每次select</code></strong> 查询前都生成一个<code>Read View</code> </li>
<li>在 RR 隔离级别下只在事务开始后 <strong><code>第一次select</code></strong> 数据前生成一个<code>Read View</code></li>
</ul>
<p><strong>快照中保存了当前数据库系统中正处于活跃（没有 commit）的事务的 ID 号</strong>，即当前不应该被本事务看到的其他事务 ID 列表（m_ids）。当用户在这个事务中要读取某个记录行的时候，<code>InnoDB</code> 会将该记录行的 <code>DB_TRX_ID</code> 与 <code>Read View</code> 中的一些变量及当前事务 ID 进行比较，判断这行记录对该事务是否可见。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">trx_id_t</span> m_low_limit_id;      <span class="comment">/* 大于等于这个 ID 的事务均不可见 */</span></span><br><span class="line"><span class="type">trx_id_t</span> m_up_limit_id;       <span class="comment">/* 小于这个 ID 的事务均可见 */</span></span><br><span class="line"><span class="type">trx_id_t</span> m_creator_trx_id;    <span class="comment">/* 创建该 Read View 的事务ID */</span></span><br><span class="line"><span class="type">ids_t</span> m_ids;                  <span class="comment">/* 创建 Read View 时的活跃事务列表 */</span></span><br></pre></td></tr></table></figure>

<ul>
<li>可见性算法</li>
</ul>
<ol>
<li>如果当前数据版本的 trx_id &#x3D;&#x3D; creator_trx_id 说明修改这条数据的事务就是当前事务，所以可见。</li>
<li>如果记录 DB_TRX_ID &lt; m_up_limit_id，那么表明最新修改该行的事务（DB_TRX_ID）在当前事务创建快照之前就提交了，所以该记录行的值对当前事务是可见的</li>
<li>如果 DB_TRX_ID &gt;&#x3D; m_low_limit_id，那么表明最新修改该行的事务（DB_TRX_ID）在当前事务创建快照之后才修改该行，所以该记录行的值对当前事务不可见。跳到步骤 5</li>
<li>如果 m_up_limit_id &lt;&#x3D; DB_TRX_ID &lt; m_low_limit_id，表明最新修改该行的事务（DB_TRX_ID）在当前事务创建快照的时候可能处于“活动状态”或者“已提交状态”；所以就要对活跃事务列表 m_ids 进行查找<ul>
<li>m_ids为空或在m_ids中找不到，则表明在当前事务创建快照之前，修改该行的事务已经提交了，所以记录行对当前事务可见。</li>
<li>如果在活跃事务列表 m_ids 中能找到 DB_TRX_ID，说明创建快照时修改这条数据的事务尚未提交，所以记录行对当前事务不可见。跳到步骤 5</li>
</ul>
</li>
<li>在该记录行的 DB_ROLL_PTR 指针所指向的 <code>undo log</code> 取出快照记录，用快照记录的 DB_TRX_ID 跳到步骤 1 重新开始判断，直到找到满足的快照版本或返回空</li>
</ol>
</li>
</ul>
</li>
<li><p>MySQL怎么实现ACID</p>
<blockquote>
<p>事务要从ACID四个特性说起，我就分别说一下MySQL怎么保证这四个特性。</p>
<p>先从原子性开始说，原子性就是事务内的操作，要么都执行成功，要么都失败。也就是说，只要其中一个操作失败，其他的已经执行成功的操作也必须回滚到操作执行之前的状态。这个主要通过undo log来实现。执行一条增删改的语句后，就会记录到undo log中。当事务回滚的时候，就去执行这些语句的反向操作，让数据回到事务执行前的状态。</p>
<p>再说一下持久性。持久性说的是一个事务被提交之后，它对数据库中数据的改变是持久的。我觉得就是事务提交之后，确保这些数据都能落到磁盘上。因为磁盘IO比较慢，如果每次读写数据都需要磁盘IO，性能就比较差。所以MySQL有一个Buffer Pool作为缓存，读写数据都是先操作Buffer Pool。然后把修改的数据定期刷到磁盘上。这就带来一个问题就是Buffer Pool是在内存里的，那么一旦MySQL宕机，可能有一部分数据没来得及写入磁盘。所以redo log就是用来解决这个问题。MySQL采用Write Ahead Logging  机制，就是先把日志写入磁盘，再更新到Buffer Pool。因为写日志是顺序写（连续，寻道时间短），要比直接把数据写入磁盘要快（随机写寻道时间长）。当MySQL宕机，就可以用redo log来恢复数据。这样就实现了持久性。</p>
<p>再说一下隔离性。隔离性就是多个事务并发执行时，一个事务的执行不应影响其他事务的执行。隔离性分为不同的隔离级别，但主要都是通过锁和MVCC来实现。锁主要用来保证写跟写之间的隔离，确保同一时刻只能有一个事务来写这个数据。MVCC主要用来解决读跟写之间的隔离，通过MVCC可以实现读已提交和可重复读这两个隔离级别，在不同隔离级别下事务能读到的数据是不一样的。。</p>
<p>最后就是一致性。一致性就是说事务应确保数据库的状态从一个一致状态转变为另一个一致状态。一致状态的含义是数据库中的数据应满足完整性约束。这个主要就是靠其他三个特性来保证。</p>
</blockquote>
<ul>
<li><p>原子性</p>
<p>实现原子性的关键，是当事务回滚时能够撤销所有已经成功执行的sql语句。InnoDB实现回滚靠的是undo log，当事务对数据库进行修改时，InnoDB会生成对应的undo log。如果事务执行失败或调用了rollback，导致事务需要回滚，便可以利用undo log中的信息将数据回滚到修改之前的样子。</p>
<p>undo log属于逻辑日志，它记录的是sql执行相关的信息。当发生回滚时，InnoDB会根据undo log的内容做与之前相反的工作。对于insert，回滚时会执行delete。对于delete，回滚时会执行insert。对于update，回滚时则会执行相反的update，把数据改回去。</p>
</li>
<li><p>持久性</p>
<p>InnoDB作为MySQL的存储引擎，数据是存放在磁盘中的，但如果每次读写数据都需要磁盘IO，效率会很低。为此，InnoDB提供了缓存(<strong>Buffer Pool</strong>)，Buffer Pool中包含了磁盘中部分数据页的映射，作为访问数据库的缓冲。当从数据库读取数据时，会首先从Buffer Pool中读取，如果Buffer Pool中没有，则从磁盘读取后放入Buffer Pool。当向数据库写入数据时，会首先写入Buffer Pool，Buffer Pool中修改的数据会<strong>定期刷新到磁盘</strong>中（这一过程称为刷脏）。</p>
<p>Buffer Pool的使用大大提高了读写数据的效率，但是也带了新的问题：如果<em>MySQL宕机</em>，而此时Buffer Pool中修改的数据还没有刷新到磁盘，就会导致<em>数据的丢失</em>，事务的持久性无法保证。</p>
<p>于是，redo log被引入来解决这个问题。当数据修改时，除了修改Buffer Pool中的数据，<em>还会在redo log记录这次操作</em>（记录到重做日志缓存<code>redo log buffer</code>里）。刷盘时机可自行设置，此外<code>InnoDB</code> 存储引擎有一个后台线程，每隔<code>1</code> 秒，就会把 <code>redo log buffer</code> 中的内容写到文件系统缓存（<code>page cache</code>），然后调用 <code>fsync</code>（系统调用） 刷盘。如果MySQL宕机，重启时可以读取redo log中的数据，对数据库进行恢复。redo log采用的是WAL（Write-ahead logging，预写式日志），所有修改<strong>先写入日志</strong>，<strong>再更新到Buffer Pool</strong>，保证了数据不会因MySQL宕机而丢失，从而满足了持久性要求。</p>
<p>在宕机后，重启 MySQL 时，InnoDB 会自动恢复 redo log 中 <code>checkpoint_lsn</code> 后的，且处于 commit 状态的事务。如果 redo log 中事务的状态为 prepare，则需要先查看 binlog 中该事务是否存在，是的话就恢复，否则就回滚（通过 undo log 回滚。脏页一直在刷，更新了脏页，但事务没提交就宕机了，所以需要回滚）。</p>
<p>（了解）既然redo log也需要在事务提交时将日志写入磁盘，为什么它比直接将Buffer Pool中修改的数据写入磁盘(即刷脏)要快呢？主要有以下两方面的原因：</p>
<ul>
<li>刷脏是随机IO，因为每次修改的数据位置随机，但写redo log是追加操作，属于<strong>顺序IO</strong>。</li>
<li>刷脏是以数据页（Page）为单位的，MySQL默认页大小是16KB，一个Page上一个小修改都要整页写入。而redo log中只包含真正需要写入的部分，无效IO大大减少。</li>
</ul>
</li>
<li><p>隔离性</p>
<p>第一方面，(一个事务)写操作对(另一个事务)写操作的影响：锁机制保证隔离性。</p>
<p>隔离性要求同一时刻只能有一个事务对数据进行写操作，InnoDB通过锁机制来保证这一点。锁机制的基本原理可以概括为：事务在修改数据之前，需要先获得相应的锁。获得锁之后，事务便可以修改数据。该事务操作期间，这部分数据是锁定的，其他事务如果需要修改数据，需要等待当前事务提交或回滚后释放锁。</p>
<p>按照粒度，锁可以分为表锁、行锁以及其他位于二者之间的锁。表锁在操作数据时会锁定整张表，并发性能较差。行锁则只锁定需要操作的数据，并发性能好。但是由于加锁本身需要消耗资源，因此在锁定数据较多情况下使用表锁可以节省大量资源。MySQL中不同的存储引擎支持的锁是不一样的，例如MyIsam只支持表锁，而InnoDB同时支持表锁和行锁，且出于性能考虑，绝大多数情况下使用的都是行锁。</p>
<p>第二方面，(一个事务)写操作对(另一个事务)读操作的影响：MVCC保证隔离性。</p>
<p>InnoDB默认的隔离级别是RR（REPEATABLE READ），RR解决脏读、不可重复读、幻读等问题，使用的是MVCC。MVCC全称Multi-Version Concurrency Control，即多版本的并发控制协议。它最大的优点是读不加锁，因此读写不冲突，并发性能好。</p>
</li>
<li><p>一致性</p>
<p>可以说，一致性是事务追求的最终目标。前面提到的原子性、持久性和隔离性，都是为了保证数据库状态的一致性。</p>
</li>
</ul>
</li>
</ul>
<h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><ul>
<li><p><strong>undo log（回滚日志）</strong>：是 Innodb 存储引擎层生成的日志，实现了事务中的<strong>原子性</strong>，主要<strong>用于事务回滚和 MVCC</strong>。</p>
<p>在事务没提交之前，MySQL 会先记录更新前的数据到 undo log 日志文件里面，在发生回滚时，就读取 undo log 里的数据，然后做与原先相反操作。</p>
<p><strong>在 <code>InnoDB</code> 存储引擎中 <code>undo log</code> 分为两种：<code>insert undo log</code> 和 <code>update undo log</code>：</strong></p>
<ol>
<li>**<code>insert undo log</code>**： 事务对insert新记录时产生的undo log, 只在事务回滚时需要, 并且在事务提交后就可以立即丢弃。</li>
<li>**<code>update undo log</code>**：事务对记录进行delete和update操作时产生的undo log，不仅在事务回滚时需要，快照读也需要，只有当其他事务快照读不涉及该日志记录，对应的回滚日志才会被删除。</li>
</ol>
</li>
<li><p><strong>redo log（重做日志）</strong>：是 Innodb 存储引擎层生成的日志，实现了事务中的<strong>持久性</strong>，主要<strong>用于掉电等故障恢复</strong>；<code>redo log</code> 是物理日志，记录内容是“在某个数据页上做了什么修改”。</p>
<p>redo log 文件是循环写，只记录未被刷入磁盘的数据的物理日志，已经刷入磁盘的数据都会从 redo log 文件里擦除。</p>
<p>详见MySQL怎么实现持久性。</p>
<ul>
<li><p>为什么canal不订阅redo log？</p>
<ul>
<li><p>redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。</p>
</li>
<li><p>redolog会记录未提交事务的数据，而binlog只会在事务提交后写入。</p>
</li>
<li><p>redo log 是物理日志，记录的是在某个数据页上做了什么修改；binlog 是逻辑日志，记录的是这个语句的原始逻辑。</p>
</li>
</ul>
</li>
<li><p>redo log什么时候删除？redo日志文件组是有限的，所以需要循环利用。当redo log日志的内容，已经由内存刷入到磁盘当中（也就是刷脏），那么对应的redo log就是可以被删除了，也就是可以被覆盖重写。具体而言，InnoDB 用检查点（<code>checkpoint_lsn</code>）指示未被刷脏页的 redo log 数据从这里开始，检查点前的数据就可以被覆盖了。</p>
</li>
</ul>
</li>
<li><p><strong>binlog （归档日志）</strong>：是 Server 层生成的日志，它记录了所有的查询语句以外的DML和DDL语句，主要<strong>用于数据备份和主从复制</strong>；MySQL 在完成一条更新操作后，Server 层还会生成一条 binlog，等之后事务提交的时候，会将该事务执行过程中产生的所有 binlog 统一写 入 binlog 文件。</p>
<p>binlog 是追加写，写满一个文件，就创建一个新的文件继续写，不会覆盖以前的日志，保存的是全量的日志。</p>
<blockquote>
<p>可以使用<code>mysqlbinlog  --base64-output=decode-rows -v path</code>命令查看mysql的binlog</p>
<p>binlog_rows_query_log_events &#x3D; 1  # 将原始的操作sql记录写入事件中</p>
</blockquote>
</li>
<li><p>（了解）两阶段提交</p>
<p><code>redo log</code>与<code>binlog</code>刷新到磁盘是两个独立的逻辑，可能发生一个刷盘成功，而另一个因MySQL宕机等还没来得及写入磁盘，这就造成两份日志之间的逻辑不一致。</p>
<p><strong>MySQL 为了避免出现两份日志之间的逻辑不一致的问题，使用了「两阶段提交」来解决</strong>，两阶段提交其实是分布式事务一致性协议，它可以保证多个逻辑操作要不全部成功，要不全部失败，不会出现半成功的状态。</p>
<p>为什么要两阶段提交？</p>
<ul>
<li>先写 redo log 直接提交，然后写 binlog，假设写完 redo log 后，机器挂了，binlog 日志没有被写入，那么机器重启后，这台机器会通过 redo log 恢复数据，但是这个时候 bingog 并没有记录该数据，后续进行机器备份的时候，就会丢失这一条数据，同时主从同步也会丢失这一条数据。</li>
<li>先写 binlog，然后写 redo log，假设写完了 binlog，机器异常重启了，由于没有 redo log，本机是无法恢复这一条记录的，但是 binlog 又有记录，那么和上面同样的道理，就会产生数据不一致的情况。</li>
</ul>
<p>如果采用 redo log 两阶段提交的方式就不一样了，写完 binglog 后，然后再提交 redo log 就会防止出现上述的问题，从而保证了数据的一致性。</p>
<p><a target="_blank" rel="noopener" href="https://xiaolincoding.com/mysql/log/how_update.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4">https://xiaolincoding.com/mysql/log/how_update.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4</a></p>
<p><a target="_blank" rel="noopener" href="https://javaguide.cn/database/mysql/mysql-logs.html#%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4">https://javaguide.cn/database/mysql/mysql-logs.html#%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4</a></p>
</li>
</ul>
<h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><ul>
<li><p>全局锁、表级锁和行级锁</p>
<p>全局锁：一般用在整个库（包含非事务引擎表）做备份（mysqldump 或者 xtrabackup）时。<strong>整个数据库处于只读状态</strong></p>
<p>MyISAM 仅仅支持表级锁(table-level locking)，一锁就锁整张表，这在并发写的情况下性非常差。InnoDB 不光支持表级锁(table-level locking)，还支持行级锁(row-level locking)，默认为行级锁。</p>
<p>行级锁的粒度更小，仅对相关的记录上锁即可（对一行或者多行记录加锁），所以对于并发写入操作来说， InnoDB 的性能更高。</p>
<p><strong>表级锁和行级锁对比</strong>：</p>
<ul>
<li><p><strong>表级锁：</strong> MySQL 中锁定粒度最大的一种锁（全局锁除外），是针对非索引字段加的锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。不过，触发锁冲突的概率最高，高并发下效率极低。表级锁和存储引擎无关，MyISAM 和 InnoDB 引擎都支持表级锁。当执行 DDL 语句去修改表结构时，会使用表级锁。</p>
</li>
<li><p><strong>行级锁：</strong> MySQL 中锁定粒度最小的一种锁，是 <strong>针对索引字段加的锁</strong> ，只针对当前操作的行记录进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。行级锁和存储引擎有关，是在存储引擎层面实现的。</p>
</li>
</ul>
</li>
<li><p>行锁有哪些</p>
<p>InnoDB 行锁是通过对索引数据页上的记录加锁实现的，MySQL InnoDB 支持三种行锁定方式：</p>
<ul>
<li><p><strong>记录锁（Record Lock）</strong>：属于单个行记录上的锁。记录锁总是锁定索引记录，即使定义的表没有索引也是如此。对于这种情况，InnoDB会创建一个隐藏的聚集索引，并将该索引用于记录锁定。防止任何其他事务插入、更新或删除</p>
</li>
<li><p><strong>间隙锁（Gap Lock）</strong>：锁定一个范围，不包括记录本身。间隙锁是对索引记录之间间隙的锁定，或对第一个索引记录之前或最后一个索引记录之后间隙的锁定。例如，SELECT c1 FROM t WHERE c1 BETWEEN 10 and 20 For UPDATE；防止其他事务将值15插入到t.c1列中，无论该列中是否已经存在任何此类值，因为该范围中所有现有值之间的间隙都被锁定。</p>
<p>InnoDB中的Gap锁是“纯抑制性的”，这意味着它们的<strong>唯一目的是防止其他事务插入到Gap中</strong>。间隙锁可以共存。一个事务执行的间隙锁定不会阻止另一个事务对同一间隙执行间隙锁定。共享和独占间隙锁之间没有区别。它们彼此不冲突，并且执行相同的功能。</p>
<p>如果将事务隔离级别更改为READ COMMITTED，间隙锁定可以明确禁用。MySQL评估WHERE条件后，将释放不匹配行的记录锁。</p>
</li>
<li><p><strong>临键锁（Next-Key Lock）</strong>：Record Lock+Gap Lock，锁定一个范围，包含记录本身，主要目的是为了解决幻读问题（MySQL 事务部分提到过）。记录锁只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁。</p>
</li>
</ul>
<p><strong>在 InnoDB 默认的隔离级别 REPEATABLE-READ 下，行锁默认使用的是 Next-Key Lock。但是，如果操作的索引是唯一索引或主键，InnoDB 会对 Next-Key Lock 进行优化，将其降级为 Record Lock，即仅锁住索引本身，而不是范围。</strong></p>
</li>
<li><p>共享锁和排他锁呢？</p>
<p>不论是表级锁还是行级锁，都存在共享锁（Share Lock，S 锁）和排他锁（Exclusive Lock，X 锁）这两类：</p>
<ul>
<li><p><strong>共享锁（S 锁）</strong>：又称读锁，事务在读取记录的时候获取共享锁，允许多个事务同时获取（锁兼容）。</p>
</li>
<li><p><strong>排他锁（X 锁）</strong>：又称写锁&#x2F;独占锁，事务在修改记录的时候获取排他锁，不允许多个事务同时获取。如果一个记录已经被加了排他锁，那其他事务不能再对这条事务加任何类型的锁（锁不兼容）。</p>
</li>
</ul>
<p>由于 MVCC 的存在，对于一般的 <code>SELECT</code> 语句，InnoDB 不会加任何锁。不过， 你可以通过以下语句显式加共享锁或排他锁。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 共享锁</span><br><span class="line"><span class="keyword">SELECT</span> ... LOCK <span class="keyword">IN</span> SHARE MODE;</span><br><span class="line"># 排他锁</span><br><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>意向锁有什么作用？</p>
<p>如果需要用到表锁的话，如何判断表中的记录没有行锁呢，一行一行遍历肯定是不行，性能太差。我们需要用到一个叫做意向锁的东东来快速判断是否可以对某个表使用表锁。</p>
<p>意向锁是表级锁，共有两种：</p>
<ul>
<li><strong>意向共享锁（Intention Shared Lock，IS 锁）</strong>：事务有意向对表中的某些记录加共享锁（S 锁），加共享锁前必须先取得该表的 IS 锁。</li>
<li><strong>意向排他锁（Intention Exclusive Lock，IX 锁）</strong>：事务有意向对表中的某些记录加排他锁（X 锁），加排他锁之前必须先取得该表的 IX 锁。</li>
</ul>
<p><strong>意向锁是由数据引擎自己维护的，用户无法手动操作意向锁，在为数据行加共享&#x2F;排他锁之前，InooDB 会先获取该数据行所在在数据表的对应意向锁</strong></p>
<p>插入意图锁是在行插入之前由insert操作设置的一种间隙锁。该锁定以这样一种方式发出插入意图的信号，即如果插入到同一索引间隙中的多个事务不在间隙内的同一位置插入，则它们不需要相互等待。假设存在值为4和7的索引记录。尝试分别插入值为5和6的单独事务，在获得插入行的独占锁之前，每个事务都使用插入意图锁来锁定4和7之间的间隙，但不会相互阻止，因为这些行不冲突。</p>
</li>
<li><p>什么情况加什么锁（翻译自官方文档<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-locks-set.html%EF%BC%89">https://dev.mysql.com/doc/refman/8.0/en/innodb-locks-set.html）</a></p>
<ul>
<li><p>如果没有适合语句的索引，MySQL必须扫描整个表来处理语句，则表中的每一行都会被锁定，从而阻止其他用户对表的所有插入</p>
</li>
<li><p>select…from是一致性读，读取数据库的快照。除非事务隔离级别设置为SERIALIZABLE，否则不设置锁。一致读取将忽略在readview中存在的记录上设置的任何锁定。</p>
</li>
<li><p>SELECT … FOR UPDATE 和 SELECT … FOR SHARE、update、delete，对于具有唯一搜索条件（结果只有一行）的唯一索引，InnoDB只对找到的索引记录加记录锁；对于其他条件和非唯一索引，InnoDB为扫描的范围加间隙锁或临键锁。</p>
</li>
<li><p>update…where &#x2F; delete … from … where在SQL语句处理过程中扫描的每个记录上（与where无关）设置一个<strong>独占的临键锁</strong>。但是，对于使用唯一索引搜索唯一行的语句，只需要index record lock。</p>
<blockquote>
<p>半一致性读（RC隔离级别下）</p>
</blockquote>
<ul>
<li>对于UPDATE或DELETE语句，InnoDB只对其更新或删除的行持有锁。在MySQL评估WHERE条件后，释放不匹配行的记录锁。这大大降低了死锁的概率，但它们仍然可能发生。</li>
</ul>
<ul>
<li><p>并发时，如果update的记录发生锁等待，那么返回该记录的prev 版本（在返回前会将锁等待的这个lock从trx中删除掉），到mysql层进行where判断，是否满足条件。如果满足where条件，那么再次进入innodb层，真正加锁或者发生锁等待。</p>
<p>这样做的好处是：减少同一行记录的锁冲突及锁等待；无并发冲突时，直接读取最新版本加锁，有冲突时，不加锁，读取prev版本不需要锁等待。</p>
</li>
</ul>
</li>
<li><p>insert对插入行加排他的<strong>记录锁</strong>，不会阻止其他会话插入插入行之前的间隙中。</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>死锁</p>
<p>MySQL 会自动检测死锁并回滚事务。在并发环境下，当多个事务同时请求数据库资源时，可能会出现死锁，即多个事务相互等待对方释放资源，导致所有事务都无法继续执行的情况。</p>
<p>MySQL 会检测到这种情况，并采取一些策略来处理死锁，其中包括自动回滚事务。当发生死锁时，MySQL 会选择一个事务作为死锁牺牲者（通常是最后发起锁请求的事务），回滚该事务，使得其他事务可以继续执行。</p>
</li>
</ul>
<h3 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h3><h4 id="分库"><a href="#分库" class="headerlink" title="分库"></a>分库</h4><p>随着业务的发展，单库中的数据量不断增加，数据库的QPS会越来越高，对数据库的读写耗时也会相应地增长，这时单库的读写性能必然会成为系统的瓶颈点。这时可以通过将单个数据库拆分为多个数据库的方法，来分担数据库的压力,提升性能。同时多个数据库分布在不同的机器上也提高了数据库的可用性。</p>
<p><strong>垂直分库</strong> 就是把单一数据库按照业务进行划分，不同的业务表使用不同的数据库，进而将一个数据库的压力分担到多个数据库。</p>
<p><strong>水平分库</strong> 是把同一个表按一定规则拆分到不同的数据库中，每个库可以位于不同的服务器上，这样就实现了水平扩展，解决了单表的存储和性能瓶颈的问题。</p>
<h4 id="分表"><a href="#分表" class="headerlink" title="分表"></a>分表</h4><p>随着单表数据量的增加，对于数据的查询和更新，即使在数据库底层有一定的优化，但是随着量变必定会引起质变，导致性能急剧下降。这时可以通过分表的方法，将单表数据按一定规则水平拆分到多个表中，减小单表的数据量，提升系统性能。</p>
<p><strong>垂直分表</strong> 是对数据表列的拆分，把一张列比较多的表拆分为多张表。</p>
<p><strong>水平分表</strong> 是对数据表行的拆分，把一张行比较多的表拆分为多张表，可以解决单一表数据量过大的问题。</p>
<p><em>顺丰：其实企业中现在比较少进行分库分表了，都是用的比较新的数据库（如TiDB、PolarDB等），解决分库分表带来的查询等问题。</em></p>
<h3 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h3><p>以下是读写分离的几个主要用途：</p>
<ol>
<li>提高读取性能：在大多数应用程序中，读取操作比写入操作更频繁。通过将读操作分发到多个从服务器上，可以将读负载均衡到多个节点，从而提高读取性能。多个从服务器可以并行处理读请求，增加系统的并发处理能力。</li>
<li>减轻主服务器负载：将写操作集中在主服务器上，可以减轻主服务器的负载。由于写操作通常需要更多的计算和磁盘写入，将其与读操作分离可以避免读操作对主服务器的性能产生负面影响。</li>
<li>提高系统的可扩展性：通过读写分离，可以根据应用程序的需求，灵活地添加或删除从服务器来扩展系统的读取能力。当应用程序的读取需求增加时，可以简单地添加更多的从服务器来分担读取负载，而无需对主服务器进行修改。</li>
<li>提高系统的容错性：在读写分离架构中，如果主服务器发生故障，可以快速切换到其中一个从服务器作为新的主服务器，从而保证系统的高可用性。这种容错机制可以减少系统的停机时间，并提供持续的服务。</li>
</ol>
<p>注：从库可以写，但数据不会同步到主库</p>
<p>用Sharding-jdbc实现主从：</p>
<ul>
<li><p>mysql的主从复制环境</p>
<ol>
<li><p>配置主服务器（Master）：</p>
<ul>
<li><p>打开主服务器的配置文件（通常是 <code>my.cnf</code> 或 <code>my.ini</code>）。</p>
</li>
<li><p>在文件中找到<code>[mysqld]</code>部分，并添加以下配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">server-id = 1</span><br><span class="line">log-bin = mysql-bin</span><br><span class="line">binlog-format = ROW</span><br></pre></td></tr></table></figure>

<ul>
<li><code>server-id</code>：给主服务器分配一个唯一的标识符。每个服务器都必须有不同的 ID。</li>
<li><code>log-bin</code>：启用二进制日志，用于记录主服务器上的所有更改。</li>
<li><code>binlog-format</code>：设置二进制日志的格式。<code>ROW</code> 格式通常是推荐的选择，因为它可以提供更准确的复制。MySQL8以后默认为ROW，因此无需配置</li>
</ul>
</li>
</ul>
</li>
<li><p>重启主服务器：</p>
<ul>
<li>保存并关闭主服务器的配置文件。</li>
<li>重启主服务器，使配置更改生效。</li>
</ul>
</li>
<li><p>配置从服务器（Slave）：</p>
<ul>
<li><p>打开从服务器的配置文件。</p>
</li>
<li><p>在文件中找到<code>[mysqld]</code>部分，并添加以下配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">server-id = 2</span><br><span class="line">relay-log = mysql-relay-bin</span><br><span class="line">log-slave-updates = 1</span><br><span class="line">read-only = 1</span><br></pre></td></tr></table></figure>

<ul>
<li><code>server-id</code>：给从服务器分配一个唯一的标识符。每个服务器都必须有不同的 ID。</li>
<li><code>relay-log</code>：设置从服务器上的中继日志文件的名称。</li>
<li><code>log-slave-updates</code>：启用从服务器记录自己的二进制日志，以便其他从服务器可以复制它。</li>
<li><code>read-only</code>：将从服务器设置为只读模式，以防止在从服务器上进行写操作。</li>
</ul>
</li>
</ul>
</li>
<li><p>重启从服务器：</p>
<ul>
<li>保存并关闭从服务器的配置文件。</li>
<li>重启从服务器，使配置更改生效。</li>
</ul>
</li>
<li><p>在主服务器上创建用于复制的用户：</p>
<ul>
<li><p>在主服务器上登录 MySQL。</p>
</li>
<li><p>创建一个用于复制的用户，并为其授予复制相关的权限。例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;replication_user&#x27;</span>@<span class="string">&#x27;slave_ip&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;password&#x27;</span>;</span><br><span class="line"><span class="keyword">GRANT</span> REPLICATION SLAVE <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;replication_user&#x27;</span>@<span class="string">&#x27;slave_ip&#x27;</span>;</span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>&#39;replication_user&#39;@&#39;slave_ip&#39;</code>：替换为实际的从服务器 IP 地址和用户名。</li>
<li><code>&#39;password&#39;</code>：替换为实际的密码。</li>
</ul>
</li>
</ul>
</li>
<li><p>在从服务器上配置复制：</p>
<ul>
<li><p>在从服务器上登录 MySQL。</p>
</li>
<li><p>运行以下命令配置复制：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CHANGE MASTER <span class="keyword">TO</span></span><br><span class="line">  MASTER_HOST <span class="operator">=</span> <span class="string">&#x27;master_ip&#x27;</span>,</span><br><span class="line">  MASTER_USER <span class="operator">=</span> <span class="string">&#x27;replication_user&#x27;</span>,</span><br><span class="line">  MASTER_PASSWORD <span class="operator">=</span> <span class="string">&#x27;password&#x27;</span>,</span><br><span class="line">  MASTER_LOG_FILE <span class="operator">=</span> <span class="string">&#x27;mysql-bin.XXXXXX&#x27;</span>,</span><br><span class="line">  MASTER_LOG_POS <span class="operator">=</span> XXXXXX;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>&#39;master_ip&#39;</code>：替换为实际的主服务器 IP 地址。</li>
<li><code>&#39;replication_user&#39;</code> 和 <code>&#39;password&#39;</code>：替换为在主服务器上创建的复制用户的凭据。</li>
<li><code>&#39;mysql-bin.XXXXXX&#39;</code> 和 <code>XXXXXX</code>：替换为主服务器上当前二进制日志文件的名称和位置，可以使用 <code>SHOW MASTER STATUS;</code> 命令在主服务器上获取。</li>
</ul>
</li>
</ul>
</li>
<li><p>启动复制：</p>
<ul>
<li><p>在从服务器上运行以下命令启动复制：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> SLAVE;</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以使用 <code>SHOW SLAVE STATUS</code> 命令检查复制状态，并确保 <code>Slave_IO_Running</code> 和 <code>Slave_SQL_Running</code> 的值都为 <code>Yes</code>。</p>
</li>
</ul>
</li>
</ol>
</li>
<li><p>导入maven坐标</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.shardingsphere&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;sharding-jdbc-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在配置文件（application.yml）中配置读写分离规则</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">shardingsphere:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">names:</span> <span class="string">master,</span> <span class="string">slave</span></span><br><span class="line">    <span class="attr">master:</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">com.zaxxer.hikari.HikariDataSource</span></span><br><span class="line">      <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">      <span class="attr">jdbc-url:</span> <span class="string">jdbc:mysql://121.41.55.70:3306/test?useSSL=false&amp;useUnicode=true&amp;serverTimezone=Asia/Shanghai&amp;characterEncoding=utf8&amp;zeroDateTimeBehavior=convertToNull&amp;allowPublicKeyRetrieval=true&amp;allowMultiQueries=true&amp;rewriteBatchedStatements=true&amp;useAffectedRows=true</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">secretforSYP999</span></span><br><span class="line">      <span class="comment"># 从机数据源</span></span><br><span class="line">    <span class="attr">slave:</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">com.zaxxer.hikari.HikariDataSource</span></span><br><span class="line">      <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">      <span class="attr">jdbc-url:</span> <span class="string">jdbc:mysql://localhost:3306/test?useSSL=false&amp;useUnicode=true&amp;serverTimezone=Asia/Shanghai&amp;characterEncoding=utf8&amp;zeroDateTimeBehavior=convertToNull&amp;allowPublicKeyRetrieval=true&amp;allowMultiQueries=true&amp;rewriteBatchedStatements=true&amp;useAffectedRows=true</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">secretforSYP999</span></span><br><span class="line">  <span class="attr">masterslave:</span></span><br><span class="line">    <span class="attr">load-balance-algorithm-type:</span> <span class="string">round_robin</span> <span class="comment"># 轮询</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">dataSource</span></span><br><span class="line">    <span class="attr">master-data-source-name:</span> <span class="string">master</span></span><br><span class="line">    <span class="attr">slave-data-source-names:</span> <span class="string">slave</span></span><br><span class="line">  <span class="attr">props:</span></span><br><span class="line">    <span class="attr">sql:</span></span><br><span class="line">      <span class="attr">show:</span> <span class="literal">true</span> <span class="comment">#开启SQL显示，默认false</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在配置文件中配置允许bean定义覆盖配置项</p>
<p>作用是防止项目启动时，shardingJDBC和Druid创建dataSource的bean对象时冲突，导致项目启动失败。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">main:</span></span><br><span class="line">        <span class="attr">allow-bean-definition-overriding:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>为了保证主从库间的事务一致性，避免跨服务的分布式事务，ShardingSphere-JDBC的主从模型中，事务中的数据读写均用主库。</p>
<p>即： 不添加@Transactional：insert对主库操作，select对从库操作<br>            添加@Transactional：则insert和select均对主库操作</p>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ul>
<li><p>useAffectedRows&#x3D;true</p>
<p>useAffectedRows&#x3D;true时, update返回值为实际更新行数; </p>
<p>useAffectedRows&#x3D;false时, update返回值为where条件匹配的行数</p>
</li>
<li><p>max_connections</p>
<p>最大并发数，默认151，最大16384（2^14）</p>
</li>
</ul>
<h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><p>Spring 是一款开源的轻量级 Java 开发框架，可以帮助我们简化应用开发、降低组件间的耦合性。</p>
<p>Spring框架包含众多模块，如Core、Testing、Data Access、Web Servlet（Spring MVC）等，其中Core是整个Spring框架的核心模块。Core模块提供了IoC容器、AOP功能、数据绑定、类型转换等一系列的基础功能，而这些功能以及其他模块的功能都是建立在IoC和AOP之上的，所以IoC和AOP是Spring框架的核心；Testing模块集成了Junit、Mockito等，让我们可以很方便的进行单元测试；Data Access模块可以简化对数据库的访问、事务管理等；</p>
<h3 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h3><p>IoC（Inversion of Control）是控制反转的意思，这是一种面向对象编程的设计思想。在不采用这种思想的情况下，当我们要使用对象时，需要手动new一个，自己去维护对象与对象之间的依赖关系，很容易造成对象之间的耦合度过高，在一个大型的项目中这十分的不利于代码的维护。控制反转就是把对象的实例化和管理交给IoC容器，让它帮我们维护对象与对象之间的依赖关系，降低对象之间的耦合度（对象间直接耦合变成都依赖于IOC容器）。</p>
<p>IoC是通过DI（Dependency Injection，即依赖注入，体现开闭原则）来实现的。而实现依赖注入的关键是IoC容器，它的本质就是一个工厂。</p>
<p>在具体的实现中，主要由三种注入方式：</p>
<ol>
<li><p>构造方法注入</p>
<p>就是被注入对象可以在它的构造方法中声明依赖对象的参数列表，让外部知道它需要哪些依赖对象。然后，IoC Service Provider会检查被注入的对象的构造方法，取得它所需要的依赖对象列表，进而为其注入相应的对象。构造方法注入方式比较直观，对象被构造完成后，即进入就绪状态，可以马上使用。</p>
</li>
<li><p>setter方法注入（注解加载setter方法上）</p>
<p>通过setter方法，可以更改相应的对象属性。所以，当前对象只要为其依赖对象所对应的属性添加setter方法，就可以通过setter方法将相应的依赖对象设置到被注入对象中。setter方法注入虽不像构造方法注入那样，让对象构造完成后即可使用，但相对来说更宽松一些， 可以在对象构造完成后再注入。</p>
</li>
<li><p>基于 field 注入</p>
<p>所谓基于 field 注入，就是在bean的变量上使用注解进行依赖注入。本质上是通过反射的方式直接注入到field。</p>
</li>
</ol>
<blockquote>
<p>为什么spring建议使用构造器注入来注入所有必需的依赖，使用 Setter 方法注入来注入其他属性。</p>
<ol>
<li>可以保证依赖不为空。如果依赖对象无法注入，启动（实例化）的时候就会发现错误，避免在对象使用时出现空指针异常等问题。字段注入只有在调用的时候才会发现为空。</li>
<li>可以注入 final 修饰的属性。字段注入不能注入 final 修饰的属性，因为 final 属性必须在声明时或构造函数或初始化块中被初始化，而字段注入是在实例化之后的属性赋值阶段进行的，因此无法满足 final 属性的初始化要求。</li>
</ol>
</blockquote>
<ul>
<li><p>IoC容器的种类</p>
<p>Spring主要提供了两种类型的容器：BeanFactory和ApplicationContext。</p>
<ul>
<li><p>BeanFactory：Spring <strong>Bean容器的顶级接口</strong>，它是一个工厂模式的实现，负责创建、配置和管理 bean 对象。它是 Spring IoC 容器的核心接口，提供了获取 bean 的方法，例如 <code>getBean()</code>。如果没有特殊指定，默认采用<strong>延迟初始化</strong>策略。只有当客户端对象需要访问容器中的某个受管对象的时候，才对该受管对象进行初始化以及依赖注入操作。所以，相对来说，容器启动初期速度较快，所需要的资源有限。对于资源有限，并且功能要求不是很严格的场景，BeanFactory是比较合适的IoC容器选择。</p>
<ul>
<li><p>FactoryBean</p>
<p>FactoryBean（工厂方法模式和装饰模式）是一个<strong>工厂Bean</strong>，它是一个接口，主要的功能是<strong>动态生成某一个类型的Bean的实例</strong>，也就是说，我们可以自定义一个Bean并且加载到IOC容器里面。</p>
<p>它里面有一个重要的方法叫<code>getObject()</code>，这个方法里面就是用来实现动态构建Bean的过程。</p>
</li>
</ul>
</li>
<li><p>ApplicationContext：它是在BeanFactory的基础上构建的，是相对比较高级的容器实现，除了拥有BeanFactory的所有支持，ApplicationContext还提供了其他高级特性，比如事件发布、国际化信息支持等。ApplicationContext所管理的对象，在该类型容器启动之后，默认全部初始化并绑定完成。所以，相对于BeanFactory来说，ApplicationContext要求更多的系统资源，同时，因为在启动时就完成所有初始化，容 器启动时间较之BeanFactory也会长一些。在那些系统资源充足，并且要求更多功能的场景中，ApplicationContext类型的容器是比较合适的选择。</p>
</li>
</ul>
</li>
<li><p>Spring是如何管理Bean的？</p>
<p>Bean 指的是那些被 IoC 容器所管理的对象。Spring通过IoC容器来管理Bean，我们可以通过XML配置或者注解配置，来指导IoC容器对Bean的管理。</p>
<p>以下是管理Bean时常用的一些注解：</p>
<ul>
<li><p>@ComponentScan用于声明扫描策略，通过它的声明，容器就知道要扫描哪些包下带有声明的类，也可以知道哪些特定的类是被排除在外的。</p>
</li>
<li><p>@Component、@Repository、@Service、@Controller用于声明Bean，它们的作用一样，但是语义不同。@Component用于声明通用的Bean，@Repository用于声明DAO层的Bean，@Service用于声明业务层的Bean，@Controller用于声明视图层的控制器Bean，被这些注解声明的类就可以被容器扫描并创建。本质上都是component，区分开结构更清晰</p>
</li>
<li><p>@Autowired、@Qualifier用于注入Bean，即告诉容器应该为当前属性注入哪个Bean。其中，@Autowired是按照Bean的类型进行匹配的，如果这个属性的类型具有多个Bean，就可以通过@Qualifier指定Bean的名称，以消除歧义。</p>
</li>
<li><p>@Scope用于声明Bean的作用域，默认情况下Bean是单例的，即在整个容器中这个类型只有一个实例。可以通过@Scope注解指定prototype值将其声明为多例的，也可以将Bean声明为session级作用域、request级作用域等等，但最常用的还是默认的单例模式。</p>
</li>
<li><p>@PostConstruct、@PreDestroy用于声明Bean的生命周期。其中，被@PostConstruct修饰的方法将在Bean实例化后被调用，@PreDestroy修饰的方法将在容器销毁前被调用。</p>
</li>
</ul>
</li>
<li><p>spring怎么知道要创建哪些bean对象？</p>
<p>xml和注解中定义了bean的信息</p>
</li>
<li><p>@Component 和 @Bean 的区别是什么？</p>
<ul>
<li><p><code>@Component</code> 注解作用于类。<code>@Component</code>通常是通过类路径扫描来自动侦测以及自动装配到 Spring 容器中（我们可以使用 <code>@ComponentScan</code> 注解定义要扫描的路径从中找出标识了需要装配的类自动装配到 Spring 的 bean 容器中）。</p>
</li>
<li><p><code>@Bean</code> 注解而作用于方法。我们在标有该注解的方法中定义产生这个bean的逻辑，告诉Spring这个方法将会返回一个对象，这个对象要注册为Spring IOC容器中的bean。</p>
</li>
<li><p><code>@Bean</code> 注解比 <code>@Component</code> 注解的自定义性更强，而且很多地方我们只能通过 <code>@Bean</code> 注解来注册 bean。比如当我们引用<strong>第三方库中的类需要装配到 <code>Spring</code>容器时</strong>，则只能通过 <code>@Bean</code>来实现。</p>
</li>
</ul>
</li>
<li><p>@Autowired和@Resource注解有什么区别？</p>
<p>都用来注入bean。</p>
<ol>
<li>@Autowired是Spring提供的注解，@Resource是JDK提供的注解。</li>
<li>@Autowired是只能按类型注入，默认情况下它要求依赖对象必须存在，如果允许null值，可以设置它required属性为false。如果我们想使用按名称装配，可以结合@Qualifier注解一起使用。（也可通过变量名，但不推荐）</li>
<li>@Resource默认按名称注入，也支持按类型注入。@Resource有两个中重要的属性：name和type。如果没有指定name属性，当注解标注在字段上，即默认取字段的名称作为bean名称寻找依赖对象；当注解标注在属性的setter方法上，即默认取属性名作为bean名称寻找依赖对象。如果按照默认的名称仍然找不到依赖对象时， @Resource注解会回退到按类型装配。但一旦指定了name属性，就只能按名称装配了。</li>
<li>作用范围：都可以作用于字段或setter方法；Resource不能作用于构造器</li>
</ol>
</li>
<li><p>Bean 的作用域有哪些?</p>
<p>Spring 中 Bean 的作用域通常有下面几种：</p>
<ul>
<li><p><strong>singleton</strong> : IoC 容器中只有唯一的 bean 实例。Spring 中的 bean 默认都是单例的，且不是线程安全的。</p>
<p>如果单例的Bean是一个无状态的Bean，即线程中的操作不会对Bean的成员执行查询以外的操作，那么这个单例的Bean是线程安全的。</p>
<p>实现线程安全：在类中定义一个 <code>ThreadLocal</code> 成员变量，将需要的可变成员变量保存在 <code>ThreadLocal</code> 中</p>
<p>使用单例模式可以减少对象的创建和销毁的开销。</p>
</li>
<li><p><strong>prototype</strong> : 原型模式。每次获取都会创建一个新的 bean 实例。需要注意的是，当容器创建了 Bean 的实例后，Bean 的实例就交给客户端代码管理，Spring 容器将不再跟踪其生命周期。</p>
</li>
<li><p><strong>request</strong> （仅 Web 应用可用）: 每一次 HTTP 请求都会产生一个新的 bean（请求 bean），该 bean 仅在当前 HTTP request 内有效。</p>
</li>
<li><p><strong>session</strong> （仅 Web 应用可用） : 每一次来自新 session 的 HTTP 请求都会产生一个新的 bean（会话 bean），该 bean 仅在当前 HTTP session 内有效。</p>
</li>
<li><p><strong>application&#x2F;global-session</strong> （仅 Web 应用可用）：每个 Web 应用在启动时创建一个 Bean（应用 Bean），该 bean 仅在当前应用启动时间内有效。</p>
</li>
<li><p><strong>websocket</strong> （仅 Web 应用可用）：每一次 WebSocket 会话产生一个新的 bean。</p>
</li>
</ul>
</li>
<li><p>bean的生命周期</p>
<p>大致分为实例化、属性赋值、初始化和销毁四个阶段：</p>
<ul>
<li>实例化：解析配置文件得到bean的定义，通过反射实例化对象</li>
<li>属性赋值：通过set方法设置对象的属性</li>
<li>初始化：<ol>
<li>如果实现了beanNameAware接口等aware接口，就调用对应的set方法；</li>
<li>调用实现了 BeanPostProcessor 接口的类 的<code>postProcessBeforeInitialization()</code> 方法（对所有bean）</li>
<li>如果有@PostConstruct标注的方法，就执行；</li>
<li>如果Bean 实现了<code>InitializingBean</code>接口，执行<code>afterPropertiesSet()</code>方法。</li>
<li>如果 配置了 initMethod ，执行指定的初始化方法。</li>
<li>如果有和加载这个 Bean 的 Spring 容器相关的 <code>BeanPostProcessor</code> 对象，执行<code>postProcessAfterInitialization()</code> 方法（对所有bean）</li>
</ol>
</li>
<li>销毁<ol>
<li>如果有@PreDestroy标注的方法，就执行</li>
<li>如果 Bean 实现了 <code>DisposableBean</code> 接口，执行 <code>destroy()</code> 方法。</li>
<li>如果配置了destroyMethod ，执行指定的方法。</li>
</ol>
</li>
</ul>
</li>
<li><p>怎么获取bean</p>
<ol>
<li><p>使用注解来自动装配Bean</p>
</li>
<li><p>使用ApplicationContext获取Bean</p>
<p>ApplicationContext是Spring Framework中的核心接口，其提供了访问Bean工厂的方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">public class Application &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ApplicationContext context = SpringApplication.run(Application.class, args) / ApplicationContextProvider.getApplicationContext();</span><br><span class="line">        UserService userService= context.getBean(UserService.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意事项：</p>
<ul>
<li>使用ApplicationContext获取Bean对象必须在SpringBoot启动类上添加@ComponentScan注解。</li>
<li>使用ApplicationContext获取Bean对象时，Bean的作用域必须为单例（Singleton）,否则会出现Bean创建多份的情况。</li>
</ul>
</li>
<li><p><strong>使用@Import注解</strong>：在配置类上使用@Import注解，将其他配置类（普通bean也行）导入当前配置类中，从而将其管理的 Bean 一起注册到 Spring 容器中。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import(&#123;OtherConfig.class, AnotherConfig.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="comment">// configuration</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>常用钩子接口</p>
<ol>
<li><strong>InitializingBean 和 DisposableBean</strong>：<ul>
<li>InitializingBean接口包含afterPropertiesSet()方法，当Bean的所有属性被设置之后，Spring容器会调用这个方法。</li>
<li>DisposableBean接口包含destroy()方法，当Bean被销毁之前，Spring容器会调用这个方法。</li>
</ul>
</li>
<li><strong>BeanPostProcessor</strong>：<ul>
<li>BeanPostProcessor接口允许在Bean初始化前后进行自定义处理。它包括postProcessBeforeInitialization()和postProcessAfterInitialization()两个方法，允许开发人员在Bean初始化前后执行自定义逻辑。</li>
</ul>
</li>
<li><strong>BeanFactoryPostProcessor</strong>：<ul>
<li>BeanFactoryPostProcessor接口允许在Bean工厂加载Bean定义之后，在实例化Bean之前对Bean定义进行修改。通过实现该接口，可以在Spring容器加载Bean定义后对其进行自定义处理。</li>
</ul>
</li>
</ol>
</li>
<li><p>配置参数怎么传递给bean</p>
<ul>
<li><p>@Value注解结合spel（${}）</p>
</li>
<li><p>以对象形式注入</p>
<p>假设有一个实体类<code>PoolProperties</code>，类上加了注解<code>@ConfigurationProperties(prefix = &quot;arcsoft.pool&quot;)</code></p>
<p>配置类（@Configuration）加上注解<code>@EnableConfigurationProperties(PoolProperties.class)</code></p>
</li>
</ul>
</li>
<li><p>怎么解决循环依赖？</p>
<p>先说一下循环依赖的问题。如果两个Bean A和B发生循环依赖，在属性赋值阶段A需要去注入B，就会先去创建B。B在属性赋值的时候也需要A已经创建完成。这就导致这两个Bean都无法完成属性赋值。</p>
<p>Spring用三级缓存解决循环依赖问题。</p>
<ul>
<li><p>第一级缓存 singletonObjects ，已完成初始化的Bean对象</p>
</li>
<li><p>第二级缓存 earlySingletonObjects ，已经实例化，但未完成属性赋值的Bean</p>
</li>
<li><p>第三级缓存 singletonFactories ，存放bean的工厂，getObject的时候会实例化一个bean对象</p>
</li>
</ul>
<p>假设A 和 B 产生循环依赖了。A实例化后，如果A是单例、允许循环依赖，就会在三级缓存里注册一个A的单例工厂。属性赋值阶段要去注入B，会依次去三级缓存里找B，没找到就去创建B。</p>
<p>B在属性赋值阶段的时候要注入A，他就会在三级缓存里找到A的单例工厂，通过工厂getObject方法，获取到A（此时的A仅仅创建出来，处于早期的状态，不是一个完整的Bean，但是可能被代理了），然后将获取到的A放入二级缓存 ，并且将A的工厂从三级缓存移除。然后把获取到的A注入B，然后B继续执行后面的属性赋值和初始化流程。B初始化完之后，就把自己放入一级缓存，然后返回给A，A就能完成对B的依赖注入。然后A继续执行，等A初始化完成之后，会把singletonFactories 和earlySingletonObjects 缓存清空，在singletonObjects 中放入自己成熟的bean。这样就解决了循环依赖的问题。</p>
<p>参考：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/438247718">https://www.zhihu.com/question/438247718</a></p>
<p><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="https://pics0.baidu.com/feed/64380cd7912397dd78d1dbc79c26e5bed2a287f3.jpeg@f_auto?token=3ceff5bb48ca543544496d0efcf3d4e8" alt="img"></p>
</li>
</ul>
<h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><p>AOP（Aspect Oriented Programming）是面向切面编程，它是一种编程思想，是面向对象编程（OOP）的一种补充。面向对象编程将对象的行为都封装在方法中，面向切面编程所做的就是将方法中一些跟对象行为无关的通用的业务流程（如事务处理、日志管理、权限控制）抽取出来，抽象成单独的模块，需要的时候再通过代理的方式将其织入到方法执行前后。这就减少了重复代码、降低了模块间的耦合度，使得模块中只需关注核心业务流程的实现。</p>
<p>Spring AOP基于代理模式中的动态代理。默认采用JDK 动态代理。JDK动态代理基于接口，会在程序运行期动态生成代理类，这个代理类会继承java.lang.reflect.Proxy类，同时实现被代理类的接口。如果要代理的类没有实现接口，则改为使用Cglib动态代理，让代理类去继承目标类（final类不能代理），然后重写其中目标类的方法</p>
<blockquote>
<p>注：SpringBoot2.x版本开始默认使用Cglib动态代理，但Spring用的还是JDK</p>
<p>好处：CGLib可以获取实际实现类中的注解，方便根据注解做对应处理。而JDK代理基于接口，无法获取实现类的注解。</p>
</blockquote>
<ul>
<li><p>Spring AOP不能对哪些类进行增强？</p>
<ol>
<li>Spring AOP<strong>只能对IoC容器中的Bean进行增强</strong>，对于不受容器管理的对象不能增强。</li>
<li>由于CGLib采用动态创建子类的方式生成代理对象，所以不能对final修饰的类进行代理。</li>
</ol>
</li>
<li><p>Spring AOP 和 AspectJ AOP 有什么区别？</p>
<p><strong>Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。</strong> Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。</p>
</li>
<li><p>多个切面的执行顺序？</p>
<p>1、通常使用<code>@Order</code> 注解直接定义切面顺序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 值越小优先级越高</span></span><br><span class="line"><span class="meta">@Order(3)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoggingAspect</span> <span class="keyword">implements</span> <span class="title class_">Ordered</span> &#123;</span><br></pre></td></tr></table></figure>

<p>2、实现<code>Ordered</code> 接口重写 <code>getOrder</code> 方法。</p>
</li>
</ul>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><ul>
<li><p>性能统计</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AOP + StopWatch统计方法执行时间</span></span><br><span class="line"><span class="meta">@Around(&quot;execution(* com.team.superStar.service.ArcFaceService.*(..))&quot;)</span></span><br><span class="line">	<span class="keyword">public</span> Object <span class="title function_">logAround</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">		org.springframework.util.<span class="type">StopWatch</span> <span class="variable">stopWatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">org</span>.springframework.util.StopWatch();</span><br><span class="line">		stopWatch.start();</span><br><span class="line">		<span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> joinPoint.proceed();</span><br><span class="line">		stopWatch.stop();</span><br><span class="line">		<span class="type">String</span> <span class="variable">target</span> <span class="operator">=</span> joinPoint.getSignature().getDeclaringTypeName() + <span class="string">&quot;.&quot;</span> + joinPoint.getSignature().getName();</span><br><span class="line">		System.out.println(target + <span class="string">&quot;执行时间：&quot;</span> + stopWatch.getTotalTimeMillis());</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li>日志记录</li>
<li>权限控制</li>
<li>声明式事务</li>
</ul>
<h3 id="事务-1"><a href="#事务-1" class="headerlink" title="事务"></a>事务</h3><ul>
<li><p>Spring 管理事务的方式有几种？</p>
<ul>
<li><p><strong>编程式事务</strong>：通过 <code>TransactionTemplate</code>或者 <code>TransactionManager</code> 手动编码管理事务。这种方式相对麻烦一些，但是好在更为灵活，我们可以将事务管理的范围控制的更为精确（声明式事务是方法级）。</p>
</li>
<li><p><strong>声明式事务</strong>：在 XML 配置文件中配置或者直接基于注解 : 实际是通过 AOP 实现（基于<code>@Transactional</code> 的全注解方式使用最多）给方法加上了<code>Transactional</code>注解的话，这个方法执行的所有<code>sql</code>会被放在一个事务中。如果不加<code>Transactional</code>，每条<code>sql</code>会开启一个单独的事务，中间被其它事务改了数据，都会实时读取到最新值。</p>
<p>原理：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/Xianhuii/p/17102828.html">https://www.cnblogs.com/Xianhuii/p/17102828.html</a></p>
</li>
</ul>
</li>
<li><p>@Transactional作用范围</p>
<ol>
<li><strong>方法</strong>：推荐将注解使用于方法上，不过需要注意的是：<strong>该注解只能应用到 public 方法上（动态代理的原因），否则不生效。</strong></li>
<li>类<strong>：如果这个注解使用在类上的话，表明该注解对该类中所有的 public 方法都生效。</strong></li>
<li>接口：不推荐在接口上使用。</li>
</ol>
</li>
<li><p><strong><code>@Transactional</code> 的常用配置参数</strong></p>
<table>
<thead>
<tr>
<th align="left">属性名</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">propagation</td>
<td align="left">事务的传播行为，默认值为 REQUIRED</td>
</tr>
<tr>
<td align="left">isolation</td>
<td align="left">事务的隔离级别，默认值采用 DEFAULT</td>
</tr>
<tr>
<td align="left">timeout</td>
<td align="left">事务的超时时间，默认值为-1（不会超时）。如果超过该时间限制但事务还没有完成，则自动回滚事务。</td>
</tr>
<tr>
<td align="left">readOnly</td>
<td align="left">指定事务是否为只读事务，默认值为 false。</td>
</tr>
<tr>
<td align="left">rollbackFor</td>
<td align="left">用于指定能够触发事务回滚的异常类型，并且可以指定多个异常类型。</td>
</tr>
</tbody></table>
</li>
<li><p>事务传播方式</p>
<p><strong>事务传播行为是为了解决业务层方法之间嵌套调用时当前事务如何传播到被嵌套调用的业务方法中</strong>。</p>
<table>
<thead>
<tr>
<th>事务传播类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>PROPAGATION_REQUIRED</td>
<td>如果当前没有事务，则新建一个事务；如果已存在一个事务，则加入到这个事务中。这是最常见的选择。</td>
</tr>
<tr>
<td>PROPAGATION_SUPPORTS</td>
<td>支持当前事务，如果当前没有事务，则以非事务方式执行。</td>
</tr>
<tr>
<td>PROPAGATION_MANDATORY</td>
<td>使用当前的事务，如果当前没有事务，则抛出异常。</td>
</tr>
<tr>
<td>PROPAGATION_REQUIRES_NEW</td>
<td>新建事务，如果当前存在事务，则把当前事务挂起。</td>
</tr>
<tr>
<td>PROPAGATION_NOT_SUPPORTED</td>
<td>以非事务方式执行操作，如果当前存在事务，则把当前事务挂起。</td>
</tr>
<tr>
<td>PROPAGATION_NEVER</td>
<td>以非事务方式执行操作，如果当前存在事务，则抛出异常。</td>
</tr>
<tr>
<td>PROPAGATION_NESTED</td>
<td>如果当前存在事务，则在嵌套事务内执行；如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。</td>
</tr>
</tbody></table>
</li>
<li><p>Spring事务隔离级别</p>
<p><strong><code>DEFAULT</code></strong> :使用后端数据库默认的隔离级别，MySQL 默认采用的 <code>REPEATABLE_READ</code> 隔离级别，Oracle 默认采用的 <code>READ_COMMITTED</code> 隔离级别。</p>
<p><strong>READ_UNCOMMITTED、READ_COMMITTED、REPEATABLE_READ、SERIALIZABLE</strong></p>
</li>
<li><p>@Transactional(rollbackFor &#x3D; Exception.class)注解了解吗？</p>
<p><code>Exception</code> 分为运行时异常 <code>RuntimeException</code> 和非运行时异常。</p>
<p>当 <code>@Transactional</code> 注解作用于类上时，该类的所有 public 方法将都具有该类型的事务属性，同时，我们也可以在方法级别使用该标注来覆盖类级别的定义。如果类或者方法加了这个注解，那么这个类里面的方法抛出异常，就会回滚，数据库里面的数据也会回滚。</p>
<p>在 <code>@Transactional</code> 注解中如果不配置<code>rollbackFor</code>属性,那么事务只会在遇到<code>RuntimeException</code>的时候才会回滚，加上 <code>rollbackFor=Exception.class</code>,可以让事务在遇到非运行时异常时也回滚</p>
</li>
<li><p>事务失效</p>
<ul>
<li><p>数据库底层不支持事务</p>
<p>Spring 事务是业务层的事务，其底层还是依赖于数据库本身的事务支持。如MyISAM引擎不支持。</p>
</li>
<li><p>类不受 Spring管理</p>
<p>被 <code>@Transactional</code> 注解的方法所在的类必须被 Spring 管理，否则不生效（基于Spring AOP）；</p>
</li>
<li><p>自调用：调用类内部的 @Transactional 方法，不会经过 Spring 的代理类。默认只有在外部调用事务才会生效。</p>
<p>解决：</p>
<ol>
<li>将两个方法合并为一个方法，用@Transactional修饰。</li>
<li>将被调用的方法放到另一个被Spring管理的类中，用实例对象调用，</li>
<li>用@Autowired在本类中注入本类实例，再用注入的实例对象调用该方法。</li>
</ol>
</li>
<li><p>异常被业务代码 catch，又没有手动抛出，则不会触发回滚</p>
</li>
<li><p>事务方法不是 public</p>
</li>
</ul>
</li>
</ul>
<h3 id="设计模式-1"><a href="#设计模式-1" class="headerlink" title="设计模式"></a>设计模式</h3><ul>
<li><strong>代理设计模式</strong> : Spring AOP 功能的实现。</li>
<li><strong>单例设计模式</strong> : Spring 中的 Bean 默认都是单例的（也可设置原型模式prototype）。</li>
<li><strong>观察者模式:</strong> Spring 事件驱动模型就是观察者模式很经典的一个应用。如ApplicationListener。</li>
<li><strong>模板方法模式</strong> : Spring 中 <code>jdbcTemplate</code>、<code>redisTemplate</code> 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。</li>
<li><strong>工厂设计模式</strong> : 简单工厂 <code>BeanFactory</code>、工厂方法<code>FactoryBean</code></li>
</ul>
<p>没有Spring怎么开发？</p>
<p>没有Spring框架之前，所有的javaWEB开发都是非常繁琐的，且十分冗余，哪里需要实例化对象，就直接new一个处理，同时还需要一个一个set属性值，或者不想满项目中都是new的话，自己实现一个单例工厂来创建获取，但是这种类太多了，那么就需要更多的单例工厂。通过Spring可以统一管理这些对象。</p>
<p>以前的Servlet开发需要手动实现javax.servlet.Servlet,一般项目都有很多功能，每一个功能类都对应一个servlet类，于是就有很多重复的代码，比如service,init,destroy等等.还要在配置文件中加入很多servletMapping。</p>
<h2 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h2><ul>
<li><p>拦截器和过滤器的区别？</p>
<ul>
<li><p><strong>出身不同</strong>：过滤器实现的是 <code>javax.servlet.Filter</code> 接口，是 Java Servlet 规范的一部分；要依赖于Tomcat等Servlet容器，导致它只能在web程序中使用；拦截器是一个Spring组件，并由Spring容器管理，不依赖于Tomcat等Servlet容器，是可以单独使用的。</p>
</li>
<li><p><strong>触发时机不同</strong>：<strong>请求的执行顺序是：请求进入容器 &gt; 进入过滤器 &gt; 进入 Servlet &gt; 进入拦截器 &gt; 执行控制器（Controller）</strong>。拦截器加载的时间点在springcontext之前</p>
</li>
<li><p><strong>实现方式不同</strong>：过滤器基于责任链模式，当前过滤器逻辑处理完成就通过调用 FilterChain 对象的 doFilter 方法将请求传递给下一个过滤器，所有过滤器都通过才会把请求交给servlet。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">【Filter】一般用于Servlet处理之前做一些前置的校验，每个Filter都有自己的职责和逻辑。</span><br><span class="line">调用filter时，需要传入当前filterChain的引用，来告诉filter当前执行的是哪一个filterChain。</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Filter</span> &#123;    </span><br><span class="line">    <span class="comment">//初始化方法    </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException;    </span><br><span class="line">    <span class="comment">//处理逻辑，    </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response,            FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException;    </span><br><span class="line">    <span class="comment">//生命周期销毁    </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line">【FilterChain】是由多个Filter组成的链条，如果在链上的filter校验通过或处理完成，那么调用<span class="string">&quot;chain.doFilter(request, response)&quot;</span>就可以让下一个filter继续执行逻辑直到filterChain结束</span><br></pre></td></tr></table></figure>

<p><strong>拦截器是基于动态代理（底层是反射）实现的</strong>，可以在Controller执行前后增加一些额外处理</p>
</li>
<li><p><strong>使用场景不同</strong>：因为拦截器更接近业务系统（Servlet执行后），所以<strong>拦截器主要用来实现项目中的业务判断的</strong>，比如：登录判断、权限判断、日志记录等业务。而<strong>过滤器通常是用来实现通用功能过滤的</strong>，比如：对请求URL做限制、敏感词过滤、对请求数据做字符转换、字符集编码设置、响应数据压缩等与详细业务不相关的请求处理都可以用过滤器来做。</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>幂等性</p>
<p>幂等这个概念，是一个数学上的概念，即：f……(f(f(x))) &#x3D; f(x)。用在计算机领域，指的是系统里的接口或方法对外的一种承诺，使用相同参数对同一资源重复调用某个接口或方法的结果与调用一次的结果相同。</p>
<p><strong>业务上的一次或多次请求，最终的处理结果是一致的，即：在一定时间内，服务的幂等其实就是请求的幂等。</strong></p>
<p>实现方法：</p>
<ul>
<li><p>token（防止重复提交）</p>
<p>进入页面时，从服务器获取token，在服务器端把token进行存储（比如存入redis，注意过期时间），提交时把token带到服务器端进行验证；常见的处理流程如下：</p>
<p>后端验证token通过，将其删除。后面的相同请求发现没有token就不会再执行。</p>
<p><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="https://s2.loli.net/2023/07/19/8Yo2mIhWSKiPce6.png" alt="token幂等"></p>
</li>
</ul>
</li>
</ul>
<h3 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h3><ul>
<li><p>什么是MVC？</p>
<p>MVC是一种设计模式，在这种模式下软件被分为三层，即Model（模型）、View（视图）、Controller（控制器）。Model代表的是数据，View代表的是用户界面，Controller代表的是数据的处理逻辑，它是Model和View这两层的桥梁。将软件分层的好处是，可以将对象之间的耦合度降低，便于代码的维护。</p>
<p>DAO是Data Access Object的缩写，即数据访问对象，在项目中它通常作为独立的一层，专门用于访问数据库。</p>
</li>
<li><p>Spring MVC 的核心组件有哪些？</p>
<ul>
<li><p><strong><code>DispatcherServlet</code><strong>：</strong>核心的中央处理器</strong>，负责接收请求、分发，并给予客户端响应。</p>
</li>
<li><p><strong><code>HandlerMapping</code><strong>：</strong>处理器映射器</strong>，根据 uri 去匹配查找能处理的 <code>Handler</code> ，并会将请求涉及到的拦截器和 <code>Handler</code> 一起封装。</p>
</li>
<li><p><strong><code>HandlerAdapter</code><strong>：</strong>处理器适配器</strong>，根据 <code>HandlerMapping</code> 找到的 <code>Handler</code> ，适配执行对应的 <code>Handler</code>；</p>
</li>
<li><p><strong><code>Handler</code><strong>：</strong>请求处理器</strong>，处理实际请求的处理器。</p>
</li>
<li><p><strong><code>ViewResolver</code><strong>：</strong>视图解析器</strong>，根据 <code>Handler</code> 返回的逻辑视图 &#x2F; 视图，解析并渲染真正的视图，并传递给 <code>DispatcherServlet</code> 响应客户端</p>
</li>
</ul>
</li>
<li><p>Spring MVC工作流程</p>
<ol>
<li>客户端发出一个HTTP请求，Web应用服务器接收到这个请求。如果匹配DispatcherServlet的请求映射路径，则Web容器将该<strong>请求转交给DispatcherServlet处理</strong>。</li>
<li>DispatcherServlet接收到这个请求后，将<strong>根据请求的信息（包括URL、HTTP方法、请求报文头、请求参数、Cookie等）及HandlerMapping的配置找到处理请求的处理器（Handler）</strong>。</li>
<li>当DispatcherServlet找到对应当前请求的Handler后，<strong>通过HandlerAdapter对Handler进行封装，再以统一的适配器接口调用Handler</strong>。HandlerAdapter是Spring MVC框架级接口，顾名思义，HandlerAdapter是一个适配器，它用统一的接口对各种Handler方法进行调用。</li>
<li>Handler完成业务逻辑的处理后，将<strong>返回一个ModelAndView给DispatcherServlet</strong>，ModelAndView包含了视图逻辑名和模型数据信息。</li>
<li>ModelAndView中包含的是“逻辑视图名”而非真正的视图对象，<strong>DispatcherServlet借由视图解析器ViewResolver完成逻辑视图名到真实视图对象View的解析工作</strong>。</li>
<li>当得到真实的视图对象View后，<strong>DispatcherServlet就把ModelAndView中的模型（Model）数据填充到视图中</strong>。</li>
<li>把 <code>View</code> 返回给请求者（浏览器）。最终客户端得到的响应消息可能是一个普通的HTML页面，也可能是一个XML或JSON串，甚至是一张图片或一个PDF文档等不同的媒体形式。</li>
</ol>
</li>
<li><p>说一说你知道的Spring MVC注解</p>
<ul>
<li><p>@RequestMapping（GetMapping、PostMapping）：</p>
<p>作用：处理请求地址映射的，也就是说将其中的处理器方法映射到url路径上。</p>
<p>属性：</p>
<ul>
<li><p>method：是让你指定请求的method的类型，比如常用的有get和post。</p>
</li>
<li><p>value：是指请求的实际地址，如果是多个地址就用{}来指定就可以啦。</p>
</li>
<li><p>params：指定request中一定要有的参数值，它才会使用该方法处理请求。</p>
</li>
</ul>
</li>
<li><p>@RequestParam：</p>
<p>作用：是将请求参数绑定到你的控制器的方法参数上，是Spring MVC中的接收普通参数的注解。</p>
<p>属性：</p>
<ul>
<li><p>value是请求参数中的名称。</p>
</li>
<li><p>required是请求参数是否必须提供参数，它的默认是true，意思是表示必须提供。</p>
</li>
</ul>
</li>
<li><p>@PathVaribale：</p>
<p>作用：该注解是用于绑定url中的占位符，但是注意，spring3.0以后，url才开始支持占位符的，它是Spring MVC支持的rest风格url的一个重要的标志。</p>
</li>
<li><p>@ResponseBody：</p>
<p>作用：如果作用在方法上，就表示该方法的返回结果是直接写入Http responsebody中，通常用来返回 JSON格式数据。</p>
</li>
<li><p>@RequestBody</p>
<p>@RequestBody 作用在形参列表上时，用于将前台发送过来固定格式的数据（xml 格式或者 json 等）封装到对应的实体对象。</p>
</li>
</ul>
</li>
<li><p>统一异常处理</p>
<p>@RestControllerAdvice加在类上，默认对所有Controller生效，也可以指定要织入的Controller类。当 <code>Controller</code> 中的方法抛出异常的时候，由被<code>@ExceptionHandler</code> 注解（可以指定要处理的异常类）修饰的方法进行处理。</p>
</li>
</ul>
<ul>
<li>接受参数三种方式<ul>
<li>用@RequestBody标注DTO</li>
<li>用@RequestParam标注参数，并指定name属性</li>
<li>用@PathVariable标注参数，并指定name属性</li>
</ul>
</li>
</ul>
<h3 id="Spring-Session"><a href="#Spring-Session" class="headerlink" title="Spring Session"></a>Spring Session</h3><p>在传统单机web应用中，一般使用tomcat&#x2F;jetty等web容器时，用户的session都是由容器管理。浏览器使用cookie中记录sessionId，容器根据sessionId判断用户是否存在会话session。这里的限制是，session存储在web容器中，被单台服务器容器管理。</p>
<p>但是网站主键演变，分布式应用和集群是趋势（提高性能）。此时用户的请求可能被负载分发至不同的服务器，此时传统的web容器管理用户会话session的方式即行不通。</p>
<p>spring-session的核心思想在于此：将session从web容器中剥离，存储在独立的存储服务器中。目前支持多种形式的session存储器：Redis、Database、MogonDB等。session的管理责任委托给spring-session承担。当request进入web容器，根据request获取session时，由spring-session负责存存储器中获取session，如果存在则返回，如果不存在则创建并持久化至存储器中。</p>
<blockquote>
<p>原理</p>
</blockquote>
<p>当请求进来的时候，SessionRepositoryFilter 会先拦截到请求，将 request 和 response 对象转换成 SessionRepositoryRequestWrapper 和SessionRepositoryResponseWrapper 。后续当第一次调用 request 的getSession方法时，会调用到 SessionRepositoryRequestWrapper 的getSession方法。</p>
<p>这个方法是被重写过的，逻辑是先从 request 的属性中查找，如果找不到；再查找一个key值是”SESSION”的 Cookie，通过这个 Cookie 拿到 SessionId 去 Redis 中查找，如果查不到，就直接创建一个RedisSession 对象，同步到 Redis 中。</p>
<p>说的简单点就是：拦截请求，将之前在服务器内存中进行 Session 创建销毁的动作，改成在 Redis 中创建。</p>
<h3 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h3><ul>
<li><p>Nginx负载均衡，其中一台挂了，还会代理过去吗</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream server_group &#123;</span><br><span class="line">    server backend1.example.com ;</span><br><span class="line">    server backend2.example.com  max_fails=3 fail_timeout=30s;</span><br><span class="line">    server backup1.example.com  backup;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="max-fails-number"><a href="#max-fails-number" class="headerlink" title="max_fails&#x3D;number"></a>max_fails&#x3D;number</h5><p>这个参数决定了多少次请求后端失败后会暂停这个业务节点，不再给它发新的请求，默认值是1。此参数需要配合fail_timeout一起用。</p>
<p>题外话：如何定义失败，有很多种类型，这里因为主要处理HTTP代理，所以更关注proxy_next_upstream。</p>
<p>proxy_next_upstream：主要定义了当服务节点出现状况时，会将请求发给其他节点，也就是定义了怎么算作业务节点失败。</p>
<h5 id="fail-timeout-time"><a href="#fail-timeout-time" class="headerlink" title="fail_timeout&#x3D;time"></a>fail_timeout&#x3D;time</h5><p>决定了当Nginx认定这个节点不可用时，暂停多久。不配置默认就是10s。</p>
<p>把上面两个参数联合起来考虑就是：当Nginx发现发送到这个节点上的请求失败了3次的时候，就会把这个节点摘除，摘除时间是30s，30s后才会再次发送请求到这个节点上。</p>
</li>
</ul>
<h3 id="幂等性"><a href="#幂等性" class="headerlink" title="幂等性"></a>幂等性</h3><p>常见幂等问题场景</p>
<ul>
<li><p>前端重复提交，多次点击，服务端收到多次请求</p>
</li>
<li><p>超时重试，调用下游服务或者依赖外部服务处理超时，或者因为网络原因导致超时</p>
</li>
<li><p>消息重复消费，使用消息中间件 pulsar、mq 等，重复消息发送，或者 ack 异常重复消费</p>
</li>
<li><p>高并发，唯一 ID 生成碰撞，重复写入，边界控制等</p>
</li>
</ul>
<p>解决方案：</p>
<ul>
<li><p>插入数据，可以借助唯一索引</p>
</li>
<li><p>通用、可靠策略：使用 UUID 或者 雪花算法生成全局唯一 ID，采用 防重表方式 实现幂等</p>
<p><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="http://oss.ripplesu.top/blog/Typora/%E9%9D%A2%E8%AF%95%E9%A2%98/640" alt="幂等方案"></p>
</li>
</ul>
<h2 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h2><ul>
<li><p>Spring、SpringMVC、SpringBoot有什么区别</p>
<ol>
<li><p>Spring 是一款开源的轻量级 Java 开发框架，可以帮助我们简化应用开发、降低组件间的耦合性。它包含众多模块，如Core、Testing、Data Access、Web Servlet等，这些模块和功能都建立在IoC和AOP两大核心的基础之上。</p>
</li>
<li><p>SpringMVC是Spring Web Servlet模块中的一部分，给予了Spring快速构建 MVC 架构的 Web 程序的能力，主要处理web开发的路径映射和视图渲染等。<br> springMvc和springBoot:</p>
</li>
<li><p>SpringBoot本质上就是Spring，但它遵循“约定优于配置”的理念，可以帮助我们快速构建一个基于Spring的项目。使用 Spring Boot避免了繁琐的XML配置，只需要很少的配置或使用默认的配置。</p>
</li>
</ol>
<p>  另外，SpringBoot还有以下优点：</p>
<ol>
<li><p>内置了Tomcat等Web服务器，无需部署War文件，打成jar包就能启动。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">tomcat:</span></span><br><span class="line">	<span class="comment"># 当所有可能的请求处理线程都在使用中时，传入连接请求的最大队列长度</span></span><br><span class="line">	<span class="attr">accept-count:</span> <span class="number">100</span></span><br><span class="line">	<span class="comment"># 服务器在任何给定时间接受和处理的最大连接数。一旦达到限制，操作系统仍然可以接受基于“acceptCount”属性的连接。</span></span><br><span class="line">	<span class="attr">max-connections:</span> <span class="number">8192</span></span><br><span class="line">		<span class="attr">threads:</span></span><br><span class="line">		<span class="comment"># 工作线程的最小数量，初始化时创建的线程数</span></span><br><span class="line">		<span class="attr">min-spare:</span> <span class="number">10</span></span><br><span class="line">		<span class="comment"># 工作线程的最大数量 io密集型建议10倍的cpu数，cpu密集型建议cpu数+1，绝大部分应用都是io密集型</span></span><br><span class="line">		<span class="attr">max:</span> <span class="number">200</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>提供了Starter，聚合了模块运行所需的依赖以及可以自动进行初始化配置，做到开箱即用。</p>
</li>
</ol>
<p>缺点：</p>
<p>​	集成度太高，屏蔽了很多细节，上手容易但难以了解底层原理</p>
</li>
<li><p>SpringBoot Starter原理</p>
<ul>
<li><p>起步依赖：其实就是将模块运行需要的依赖打包到一起（starter），可以简化依赖导入的过程。</p>
</li>
<li><p>自动配置：Starter中写@Configuration标记的配置类，类内用@Bean注解声明需要装配到IoC容器的对象，并用@Conditional注解指定生效条件；在类路径下<code>META-INF/spring.factories</code>中填写配置类的全类名。</p>
<p>自动配置过程：</p>
<ol>
<li>Spring Boot通过@EnableAutoConfiguration注解开启自动配置</li>
<li>加载所有jar包类路径下<code>META-INF/spring.factories</code>中注册的各种AutoConfiguration类</li>
<li>当某个AutoConfiguration类满足其注解@Conditional指定的生效条件（Starters提供的依赖、配置或Spring容器中是否存在某个Bean等）时，实例化该AutoConfiguration类中定义的Bean（组件等），并注入Spring容器，就可以完成依赖框架的自动配置。</li>
</ol>
</li>
<li><p>如何实现starter</p>
<ol>
<li>pom中引入相关依赖（Spring-boot-starter）</li>
<li>自动配置中流程</li>
<li>maven install安装到本地仓库</li>
</ol>
</li>
</ul>
</li>
<li><p>SpringBoot 核心注解<code>SpringBootApplication</code></p>
<p><code>@Configuration</code>、<code>@EnableAutoConfiguration</code>、<code>@ComponentScan</code> 注解的集合。</p>
<p>这三个注解的作用分别是：</p>
<ul>
<li><code>@EnableAutoConfiguration</code>：启用 SpringBoot 的自动配置机制</li>
<li><code>@Configuration</code>：允许在Spring上下文中注册额外的 bean或导入其他配置类。会将当前类内声明的一个或多个以**@Bean**注解标记的方法的实例纳入到Spring容器中，并且实例名就是方法名。</li>
<li><code>@ComponentScan</code>：注解默认会扫描启动类所在的包下所有的被<code>@Component</code> (<code>@Service</code>,<code>@Controller</code>、<code>@Repository</code>)注解标记的类，可以自定义不扫描某些 bean。</li>
</ul>
</li>
</ul>
<h4 id="自动装配"><a href="#自动装配" class="headerlink" title="自动装配"></a>自动装配</h4><p>自动装配指springBoot 在启动时会扫描外部引用 jar 包中的<code>META-INF/spring.factories</code>文件，将文件中配置的类型信息（Bean）加载到 Spring 的IoC容器。</p>
<p>SpringBoot 核心注解<code>SpringBootApplication</code>可以看做三个注解的集合，这三个注解中包括<code>@EnableAutoConfiguration</code>，用来启用 SpringBoot 的自动配置机制。</p>
<p>注解中通过import注解将 <code>AutoConfigurationImportSelector</code>类导入容器，类中有一个<code>selectImports</code>方法，该方法主要用于<strong>获取所有符合条件的类的全限定类名，这些类需要被加载到 IoC 容器中</strong>。</p>
<p><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="https://s2.loli.net/2023/08/12/NZjdpQzwIqFx3G8.png" alt="selectImports"></p>
<p>selectImports方法调用getAutoConfigurationEntry方法，</p>
<p><strong>第 1 步</strong>:</p>
<p>判断是否启用自动装配。默认<code>spring.boot.enableautoconfiguration=true</code>，可在 <code>application.properties</code> 或 <code>application.yml</code> 中设置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span> <span class="comment">//作用：将main包下的所有组件注册到容器中</span></span><br><span class="line"><span class="meta">@Import(&#123;AutoConfigurationImportSelector.class&#125;)</span> <span class="comment">//加载自动装配类 xxxAutoconfiguration</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">ENABLED_OVERRIDE_PROPERTY</span> <span class="operator">=</span> <span class="string">&quot;spring.boot.enableautoconfiguration&quot;</span>;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt;[] exclude() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    String[] excludeName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第 2 步</strong>：</p>
<p>获取<code>EnableAutoConfiguration</code>注解中的属性，即不需要的配置类<code>exclude</code> 和 <code>excludeName</code>。</p>
<p><strong>第 3 步</strong></p>
<p><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="https://s2.loli.net/2023/08/12/bcxkrteg5yaLPpB.png" alt="getAutoConfigurationEntry"></p>
<p><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="https://s2.loli.net/2023/08/12/kGTJ2p9iXHgnPML.png" alt="loadFactoryNames"></p>
<p>通过SpringFactoriesLoader类的loadFactoryNames，读取所有starter的<code>META-INF/spring.factories</code>，获取所有需要自动装配的配置类，封装到list中</p>
<p><strong>第 4 步</strong>：</p>
<p>去除重复的配置类、排除<code>EnableAutoConfiguration</code>注解中声明的不需要的配置类、去除不符合条件（Conditional注解中声明的）的配置类，然后返回所有能够自动装配的类的全限定名。</p>
<p>最后就是实例化该AutoConfiguration类中定义的Bean（组件等），并注入Spring容器，就可以完成依赖框架的自动配置。</p>
<ul>
<li>其他问题<ul>
<li>如何集成spring：引入aop和web的starter</li>
</ul>
</li>
</ul>
<h4 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h4><p>1、在springboot启动的时候会创建一个SpringApplication对象，在对象的构造方法里面会进行一些参数的初始化工作，最主要的是判断当前应用程序的类型以及设置初始化器以及监听器，并在这个过程中会加载整个应用程序的spring.factories文件，将文件中的内容放到缓存当中，方便后续获取；</p>
<p>2、SpringApplication对象创建完成之后会执行run()方法来完成整个应用程序的启动，启动的过程中有两个最主要的方法prepareContext()和refreshContext()，在这两个方法中完成了自动装配的核心功能，在run()方法里还执行了一些包括上下文对象的创建，打印banner图，异常报告期的准备等各个准备工作，方便后续进行调用；</p>
<p>3、在prepareContext()中主要完成的是对上下文对象的初始化操作，包括属性的设置，比如设置环境变量。在整个过程中有一个load()方法，它主要是完成一件事，那就是将启动类作为一个beanDefinition注册到registry，方便后续在进行BeanFactoryPostProcessor调用执行的时候，可以找到对应执行的主类，来完成对@SpringBootApplication、@EnableAutoConfiguration等注解的解析工作；</p>
<p>4、在refreshContext()方法中会进行整个容器的刷新过程，会调用spring中的refresh()方法，refresh()方法中有13个非常关键的方法，来完成整个应用程序的启动。而在自动装配过程中，会调用的关键的一个方法就是invokeBeanFactoryPostProcessors()方法，在这个方法中主要是对ConfigurationClassPostProcessor类的处理，这个类是BFPP（BeanFactoryPostProcessor）的子类，因为实现了BDRPP（BeanDefinitionRegistryPostProcessor）接口，在调用的时候会先调用BDRPP中的postProcessBeanDefinitionRegistry()方法，然后再调用BFPP中的postProcessBeanFactory()方法，在执行postProcessBeanDefinitionRegistry()方法的时候会解析处理各种的注解，包含@PropertySource、@ComponentScan、@Bean、@Import等注解，最主要的是对@Import注解的解析；</p>
<p>5、在解析@Import注解的时候，会有一个getImport()方法，从主类开始递归解析注解，把所有包含@Import的注解都解析到，然后在processImport()方法中对import的类进行分类，例如AutoConfigurationImportSelect归属于ImportSelect的子类，在后续的过程中会调用DeferredImportSelectorHandler类里面的process方法，来完成整个EnableAutoConfiguration的加载。</p>
<h4 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h4><p>Spring Boot 常用注解汇总</p>
<p>一、启动注解 @SpringBootApplication</p>
<ul>
<li><p>@SpringBootConfiguration 注解，继承@Configuration注解，主要用于加载配置文件</p>
</li>
<li><p>@EnableAutoConfiguration 注解，开启自动配置功能</p>
</li>
<li><p>@ComponentScan 注解，主要用于组件扫描和自动装配</p>
</li>
</ul>
<p>二、Controller 相关注解</p>
<ul>
<li><p>@Controller</p>
</li>
<li><p>@RestController 复合注解</p>
</li>
<li><p>@ResponseBody</p>
</li>
<li><p>@RequestBody</p>
</li>
<li><p>@RequestMapping</p>
</li>
<li><p>@GetMapping用于将HTTP get请求映射到特定处理程序的方法注解</p>
</li>
<li><p>@PostMapping用于将HTTP post请求映射到特定处理程序的方法注解</p>
</li>
</ul>
<p>三、取请求参数值</p>
<ul>
<li>@PathVariable:获取url中的数据</li>
<li>@RequestParam:获取请求参数的值</li>
<li>@RequestHeader 把Request请求header部分的值绑定到方法的参数上</li>
<li>@CookieValue 把Request header中关于cookie的值绑定到方法的参数上</li>
</ul>
<p>四、注入bean相关</p>
<ul>
<li>@Repository（DAO）</li>
<li>@Service（本质是component）</li>
<li>@Scope作用域注解</li>
<li>@Entity实体类注解</li>
<li>@Bean产生一个bean的方法</li>
<li>@Autowired 自动导入</li>
<li>@Component</li>
<li>@Lazy延迟加载bean</li>
</ul>
<p>五、导入配置文件</p>
<ul>
<li>@PropertySource注解</li>
<li>@ImportResource导入xml配置文件</li>
<li>@Import 导入额外的配置信息</li>
</ul>
<p>六、事务注解 </p>
<ul>
<li>@Transactional</li>
</ul>
<p>七、全局异常处理</p>
<ul>
<li>@ControllerAdvice 统一处理异常</li>
<li>@ExceptionHandler 注解声明异常处理方法</li>
</ul>
<h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><p>properties（键值对，&#x3D;）和yaml（key:(空格)value）优先级？properties高</p>
<p>Bootstrap 配置文件是 Spring 应用程序的<strong>启动配置</strong>文件，用于配置 Spring 环境和初始化 Spring 容器。Bootstrap 配置文件的名称通常为 bootstrap.yml 或 bootstrap.properties。Bootstrap 配置文件中可以配置一些与应用程序无关的配置项，例如数据源、缓存、消息队列等等。这些配置项可以在应用程序的任何地方使用，因为它们是在<strong>应用程序启动之前</strong>就加载和初始化好的。</p>
<p>Application 配置文件是 Spring 应用程序的业务逻辑配置文件，用于配置应用程序的各种组件和服务。Application 配置文件的名称通常为 application.yml 或 application.properties。</p>
<h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><ul>
<li><p>跨域：主要原因是浏览器的同源策略</p>
<p>实现WebMvcConfiger接口，重写addCorsMappings方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> &#123;</span><br><span class="line">    registry.addMapping(<span class="string">&quot;/**&quot;</span>)</span><br><span class="line">            .allowCredentials(<span class="literal">true</span>)</span><br><span class="line">            .allowedMethods(<span class="string">&quot;*&quot;</span>)</span><br><span class="line">            .allowedOrigins(<span class="string">&quot;*&quot;</span>)</span><br><span class="line">            .allowedHeaders(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">    <span class="built_in">super</span>.addCorsMappings(registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Spring-Security"><a href="#Spring-Security" class="headerlink" title="Spring Security"></a>Spring Security</h2><p>Spring Security 应用级别的安全主要包含两个主要部分，即登录<strong>认证</strong>（Authentication）和访问<strong>授权</strong>（Authorization），首先用户登录的时候传入登录信息，登录验证器完成登录认证并将登录认证好的信息存储到请求上下文，然后在进行其他操作，如接口访问、方法调用时，权限认证器从上下文中获取登录认证信息，然后根据认证信息获取权限信息，通过权限信息和特定的授权策略决定是否授权。</p>
<ul>
<li><code>认证</code>：验证当前访问系统的是不是本系统的用户，并且要确认具体是哪个用户</li>
<li><code>授权</code>：经过认证后判断当前用户是否有权限进行某个操作</li>
</ul>
<h3 id="RBAC"><a href="#RBAC" class="headerlink" title="RBAC"></a>RBAC</h3><p>RBAC 即基于角色的权限访问控制（Role-Based Access Control）。这是一种通过角色关联权限，角色同时又关联用户的授权的方式。</p>
<p>简单地说：<strong>一个用户可以拥有若干角色，每一个角色又可以被分配若干权限</strong>，这样就构造成“用户-角色-权限” 的授权模型。在这种模型中，用户与角色、角色与权限之间构成了多对多的关系</p>
<h2 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h2><p>MyBatis 是一个 半自动的ORM（Object Relation Mapping）框架。</p>
<p>MyBatis 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。</p>
<p><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="https://s2.loli.net/2023/07/08/wuQobYRXCPJqpAK.png" alt="mybatis层次结构"></p>
<ul>
<li><p>JDBC</p>
<p>JDBC（Java DataBase Connectivity，Java数据库链接）就是使用JAVA语言操作关系型数据库的一套API。</p>
<p><strong>本质</strong></p>
<ol>
<li>官方（sun）定义的一套<strong>操作所有关系型数据库的规则</strong>，即接口（没有提供实现类）。</li>
<li>各个数据库厂商自行去实现这套接口，所以有了数据库驱动jar包。</li>
<li>我们使用接口（JDBC）来编写通用的代码，真正执行的是驱动jar包中的实现类。</li>
</ol>
<p><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="https://s2.loli.net/2023/07/16/2Yq1yumj3SwCeGi.png" alt="JDBC"></p>
</li>
<li><p>MyBatis中的$和#有什么区别？</p>
<p>使用#设置参数时，MyBatis会创建预编译的SQL语句，即JDBC中的PreparedStatement。执行前会将<code>#&#123;&#125;</code>替换为占位符‘?’，然后在执行时依次为占位符（?）赋值，传入的参数自动加上双引号，即当成普通字符串。预编译的SQL语句执行效率高，并且可以防止注入攻击。</p>
<p>使用$设置参数时，MyBatis只是创建普通的SQL语句，即JDBC中的Statement。然后在执行SQL语句时MyBatis将参数直接拼入到SQL里。有sql注入风险。一般用于传入数据库对象，可以解决一些特殊情况下的问题。例如，有时需要根据某些列进行排序，<strong>但参与排序的字段并不确定，而是要通过前端参数传递过来，</strong>这就无法使用预编译的方式了。</p>
<ul>
<li><p>sql注入</p>
<p>现在假设我们后台的SQL语句如下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from user where username=&#x27;$&#123;username&#125;&#x27; and password=&#x27;$&#123;password&#125;&#x27;</span><br></pre></td></tr></table></figure>

<p>前端网页有两个输入框，一个是用户名输入框，另一个是密码输入框。假设用户老老实实地输入用户名为zhangsan，密码为123，那么最终生成的SQL语句如下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from user where username=&#x27;zhangsan&#x27; and password=&#x27;123&#x27;</span><br></pre></td></tr></table></figure>

<p>假设用户输入的用户名是 <code>zhangsan&#39; or 1=1 #</code>，密码则随意给了个值 111，那么最终生成的 SQL语句可能就是下面这样了：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from user where username=&#x27;zhangsan&#x27; or 1=1 #&#x27; and password=&#x27;123&#x27;</span><br></pre></td></tr></table></figure>

<p>大家知道，# 在 SQL语句中的含义是注释，#后面的SQL内容是不执行的。所以这个SQL无论怎么执行，最终都会返回true。这就是所谓的SQL注入了。</p>
</li>
</ul>
</li>
<li><p>为啥<code>mapper</code>接口能执行？</p>
<p>基于JDK动态代理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">newInstance</span><span class="params">(SqlSession sqlSession)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> MapperProxy&lt;T&gt; mapperProxy = <span class="keyword">new</span> <span class="title class_">MapperProxy</span>&lt;T&gt;(sqlSession, mapperInterface, methodCache);</span><br><span class="line">    <span class="keyword">return</span> newInstance(mapperProxy);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">protected</span> T <span class="title function_">newInstance</span><span class="params">(MapperProxy&lt;T&gt; mapperProxy)</span> &#123;</span><br><span class="line">    <span class="comment">//用JDK自带的动态代理生成映射器</span></span><br><span class="line">    <span class="keyword">return</span> (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; mapperInterface &#125;, mapperProxy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/ygy162/article/details/106459395/">https://blog.csdn.net/ygy162/article/details/106459395/</a></p>
</li>
<li><p>分页</p>
<ul>
<li><p>MyBatis的分页是内存分页还是物理分页</p>
<ul>
<li><p>Mybatis使用RowBounds对象进行分页<br>RowBounds 表面是在“所有”数据中检索数据，其实并非是一次性查询出所有数据，因为 MyBatis 是对 jdbc 的封装，在 jdbc 驱动中有一个 Fetch Size 的配置，它规定了每次最多从数据库查询多少条数据。它是针对 ResultSet 结果集执行的<strong>内存分页</strong>而非物理分页。</p>
</li>
<li><p>可以在 SQL 内直接书写带有物理分页的参数来完成物理分页功能</p>
<p>也可以使用分页插件来完成物理分页</p>
</li>
</ul>
</li>
<li><p>分页插件：PageHelper（物理分页）</p>
<p>原理：Mybatis中真正用来执行Sql语句的对象是Executor；它在初始化完成之后，会调用interceptorChain的pluginAll方法，pluginAll方法遍历所有Interceptor对象并调用其plugin方法；plugin方法其实就是调用Plugin类的静态方法wrap()基于JDK动态代理得到executor的代理对象；plugin类（实现了InvocationHandler）的invoke方法中判断是否执行的方法是否是要拦截的方法，如果是就执行Interceptor中的intercept方法，否则调用原方法。</p>
<ol>
<li>先使用PageHelper.startPage传入分页参数，该方法将分页参数放到一个ThreadLocal变量中；</li>
<li>再利用PageInterceptor这个分页拦截器拦截executor的query方法，从ThreadLocal中拿到分页的信息，如果需要分页就拼装分页SQL（limit语句等）进行分页查询；</li>
<li>执行完查询（doSelect）最后再把ThreadLocal中的东西清除掉。</li>
</ol>
</li>
</ul>
</li>
<li><p>动态sql</p>
<ul>
<li><code>&lt;if test = &quot;&quot;&gt;&lt;/if&gt;</code>满足条件拼上标签中的语句<ul>
<li>注意：test中参数不用加#{}或${}</li>
</ul>
</li>
<li><code>&lt;where&gt;&lt;/where&gt;</code> 有条件自动加上where子句</li>
<li><code>trim </code>用于insert，拼接上前后缀</li>
<li><code>set </code>用于update</li>
<li><code>&lt;choose&gt;&lt;/choose&gt;（when, otherwise）</code></li>
<li><code>&lt;foreach&gt;&lt;/foreach&gt;</code></li>
<li><code>&lt;bind/&gt;</code></li>
</ul>
</li>
<li><p>怎么把数据库中的数据映射到实体对象</p>
<p>查询结果中字段名与对象（resultType）属性名一般是一致的，或使用resultMap指定字段与属性的映射关系。</p>
<p>有了列名与属性名的映射关系后，MyBatis 通过反射创建实体对象，同时使用反射给对象的属性逐一赋值并返回。</p>
</li>
</ul>
<ul>
<li><p>怎么返回自增主键</p>
<p>xml中设置useGeneratedKeys&#x3D;”true” keyProperty&#x3D;”id（实体类表示id字段）”</p>
</li>
</ul>
<ul>
<li><p>二级缓存</p>
<p>一级缓存：</p>
<p>一级缓存存在于SqlSession的生命周期中，它默认会启用，并且不能关闭。在同一个 SqlSession（同一个事务） 中查询时，MyBatis 会把执行的方法和参数通过算法生成缓存的键值，将键值和查询结果存入一个Map对象中。如果同一个SqlSession 中执行的方法和参数完全一致，那么通过算法会生成相同的键值，当Map 缓存对象中己经存在该键值时，则会返回缓存中的对象。</p>
<p>二级缓存：</p>
<p>在MyBatis 的全局配置settings 中有一个参数cacheEnabled，这个参数是二级缓存的全局开关，默认值是true，初始状态为开启状态。</p>
<p>MyBatis 的二级缓存是和命名空间绑定的，可以被多个SQLSession共享，不同的SQLSession只要执行相同 namespace 下的 相同的sql 语句，数据查询出来先缓存在一级缓存，当事务提交后(sqlSession.commit())再缓存到二级缓存，第二次会先查二级再查一级。</p>
<p>在保证二级缓存的全局配置开启的情况下，给Mapper.xml 开启二级缓存只需要在Mapper. xml 中添加如下代码：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>映射语句文件中的所有select语句将会被缓存。</li>
<li>映射语句文件中的所有insert、update和delete语句会清空缓存。</li>
<li>MyBatis要求返回的POJO必须是可序列化的（ 要求实现Serializable接口）</li>
</ul>
<p>适用条件：</p>
<ol>
<li>namespace中查询的数据没有其他namespace会修改，否则两个namespace的缓存可能不一致</li>
<li>增删改不频繁，否则频繁清空缓存</li>
</ol>
<p>回收策略：LRU</p>
</li>
<li><p>一对一、一对多。多对多</p>
<p>联合查询：SQL 语句直接关联查询到关系表的字段，resultMap 中关系对象的映射使用 association 标签，标签中 javaType 属性指定关系对象的 java 类型，子标签配置该关系对象的属性映射。</p>
<p>嵌套查询：SQL 只查主表字段，resultMap 中关系对象的映射使用 association 标签，配置 select 属性引用嵌套查询标签，关系对象使用嵌套查询标签中的 resultMap 进行映射。</p>
<p>association 指的就是一对一，collection 指的就是一对多查询</p>
</li>
<li><p>Mapper接口怎么和xml中的sql关联</p>
<p>xml文件中，<mapper> 根标签的namespace属性需要配置成接口的全类名。</p>
<p>select等标签的id与接口中的方法绑定、parameterType绑定参数类型</p>
</li>
<li><p>why mybatis</p>
<ol>
<li>灵活性：MyBatis允许您直接编写原生的SQL语句，提供了很高的灵活性。您可以根据需要编写任何复杂的SQL，从而满足各种业务需求。</li>
<li>易于使用：MyBatis通过XML配置文件和注解，让您可以轻松地将SQL语句与Java代码分离，使得代码结构更清晰、易于维护。</li>
<li>映射简单：MyBatis提供了简单的映射方式，可以将数据库表中的字段自动映射到Java对象的属性上，降低了数据转换的复杂性。</li>
<li>良好的扩展性：MyBatis提供了丰富的插件接口，您可以通过编写自定义插件来扩展MyBatis的功能，以满足特定需求。</li>
<li>与其他框架集成：MyBatis可以与Spring、Spring Boot等流行框架无缝集成，提供更加完整的解决方案。</li>
<li>社区支持：MyBatis有一个活跃的开发者社区，为使用者提供了丰富的文档、教程和支持。这有助于在遇到问题时快速找到解决方案。</li>
</ol>
</li>
</ul>
<h3 id="批量提交的若干问题"><a href="#批量提交的若干问题" class="headerlink" title="批量提交的若干问题"></a>批量提交的若干问题</h3><p><a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=Mybatis&spm=1001.2101.3001.7020">Mybatis</a>中有两种批量插入的方式：</p>
<ol>
<li><p>动态SQL使用foreach标签进行批量插入</p>
</li>
<li><p>使用Mybatis的batch模式进行批量插入</p>
<p>注意：</p>
<ul>
<li>方法需要被spring事务管理（@Transactional）</li>
</ul>
</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/a82514921/article/details/129370033?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-129370033-blog-127187599.235%5Ev38%5Epc_relevant_sort_base3&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-129370033-blog-127187599.235%5Ev38%5Epc_relevant_sort_base3&utm_relevant_index=1">https://blog.csdn.net/a82514921/article/details/129370033?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-129370033-blog-127187599.235%5Ev38%5Epc_relevant_sort_base3&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-129370033-blog-127187599.235%5Ev38%5Epc_relevant_sort_base3&amp;utm_relevant_index=1</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(rollbackFor = Exception.class)</span> <span class="comment">// 这里回滚可以生效</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">batchInsertOrUpdateLikeRecord</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionTemplate.getSqlSessionFactory().openSession(ExecutorType.BATCH, <span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 需要rewriteBatchedStatements=true，效果是将</span></span><br><span class="line">    <span class="comment">// insert into t values();insert into t values();转换成insert into t values(),();。</span></span><br><span class="line">    <span class="type">LikeMapper</span> <span class="variable">likeMapper</span> <span class="operator">=</span> sqlSession.getMapper(LikeMapper.class);</span><br><span class="line">    <span class="comment">// 批量写数据库</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)&#123;</span><br><span class="line">        <span class="comment">// 这里不会实际执行</span></span><br><span class="line">        likeMapper.test(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        sqlSession.commit();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        <span class="comment">// 这里回滚不会生效</span></span><br><span class="line">        <span class="comment">//            sqlSession.rollback();</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="常见BUG"><a href="#常见BUG" class="headerlink" title="常见BUG"></a>常见BUG</h3><ul>
<li><p>数据库字段名和属性名对不上</p>
</li>
<li><p>元素内容必须由格式正确的字符数据或标记组成。</p>
<p>@Update等注解中，小于号（&lt;）、大于号（&gt;）需要转义，否则会视为括号</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&amp;lt; &lt;  小于号</span><br><span class="line">&amp;gt; &gt; 大于号 </span><br><span class="line">&amp;amp; &amp; 和</span><br><span class="line">&amp;apos;  ‘’单引号</span><br><span class="line">&amp;quot; “”  双引号</span><br></pre></td></tr></table></figure>
</li>
<li><p>nested exception is org.apache.ibatis.binding.BindingException: Parameter ‘xxx‘ not found。Available parameters are [arg2, arg1, arg0, param3, param1, param2]（相关问题：Mybatis多个参数怎么处理？）</p>
<p>原因：Mybatis参数映射出现问题，#{xxx}找不到对应的参数，这是因为编译器在编译时对形参变量名进行了转化，改变了形参。<br>传递JavaBean对象和单个参数不会出错，因此除了这两种情况外，传递多个非JavaBean对象或基本数据类型时要用**@Param标注形参**。</p>
<blockquote>
<p>mybatis 框架会自动创建一个 map 集合用于存储实际参数，而每个实参都会用 两个键值对进行存储.</p>
<p>如果有多个参数，依次对应arg0、arg1、arg2···，param1，param2···</p>
<p>需要注意的是，使用了 @Param 注解之后，arg0 和 arg1 失效了，但 param1 和 param2 还可以使用。</p>
<p>如果只有一个参数，MyBatis 会<strong>自动的使用唯一的那一个参数</strong>，所以，在配置SQL映射时，使用的 #{} 占位符中的占位参数名称根本就不重要！在开发时，推荐使用规范的名称，但是，从代码是否可以运行的角度来说，这个占位符中写什么都不重要！</p>
<p><strong>如果只有一个参数,并且在<if>里使用,则必须加别名.</strong></p>
</blockquote>
</li>
</ul>
<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p>Redis是基于内存的数据库，按键值对存储。Redis 内置了多种数据类型实现（比如 String、Hash、Sorted Set、Bitmap、HyperLogLog、GEO），并且对数据类型的操作都是<strong>原子性</strong>的，因为执行命令由单线程负责的。另外，Redis 还支持持久化、多种开箱即用的集群方案、Lua 脚本、发布&#x2F;订阅模式，内存淘汰机制、过期删除机制、事务（不支持原子性、回滚）等等。</p>
<ul>
<li>Redis可以用来做什么？&#x2F; 为什么用redis<ol>
<li>Redis最常用来做缓存，高性能、承载并发请求数量是MySQL的数倍，是实现分布式缓存的首先中间件；</li>
<li>Redis可以作为数据库，实现诸如点赞、关注、排行等对性能要求极高的互联网需求；</li>
<li>Redis可以作为计算工具，能用很小的代价，统计诸如PV&#x2F;UV、用户在线天数等数据；</li>
<li>Redis还有很多其他的使用场景，例如：可以实现分布式锁、限流、可以作为消息队列使用。</li>
</ol>
</li>
</ul>
<ul>
<li><p>Redis 与 Memcached <strong>共同点</strong>：</p>
<ol>
<li>都是基于内存的数据库，一般都用来当做缓存使用。</li>
<li>都有过期策略。</li>
<li>两者的性能都非常高。</li>
</ol>
<p>Redis 与 Memcached <strong>区别</strong>：</p>
<ul>
<li>Redis 支持的数据类型更丰富（String、Hash、List、Set、ZSet），而 Memcached 只支持最简单的 key-value 数据类型；</li>
<li>Redis 支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用，而 Memcached 没有持久化功能，数据全部存在内存之中，Memcached 重启或者挂掉后，数据就没了；</li>
<li>Redis 原生支持集群模式，Memcached 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；</li>
<li>Redis 支持发布订阅模型、Lua 脚本、事务等功能，而 Memcached 不支持；</li>
<li>Redis执行命令是单线程，所以非常适合做分布式锁。最佳实践：单机多实例以充分利用cpu。Memcached，是多线程，适合极高并发场景（微博说性能更高，微博内大量用了Memcached）</li>
</ul>
</li>
</ul>
<h3 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h3><ul>
<li><p>Redis如何找出大量以某一个前缀开头的key</p>
<p>scan cursor [MATCH pattern] [COUNT count]</p>
<ol>
<li>基于游标的迭代器，需要基于上一次的游标延续之前的迭代过程；</li>
<li>以0作为游标开始一次新的迭代，知道命令返回游标0完成一次遍历；</li>
<li>不保证每次执行都返回某个给定数量的元素，支持模糊查询；</li>
<li>一次返回的数量不可控，只能是大概率符合count参数；</li>
</ol>
<p>scan 0 match k1* count 10 其含义是从0开始迭代返回前缀为k1的key，并且希望一次返回10个</p>
</li>
</ul>
<ul>
<li><p>查看key的过期时间</p>
<p>redisTemplate.getExpire()、原生TTL命令</p>
</li>
<li><p>memory usage [key] 查看key的内存占用</p>
</li>
<li><p>Redis提供了多个原子性命令，用于在单个操作中执行多个操作，确保它们在执行过程中不会被其他命令中断。以下是几个常见的原子性命令：</p>
<p>SETNX：如果指定的键不存在，则设置键的值为指定值。该操作是原子性的，只在键不存在时执行。</p>
<p>GETSET：设置指定键的新值，并返回键之前的旧值。该操作是原子性的，确保其他命令在SET和GET操作中间不会干扰。</p>
<p>INCR、DECR：对指定键的整数值进行递增或递减。这两个命令都是原子性的，保证在执行过程中不会有其他命令干扰。</p>
<p>MSET、MSETNX：分别用于设置多个键值对和多个不存在的键值对。这两个命令都是原子性的，确保设置操作在执行过程中不会被其他命令中断。</p>
<p>HSET、HSETNX：用于设置哈希表中指定字段的值，并返回是否成功设置。这两个命令都是原子性的，确保设置操作在执行过程中不会被其他命令中断。</p>
<p>LPUSH、RPUSH：分别在列表的头部和尾部插入一个或多个元素。这两个命令都是原子性的，确保在执行过程中不会有其他命令干扰。</p>
</li>
</ul>
<h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p>时间复杂度 <a target="_blank" rel="noopener" href="https://coldsmog.cn/project-4/doc-117/">https://coldsmog.cn/project-4/doc-117/</a></p>
<p>基本数据类型：<strong>String（字符串），Hash（哈希），List（列表），Set（集合）、Zset（有序集合）</strong>。</p>
<p><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="https://s2.loli.net/2023/05/26/9m5QI18Grl2BuLV.png" alt="img"></p>
<ul>
<li><p>String ：SDS（Simple Dynamic String，简单动态字符串）</p>
<ul>
<li><p>常规文本或二进制数据（比如 session、token、序列化后的对象、图片的路径）的缓存；</p>
</li>
<li><p>计数比如用户单位时间的请求数（简单限流可以用到）、页面单位时间的访问数；</p>
</li>
<li><p>分布式锁(利用 <code>SETNX key value</code> 命令可以实现一个最简易的分布式锁)；</p>
<ul>
<li>如果 key 不存在，则显示插入成功，可以用来表示加锁成功；</li>
<li>如果 key 存在，则会显示插入失败，可以用来表示加锁失败。</li>
</ul>
</li>
<li><p>分布式session</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">（M）SET、（M）GET </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">判断某个 key 是否存在</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">EXISTS name</span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除某个 key 对应的值</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">DEL name</span></span><br><span class="line">(integer) 1</span><br><span class="line">INCR、DECR；INCRBY</span><br><span class="line">EXPIRE、TTL</span><br><span class="line">SETNX（不存在才设置）、SETEX（同时设置过期时间）</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p>hash：哈希表(dict)+listpack</p>
<ul>
<li>如果哈希类型元素个数小于 512 个（默认值，可由 hash-max-ziplist-entries 配置），所有值小于 64 字节（默认值，可由 hash-max-ziplist-value 配置）的话，Redis 会使用<strong>压缩列表</strong>（listpack）作为 Hash 类型的底层数据结构；</li>
<li>如果哈希类型元素不满足上面条件，Redis 会使用<strong>哈希表</strong>作为 Hash 类型的底层数据结构。</li>
</ul>
<p>场景：</p>
<ul>
<li>缓存对象，hash的field与对象的属性对应</li>
<li>购物车：以用户 id 为 key，商品 id 为 field，商品数量为 value，恰好构成了购物车的3个要素</li>
</ul>
<p>String 还是 Hash 存储对象数据更好呢？</p>
<ul>
<li>String 存储的是序列化后的对象数据，存放的是整个对象。Hash 是对对象的每个字段单独存储，可以获取部分字段的信息，也可以修改或者添加部分字段，节省网络流量。如果对象中某些字段需要经常变动或者经常需要单独查询对象中的个别字段信息，Hash 就非常适合。</li>
<li>String 存储相对来说更加节省内存，缓存相同数量的对象数据，String 消耗的内存约是 Hash 的一半。并且，存储具有多层嵌套的对象时也方便很多。如果系统对性能和资源消耗非常敏感的话，String 就非常适合。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">存储一个哈希表key的键值</span></span><br><span class="line">HSET key field value   </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取哈希表key对应的field键值</span></span><br><span class="line">HGET key field</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在一个哈希表key中存储多个键值对</span></span><br><span class="line">HMSET key field value [field value...] </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">批量获取哈希表key中多个field键值</span></span><br><span class="line">HMGET key field [field ...]       </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除哈希表key中的field键值</span></span><br><span class="line">HDEL key field [field ...]    </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">返回哈希表key中field的数量</span></span><br><span class="line">HLEN key       </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">返回哈希表key中所有的键值</span></span><br><span class="line">HGETALL key </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">为哈希表key中field键的值加上增量n</span></span><br><span class="line">HINCRBY key field n      </span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p>list：quickList，一个quickList是一个双向链表，每个节点是一个压缩列表（ziplist）</p>
<ul>
<li>显示最新的项目列表<br>比如说，当我们想要在网页上列出用户的最新20条评论，在最新的评论边上我们有一个“显示全部”的链接，点击后就可以获得更多的评论。<br>Redis列表结构，LPUSH可以在列表头部插入一个内容ID作为关键字，LTRIM可用来限制列表的数量，这样列表永远为N个ID，无需查询最新的列表，直接根据ID去到对应的内容页即可。<br>即每次新评论发表时，我们会将它的ID添加到一个Redis列表。可以限定列表的长度为1000</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将一个或多个值value插入到key列表的表头(最左边)，最后的值在最前面</span></span><br><span class="line">LPUSH key value [value ...] </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将一个或多个值value插入到key列表的表尾(最右边)</span></span><br><span class="line">RPUSH key value [value ...]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">移除并返回key列表的头元素</span></span><br><span class="line">LPOP key     </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">移除并返回key列表的尾元素</span></span><br><span class="line">RPOP key </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">返回列表key中指定区间内的元素，区间以偏移量start和stop指定，从0开始</span></span><br><span class="line">LRANGE key start stop</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从key列表表头弹出一个元素，没有就阻塞<span class="built_in">timeout</span>秒，如果<span class="built_in">timeout</span>=0则一直阻塞</span></span><br><span class="line">BLPOP key [key ...] timeout</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从key列表表尾弹出一个元素，没有就阻塞<span class="built_in">timeout</span>秒，如果<span class="built_in">timeout</span>=0则一直阻塞</span></span><br><span class="line">BRPOP key [key ...] timeout</span><br></pre></td></tr></table></figure>

<p>Set 类型和 List 类型的区别如下：</p>
<ul>
<li>List 可以存储重复元素，Set 只能存储非重复元素；</li>
<li>List 是按照元素的先后顺序存储元素的，而 Set 则是无序方式存储元素的。</li>
</ul>
</li>
<li><p>set：哈希表+整数集合</p>
<ul>
<li>如果集合中的元素都是整数且元素个数小于 <code>512</code> （默认值，<code>set-maxintset-entries</code>配置）个，Redis 会使用<strong>整数集合（inset）</strong>作为 Set 类型的底层数据结构；</li>
<li>如果集合中的元素不满足上面条件，则 Redis 使用<strong>哈希表</strong>作为 Set 类型的底层数据结构。</li>
</ul>
<p>无序并唯一的键值集合，支持多个集合取交集、并集、差集。</p>
<p>应用场景：</p>
<ul>
<li>点赞：保证一个用户只能点一个赞</li>
<li>支持交集运算，所以可以用来计算共同关注的好友、公众号等</li>
<li>抽奖：SrandomMember或SRandomPop</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">往集合key中存入元素，元素存在则忽略，若key不存在则新建 O(1)</span></span><br><span class="line">SADD key member [member ...] </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从集合key中删除元素 O(1)</span></span><br><span class="line">SREM key member [member ...] </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取集合key中所有元素</span></span><br><span class="line">SMEMBERS key</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">判断member元素是否存在于集合key中 O(1)</span></span><br><span class="line">SISMEMBER key member</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从集合key中随机选出count个元素，元素不从key中删除</span></span><br><span class="line">SRANDMEMBER key [count]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从集合key中随机选出count个元素，元素从key中删除</span></span><br><span class="line">SPOP key [count]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">交集运算</span></span><br><span class="line">SINTER key [key ...]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将交集结果存入新集合destination中</span></span><br><span class="line">SINTERSTORE destination key [key ...]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">并集运算</span></span><br><span class="line">SUNION key [key ...]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将并集结果存入新集合destination中</span></span><br><span class="line">SUNIONSTORE destination key [key ...]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">差集运算</span></span><br><span class="line">SDIFF key [key ...]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将差集结果存入新集合destination中</span></span><br><span class="line">SDIFFSTORE destination key [key ...]</span><br></pre></td></tr></table></figure>
</li>
<li><p>zset：listpack+跳表</p>
<ul>
<li>如果有序集合的元素个数小于 <code>128</code> 个，并且每个元素的值小于 <code>64</code> 字节时，Redis 会使用<strong>压缩列表</strong>（listpack）作为 Zset 类型的底层数据结构；</li>
<li>如果有序集合的元素不满足上面的条件，Redis 会使用<strong>跳表</strong>作为 Zset 类型的底层数据结构；</li>
</ul>
<p>Zset 类型（有序集合类型）相比于 Set 类型多了一个排序属性 score（分值），对于有序集合 ZSet 来说，每个存储元素相当于有两个值组成的，一个是有序集合的元素值，一个是排序值。</p>
<ul>
<li>排行榜</li>
<li>姓名、电话号码排序等</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">https://blog.csdn.net/qq_43842093/article/details/122905910</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">往有序集合key中加入带分值元素 复杂度O（logn）</span></span><br><span class="line">ZADD key score member [[score member]...]   </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">往有序集合key中删除元素 O（logn）</span></span><br><span class="line">ZREM key member [member...]                 </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">返回有序集合key中元素member的分值 复杂度O（1）</span></span><br><span class="line">ZSCORE key member</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">为有序集合key中元素member的分值加上increment</span></span><br><span class="line">ZINCRBY key increment member </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">正序获取有序集合key从start下标到stop下标的元素 复杂度<span class="built_in">log</span>(n)+k</span></span><br><span class="line">ZRANGE key start stop [WITHSCORES]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">倒序获取有序集合key从start下标到stop下标的元素</span></span><br><span class="line">ZREVRANGE key start stop [WITHSCORES]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">返回有序集合中指定分数区间内的成员，分数由低到高排序。</span></span><br><span class="line">ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">返回指定成员区间内的成员，按字典正序排列, 分数必须相同。</span></span><br><span class="line">ZRANGEBYLEX key min max [LIMIT offset count]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">返回指定成员区间内的成员，按字典倒序排列, 分数必须相同</span></span><br><span class="line">ZREVRANGEBYLEX key max min [LIMIT offset count]</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="特殊数据类型"><a href="#特殊数据类型" class="headerlink" title="特殊数据类型"></a>特殊数据类型</h3><ul>
<li><p>BitMap</p>
<p>Bitmap，即位图，是一串连续的二进制数组（0和1），可以通过偏移量（offset）定位元素。BitMap通过最小的单位bit来进行<code>0|1</code>的设置，表示某个元素的值或者状态，时间复杂度为O(1)。</p>
<p>Bitmap 本身是用 String 类型作为底层数据结构实现的一种统计二值状态的数据类型。</p>
<p>String 类型是会保存为二进制的字节数组，所以，Redis 就把字节数组的每个 bit 位利用起来，用来表示一个元素的二值状态，你可以把 Bitmap 看作是一个 bit 数组。</p>
<p>两种状态的统计都可以使用bitmaps，例如：统计用户活跃与非活跃数量、登录与非登录、上班打卡等等。</p>
<ul>
<li>签到</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置值，其中value只能是 0 和 1</span></span><br><span class="line">SETBIT key offset value</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取值</span></span><br><span class="line">GETBIT key offset</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取指定范围内值为 1 的个数</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">start 和 end 以字节为单位</span></span><br><span class="line">BITCOUNT key start end</span><br></pre></td></tr></table></figure>
</li>
<li><p>HyperLoglog</p>
<p>是一种用于「统计基数」的数据集合类型，基数统计就是指统计一个集合中不重复的元素个数。但要注意，HyperLogLog 是统计规则是基于概率完成的，不是非常准确，标准误算率是 0.81%。</p>
<p>在 Redis 里面，<strong>每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 <code>2^64</code> 个不同元素的基数</strong>。</p>
<ul>
<li>UV统计（浏览用户数量）</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加指定元素到 HyperLogLog 中</span></span><br><span class="line">PFADD key element [element ...]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">返回给定 HyperLogLog 的基数估算值。</span></span><br><span class="line">PFCOUNT key [key ...]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将多个 HyperLogLog 合并为一个 HyperLogLog</span></span><br><span class="line">PFMERGE destkey sourcekey [sourcekey ...]</span><br></pre></td></tr></table></figure>
</li>
<li><p>GEO</p>
<p>底层为sorted set。应用场景：按经纬度查看附近的人</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">存储指定的地理空间位置，可以将一个或多个经度(longitude)、纬度(latitude)、位置名称(member)添加到指定的 key 中。</span></span><br><span class="line">GEOADD key longitude latitude member [longitude latitude member ...]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从给定的 key 里返回所有指定名称(member)的位置（经度和纬度），不存在的返回 nil。</span></span><br><span class="line">GEOPOS key member [member ...]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">返回两个给定位置之间的距离。</span></span><br><span class="line">GEODIST key member1 member2 [m|km|ft|mi]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">根据用户给定的经纬度坐标来获取指定范围内的地理位置集合。</span></span><br><span class="line">GEORADIUS key longitude latitude radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count] [ASC|DESC] [STORE key] [STOREDIST key]</span><br></pre></td></tr></table></figure>
</li>
<li><p>Stream</p>
<ul>
<li>如果你的业务场景足够简单，对于<strong>数据丢失</strong>不敏感，而且<strong>消息积压</strong>概率比较小的情况下，把 Redis 当作队列是完全可以的。</li>
<li>如果你的业务有海量消息，消息积压的概率比较大，并且不能接受数据丢失，那么还是用专业的消息队列中间件吧。</li>
</ul>
</li>
</ul>
<blockquote>
<p>介绍一下Redis数据结构？</p>
<p>先说说Redis数据类型，主要包括5种基本数据类型和3种特殊类型。</p>
<p>基本数据类型包括String、List、Set、Sorted Set和Hash。</p>
<p>String就是字符串，应用场景：作为缓存、计数器</p>
<p>String底层基于SDS（简单动态字符串）实现，解决了C语言字符串存在的一些问题。比如C语言的字符串用‘\0’表示结束，最先遇到的‘\0’会被视为字符串结尾，所以不能保存二进制数据。SDS用一个字节数组存放数据，另外用一个len成员记录字符串长度，所以不需要用‘\0’结尾（为了兼容实际还是用了）,可以存文本也可以存二进制数据。</p>
<p>List就是链表，它的元素是有序的，而且列表内的元素是可以重复的。可以用来做数据分页展示</p>
<p>底层基于quicklist实现。quicklist就是一个双向链表，链表的每个节点指向一个压缩列表ziplist（ziplist所存储的内容都是在连续的内存区域当中的，可以通过数据元素的类型和大小来分配内存空间，所以更省内存。插入的时间复杂化度为O(n)，而且每当插入新的元素需要realloc做内存扩展）。</p>
<p>Set是字符串集合，它不允许存放重复元素，并且元素是无序的。适用于一些需要去重的场景如项目中评论的点赞，也可以借助SrandomMember来做抽奖。</p>
<p>Set在存放元素都是整数且元素个数少于512的时候采用inset结构，它是一个有序的整数集合。不满足这个条件就采用hashtable。</p>
<p>Sorted Set是有序集合，它保留了集合中元素不能重复的特性，但是有序集合给每个元素多设置了一个分数用来排序。应用场景就是用来做排行榜，比如项目中帖子的点赞用zset按点赞时间来排。</p>
<p>在zset元素比较少（&lt;128）并且每个元素都比较小（&lt;64字节）时采用压缩列表，每个集合元素使用两个紧挨在一起的压缩列表节点来保存，第一个节点保存元素的成员（member），而第二个元素则保存元素的分值（score）。其他情况用的是skiplist和哈希表。跳表是多层的有序列表，增删复杂度o(logn)，通过跳表能进行高效的范围查询，通过哈希表能进行高效单点查询。</p>
<p>Hash就是一个键值对（key-value）集合。可以用来存对象，比如用户信息，不同信息分别对应一个field，这样就可以按需要获取用户的信息，不用每次去数据库查。</p>
<p>在hash元素比较少（&lt;512）并且每个元素都比较小（&lt;64字节）时采用压缩列表，其他情况用的是哈希表。</p>
</blockquote>
<h3 id="数据结构-Redis7-0-listpack取代了压缩列表ziplist"><a href="#数据结构-Redis7-0-listpack取代了压缩列表ziplist" class="headerlink" title="数据结构(Redis7.0,listpack取代了压缩列表ziplist)"></a>数据结构(Redis7.0,listpack取代了压缩列表ziplist)</h3><p><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="https://s2.loli.net/2023/06/24/qcaeEJTOIwht15o.png" alt="Redis数据结构"></p>
<ul>
<li><p>SDS</p>
<p>Redis基于C语言实现，但C语言的字符串有如下缺点：</p>
<ul>
<li>获取字符串长度的时间复杂度为 O（N）；</li>
<li>字符串的结尾是以 “\0” 字符标识，字符串里面不能包含有 “\0” 字符，因此不能保存二进制数据；</li>
<li>字符串操作函数不高效且不安全，比如有缓冲区溢出的风险，有可能会造成程序运行终止；</li>
</ul>
<p><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="https://s2.loli.net/2023/06/24/GVFE3OvQ7nUWrTt.png" alt="Redis-SDS"></p>
<ul>
<li><strong>len，记录了字符串长度</strong>。这样获取字符串长度的时候，只需要返回这个成员变量值就行，时间复杂度只需要 O（1）。（C 语言的字符串长度获取 strlen 函数，需要通过遍历的方式来统计字符串长度，时间复杂度是 O（N）。）</li>
<li><strong>alloc，分配给字符数组的空间长度</strong>。这样在修改字符串的时候，可以通过 <code>alloc - len</code> 计算出剩余的空间大小，可以用来判断空间是否满足修改需求，如果不满足的话，就会自动将 SDS 的空间扩展至执行修改所需的大小，然后才执行实际的修改操作，所以使用 SDS 既不需要手动修改 SDS 的空间大小，也不会出现前面所说的缓冲区溢出的问题。</li>
<li><strong>flags，用来表示不同类型的 SDS</strong>。一共设计了 5 种类型，分别是 sdshdr5、sdshdr8、sdshdr16、sdshdr32 和 sdshdr64，可以灵活保存不同大小字符串。比如，sdshdr16 类型的 SDS，默认情况下，编译器会按照 2 字节对齐的方式给变量分配内存，这意味着，即使一个变量的大小不到 2 个字节，编译器也会给它分配 2 个字节。</li>
<li><strong>buf[]，字符数组，用来保存实际数据</strong>。不仅可以保存字符串，也可以保存二进制数据。因为 SDS 不需要用 “\0” 字符来标识字符串结尾了，而是<strong>有个专门的 len 成员变量来记录长度，所以可存储包含 “\0” 的数据</strong>。但是 SDS 为了兼容部分 C 语言标准库的函数， SDS 字符串结尾还是会加上 “\0” 字符。</li>
</ul>
</li>
</ul>
<h5 id="skiplist跳表"><a href="#skiplist跳表" class="headerlink" title="skiplist跳表"></a>skiplist跳表</h5><p>Redis 只有 Zset 对象的底层实现用到了跳表，跳表的优势是能支持平均 O(logN) 复杂度的节点查找。</p>
<p>zset 结构体里有两个数据结构：一个是跳表，一个是哈希表。这样的好处是既能进行高效的范围查询，也能进行高效单点查询。</p>
<p>Zset 对象在执行数据插入或是数据更新的过程中，会依次在跳表和哈希表中插入或更新相应的数据，从而保证了跳表和哈希表中记录的信息一致。</p>
<p>Zset 对象能支持范围查询（如 ZRANGEBYSCORE 操作），这是因为它的数据结构设计采用了跳表，而又能以常数复杂度获取元素权重（如 ZSCORE 操作），这是因为它同时采用了哈希表进行索引。</p>
<p>链表在查找元素的时候，因为需要逐一查找，所以查询效率非常低，时间复杂度是O(N)，于是就出现了跳表。<strong>跳表是在链表基础上改进过来的，实现了一种「多层」的有序链表</strong>（空间换时间），这样的好处是能快读定位数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">    <span class="comment">//Zset 对象的元素值</span></span><br><span class="line">    sds ele;</span><br><span class="line">    <span class="comment">//元素权重值</span></span><br><span class="line">    <span class="type">double</span> score;</span><br><span class="line">    <span class="comment">//后向指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">//节点的level数组，保存每层上的前向指针和跨度</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> span;</span><br><span class="line">    &#125; level[];</span><br><span class="line">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure>

<p><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="https://s2.loli.net/2023/06/29/GqD3fFx8uCOHzPL.png" alt="跳表"></p>
<ul>
<li><p>查询过程</p>
<p>查找一个跳表节点的过程时，跳表会从头节点的最高层开始，逐一遍历每一层。在遍历某一层的跳表节点时，会用跳表节点中的 SDS 类型的元素和元素的权重来进行判断，共有两个判断条件：</p>
<ul>
<li>如果当前节点的权重「小于」要查找的权重时，跳表就会访问该层上的下一个节点。</li>
<li>如果当前节点的权重「等于」要查找的权重时，并且当前节点的 SDS 类型数据「小于」要查找的数据时，跳表就会访问该层上的下一个节点。</li>
</ul>
<p>如果上面两个条件都不满足，或者下一个节点为空时，跳表就会使用目前遍历到的节点的 level 数组里的下一层指针，然后沿着下一层指针继续查找，这就相当于跳到了下一层接着查找。</p>
</li>
<li><p>结点层数的设置</p>
<p><strong>跳表在创建节点的时候，随机生成每个节点的层数</strong>，并没有严格维持相邻两层的节点数量比例为 2 : 1 的情况。</p>
<p>具体的做法是，<strong>跳表在创建节点时候，会生成范围为[0-1]的一个随机数，如果这个随机数小于 0.25（相当于概率 25%），那么层数就增加 1 层，然后继续生成下一个随机数，直到随机数的结果大于 0.25 结束，最终确定该节点的层数</strong>。</p>
<p>这样的做法，相当于每增加一层的概率不超过 25%，层数越高，概率越低，层高最大限制是 32。</p>
</li>
</ul>
<ul>
<li><p>为什么用跳表不用红黑树？</p>
<ul>
<li><strong>从内存占用上来比较，跳表比平衡树更灵活一些</strong>。平衡树每个节点包含 2 个指针（分别指向左右子树），而跳表每个节点包含的指针数目平均为 1&#x2F;(1-p)，具体取决于参数 p 的大小。如果像 Redis里的实现一样，取 p&#x3D;1&#x2F;4，那么平均每个节点包含 1.33 个指针，比平衡树更有优势。</li>
<li><strong>在做范围查找的时候，跳表比平衡树操作要简单</strong>。在平衡树上，我们找到指定范围的小值之后，还需要以中序遍历的顺序继续寻找其它不超过大值的节点。如果不对平衡树进行一定的改造，这里的中序遍历并不容易实现。而在跳表上进行范围查找就非常简单，只需要在找到小值之后，对第 1 层链表进行若干步的遍历就可以实现。</li>
<li><strong>从算法实现难度上来比较，跳表比平衡树要简单得多</strong>。平衡树的插入和删除操作可能引发子树的调整，逻辑复杂，而跳表的插入和删除只需要修改相邻节点的指针，操作简单又快速。</li>
</ul>
</li>
<li><p>为什么不用B+树？</p>
<ul>
<li><p><strong>简单实现</strong></p>
<p>跳跃表的实现相对简单，相比B+ Tree而言，代码实现难度要小很多。在实际应用中，简单的实现通常能够提高代码的可读性和可维护性，因此跳跃表比B+ Tree更适合Redis这种注重性能和易用性的应用。</p>
</li>
<li><p><strong>更好的内存效率</strong></p>
<p>在存储相同数量的元素时，跳跃表通常需要更少的内存。这是因为跳跃表在实现过程中，节点的层数是随机的，并且每个节点只需要记录下一层节点的指针，而不是像B+ Tree那样需要记录所有子节点的指针。这样一来，跳跃表在存储相同数量的元素时，所需的内存通常比B+ Tree要少。</p>
</li>
<li><p><strong>更高的写入性能</strong></p>
<p>在写入操作方面，跳跃表比B+ Tree具有更高的性能。这是因为在跳跃表中，每个节点都是独立的，当需要进行插入或删除操作时，只需要修改少量节点即可，而B+ Tree需要从根节点开始遍历到叶子节点，才能找到正确的位置进行插入或删除操作。而且B+树需要考虑平衡性、页分裂等问题，跳表不需要考虑。因此，在频繁进行写入操作的场景中，跳跃表比B+ Tree更加高效。</p>
</li>
</ul>
</li>
</ul>
<h5 id="ziplist压缩列表"><a href="#ziplist压缩列表" class="headerlink" title="ziplist压缩列表"></a>ziplist压缩列表</h5><p>简言之，有点类似于数组，用一块连续的内存空间，但是根据每个节点存放的具体元素的不同采用不同的编码以节省内存（按实际存放元素分配内存）。查首尾O（1），其他位置O（n）</p>
<p>压缩列表的最大特点，就是它被设计成一种内存紧凑型的数据结构，占用一块连续的内存空间，不仅可以利用 CPU 缓存，而且会针对不同长度的数据，进行相应编码，这种方法可以有效地节省内存开销。</p>
<p><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="https://s2.loli.net/2023/06/29/m53FSzEICUfcBZA.png" alt="ziplist"></p>
<p>压缩列表在表头有三个字段：</p>
<ul>
<li><em><strong>zlbytes</strong></em>，记录整个压缩列表占用对内存字节数；</li>
<li><em><strong>zltail</strong></em>，记录压缩列表「尾部」节点距离起始地址由多少字节，也就是列表尾的偏移量；</li>
<li><em><strong>zllen</strong></em>，记录压缩列表包含的节点数量；</li>
<li><em><strong>zlend</strong></em>，标记压缩列表的结束点，固定值 0xFF（十进制255）。</li>
</ul>
<p>在压缩列表中，如果我们要查找定位第一个元素和最后一个元素，可以通过表头三个字段（zllen）的长度直接定位，复杂度是 O(1)。而<strong>查找其他元素时，就没有这么高效了，只能逐个查找，此时的复杂度就是 O(N) 了，因此压缩列表不适合保存过多的元素</strong>。</p>
<p>压缩列表节点包含三部分内容：</p>
<ul>
<li><em><strong>prevlen</strong></em>，记录了「前一个节点」的长度，目的是为了实现从后向前遍历；</li>
<li><em><strong>encoding</strong></em>，记录了当前节点实际数据的「类型和长度」，类型主要有两种：字符串和整数。</li>
<li><em><strong>data</strong></em>，记录了当前节点的实际数据，类型和长度都由 <code>encoding</code> 决定；</li>
</ul>
<p>当我们往压缩列表中插入数据时，压缩列表就会根据数据类型是字符串还是整数，以及数据的大小，会使用不同空间大小的 prevlen 和 encoding 这两个元素里保存的信息，<strong>这种根据数据大小和类型进行不同的空间大小分配的设计思想，正是 Redis 为了节省内存而采用的</strong>。</p>
<h5 id="quicklist"><a href="#quicklist" class="headerlink" title="quicklist"></a>quicklist</h5><p>quicklistNode 结构体里包含了前一个节点和下一个节点指针，这样每个 quicklistNode 形成了一个双向链表。但是链表节点的元素不再是单纯保存元素值，而是保存了一个压缩列表，所以 quicklistNode 结构体里有个指向压缩列表的指针 *zl。</p>
<p><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="https://s2.loli.net/2023/06/29/d2Rv7IzSq4X9tWn.png" alt="quicklist"></p>
<p>在向 quicklist 添加一个元素的时候，不会像普通的链表那样，直接新建一个链表节点。而是会检查插入位置的压缩列表是否能容纳该元素，如果能容纳就直接保存到 quicklistNode 结构里的压缩列表，如果不能容纳，才会新建一个新的 quicklistNode 结构。</p>
<p>quicklist 会控制 quicklistNode 结构里的压缩列表的大小或者元素个数，来规避潜在的连锁更新的风险，但是这并没有完全解决连锁更新的问题。</p>
<h5 id="listpack"><a href="#listpack" class="headerlink" title="listpack"></a>listpack</h5><p>listpack 采用了压缩列表的很多优秀的设计，比如还是用一块连续的内存空间来紧凑地保存数据，并且为了节省内存的开销，listpack 节点会采用不同的编码方式保存不同大小的数据。</p>
<p><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="https://s2.loli.net/2023/06/29/Rkv8LfdaOsbeEYT.png" alt="listpack"></p>
<p>主要包含三个方面内容：</p>
<ul>
<li>encoding，定义该元素的编码类型，会对不同长度的整数和字符串进行编码；</li>
<li>data，实际存放的数据；</li>
<li>len，encoding+data的总长度；</li>
</ul>
<p>可以看到，<strong>listpack 没有压缩列表中记录前一个节点长度的字段了，listpack 只记录当前节点的长度，当我们向 listpack 加入一个新元素的时候，不会影响其他节点的长度字段的变化，从而避免了压缩列表的连锁更新问题</strong>。</p>
<h5 id="Dict-两个Hashtable"><a href="#Dict-两个Hashtable" class="headerlink" title="Dict(两个Hashtable)"></a>Dict(两个Hashtable)</h5><p>采用<strong>拉链法</strong>解决Hash冲突。链式哈希局限性也很明显，随着链表长度的增加，在查询这一位置上的数据的耗时就会增加，毕竟链表的查询的时间复杂度是 O(n)。</p>
<p>要想解决这一问题，就需要进行 rehash，也就是对哈希表的大小进行扩展。Redis采用渐进式rehash。</p>
<p><strong>所谓渐进式rehash是指我们的大字典的扩容是比较消耗时间的，需要重新申请新的数组，然后将旧字典所有链表的元素重新挂接到新的数组下面，是一个O(n)的操作。但是因为我们的redis是单线程的，无法承受这样的耗时过程，所以采用了渐进式rehash小步搬迁，虽然慢一点，但是可以搬迁完毕</strong>。</p>
<p>扩容条件</p>
<p>我们的扩容一般会在Hash表中的元素个数等于第一维数组的长度的时候，就会开始扩容。扩容的大小是原数组的两倍。不过在redis在做bgsave（RDB持久化操作的过程），为了减少内存页的过多分离（Copy On Write），redis不会去扩容。但是如果hash表的元素个数已经到达了第一维数组长度的5倍的时候，就会强制扩容，不管你是否在持久化。</p>
<p>不扩容主要是为了尽可能减少内存页过多分离，系统需要更多的开销去回收内存。</p>
<p>缩容条件</p>
<p>当我们的hash表元素逐渐删除的越来越少的时候。redis于是就会对hash表进行缩容来减少第一维数组长度的空间占用。缩容的条件是元素个数低于数组长度的10%，并且缩容不考虑是否在做redis持久化。</p>
<p>不用考虑bgsave主要是因为我们的缩容的内存都是已经使用过的，缩容的时候可以直接置空，而且由于申请的内存比较小，同时会释放掉一些已经使用的内存，不会增大系统的压力。</p>
<p>rehash步骤</p>
<p>1、为ht[1] 分配空间，让字典同时持有ht[0]和ht[1]两个哈希表；</p>
<p>2、定时维持一个索引计数器变量rehashidx，并将它的值设置为0，表示rehash 开始；</p>
<p>3、在rehash进行期间，每次对字典执行CRUD操作时，程序除了执行指定的操作以外，还会将ht[0]中的数据rehash 到ht[1]表中，并且将rehashidx加一；</p>
<p>4、当ht[0]中所有数据转移到ht[1]中时，将rehashidx 设置成-1，表示rehash 结束；</p>
<p>（采用渐进式rehash 的好处在于它采取分而治之的方式，避免了集中式rehash 带来的庞大计算量。特别的在进行rehash时只能对h[0]元素减少的操作，如查询和删除；而查询是在两个哈希表中查找的，而插入只能在ht[1]中进行，ht[1]也可以查询和删除。）</p>
<p>5、将ht[0]释放，然后将ht[1]设置成ht[0]，最后为ht[1]分配一个空白哈希表。</p>
<p><a target="_blank" rel="noopener" href="https://www.xiaolincoding.com/redis/data_struct/command.html#string">https://www.xiaolincoding.com/redis/data_struct/command.html#string</a></p>
<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><h4 id="RedisBloom"><a href="#RedisBloom" class="headerlink" title="RedisBloom"></a>RedisBloom</h4><p><a target="_blank" rel="noopener" href="https://bugwz.com/2022/01/01/redismodule-redisbloom/">https://bugwz.com/2022/01/01/redismodule-redisbloom/</a></p>
<h3 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h3><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/-op5WR1wSkgAuP7JYZWP8g">https://mp.weixin.qq.com/s/-op5WR1wSkgAuP7JYZWP8g</a></p>
<ul>
<li><p>redis为什么快</p>
<ul>
<li><p>Redis <strong>基于内存</strong>，内存的访问速度是磁盘的上千倍；</p>
</li>
<li><p>Redis 是键值数据库，底层是全局哈希表，可以用O(1)的时间复杂度定位到元素；内置了多种<strong>高效的数据结构</strong>实现，不同场景下都能有较高的性能。</p>
</li>
<li><p>Redis处理主要业务逻辑是单线程的，单线程模型可以避免了多线程之间的竞争，<strong>规避进程内频繁的线程上下文切换开销</strong>，避免同步机制（比如锁）的开销</p>
<p><strong>CPU 并不是制约 Redis 性能表现的瓶颈所在</strong>，更多情况下是受到内存大小和网络I&#x2F;O的限制。网络 I&#x2F;O 在 Redis 整个执行期间占用了大部分的 CPU 时间，所以 <strong>Redis 6.0 版本之后，也采用了多个 I&#x2F;O 线程（默认3个）来处理网络请求</strong>，性能提升一倍以上。</p>
</li>
</ul>
<ul>
<li><p>Redis 基于 Reactor 模式设计开发了一套高效的事件处理模型，主要是单线程事件循环和<strong>IO 多路复用</strong>；</p>
<p> <strong>I&#x2F;O 多路复用机制</strong>处理大量的客户端 Socket 请求，IO 多路复用机制是指一个线程处理多个 IO 流，就是我们经常听到的 select&#x2F;epoll 机制。简单来说，在 Redis 只运行单线程的情况下，该机制允许内核中，同时存在多个监听 Socket 和已连接 Socket。内核会一直监听这些 Socket 上的连接请求或数据请求。一旦有请求到达，就会交给 Redis 线程处理，这就实现了一个 Redis 线程处理多个 IO 流的效果。</p>
</li>
</ul>
</li>
</ul>
<p><strong>Redis 单线程指的是「接收客户端请求-&gt;解析请求 -&gt;进行数据读写等操作-&gt;发送数据给客户端」这个过程是由一个线程（主线程）来完成的</strong>。</p>
<p>Redis有一些后台线程用于执行一些比较耗时（关闭文件、AOF 刷盘、释放内存，如果由主线程执行会<strong>阻塞主线程</strong>）的操作：</p>
<ul>
<li>通过 <code>bio_close_file</code> 后台线程来<strong>释放</strong>AOF &#x2F; RDB 等过程中产生的临时<strong>文件资源</strong>。</li>
<li>通过 <code>bio_aof_fsync</code> 后台线程调用 <code>fsync</code> 函数将系统内核缓冲区还未同步到到磁盘的数据强制<strong>刷</strong>到磁<strong>盘</strong>（ AOF 文件）。</li>
<li>通过 <code>bio_lazy_free</code>后台线程<strong>释放大对象</strong>（已删除）占用的内存空间.</li>
</ul>
<h3 id="事务、pipeline、Lua脚本"><a href="#事务、pipeline、Lua脚本" class="headerlink" title="事务、pipeline、Lua脚本"></a>事务、pipeline、Lua脚本</h3><p><code>Redis</code>事务在发送每个指令到事务缓存队列时都要经过一次网络读写，当一个事务内部的指令较多时，需要的网络 IO 时间也会线性增长。所以通常 <code>Redis</code>的客户端在执行事务时都会结合 <code>pipeline</code>一起使用，这样可以**将多次 IO 操作压缩为单次 IO **操作。</p>
<p>需要注意的是：一个<code>pipeline</code>包含的命令不应太多，因为在使用流水线操作时，<code>Redis</code>在将所有响应批量返回给客户端之前会<strong>将所有响应缓存在内存</strong>中，因此对数千个查询（特别是那些返回大量数据的查询）进行流水线操作可能会对服务器和客户端都造成负担。</p>
<p>Lua脚本：</p>
<ul>
<li><p>原子性<br> 脚本会将多个命令和操作当成一个命令在redis中执行，在执行脚本的时候不会被其他的命令插入，具有原子性，因此更适合于处理事务；<br> 而管道虽然也会将多个命令一次性传输到服务端，但在服务端执行的时候仍然是多个命令，如在执行CMD1的时候，外部另一个客户端提交了CMD9，会先执行完CMD9再执行管道中的CMD2，因此事实上<strong>管道是不具有原子性的</strong>。</p>
</li>
<li><p>redis本身是不支持事务回滚的，那也就是说如果 在执行lua脚本过程中，有一部分命令成功了，有一部分失败了，也不会出现回滚的操作。</p>
</li>
<li><p>优点</p>
<ul>
<li>原子性操作：Redis使用单线程执行Lua脚本，保证了脚本的原子性操作，避免了多个操作之间的竞态条件。</li>
<li>减少网络开销：通过执行Lua脚本，可以将多个Redis操作合并为一个网络请求，减少了网络开销。Redis将Lua脚本编译成一个SHA1哈希值，并将其存储在一个键名为SCRIPTS的Redis哈希集中。在脚本第一次运行后，这个哈希值将被存储在Redis缓存中。后续只需发送这个SHA1值和脚本的参数即可（RedisTemplate可以帮我们实现）</li>
<li>复杂操作的封装：Lua脚本可以将多个操作封装成一个原子性的命令，提高了代码的简洁性和可读性。</li>
<li>高效：Lua语言是快速轻量级的脚本语言，它具有快速的解释能力。</li>
</ul>
</li>
</ul>
<p>redis事务可以原子性的执行一组命令，但是每条命令实际上是不是马上执行的：先发到server端队列里攒着一起exec，这样的话如果命令之间有依赖就没法搞定了。</p>
<blockquote>
<p>注意事项：java参数类型一定要跟lua脚本类型匹配！</p>
</blockquote>
<h3 id="过期删除与内存淘汰"><a href="#过期删除与内存淘汰" class="headerlink" title="过期删除与内存淘汰"></a>过期删除与内存淘汰</h3><h4 id="过期删除策略"><a href="#过期删除策略" class="headerlink" title="过期删除策略"></a>过期删除策略</h4><p><strong>Redis 中除了字符串类型有自己独有设置过期时间的命令 <code>setex</code> 外，其他方法都需要依靠 <code>expire</code> 命令来设置过期时间 （通过expire可以续期）。另外， <code>persist</code> 命令可以移除一个键的过期时间。</strong></p>
<p>每当我们对一个 key 设置了过期时间时，Redis 会把该 key 带上过期时间（值是一个 long long 类型的整数）存储到一个<strong>过期字典</strong>（expires dict）中，也就是说过期字典保存了数据库中所有 key 的过期时间。</p>
<p>当我们查询一个 key 时，Redis 首先检查该 key 是否存在于过期字典中：</p>
<ul>
<li>如果不在，则正常读取键值；</li>
<li>如果存在，则会获取该 key 的过期时间，然后与当前系统时间进行比对，如果比系统时间大，那就没有过期，否则判定该 key 已过期。</li>
</ul>
<p>常用的过期数据的删除策略就两个：</p>
<ol>
<li><strong>惰性删除</strong>：<strong>不主动删除过期键，每次从访问 key 时，才检测 key 是否过期，如果过期则删除该 key</strong>。这样对 CPU 最友好，但是可能会造成太多过期 key 没有被删除。</li>
<li><strong>定期删除</strong>：<strong>每隔一段时间「随机」从数据库中取出一定数量的 key 进行检查，并删除其中的过期key。</strong>并且，Redis 底层会通过限制删除操作执行的时长和频率来减少删除操作对 CPU 时间的影响。</li>
</ol>
<p>定期删除对内存更加友好，惰性删除对 CPU 更加友好。两者各有千秋，所以 Redis 采用的是 <strong>定期删除+惰性&#x2F;懒汉式删除</strong> 。</p>
<p>Redis 的定期删除的流程：</p>
<ol>
<li>从过期字典中随机抽取 20 个 key；</li>
<li>检查这 20 个 key 是否过期，并删除已过期的 key；</li>
<li>如果本轮检查的已过期 key 的数量，超过 5 个（4分之一），也就是「已过期 key 的数量」占比「随机抽取 key 的数量」大于 25%，则继续重复步骤 1；如果已过期的 key 比例小于 25%，则停止继续删除过期 key，然后等待下一轮再检查。</li>
</ol>
<p>可以看到，定期删除是一个循环的流程。那 Redis 为了保证定期删除不会出现循环过度，导致线程卡死现象，为此增加了定期删除循环流程的时间上限，默认不会超过 25ms。</p>
<h4 id="内存淘汰"><a href="#内存淘汰" class="headerlink" title="内存淘汰"></a>内存淘汰</h4><p><strong>no eviction</strong>（Redis3.0之后，默认的内存淘汰策略） ：它表示当运行内存超过最大设置内存时，不淘汰任何数据，而是不再提供服务，直接返回错误。</p>
<p><strong>allkeys-lru（least recently used）</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）。</p>
<p><strong>volatile-lru（least recently used）</strong>：从已设置过期时间的数据集（<code>server.db[i].expires</code>）中挑选最近最少使用的数据淘汰。</p>
<p><strong>volatile-random &#x2F; allkeys-random</strong>：从<em>已设置过期时间的数据集</em> &#x2F; <em>所有数据</em> 中任意选择数据淘汰。</p>
<p><strong>volatile-lfu &#x2F; allkeys-lfu（least frequently used）</strong>：从<em>已设置过期时间的数据集</em> &#x2F; <em>所有数据</em>中挑选最不经常使用的数据淘汰。</p>
<p><strong>volatile-ttl</strong>：从已设置过期时间的数据集中挑选将要过期的数据淘汰。</p>
<ul>
<li><p>lru 最近最少使用</p>
<p>传统 LRU 算法的实现是基于「链表」结构，链表中的元素按照操作顺序从前往后排列，最新操作的键会被移动到表头，当需要内存淘汰时，只需要删除链表尾部的元素即可，因为链表尾部的元素就代表最久未被使用的元素。</p>
<p>Redis 实现的是一种<strong>近似 LRU 算法</strong>，目的是为了更好的节约内存，它的<strong>实现方式是在 Redis 的对象结构体中添加一个额外的字段，用于记录此数据的最后一次访问时间</strong>。</p>
<p>当 Redis 进行内存淘汰时，会使用<strong>随机采样的方式来淘汰数据</strong>，它是随机取 5 个值（此值可配置），然后<strong>淘汰最久没有使用的那个</strong>。</p>
<p>LRU算法的不足之处在于，若一个key很少被访问，只是刚刚偶尔被访问了一次，则它就被认为是热点数据，短时间内不会被淘汰。</p>
</li>
<li><p>lfu 最近最不常用</p>
<p>它根据key的最近访问频率进行淘汰。LFU在LRU的基础上，为每个数据增加了一个计数器，来统计这个数据的访问次数。当使用LFU策略淘汰数据时，首先会根据数据的访问次数进行筛选，把访问次数最低的数据淘汰出内存。如果两个数据的访问次数相同，LFU再比较这两个数据的访问时间，把访问时间更早的数据淘汰出内存。</p>
</li>
</ul>
<h3 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h3><p>Redis 的读写操作都是在内存中，所以 Redis 性能才会高，但是当 Redis 重启后，内存中的数据就会丢失，那为了保证内存中的数据不会丢失，Redis 实现了数据持久化的机制，这个机制会把数据存储到磁盘，这样在 Redis 重启就能够从磁盘中恢复原有的数据。</p>
<p>Redis 共有三种数据持久化的方式：</p>
<h4 id="AOF-日志"><a href="#AOF-日志" class="headerlink" title="AOF 日志"></a><strong>AOF 日志</strong></h4><p>类似于MySQL的binlog，每执行一条写操作命令，就把该命令以追加的方式写入到一个文件里；然后 Redis 重启时，会读取该文件记录的命令，然后逐一执行命令的方式来进行数据恢复。</p>
<ul>
<li><p>AOF过程</p>
<p>先执行写操作命令后，才将该命令记录到 AOF 日志里；AOF 日志是在主线程中执行</p>
<ul>
<li>避免额外的检查开销，AOF 记录日志不会对命令进行语法检查；</li>
<li>在命令执行完之后再记录，不会阻塞当前的命令执行。</li>
</ul>
<p>AOF 持久化功能的实现可以简单分为 5 步：</p>
<ol>
<li><strong>命令追加（append）</strong>：所有的写命令会追加到 AOF 缓冲区中。</li>
<li><strong>文件写入（write）</strong>：调用系统调用write将 AOF 缓冲区的数据写入到 系统内核缓冲区，等待系统写入AOF 文件中。</li>
<li><strong>文件同步（fsync）</strong>：AOF 缓冲区根据对应的持久化方式（ <code>fsync</code> 策略）向硬盘做同步操作。这一步需要调用 <code>fsync</code> 函数（系统调用）， <code>fsync</code> 针对单个文件操作，对其进行强制硬盘同步，<code>fsync</code> 将阻塞直到写入磁盘完成后返回，保证了数据持久化。</li>
<li><strong>文件重写（rewrite）</strong>：随着 AOF 文件越来越大，需要定期对 AOF 文件进行重写，达到压缩的目的。</li>
<li><strong>重启加载（load）</strong>：当 Redis 重启时，可以加载 AOF 文件进行数据恢复。</li>
</ol>
</li>
<li><p>写回磁盘策略</p>
<p>Redis 提供了 3 种写回硬盘的策略，控制的就是上面说的第三步的过程。 在 Redis.conf 配置文件中的 appendfsync 配置项可以有以下 3 种参数可填：</p>
<ul>
<li><p><strong>Always</strong>，这个单词的意思是「总是」，所以它的意思是每次写操作命令执行完后，同步将 AOF 日志数据写回硬盘；</p>
</li>
<li><p><strong>Everysec</strong>，这个单词的意思是「每秒」，所以它的意思是每次写操作命令执行完后，先将命令写入到 AOF 文件的内核缓冲区，然后每隔一秒将缓冲区里的内容写回到硬盘；</p>
</li>
<li><p><strong>No</strong>，意味着不由 Redis 控制写回硬盘的时机，转交给操作系统控制写回的时机，也就是每次写操作命令执行完后，先将命令写入到 AOF 文件的内核缓冲区，再由操作系统决定何时将缓冲区内容写回硬盘。</p>
</li>
</ul>
</li>
<li><p>AOF重写：由后台线程执行</p>
<p>Redis 为了避免 AOF 文件越写越大，提供了 <strong>AOF 重写机制</strong>，当 AOF 文件的大小超过所设定的阈值后，Redis 就会启用 AOF 重写机制，来压缩 AOF 文件。</p>
<p>AOF 重写机制是在重写时，读取当前数据库中的所有键值对，然后将每一个键值对用一条命令记录到「新的 AOF 文件」。</p>
<p>AOF 文件重写期间，Redis 还会维护一个 <strong>AOF 重写缓冲区</strong>，该缓冲区会在子进程创建新 AOF 文件期间，记录服务器执行的所有写命令。当子进程完成创建新 AOF 文件的工作之后，服务器会将重写缓冲区中的所有内容追加到新 AOF 文件的末尾，使得新的 AOF 文件保存的数据库状态与现有的数据库状态一致。最后，服务器用新的 AOF 文件替换旧的 AOF 文件，以此来完成 AOF 文件重写操作。</p>
</li>
</ul>
<h4 id="RDB-快照"><a href="#RDB-快照" class="headerlink" title="RDB 快照"></a><strong>RDB 快照</strong></h4><p>Redis 可以通过创建快照来获得存储在内存里面的数据在 <strong>某个时间点</strong> 上的副本，以二进制的方式写入磁盘；</p>
<p>恢复数据时， RDB 恢复数据的效率会比 AOF 高些，因为直接将 RDB 文件读入内存就可以。</p>
<ul>
<li><p>RDB 做快照时会阻塞线程吗？</p>
<p>Redis 提供了两个命令来生成 RDB 文件，分别是 save 和 bgsave，他们的区别就在于是否在「主线程」里执行：</p>
<ul>
<li><p>执行了 save 命令，就会在主线程生成 RDB 文件，由于和执行操作命令在同一个线程，所以如果写入 RDB 文件的时间太长，<strong>会阻塞主线程</strong>；</p>
</li>
<li><p>执行了 bgsave 命令，<strong>会创建一个子进程来生成 RDB 文件</strong>，这样可以<strong>避免主线程的阻塞</strong>；</p>
</li>
</ul>
</li>
</ul>
<p>Redis 还可以通过配置文件的选项来实现每隔一段时间自动执行一次 bgsave 命令，默认会提供以下配置:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">save <span class="number">900</span> <span class="number">1</span> <span class="comment">// 900s之内至少1次修改</span></span><br><span class="line">save <span class="number">300</span> <span class="number">10</span></span><br><span class="line">save <span class="number">60</span> <span class="number">10000</span></span><br></pre></td></tr></table></figure>

<p>执行 bgsave 过程中，Redis 依然<strong>可以继续处理操作命令</strong>的，也就是数据是能被修改的，关键的技术就在于<strong>写时复制技术（Copy-On-Write, COW）。</strong></p>
<p>执行 bgsave 命令的时候，会通过 fork() 创建子进程，此时子进程和父进程是共享同一片内存数据的，因为创建子进程的时候，会复制父进程的页表，但是页表指向的物理内存还是一个，此时如果主线程执行读操作，则主线程和 bgsave 子进程互相不影响；如果主线程执行写操作，则被修改的数据会复制一份副本，然后 bgsave 子进程会把该副本数据写入 RDB 文件，在这个过程中，主线程仍然可以直接修改原来的数据。</p>
<h4 id="混合持久化方式"><a href="#混合持久化方式" class="headerlink" title="混合持久化方式"></a><strong>混合持久化方式</strong></h4><p>Redis 4.0 新增的方式，集成了 AOF 和 RBD 的优点；</p>
<p>RDB 优点是数据恢复速度快，但是快照的频率不好把握。频率太低，丢失的数据就会比较多，频率太高，就会影响性能。</p>
<p>AOF 优点是丢失数据少，但是文件体积大且数据恢复不快。</p>
<p>混合持久化工作在 <strong>AOF 日志重写过程</strong>，当开启了混合持久化时，在 AOF 重写日志时，fork 出来的重写子进程会先将与主线程共享的内存数据以 RDB 方式写入到 AOF 文件，然后主线程处理的操作命令会被记录在重写缓冲区里，<strong>重写缓冲区里的增量命令会以 AOF 方式写入到 AOF 文件</strong>，写入完成后通知主进程将新的含有 RDB 格式和 AOF 格式的 AOF 文件替换旧的的 AOF 文件。</p>
<p>也就是说，使用了混合持久化，AOF 文件的<strong>前半部分是 RDB 格式的全量数据，后半部分是 AOF 格式的增量数据</strong>。这样的好处在于，重启 Redis 加载数据的时候，由于前半部分是 RDB 内容，这样<strong>加载的时候速度会很快</strong>。加载完 RDB 的内容后，才会加载后半部分的 AOF 内容，这里的内容是 Redis 后台子进程重写 AOF 期间，主线程处理的操作命令，可以使得<strong>数据更少的丢失</strong>。</p>
<p><strong>混合持久化优点：</strong></p>
<ul>
<li>混合持久化结合了 RDB 和 AOF 持久化的优点，开头为 RDB 的格式，使得 Redis 可以更快的启动，同时结合 AOF 的优点，减低了大量数据丢失的风险。</li>
</ul>
<h4 id="RDB与AOF对比"><a href="#RDB与AOF对比" class="headerlink" title="RDB与AOF对比"></a>RDB与AOF对比</h4><p><strong>RDB 比 AOF 优秀的地方</strong>：</p>
<ul>
<li>RDB 文件存储的内容是经过压缩的二进制数据， 保存着某个时间点的数据集，文件很小，适合做数据的备份，灾难恢复。AOF 文件存储的是每一次写命令，类似于 MySQL 的 binlog 日志，通常会比 RDB 文件大很多。当 AOF 变得太大时，Redis 能够在后台自动重写 AOF。新的 AOF 文件和原有的 AOF 文件所保存的数据库状态一样，但体积更小。</li>
<li>使用 RDB 文件恢复数据，直接解析还原数据即可，不需要一条一条地执行命令，速度非常快。而 AOF 则需要依次执行每个写命令，速度非常慢。也就是说，与 AOF 相比，恢复大数据集的时候，RDB 速度更快。</li>
</ul>
<p><strong>AOF 比 RDB 优秀的地方</strong>：</p>
<ul>
<li>RDB 的数据安全性不如 AOF，没有办法实时或者秒级持久化数据。生成 RDB 文件的过程是比较繁重的， 虽然 BGSAVE 子进程写入 RDB 文件的工作不会阻塞主线程，但会对机器的 CPU 资源和内存资源产生影响，严重的情况下甚至会直接把 Redis 服务干宕机。AOF 支持秒级数据丢失（取决 fsync 策略，如果是 everysec，最多丢失 1 秒的数据），仅仅是追加命令到 AOF 文件，操作轻量。</li>
</ul>
<p><strong>综上</strong>：</p>
<ul>
<li>Redis 保存的数据丢失一些也没什么影响的话，可以选择使用 RDB。</li>
<li>不建议单独使用 AOF，因为时不时地创建一个 RDB 快照可以进行数据库备份、更快的重启以及解决 AOF 引擎错误。</li>
<li>如果保存的数据要求安全性比较高的话，建议同时开启 RDB 和 AOF 持久化或者开启 RDB 和 AOF 混合持久化。</li>
</ul>
<h3 id="缓存设计"><a href="#缓存设计" class="headerlink" title="缓存设计"></a>缓存设计</h3><p>key的设计：[业务名]:[数据名]:[主键]</p>
<h4 id="常见问题-1"><a href="#常见问题-1" class="headerlink" title="常见问题"></a>常见问题</h4><ul>
<li><p>缓存穿透</p>
<p>查询的数据既不在缓存中，也不在数据库中。故请求直达数据库，一般为恶意攻击。</p>
<p>解决方案：</p>
<ol>
<li><p>缓存空对象：存储层未命中后，仍然将空值存入缓存层，并设置一个<strong>较短</strong>的过期时间。客户端再次访问数据时，缓存层会直接返回空值。</p>
<blockquote>
<p>为什么要较短的过期时间？如果这个时候数据库突然又有了对应数据，就会存在不一致问题。</p>
</blockquote>
</li>
<li><p>布隆过滤器：把所有可能存在的请求的值都存放在布隆过滤器中，当用户请求过来，先判断用户发来的请求的值是否存在于布隆过滤器中，若请求的数据不存在则直接返回空值。</p>
<p>缺点：</p>
<ul>
<li>布隆过滤器可能会存在误判的情况。总结来说就是：<strong>布隆过滤器说某个元素存在，小概率会误判（随着里面内容的增加，误判率就会随之上升）。布隆过滤器说某个元素不在，那么这个元素一定不在。</strong></li>
<li>不允许有删除操作。会导致其中的无效元素可能会越来越多，即实际已经在磁盘删除中的元素，但在bloomfilter中还认为可能存在，这会造成越来越多的false positive（假阳性）。</li>
</ul>
<p>底层：bitmap + k个hash函数</p>
<p>当一个元素加入位图时，通过k个hash函数将元素映射到位图的k个点，并把它们置1；当检索时，再通过k个hash函数运算检查位图的k个点是否都为1；如果有不为1的点，那么认为该key不存在；如果全部为1，则可能存在（<strong>不同的字符串可能哈希出来的位置相同</strong>）。</p>
<blockquote>
<p>“我们提到了布隆过滤器清除状态比较困难，但有些缓存数据是有生命周期的，比如一周或者一个月之后就大概率过期了，你有没有什么好办法可以帮助我们更好地清理过期数据呢？”</p>
<p>解决：每过一定的周期就建立一个新的布隆过滤器B，和原有的布隆过滤器A保持双写，再过一段时间后，A与B的指代交换，然后删除A。</p>
<p>注：Redis Bloom 的布隆当容量超出设定值，会创建一个2倍大小的<em>子过滤器</em>，查询时依次检索</p>
<p>布隆过滤器及其变种对比</p>
<p>Cuckoo（ [ˈkʊku:]） Filter相比Bloom Filter优点：</p>
<ol>
<li><p>支持删除数据。布隆过滤器因为多个元素可能映射到同一个点位，因此不能删除。而布谷鸟过滤器每个元素只对应一个位置。</p>
</li>
<li><p>比 Bloom filters 具有更好的<strong>查询</strong>性能（默认2个bucket，最多两次访存。布隆有k个hash函数，需要k次访存。写性能布隆更优）。</p>
</li>
<li><p>论文里说在误判率小于 3% 的情况下，大概能比 Bloom filters 节省 40% 多空间。（布谷鸟过滤器误判的情况：元素不存在，但是它的两个bucket中对应位置都被其他元素占了）。我看了一下Redisbloom的这两个过滤器，误判率为1.56%的情况下，cuckooFilter大概省20%+</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">error_rate = (buckets * hash_functions)/2^fingerprint_size = (buckets*2)/256，即默认为1.56%</span><br><span class="line">https://redis.io/docs/data-types/probabilistic/cuckoo-filter/#sizing-cuckoo-filters</span><br></pre></td></tr></table></figure></li>
</ol>
<p>缺点：</p>
<ol>
<li><p>长度必须是2的幂次</p>
</li>
<li><p>插入数据性能比布隆差，负载越大插入越慢（因为可能踢来踢去）</p>
<p>实测：差不多，因为瓶颈主要是网络</p>
</li>
<li><p>Cuckoo误判率较高，redis的Cuckoo最低貌似只能达到1&#x2F;128的误判率</p>
</li>
</ol>
<p>原理：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/429437541/answer/3015446209">https://www.zhihu.com/question/429437541/answer/3015446209</a></p>
<p>cuckoo hash 使用 2 个 hash 函数得到 2 个 bucket 的位置，但是 cuckoo filter 中首先利用 hash 函数得到 bucket1， 然后利用下面公式得到 bucket2 的位置。<code>bucket2 = bucket1 ⊕ hash(fingerprint)</code><br>这样就可以利用异或 hash(fingerprint) 通过一个 bucket 的位置来获取另外一个 bucket 的位置。</p>
<ol>
<li>它的哈希函数是成对的（具体的实现可以根据需求设计），每一个元素都是两个哈希函数，分别映射到两个位置，一个是记录的位置，另一个是备用位置。这个备用位置是处理碰撞时用的。</li>
<li>cuckoo hash 处理碰撞的方法，主要把原来占用位置的这个元素踢走; 被踢出去的元素插入到它的备用位置。如果备用位置上还有人，再把它踢走，如此往复。直到被踢的次数达到一个上限，才确认哈希表已满，并执行 rehash 操作（默认2倍扩容，生成一个2倍大小的子过滤器）。</li>
</ol>
<p>它有两个 hash 表，记为 T1，T2。两个 hash 函数，记为 h1，h2。</p>
<p>当一个<em>不存在的元素</em>插入的时候，会先根据 h1 计算出其在 T1 表的位置，如果该位置为空则可以放进去。</p>
<p>如果该位置不为空，则根据 h2 计算出其在 T2 表的位置，如果该位置为空则可以放进去。</p>
<p>如果该位置不为空，就把当前位置上的元素踢出去，然后把当前元素放进去就行了。</p>
<p>也可以随机踢出两个位置中的一个，总之会有一个元素被踢出去。</p>
<p>举个例子：</p>
<p>我想要插入元素 x，经过两个 hash 函数计算后，它的两个位置分别为 T1 表的 2 号位置和 T2 表的 1 号位置。</p>
<p><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="http://oss.ripplesu.top/blog/Typora/%E9%9D%A2%E8%AF%95%E9%A2%98/v2-827d8877490a14c1427f71594ee52570_720w.webp" alt="布谷鸟过滤器插入示例1"></p>
<p>两个位置都被占了，那就随机把 T1 表 2 号位置上的 y 踢出去吧。</p>
<p>而 y 的另一个位置被 z 元素占领了。</p>
<p>于是 y 毫不留情把 z 也踢了出去。</p>
<p>z 发现自己的备用位置还空着（虽然这个备用位置也是元素 v 的备用位置），赶紧就位。</p>
<p>所以，当 x 插入之后，图就变成了这样：</p>
<p><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="http://oss.ripplesu.top/blog/Typora/%E9%9D%A2%E8%AF%95%E9%A2%98/v2-cc7f200ac26f61e2a183a9705a8510b9_720w.webp" alt="布谷鸟过滤器插入示例2"></p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://www.modb.pro/db/32203">https://www.modb.pro/db/32203</a></p>
<p><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="http://oss.ripplesu.top/blog/Typora/%E9%9D%A2%E8%AF%95%E9%A2%98/modb_019e53dc-f634-11ea-9c9b-5254001c05fe.png" alt="布隆过滤器及其变种对比"></p>
</li>
<li><p><strong>非法请求的限制</strong>：做好参数校验，过滤非法请求；限制ip</p>
</li>
</ol>
</li>
<li><p>缓存击穿</p>
<p>热点数据（在数据库中）突然失效，大量请求直达数据库，瞬间对数据库造成巨大压力。</p>
<p>解决思路主要有两种：</p>
<ol>
<li><p>永不过期：热点数据不设置过期时间，所以不会出现上述问题，这是“物理”上的永不过期。</p>
<p>或者为每个数据设置<strong>逻辑过期</strong>时间。命中缓存后，将value取出，判断value中的逻辑过期时间，如果没有过期，则直接返回redis中的旧数据；如果过期，则在开启独立线程去重构缓存，然后直接返回之前的数据。（或访问时续期，但每次访问都多一次写操作，性能差）</p>
<p>对于时间确定，可以预知是一个热点key的情况，比如秒杀场景（或项目中的考试场景），可以提前预热数据到缓存中，并保证在活动时间内缓存不会过期。</p>
</li>
<li><p>加互斥锁：对数据的访问加互斥锁（如用setnx），当一个线程访问该数据时，获取到了锁的线程前往查询数据库，查询后将数据写入redis，再释放锁；其他线程只能休眠一段时间后重试。</p>
</li>
</ol>
</li>
<li><p>缓存雪崩</p>
<p>缓存中有大量数据同时过期，或是Redis宕机，导致大量请求直达数据库。</p>
<ol>
<li>避免数据同时过期：设置过期时间时，附加一个随机数，使过期时间分布尽量均匀，避免大量的key同时过期。</li>
<li>多级缓存（二级缓存失效，一级缓存可能还命中，不会直达数据库）</li>
<li>构建高可用的Redis服务：采用哨兵或集群模式，部署多个Redis实例，个别节点宕机，依然可以保持服务的整体可用。</li>
<li>启用限流、降级和熔断措施：在发生雪崩时，若应用访问的不是核心数据，则直接返回预定义信息&#x2F;空值&#x2F;错误信息。或者在发生雪崩时，对于访问缓存接口的请求，客户端并不会把请求发给Redis，而是直接返回。</li>
</ol>
</li>
</ul>
<h5 id="大key与热key"><a href="#大key与热key" class="headerlink" title="大key与热key"></a>大key与热key</h5><ul>
<li><p>大key</p>
<p>简单来说，如果一个 key 对应的 value 所占用的内存比较大，那这个 key 就可以看作是 bigkey。具体多大才算大呢？有一个不是特别精确的参考标准：string 类型的 value 超过 10 kb，复合类型的 value 包含的元素超过 5000 个（对于复合类型的 value 来说，不一定包含的元素越多，占用的内存就越多）。</p>
<ul>
<li><p><strong>客户端超时阻塞</strong>。由于 Redis 执行命令是单线程处理，然后在操作大 key 时会比较耗时，那么就会阻塞 Redis，从客户端这一视角看，就是很久很久都没有响应。</p>
</li>
<li><p><strong>引发网络阻塞</strong>。每次获取大 key 产生的网络流量较大，如果一个 key 的大小是 1 MB，每秒访问量为 1000，那么每秒会产生 1000MB 的流量，这对于普通千兆网卡的服务器来说是灾难性的。</p>
</li>
<li><p><strong>阻塞工作线程</strong>。如果使用 del 删除大 key 时，会阻塞工作线程，这样就没办法处理后续的命令。</p>
</li>
<li><p><strong>内存分布不均</strong>。集群模型在 slot 分片均匀情况下，会出现数据和查询倾斜情况，部分有大 key 的 Redis 节点占用内存多，QPS 也会比较大。</p>
<ul>
<li><p>注：</p>
<p>TPS：即每秒处理事务数，QPS：每秒查询率。</p>
<p>对于一个页面的一次访问，形成一个Tps；但一次<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E9%A1%B5%E9%9D%A2%E8%AF%B7%E6%B1%82&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2429686279%7D">页面请求</a>，可能产生多次对服务器的请求，服务器对这些请求，就可计入“Qps”之中。</p>
<p>例如：访问一个页面会请求服务器3次，产生一个“T”，产生3个“Q”</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><strong>使用 Redis 自带的 <code>--bigkeys</code> 参数来查找</strong></li>
</ul>
<p>如何处理 bigkey？</p>
<p>bigkey 的常见处理以及优化办法如下（这些方法可以配合起来使用）：</p>
<ul>
<li><strong>分割 bigkey</strong>：将一个 bigkey 分割为多个小 key。这种方式需要修改业务层的代码，一般不推荐这样做。</li>
<li><strong>手动清理</strong>：Redis 4.0+ 可以使用 <code>UNLINK</code> 命令来<strong>异步删除</strong>一个或多个指定的 key。Redis 4.0 以下可以考虑使用 <code>SCAN</code> 命令结合 <code>DEL</code> 命令来分批次删除。</li>
<li><strong>开启 lazy-free（惰性删除&#x2F;延迟释放）</strong> ：lazy-free 特性是 Redis 4.0 开始引入的，指的是让 Redis 采用异步方式延迟释放 key 使用的内存，将该操作交给单独的子线程处理，避免阻塞主线程。</li>
</ul>
</li>
</ul>
<ul>
<li><h4 id="什么是-hotkey？"><a href="#什么是-hotkey？" class="headerlink" title="什么是 hotkey？"></a>什么是 hotkey？</h4><p>简单来说，如果一个 key 的访问次数比较多且明显多于其他 key 的话，那这个 key 就可以看作是 hotkey。例如在 Redis 实例的每秒处理请求达到 5000 次，而其中某个 key 的每秒访问量就高达 2000 次，那这个 key 就可以看作是 hotkey。hotkey 出现的原因主要是某个热点数据访问量暴增，如重大的热搜事件、参与秒杀的商品。</p>
<p>处理 hotkey 会占用大量的 CPU 和带宽，可能会影响 Redis 实例对其他请求的正常处理。</p>
<ul>
<li><strong>使用 Redis 自带的 <code>--hotkeys</code> 参数来查找。</strong>前提是内存淘汰策略选择<strong>LFU</strong></li>
</ul>
<h4 id="如何解决-hotkey？"><a href="#如何解决-hotkey？" class="headerlink" title="如何解决 hotkey？"></a>如何解决 hotkey？</h4><p>hotkey 的常见处理以及优化办法如下（这些方法可以配合起来使用）：</p>
<ul>
<li><strong>读写分离</strong>：主节点处理写请求，从节点处理读请求。</li>
<li><strong>使用 Redis Cluster</strong>：将热点数据分散存储在多个 Redis 节点上。</li>
<li><strong>二级缓存</strong>：hotkey 采用二级缓存的方式进行处理，将 hotkey 存放一份到 JVM 本地内存中（可以用 Caffeine）。</li>
</ul>
</li>
</ul>
<h5 id="慢查询-1"><a href="#慢查询-1" class="headerlink" title="慢查询"></a>慢查询</h5><p>慢查询日志主要用于记录Redis实例中<strong>执行时间</strong>超过指定阈值的命令。</p>
<ul>
<li><p><code>config set slowlog-log-slower-than n</code>设置慢查询阈值</p>
<ul>
<li>值为正数，执行时间大于该值设置的微秒时才记录到慢日志中。默认 10000 微秒。</li>
<li>值为负数，禁用慢查询日志。</li>
<li>值为 0，所有命令都记录到慢日志中</li>
</ul>
</li>
<li><p><code>slowlog-max-len</code></p>
<ul>
<li>慢查询日志长度，最小值为零。默认 128</li>
<li>当记录新命令并且当前慢日志已达到最大长度时，最旧的一条记录将被删除。</li>
</ul>
</li>
<li><p><code>slowlog reset</code>清空日志</p>
</li>
<li><p>慢查询日志输出格式</p>
<p>1）每条日志唯一标识符</p>
<p>2）命令执行时的<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E6%97%B6%E9%97%B4%E6%88%B3&spm=1001.2101.3001.7020">时间戳</a></p>
<p>3）命令执行消耗的时间，单位微秒</p>
<p>4）执行的命令数组</p>
<p>5）客户端地址和端口 （仅 4.0 以上版本支持）</p>
<p>6）客户端名称 （仅 4.0 以上版本支持，默认名称为空，需要通过 client setname 命令进行设置）</p>
</li>
</ul>
<h5 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h5><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/nNEuYw0NlYGhuKKKKoWfcQ">https://mp.weixin.qq.com/s/nNEuYw0NlYGhuKKKKoWfcQ</a></p>
<h4 id="缓存更新策略"><a href="#缓存更新策略" class="headerlink" title="缓存更新策略"></a>缓存更新策略</h4><p>腾讯云：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/uex9zkf2uPeTp56cfv4dHA">https://mp.weixin.qq.com/s/uex9zkf2uPeTp56cfv4dHA</a></p>
<ul>
<li><p>Cache Aside（旁路缓存）策略；</p>
</li>
<li><p>Read&#x2F;Write Through（读穿 &#x2F; 写穿）策略：<strong>同步更新 cache 和 db</strong>。</p>
<p>Read-Through意为读穿透模式，它的流程和Cache-Aside类似，不同点在于Read-Through中多了一个访问控制层，读请求只和该访问控制层进行交互，而背后缓存命中与否的逻辑则由访问控制层与数据源进行交互，业务层的实现会更加简洁，并且对于缓存层及持久化层交互的封装程度更高，更易于移植。</p>
<p>Write-Through意为直写模式，对于Write-Through直写模式来说，它也增加了访问控制层来提供更高程度的封装。不同于Cache-Aside的是，Write-Through直写模式在写请求更新数据库之后，并不会删除缓存，而是更新缓存。缺点：更新效率低，并且两个写操作任何一次写失败都会造成数据不一致。</p>
</li>
<li><p>Write Behind Caching（<strong>Write-back</strong>）：Write behind意为异步回写模式，它也具有类似Read-Through&#x2F;Write-Through的访问控制层，不同的是，Write behind在处理写请求时，只更新缓存而不更新数据库，对于数据库的更新，则是通过<strong>批量异步更新</strong>的方式进行的，批量写入的时间点可以选在数据库负载较低的时间进行。</p>
<p>在Write-Behind模式下，写请求延迟较低，减轻了数据库的压力，具有较好的吞吐性。但数据库和缓存的一致性较弱，比如当更新的数据还未被写入数据库时，直接从数据库中查询数据是落后于缓存的。同时，缓存的负载较大，如果缓存宕机会导致数据丢失，所以需要做好缓存的高可用。显然，Write behind模式下适合大量写操作的场景，常用于电商秒杀场景中库存的扣减。</p>
<p><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="https://s2.loli.net/2023/07/11/SmT9BQE3fCq4bc7.png" alt="Write-Behind"></p>
</li>
</ul>
<h5 id="Cache-Aside（旁路缓存）策略"><a href="#Cache-Aside（旁路缓存）策略" class="headerlink" title="Cache Aside（旁路缓存）策略"></a>Cache Aside（旁路缓存）策略</h5><p>携程：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/E-chAZyHtaZOdA19mW59-Q">https://mp.weixin.qq.com/s/E-chAZyHtaZOdA19mW59-Q</a></p>
<p>旁路缓存策略是比较常用的方法，它需要由缓存的调用者同时维护数据库与缓存。具体又可以细分为读和写两种策略。<br>读策略较为简单，只需要先从缓存中读取数据，缓存命中则直接将对应数据返回；缓存未命中，则从数据库中读出对应的数据返回，同时将数据放入缓存中。<br>而写策略就需要考虑如下两个问题：</p>
<h5 id="数据写入数据库时，是删除缓存还是更新缓存？"><a href="#数据写入数据库时，是删除缓存还是更新缓存？" class="headerlink" title="数据写入数据库时，是删除缓存还是更新缓存？"></a>数据写入数据库时，是删除缓存还是更新缓存？</h5><ul>
<li><p>更新缓存：更新缓存的<strong>消耗比较大</strong>。如果数据需要经过复杂的计算再写入缓存，那么频繁的更新缓存，就会影响服务器的性能。如果是写入数据频繁的业务场景，那么可能频繁的更新缓存时，却没有业务读取该数据。</p>
<p>另外，如果同时有请求A和请求B进行更新操作，那么会出现</p>
<ol>
<li>线程A更新了数据库</li>
<li>线程B更新了数据库</li>
<li>线程B更新了缓存</li>
<li>线程A更新了缓存</li>
</ol>
<p>这就出现请求A更新缓存应该比请求B更新缓存早才对，但是因为网络等原因，B却比A更早更新了缓存。这就导致了<strong>脏数据</strong>，因此不考虑。</p>
</li>
<li><p>删除缓存：更新数据库时让缓存失效，查询时再更新缓存。减少了无效操作，一般采用这种策略。</p>
</li>
</ul>
<h5 id="先操作缓存还是数据库？"><a href="#先操作缓存还是数据库？" class="headerlink" title="先操作缓存还是数据库？"></a>先操作缓存还是数据库？</h5><h6 id="先删缓存，再操作数据库"><a href="#先删缓存，再操作数据库" class="headerlink" title="先删缓存，再操作数据库"></a>先删缓存，再操作数据库</h6><ul>
<li><p>异常情况<br>异常情况下，线程1删除缓存后，在执行更新数据库操作完成前，线程2查询缓存但未命中，故前往查询数据库。而此时线程1的更新操作尚未完成，于是线程2得到了旧数据，并将其写入缓存。这样就产生了缓存与数据库不一致的现象。由于更新缓存的速度远高于更新数据库，因此异常情况发生概率较高。<img src="http://oss.ripplesu.top/blog/loading.gif" data-original="https://s2.loli.net/2023/05/27/5nUyRw2Z1gY8obz.png" alt="image.png"></p>
<p>3和4可以交换顺序。</p>
<p>为什么要延时？如果3和4交换顺序，更新了数据库后马上删缓存，而此时线程2还未写入缓存，则无效删除。</p>
<blockquote>
<p>延时双删</p>
</blockquote>
<p>上面我们提到，如果是先删缓存、再更新数据库，在没有出现失败时可能会导致数据的不一致。如果在实际的应用中，出于某些考虑我们需要选择这种方式，那有办法解决这个问题吗？答案是有的，那就是采用延时双删的策略，延时双删的基本思路如下：</p>
<ol>
<li>删除缓存；</li>
<li>更新数据库；</li>
<li>sleep N毫秒（将失效指令放入延时队列，另一个线程轮询队列获取指令并执行。）；</li>
<li>再次删除缓存。</li>
</ol>
<p>延迟的实现可以在代码中sleep或采用延迟队列。显而易见的是，无论这个值如何预估，都很难和读请求的完成时间点准确衔接，这也是延时双删被诟病的主要原因。</p>
</li>
</ul>
<h6 id="先操作数据库，再删除缓存"><a href="#先操作数据库，再删除缓存" class="headerlink" title="先操作数据库，再删除缓存"></a>先操作数据库，再删除缓存</h6><ul>
<li><p>异常情况<br>线程1查询缓存前恰好缓存失效，故前往查询数据库；而此时线程2更新完数据库执行删除缓存操作；此后线程1将从数据库中查出的数据放入缓存，故产生了不一致现象。但这种情况出现的可能性较低，因为线程2要在线程1查询完数据库后写入缓存的极短时间内完成更新数据库的操作。<img src="http://oss.ripplesu.top/blog/loading.gif" data-original="https://s2.loli.net/2023/05/27/8gtIaZKSpFMUf1C.png" alt="image.png"></p>
<p>这种场景的出现，不仅需要缓存失效且读写并发执行，而且还需要读请求查询数据库的执行早于写请求更新数据库，同时读请求的执行完成晚于写请求。足以见得，这种不一致场景产生的条件非常严格，在实际的生产中出现的可能性较小。</p>
<p>除此之外，在并发环境下，Cache-Aside中也存在读请求命中缓存的时间点在写请求更新数据库之后，删除缓存之前，这样也会导致读请求查询到的缓存落后于数据库的情况。</p>
<p>虽然在下一次读请求中，缓存会被更新，但如果业务层面对这种情况的容忍度较低，为了避免并发带来的缓存不一致问题，需要将**”更新DB”+”删除缓存”、”查询DB”+”更新缓存”两个流程都进行加锁，两处对应的锁key是相同的**。此处需要加的是分布式锁。加锁势必会导致吞吐量的下降，故采取加锁的方案应该对性能的损耗有所预期。</p>
<p><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="https://s2.loli.net/2023/07/11/mlXJWCf37jgreiv.png" alt="缓存更新与DB更新并发控制"></p>
<p>（1）缓存查询和DB更新的并发控制</p>
<p>查询操作流程中，先判断lock是否存在，若存在，则表示当前DB或缓存正在更新，不能直接查询缓存，在查询DB后返回数据。之所以这么做，还是由场景决定的，如前文所述，我们场景下的基本处理思路是，缓存仅作为“DB降压”的辅助手段，在不确定缓存数据是否最新的情况下，宁可多查询几次DB，也不要查询到缓存中的不一致数据。此外，更新操作相对于查询操作是很少的，在我们贷前服务中，读写比例约为8:1。</p>
<p>此处另外的一个可行方案是可在检测到有锁后可进行短暂的等待和重试，好处是可进一步增加缓存的命中率，但是多一次锁等待，可能会影响到查询接口的性能。可根据自身场景进行抉择。</p>
<p>此外，为了进行降级，在锁判断前也增加了降级开关判断，若降级开关开启，也会直接查询DB。而降级主要是由于redis故障引起的，下文详述。若检测是否有锁时发生了异常同样也会直接查询DB。</p>
<p>（2）缓存更新和DB更新的并发控制</p>
<p>查询操作流程中，若缓存不存在，则进行缓存的更新，在更新时候先尝试进行加锁，若当前有锁说明当前有DB或缓存正在更新，则进行等待和重试，从而可避免查询到DB中的老数据更新到缓存中。</p>
<p>其中lock2的流程（load cache），我们是同步进行的。另外一个可行的方案是，异步发起缓存的加载，可减少锁等待时间，但是若出现瞬时的高并发查询，可能缓存无法及时加载产生从而频繁产生瞬时压力。可根据自身场景进行抉择。</p>
</li>
</ul>
<p>综上所述，执行写操作时应先更新数据库，再删除缓存。<br>不过，这种方案还存在一个问题：万一<strong>缓存删除失败</strong>，那么缓存中的数据仍然是旧的数据。为了尽可能减小删除缓存失败带来的影响，应该为数据设置一个过期时间。</p>
<blockquote>
<p>如果必须保证更新数据库与删除缓存这两个操作都成功，可以考虑如下解决策略：</p>
</blockquote>
<ul>
<li><p>将删除缓存的操作加入到消息队列，利用其<strong>重试机制</strong>确保删除缓存操作成功。</p>
</li>
<li><p>通过Canal等中间件订阅Mysql的binlog，只要数据库更新成功，canal都会自动将消息投递给下游的消息队列。</p>
<blockquote>
<p>为什么要canal？删缓存可能失败，需要通过重试保证删除成功。不用canal，需要手动重试或发到消息队列。</p>
<p>用canal的好处：解耦和异步处理。通过将数据库的数据变更事件发送到消息队列中，可以实现数据库与应用程序之间的解耦。应用程序可以异步地从消息队列中消费数据变更事件，并根据需要进行处理，而不需要直接依赖数据库。</p>
</blockquote>
</li>
</ul>
<h4 id="强一致性策略"><a href="#强一致性策略" class="headerlink" title="强一致性策略"></a>强一致性策略</h4><p>上述策略只能保证数据的最终一致性。要想做到强一致，最常见的方案是 2PC、3PC、Paxos、Raft 这类一致性协议，但它们的性能往往比较差，而且这些方案也比较复杂，还要考虑各种容错问题。如果业务层要求必须读取数据的强一致性，可以采取以下策略：</p>
<p><strong>（1）暂存并发读请求</strong></p>
<p>在更新数据库时，先在 Redis 缓存客户端暂存并发读请求，等数据库更新完、缓存值删除后，再读取数据，从而保证数据一致性。</p>
<p><strong>（2）串行化</strong></p>
<p>读写请求入队列，工作线程从队列中取任务来依次执行</p>
<ol>
<li>修改服务 Service 连接池，id 取模选取服务连接，能够保证同一个数据的读写都落在同一个后端服务上</li>
<li>修改数据库 DB 连接池，id 取模选取 DB 连接，能够保证同一个数据的读写在数据库层面是串行的</li>
</ol>
<p><strong>（3）使用 Redis 分布式读写锁</strong></p>
<p>将淘汰缓存与更新库表放入同一把写锁中，与其它读请求互斥，防止其间产生旧数据。读写互斥、写写互斥、读读共享，可满足读多写少的场景数据一致，也保证了并发性。并根据逻辑平均运行时间、响应超时时间来确定过期时间。</p>
<h4 id="Redis分布式锁"><a href="#Redis分布式锁" class="headerlink" title="Redis分布式锁"></a>Redis分布式锁</h4><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/hvTx6_WSZ82ok3na7L1IiA">https://mp.weixin.qq.com/s/hvTx6_WSZ82ok3na7L1IiA</a></p>
<p>目前分布式锁的实现方式有3种主流方法，即：</p>
<ul>
<li><p>基于数据库实现分布式锁，此处的数据库指的是MySQL关系型数据库</p>
</li>
<li><ul>
<li><p>基于MySQL锁表</p>
<p>其实现原理是：创建一张锁表，对临界资源做唯一性约束，通过增加一条记录对某一资源上锁，释放锁时删除记录；一般不推荐此种用法。</p>
</li>
<li><p>数据库版本号乐观锁</p>
<p>在数据库的表中需要包含一个数字类型的字段version，读取数据时把version字段读出来，更新数据时判断当前version是否等于读取出来的version，并对当前version+1；如果等于就更新成功，不等于表示数据已过期更新失败。例如以积分体系为例，存在多种场景增加积分，通过乐观锁来保证数据的正确性。</p>
<p>乐观锁CR注意点:</p>
</li>
</ul>
</li>
<li><ul>
<li>where 条件一定要命中索引(最好是主键或者唯一索引)，否则会锁表；</li>
</ul>
</li>
<li><p>update table set 中必须要包含version &#x3D; version + 1；</p>
<ul>
<li>update 返回结果为0时，一定要根据业务场景进行相应的处理，自主重试或者抛异常；</li>
</ul>
</li>
<li><p>基于缓存实现分布式锁，此处的缓存指的是Redis</p>
</li>
<li><p>基于zookeeper&#x2F;etcd实现分布式锁</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>实现方式</th>
<th>优点</th>
<th>缺点</th>
<th>应用场景</th>
</tr>
</thead>
<tbody><tr>
<td>MySQL数据库表</td>
<td>易于理解&#x2F;易于实现</td>
<td>容易出现单点故障、死锁性能低&#x2F;可靠性低</td>
<td>适用于并发量低、性能要求低的场景</td>
</tr>
<tr>
<td>Redis分布式锁</td>
<td>性能高&#x2F;易于实现可跨集群部署，无单点故障</td>
<td>锁失效时间的控制不稳定稳定性低于ZooKeeper</td>
<td>适用于高并发、高性能场景</td>
</tr>
<tr>
<td>ZooKeeper分布式锁</td>
<td>无单点故障&#x2F;可靠性高不可重入&#x2F;无死锁问题</td>
<td>实现复杂性能低于缓存分布式锁</td>
<td>适用于大部分分布式场景，除对性能要求极高的场景</td>
</tr>
</tbody></table>
<h5 id="用setnx实现简单分布式锁"><a href="#用setnx实现简单分布式锁" class="headerlink" title="用setnx实现简单分布式锁"></a>用setnx实现简单分布式锁</h5><p>首先加锁的逻辑可以通过<code>setnx key value</code>来实现，第一个进入的线程执行成功，返回1，表示它抢到了锁。那么在线程执行完业务后，就把锁删除，表示释放锁。在此期间，没有抢到锁的线程需等待一段时间后重试。<br>如果客户端<strong>忘记解锁或解锁失败</strong>,那么这种情况就很有可能造成<strong>死锁</strong>。但如果直接给锁增加过期时间（减少死锁影响）即新增<code>expire key seconds</code>又会发生其他问题,即这两个命令并<strong>不是原子性</strong>的。那么如果第二步失败,依然无法避免死锁问题。考虑到如上问题,我们最终可以通过<code>set...nx...</code>命令,<strong>将加锁、过期命令编排到一起</strong>,把他们变成原子操作,这样就可以避免死锁。写法为**<code>set key value nx ex seconds</code>**。java中可以用如下方法实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String KEY_PREFIX=<span class="string">&quot;lock:&quot;</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> timeoutSec)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取线程标示</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">threadId</span> <span class="operator">=</span> Thread.currentThread().getId()</span><br><span class="line">    <span class="comment">// 获取锁</span></span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">success</span> <span class="operator">=</span> stringRedisTemplate.opsForValue()</span><br><span class="line">            .setIfAbsent(KEY_PREFIX + name, threadId + <span class="string">&quot;&quot;</span>, timeoutSec, TimeUnit.SECONDS);</span><br><span class="line">    <span class="keyword">return</span> Boolean.TRUE.equals(success);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//通过del删除锁</span></span><br><span class="line">    stringRedisTemplate.delete(KEY_PREFIX + name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="直接删除锁时可能导致误删问题"><a href="#直接删除锁时可能导致误删问题" class="headerlink" title="直接删除锁时可能导致误删问题"></a>直接删除锁时可能导致误删问题</h5><p>释放锁时，如果直接将锁删除，又会出现新的问题： <strong>持有锁的线程1</strong>在锁的内部出现了阻塞等情况，导致他的<strong>锁过期自动释放</strong>。这时<strong>线程2来尝试获得锁，就拿到了这把锁</strong>。然后线程2在持有锁执行过程中，<strong>线程1</strong>反应过来，<strong>继续执行</strong>，在任务完成后依然会尝试释放锁,因为它的代码逻辑规定它在任务结束后释放锁,但是它的锁早已经被释放了,此时就会<strong>把本应该属于线程2的锁进行删除</strong>。<br>解决方案：我们可以在加锁时为key的值赋一个随机且不重复的字符串,作为锁的<strong>标识</strong>，线程要记住这个标识（线程号？存在threadLocal中？）。在每个线程释放锁的时候，去判断一下当前这把锁是否属于自己，如果不属于自己，则不进行锁的删除。</p>
<p>具体实现代码如下，用UUID与线程id拼接作为锁的标识：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ID_PREFIX</span> <span class="operator">=</span> UUID.randomUUID().toString(<span class="literal">true</span>) + <span class="string">&quot;-&quot;</span>;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> timeoutSec)</span> &#123;</span><br><span class="line">   <span class="comment">// 获取线程标示</span></span><br><span class="line">   <span class="type">String</span> <span class="variable">threadId</span> <span class="operator">=</span> ID_PREFIX + Thread.currentThread().getId();</span><br><span class="line">   <span class="comment">// 获取锁</span></span><br><span class="line">   <span class="type">Boolean</span> <span class="variable">success</span> <span class="operator">=</span> stringRedisTemplate.opsForValue()</span><br><span class="line">                .setIfAbsent(KEY_PREFIX + name, threadId, timeoutSec, TimeUnit.SECONDS);</span><br><span class="line">   <span class="keyword">return</span> Boolean.TRUE.equals(success);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 获取线程标示</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">threadId</span> <span class="operator">=</span> ID_PREFIX + Thread.currentThread().getId();</span><br><span class="line">    <span class="comment">// 获取锁中的标示</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(KEY_PREFIX + name);</span><br><span class="line">    <span class="comment">// 判断标示是否一致</span></span><br><span class="line">    <span class="keyword">if</span>(threadId.equals(id)) &#123;</span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">        stringRedisTemplate.delete(KEY_PREFIX + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="锁的判断与删除的原子性问题"><a href="#锁的判断与删除的原子性问题" class="headerlink" title="锁的判断与删除的原子性问题"></a>锁的判断与删除的原子性问题</h5><p>如果锁的<strong>判断与释放</strong>这两步不是<strong>原子</strong>的，仍会导致误删。<br>例如：线程1现在持有锁之后，在执行业务逻辑过程中，他正准备删除锁，而且已经走到了条件判断的过程中，比如他已经拿到了当前这把<strong>锁确实是属于他自己的，正准备删除锁，但是此时他的锁到期了（或删除失败）</strong>。此时线程2进来并获得了锁，而线程1会接着往后执行，直接就会执行删除锁那行代码，相当于条件判断并没有起到作用。<br>要防止上述情况发生,就需要采用Lua脚本,<strong>通过Lua脚本将两个命令编排在一起,而整个Lua脚本的执行是原子的</strong>。<br>Redis提供的调用函数，语法如下：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis.call(<span class="string">&#x27;命令名称&#x27;</span>, <span class="string">&#x27;key&#x27;</span>, <span class="string">&#x27;其它参数&#x27;</span>, ...)</span><br></pre></td></tr></table></figure>

<p>实现判断并删除锁的lua脚本如下：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 这里的 KEYS[1] 就是锁的key，这里的ARGV[1] 就是当前线程标示</span></span><br><span class="line"><span class="comment">-- 获取锁中的标示，判断是否与当前线程标示一致</span></span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;GET&#x27;</span>, KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>]) <span class="keyword">then</span></span><br><span class="line">  <span class="comment">-- 一致，则删除锁</span></span><br><span class="line">  <span class="keyword">return</span> redis.call(<span class="string">&#x27;DEL&#x27;</span>, KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 不一致，则直接返回</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>java调用lua脚本实现锁的释放的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DefaultRedisScript&lt;Long&gt; UNLOCK_SCRIPT;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        UNLOCK_SCRIPT = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;();</span><br><span class="line">        UNLOCK_SCRIPT.setLocation(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;unlock.lua&quot;</span>));</span><br><span class="line">        UNLOCK_SCRIPT.setResultType(Long.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 调用lua脚本</span></span><br><span class="line">    stringRedisTemplate.execute(</span><br><span class="line">            UNLOCK_SCRIPT,</span><br><span class="line">            Collections.singletonList(KEY_PREFIX + name),</span><br><span class="line">            ID_PREFIX + Thread.currentThread().getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>基于Redis的分布式锁实现思路：</p>
<ul>
<li>利用set nx ex获取锁，并设置过期时间，保存线程标示</li>
<li>释放锁时先判断线程标示是否与自己一致，一致则删除锁</li>
<li>基于lua脚本，保证锁的判断与删除是原子的</li>
<li>特性：<ul>
<li>利用set nx满足互斥性</li>
<li>利用set ex保证故障时锁依然能释放，避免死锁，提高安全性</li>
<li>利用Redis集群保证高可用和高并发特性</li>
</ul>
</li>
</ul>
<h5 id="存在的问题（了解）"><a href="#存在的问题（了解）" class="headerlink" title="存在的问题（了解）"></a>存在的问题（了解）</h5><p>基于setnx实现的分布式锁存在下面的问题：</p>
<p><strong>重入问题</strong>：重入问题是指 获得锁的线程可以再次进入到相同的锁的代码块中，可重入锁的意义在于防止死锁，比如HashTable这样的代码中，他的方法都是使用synchronized修饰的，假如他在一个方法内，调用另一个方法，那么此时如果是不可重入的，不就死锁了吗？所以可重入锁他的主要意义是防止死锁，我们的synchronized和Lock锁都是可重入的。</p>
<p><strong>不可重试</strong>：是指目前的分布式只能尝试一次，我们认为合理的情况是：当线程在获得锁失败后，他应该能再次尝试获得锁。</p>
<p><strong>超时释放：</strong>我们在加锁时增加了过期时间，这样的我们可以防止死锁，但是如果卡顿的时间超长，虽然我们采用了lua表达式防止删锁的时候，误删别人的锁，但是毕竟没有锁住，有安全隐患</p>
<p><strong>主从一致性：</strong> 如果Redis提供了主从集群，当我们向集群写数据时，主机需要异步的将数据同步给从机，而万一在同步过去之前，主机宕机了，就会出现死锁问题。</p>
<p>解决：RedLock（Redisson）</p>
<p>RedLock算法思想，意思是不能只在一个redis实例上创建锁，应该是在多个redis实例上创建锁，<strong>n &#x2F; 2 + 1</strong>，必须在大多数redis节点上都成功创建锁，才能算这个整体的RedLock加锁成功</p>
<h5 id="Redisson分布式锁"><a href="#Redisson分布式锁" class="headerlink" title="Redisson分布式锁"></a>Redisson分布式锁</h5><p>在分布式锁中，他采用hash结构用来存储锁，其中大key表示表示这把锁是否存在，用小key表示当前这把锁被哪个线程持有。</p>
<p>lua脚本中一共有3个参数：</p>
<ul>
<li><p><strong>KEYS[1] ： 锁名称</strong></p>
</li>
<li><p><strong>ARGV[1]：  锁失效时间</strong></p>
</li>
<li><p><strong>ARGV[2]：  id + “:” + threadId; 锁的小key</strong></p>
</li>
</ul>
<p>源码中判断当前这个方法的返回值是否为null，如果是null，则对应则前两个if对应的条件，退出抢锁逻辑，如果返回的不是null，即走了第三个分支，在源码处会进行while(true)的自旋抢锁。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 锁是否存在，== <span class="number">0</span> 表示不存在</span><br><span class="line"><span class="string">&quot;if (redis.call(&#x27;exists&#x27;, KEYS[1]) == 0) then &quot;</span> +</span><br><span class="line">	// hash中写入 id + <span class="string">&quot;:&quot;</span> + threadId :  <span class="number">1</span></span><br><span class="line">	<span class="string">&quot;redis.call(&#x27;hset&#x27;, KEYS[1], ARGV[2], 1); &quot;</span> +</span><br><span class="line">	// 设置锁的过期时间</span><br><span class="line">	<span class="string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;</span> +</span><br><span class="line">	<span class="string">&quot;return nil; &quot;</span> +</span><br><span class="line"><span class="string">&quot;end; &quot;</span> +</span><br><span class="line">// 锁存在，判断锁是否是自己的</span><br><span class="line"><span class="string">&quot;if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[2]) == 1) then &quot;</span> +</span><br><span class="line">	// 如果是，则将计数值 + <span class="number">1</span></span><br><span class="line">	<span class="string">&quot;redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[2], 1); &quot;</span> +</span><br><span class="line">	// 设置过期时间</span><br><span class="line">	<span class="string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;</span> +</span><br><span class="line">	<span class="string">&quot;return nil; &quot;</span> +</span><br><span class="line"><span class="string">&quot;end; &quot;</span> +</span><br><span class="line">// 加锁失败，返回锁的过期时间</span><br><span class="line"><span class="string">&quot;return redis.call(&#x27;pttl&#x27;, KEYS[1]);&quot;</span></span><br></pre></td></tr></table></figure>

<p><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="https://s2.loli.net/2023/08/02/5faFUR6Wtpod1yD.png" alt="Redisson分布式锁"></p>
<p><strong>watch dog自动延期机制</strong></p>
<p>客户端1加锁的锁key默认生存时间才30秒，如果超过了30秒，客户端1还想一直持有这把锁，怎么办呢？</p>
<p>简单！只要客户端1一旦加锁成功，就会启动一个watch dog看门狗，**他是一个后台线程，会每隔**10秒**检查一下**，如果客户端1还持有锁key（计数值&gt;0），那么就会重置锁key的过期时间。</p>
<p><strong>MultiLock</strong></p>
<p>为了提高redis的可用性，我们会搭建集群或者主从，现在以主从为例</p>
<p>此时我们去写命令，写在主机上， 主机会将数据同步给从机，但是假设在主机还没有来得及把数据写入到从机去的时候，此时主机宕机，哨兵会发现主机宕机，并且选举一个slave变成master，而此时新的master中实际上并没有锁信息，此时锁信息就已经丢掉了。</p>
<p>为了解决这个问题，redission提出来了MutiLock锁，使用这把锁咱们就不使用主从了，每个节点的地位都是一样的， 这把锁加锁的逻辑需要写入到每一个主丛节点上，只有所有的服务器都写入成功，此时才是加锁成功，假设现在某个节点挂了，那么他去获得锁的时候，只要有一个节点拿不到，都不能算是加锁成功，就保证了加锁的可靠性。</p>
<h3 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h3><p>Redis 提供了基于“发布&#x2F;订阅”模式的消息机制，此种模式下，消息发布者和订阅者不进行直接通信，发布者客户端向指定的频道（channel）发布消 息，订阅该频道的每个客户端都可以收到该消息。</p>
<p>主要对应的 Redis 命令为:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">subscribe channel [channel ...] # 订阅一个或多个频道</span><br><span class="line">unsubscribe channel # 退订指定频道</span><br><span class="line">publish channel message # 发送消息</span><br><span class="line">psubscribe pattern # 订阅指定模式</span><br><span class="line">punsubscribe pattern # 退订指定模式</span><br></pre></td></tr></table></figure>

<p>使用案例：</p>
<p>打开一个 Redis 客户端，如向 TestChanne 说一声 hello:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; publish TestChanne hello</span><br><span class="line">(integer) 1 # 返回的是接收这条消息的订阅者数量</span><br></pre></td></tr></table></figure>

<p>这样消息就发出去了。发出去的消息不会被持久化，也就是有客户端订阅 TestChanne 后只能接收到后续发布到该频道的消息，之前的就接收不到了。</p>
<p>打开另一 Redis 个客户端，这里假设发送消息之前就打开并且订阅了 TestChanne 频道：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; subscribe TestChanne # 执行上面命令客户端会进入订阅状态</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) &quot;subscribe&quot; // 消息类型</span><br><span class="line">2) &quot;TestChanne&quot; // 频道</span><br><span class="line">3) &quot;hello&quot; // 消息内容</span><br></pre></td></tr></table></figure>

<p>我们可以利用 Redis 发布订阅功能，实现的简单 MQ 功能，实现上下游的解耦。不过需要注意了，由于 Redis 发布的消息<strong>不会被持久化</strong>，这就会导致新订阅的客户端将不会收到历史消息。所以，如果当前的业务场景不能容忍这些缺点，那还是用专业 MQ 吧。</p>
<p>优势</p>
<ul>
<li><p>消息具备广播能力</p>
</li>
<li><p>psubscribe能按字符串通配符匹配，给予了业务逻辑的灵活性</p>
</li>
<li><p>能订阅特定key或特定命令的系统消息</p>
</li>
</ul>
<p>不足</p>
<ul>
<li><p>Redis异常、客户端断连都会导致消息丢失</p>
</li>
<li><p>消息缺乏堆积能力，不能削峰填谷。推送的方式缺乏背压机制，没有考虑消费者处理能力，推送的消息超过消费者处理能力后可能导致消息丢失或服务异常</p>
</li>
</ul>
<p>可见，Pub&#x2F;Sub 模式不适合做消息存储，消息积压类的业务，而是擅长处理广播，即时通讯，即时反馈的业务。</p>
<h3 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_45076180/article/details/109532216">https://blog.csdn.net/qq_45076180/article/details/109532216</a></p>
<h4 id="主从"><a href="#主从" class="headerlink" title="主从"></a>主从</h4><h4 id="哨兵"><a href="#哨兵" class="headerlink" title="哨兵"></a>哨兵</h4><h4 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h4><h3 id="Caffeine"><a href="#Caffeine" class="headerlink" title="Caffeine"></a>Caffeine</h3><p>本地缓存基于本地环境的内存，访问速度非常快，对于一些变更频率低、实时性要求低的数据，可以放在本地缓存中，提升访问速度<br>使用本地缓存能够减少和Redis类的远程缓存间的数据交互，减少网络I&#x2F;O开销，降低这一过程中在网络通信上的耗时</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/348695568">https://zhuanlan.zhihu.com/p/348695568</a></p>
<p>优点：性能非常高</p>
<p>缺点：服务器内存有限，不能存大量数据；集群部署需要考虑本地缓存一致性问题</p>
<h4 id="淘汰算法"><a href="#淘汰算法" class="headerlink" title="淘汰算法"></a>淘汰算法</h4><h5 id="常见算法"><a href="#常见算法" class="headerlink" title="常见算法"></a>常见算法</h5><p><strong>FIFO(First In First Out)：先进先出。</strong></p>
<p>它是优先淘汰掉最先缓存的数据、是最简单的淘汰算法。缺点是如果先缓存的数据使用频率比较高的话，那么该数据就不停地进进出出，因此它的缓存命中率比较低。</p>
<p><strong>LRU(Least Recently Used)：最近最久未使用。</strong></p>
<p>它是优先淘汰掉最久未访问到的数据。缺点是不能很好地应对偶然的突发流量。比如一个数据在一分钟内的前59秒访问很多次，而在最后1秒没有访问，但是有一批冷门数据在最后一秒进入缓存，那么热点数据就会被冲刷掉。</p>
<p><strong>LFU(Least Frequently Used)：</strong></p>
<p>最近最少频率使用。它是优先淘汰掉最不经常使用的数据，需要维护一个表示使用频率的字段。</p>
<p>主要有两个缺点：</p>
<p>一、如果访问频率比较高的话，频率字段会占据一定的空间；</p>
<p>二、无法合理更新新上的热点数据，比如某个歌手的老歌播放历史较多，新出的歌如果和老歌一起排序的话，就永无出头之日。</p>
<p><strong>W-TinyLFU 算法</strong></p>
<p>Caffeine 使用了 W-TinyLFU 算法，解决了 LRU 和LFU上述的缺点。W-TinyLFU 算法由论文《TinyLFU: A Highly Efficient Cache Admission Policy》提出。</p>
<p>它主要干了两件事：</p>
<p>一、采用 Count–Min Sketch 算法降低频率信息带来的内存消耗；</p>
<p>二、维护一个PK机制保障新上的热点数据能够缓存。</p>
<h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>消息队列是一个存放消息的容器，用于在不同的应用程序之间传递消息。生产者将消息放到队列中，消费者按顺序从队列中取出消息进行处理。</p>
<p>消息队列选型：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/WuIjtx1PjICG4gFZE5X6-g">https://mp.weixin.qq.com/s/WuIjtx1PjICG4gFZE5X6-g</a></p>
<p><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="https://s2.loli.net/2023/08/21/TNEQW9qYusPfeo1.png" alt="消息队列对比"></p>
<p>注：RocketMQ可以做到消息0丢失，kafka可以做到最小概率丢失</p>
<p>Kafka 一开始的目的就是用于日志收集和传输，适合有大量数据产生的互联网业务，特别是<strong>大数据领域的实时计算、日志采集</strong>等场景，用 Kafka 绝对没错，社区活跃度高，业内标准。</p>
<p>RocketMQ 特别适用于金融互联网领域这类对于可靠性要求很高的场景，比如订单交易等，而且 RocketMQ 是阿里出品的，经历过那么多次淘宝双十一的考验，大品牌，在稳定性值得信赖。目前社区也比RabbitMQ活跃。因此如果公司对自己的技术实力有自信，基础架构研发实力较强，推荐用 RocketMQ。</p>
<p>RabbitMQ 适用于公司对外提供能力，可能会有很多主题接入的中台业务场景，毕竟它是百万级主题数的。它的时效性是毫秒级的，但实际毫秒级和微秒级在感知上没有什么太大的区别，所以它的这一大优点并不太会作为考量标准。同时，它的功能是比较完善的，开源社区活跃度高（目前低于RocketMQ），能解决开发中遇到的bug，所以万级别数据量业务场景的小公司可以优先选择功能完善的RabbitMQ。它的缺点就是用 Erlang 语言编写，所以很多开发人员很难去看懂源码并进行二次开发和维护，也就是说对于公司来说可能处于不可控的状态。</p>
<h3 id="消息队列作用"><a href="#消息队列作用" class="headerlink" title="消息队列作用"></a>消息队列作用</h3><ul>
<li><p>解耦</p>
<p>传统的软件开发模式，各个模块之间相互调用，每个模块都要时刻关注所调用的模块的是否更改或者是否执行成功等等。使用消息队列，可以避免模块之间直接调用，将所需共享的数据放在消息队列中，消息接受者对消息进行处理或包装后，构造成一个新的消息类型，将消息继续发送出去。对于新增业务模块，只要对该类消息感兴趣，即可订阅该类消息，对原有系统和业务没有任何影响，降低了系统各个模块的耦合度，提高了系统的可扩展性。</p>
</li>
<li><p>异步</p>
<p>很多时候应用不想或不需要立即处理消息，就可以将用户的请求数据存储到消息队列之后就立即返回结果，从而降低系统响应时间。随后，系统再慢慢对消息进行消费。</p>
<ul>
<li><p>不用MQ怎么实现异步？</p>
<ul>
<li>直接创建一个新线程去执行异步任务</li>
<li>提交任务到线程池</li>
<li>复杂一点可以用CompletableFuture结合线程池</li>
</ul>
<p>优点：实现简单，不需要考虑消息丢失、重复消费等问题。MQ需要引入消息中间件，增加了系统的复杂度和维护成本</p>
</li>
<li><p>MQ异步与多线程异步有何区别？</p>
<ul>
<li>处理任务的维度不同。多线程是在一个进程中可以有多个线程并发处理任务，MQ是把消息发送到不同节点的不同进程来处理任务。</li>
<li>数据可靠性不同。多线程数据基于内存来交互，消息队列可以将消息持久化。</li>
<li>分布式能力。MQ具备分布式能力，多线程只能在一个进程中去处理任务。</li>
</ul>
</li>
<li><p>另一种实现：Spring事件监听ApplicationEventPublisher</p>
<p>缺点：</p>
<ol>
<li>有限的可靠性：<code>ApplicationEventPublisher</code> 是在应用程序内部实现的，因此它依赖于应用程序的运行状态。如果应用程序崩溃或重启，那些未被处理的事件可能会丢失。与消息队列相比，消息队列通常具有持久化和可靠性保证，可以在应用程序故障后保留未处理的消息。</li>
<li>性能开销：尽管 <code>ApplicationEventPublisher</code> 是应用程序内部的实现，但它仍然需要遍历所有的事件监听器并调用它们的处理方法。如果事件监听器过多或处理逻辑复杂，可能会导致性能开销。</li>
<li>难以追踪和调试：由于事件的传播过程是通过接口和抽象类型进行定义的，它们的调用和处理过程可能比较难以跟踪和调试。相比之下，使用消息队列可以更容易地追踪和监控消息的传递和处理过程。</li>
</ol>
</li>
</ul>
</li>
<li><p>削峰</p>
<p>先将短时间产生的大量消息存储在消息队列中，然后后端服务再慢慢根据自己的能力去消费这些消息。高峰期的消息可以被积压起来，在随后的时间内进行平滑的处理完成，而不至于让系统短时间内无法承载而导致崩溃。常见场景：秒杀</p>
</li>
</ul>
<h3 id="使用消息队列会带来哪些问题？"><a href="#使用消息队列会带来哪些问题？" class="headerlink" title="使用消息队列会带来哪些问题？"></a>使用消息队列会带来哪些问题？</h3><ul>
<li><strong>系统可用性降低：</strong>消息丢失、重复消费、消费失败等</li>
<li><strong>系统复杂性提高：</strong> 加入 MQ 之后，你需要保证消息没有被重复消费、处理消息丢失的情况、保证消息传递的顺序性等</li>
<li><strong>一致性问题：</strong> 消息没有被正确消费导致数据不一致的情况</li>
</ul>
<h3 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h3><h4 id="发布-订阅模型-Kafka-消息模型"><a href="#发布-订阅模型-Kafka-消息模型" class="headerlink" title="发布-订阅模型:Kafka 消息模型"></a>发布-订阅模型:Kafka 消息模型</h4><p>队列模型<strong>使用队列（Queue）作为消息通信载体，满足生产者与消费者模式，一条消息只能被一个消费者使用，未被消费的消息在队列中保留直到被消费或超时。</strong> 比如：我们生产者发送 100 条消息的话，两个消费者来消费一般情况下两个消费者会按照消息发送的顺序各自消费一半（也就是你一个我一个的消费。）</p>
<p>发布-订阅模型主要是为了解决队列模型存在的问题，即单个消息分发给多个消费者处理。</p>
<p>发布订阅模型（Pub-Sub） 使用<strong>主题（Topic）</strong> 作为消息通信载体，类似于<strong>广播模式</strong>；发布者发布一条消息，该消息通过主题传递给所有的订阅者，<strong>在一条消息广播之后才订阅的用户则是收不到该条消息的</strong>。</p>
<p><strong>在发布 - 订阅模型中，如果只有一个订阅者，那它和队列模型就基本是一样的了。所以说，发布 - 订阅模型在功能层面上是可以兼容队列模型的。</strong></p>
<h4 id="为什么选择Kafka？"><a href="#为什么选择Kafka？" class="headerlink" title="为什么选择Kafka？"></a>为什么选择Kafka？</h4><p>这里就需要先了解Kakfa的特性。</p>
<ul>
<li>高吞吐、低延迟：kakfa 最大的特点就是收发消息非常快，kafka 每秒可以处理几十万条消息，它的最低延迟只有几毫秒（批量收发，其实时延相对高）。</li>
<li>伸缩性：每个主题(topic) 包含多个分区(partition)，主题中的分区可以分布在不同的主机(broker)中。</li>
<li>持久性、可靠性：Kafka能够允许数据的持久化存储，消息被持久化到磁盘，并支持数据备份防止数据丢失，Kafka底层的数据存储是基于Zookeeper存储的，Zookeeper我们知道它的数据能够持久存储。</li>
<li>容错性：允许集群中的节点失败，某个节点宕机，Kafka集群能够正常工作。</li>
<li>高并发：支持数千个客户端同时读写。</li>
</ul>
<p>吞吐量高，生态兼容性很好，可以方便地与其他大数据组件集成，如 Hadoop、Spark，在日志采集、大数据实时计算方面应用广泛，大数据领域的标准。但是功能相对少。</p>
<h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a><strong>缺点</strong></h5><p><strong>分区有序</strong>：仅在同一分区内保证有序，无法实现全局有序；</p>
<p><strong>无延时消息</strong>：消费顺序是按照写入时的顺序，不支持延时消息</p>
<p><strong>重复消费</strong>：消费系统宕机、重启导致 offset 未提交；</p>
<p><strong>Rebalance</strong>：Rebalance 的过程中 consumer group 下的所有消费者实例都会停止工作，等待 Rebalance 过程完成。</p>
<p>topic数量不能太大：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/1BOriPt5j4UvwIZ3Qs8F9A%EF%BC%88%E8%B7%9F%E9%A1%BA%E5%BA%8F%E5%86%99%E7%9B%98%E6%9C%89%E5%85%B3%EF%BC%89">https://mp.weixin.qq.com/s/1BOriPt5j4UvwIZ3Qs8F9A（跟顺序写盘有关）</a></p>
<h5 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a><strong>使用场景</strong></h5><p><strong>日志收集</strong>：大量的日志消息先写入 kafka，数据服务通过消费 kafka 消息将数据落地；</p>
<p><strong>消息系统</strong>：解耦生产者和消费者、缓存消息等；</p>
<p><strong>用户活动跟踪</strong>：kafka 经常被用来记录 web 用户或者 app 用户的各种活动，如浏览网页、搜索、点击等活动，这些活动信息被各个服务器发布到 kafka 的 topic 中，然后消费者通过订阅这些 topic 来做实时的监控分析，亦可保存到数据库；</p>
<p><strong>运营指标</strong>：记录运营、监控数据，包括收集各种分布式应用的数据，生产各种操作的集中反馈，比如报警和报告；</p>
<p><strong>流式处理</strong>、大数据实时计算：比如 spark streaming。</p>
<h4 id="Kafka为什么这么快？"><a href="#Kafka为什么这么快？" class="headerlink" title="Kafka为什么这么快？"></a>Kafka为什么这么快？</h4><p>Kafka 高可靠高性能原理探究<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/_g11mmmQse6KrkUE8x4abQ">https://mp.weixin.qq.com/s/_g11mmmQse6KrkUE8x4abQ</a></p>
<ol>
<li><p>Kafka通过<strong>零拷贝</strong>原理来快速移动数据（零拷贝并不是不需要拷贝，而是减少不必要的拷贝次数）。</p>
<ul>
<li><p>网络数据持久化到磁盘 (Producer 到 Broker)</p>
<p>通过<strong>mmap</strong>（Memory Mapped Files） 将内核中读缓冲区（read buffer）的地址与用户空间的缓冲区（user buffer）进行映射，从而实现内核缓冲区与应用程序内存的共享，<strong>省去了将数据从内核读缓冲区（read buffer）拷贝到用户缓冲区（user buffer）的过程</strong></p>
</li>
<li><p>磁盘文件通过网络发送（Broker 到 Consumer）</p>
<p>Kafka 在 Consumer 从 Broker 读数据过程中使用了 sendfile 技术。具体在这里采用的方案是通过 NIO 的 <code>transferTo/transferFrom</code> 调用操作系统的 sendfile 实现零拷贝，消除了 CPU 数据拷贝。</p>
</li>
</ul>
</li>
<li><p>Kafka 支持<strong>批量发送消息</strong>，将多个消息打包成一个批次进行发送，从而减少网络传输的开销，提高网络传输的效率和吞吐量。Kafka 的批量发送消息是通过以下两个参数来控制的：</p>
<ul>
<li><p>batch.size：控制批量发送消息的大小，默认值为 16KB，可适当增加 batch.size 参数值提升吞吐。但是，需要注意的是，<strong>如果批量发送的大小设置得过大，可能会导致消息发送的延迟增加，因此需要根据实际情况进行调整</strong>。</p>
</li>
<li><p>linger.ms：控制消息在批量发送前的等待时间，默认值为 0。当 linger.ms 大于 0 时，如果有消息发送，Kafka 会等待指定的时间，如果等待时间到达或者批量大小达到 batch.size，就会将消息打包成一个批次进行发送。可适当增加 linger.ms 参数值提升吞吐，比如 10 ～ 100。</p>
</li>
</ul>
<p>在 Kafka 的生产者客户端中，当发送消息时，如果启用了批量发送，Kafka 会将消息缓存到缓冲区中。当缓冲区中的消息大小达到 batch.size 或者等待时间到达 linger.ms 时，Kafka 会将缓冲区中的消息打包成一个批次进行发送。如果在等待时间内没有达到 batch.size，Kafka 也会将缓冲区中的消息发送出去，从而避免消息积压。</p>
</li>
<li><p>Kafka采取<strong>顺序写入磁盘</strong>的方式，避免了随机磁盘寻址的浪费（寻址开销小）。</p>
<p>kafka 为了提升系统吞吐、降低时延，Broker 接收到消息后只是将数据写入<strong>PageCache</strong>后便认为消息已写入成功，而 PageCache 中的数据通过 linux 的 flusher 程序进行异步刷盘（避免了同步刷盘的巨大系统开销），将数据<strong>顺序追加写</strong>到磁盘日志文件中。由于 pagecache 是在内存中进行缓存，因此读写速度非常快，可以大大提高读写效率。顺序追加写充分利用顺序 I&#x2F;O 写操作，避免了缓慢的随机 I&#x2F;O 操作，可有效提升 Kafka 吞吐。</p>
</li>
<li><p>Kafka 支持<strong>压缩</strong>技术，通过将消息进行压缩后再进行传输，从而减少网络传输的开销（压缩和解压缩的过程会消耗一定的 CPU 资源，因此需要根据实际情况进行调整）。</p>
</li>
</ol>
<h4 id="什么是-Producer、Consumer、Broker、Topic、Partition？"><a href="#什么是-Producer、Consumer、Broker、Topic、Partition？" class="headerlink" title="什么是 Producer、Consumer、Broker、Topic、Partition？"></a>什么是 Producer、Consumer、Broker、Topic、Partition？</h4><p>Kafka 将生产者发布的消息发送到 <strong>Topic（主题）</strong> 中，需要这些消息的消费者可以订阅这些 <strong>Topic（主题）</strong>，如下图所示：</p>
<p><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="https://s2.loli.net/2023/07/06/iU1FVNEksKjpo6Y.png" alt="img"></p>
<p>上面这张图也为我们引出了，Kafka 比较重要的几个概念：</p>
<ol>
<li><strong>Producer（生产者）</strong> : 生产者，负责消息的创建并通过一定的路由策略发送消息到合适的 Broker；</li>
<li><strong>Consumer（消费者）</strong> : 消费者，负责从 Broker 中拉取（Pull）订阅的消息并进行消费，通常多个消费者构成一个分组，消息只能被同组中的一个消费者消费；</li>
<li><strong>Broker（代理）</strong> : 可以看作是一个独立的 Kafka 实例，负责消息的持久化、中转等功能。多个 Kafka Broker 组成一个 Kafka Cluster。</li>
<li><strong>ZooKeeper</strong>：ZooKeeper 是一个分布式的协调服务，可以用于解决分布式系统中的一些常见问题，例如协调分布式进程、配置管理。负责 broker、consumer 集群元数据的管理等；（<strong>注意：Producer 端直接连接 broker，不在 zk 上存任何数据，只是通过 ZK 监听 broker 和 topic 等信息</strong></li>
</ol>
<p>同时，你一定也注意到每个 Broker 中又包含了 Topic 以及 Partition 这两个重要的概念：</p>
<ul>
<li><strong>Topic（主题）</strong> : Kafka 按 topic 对消息进行分类，Producer 将消息发送到特定的主题，Consumer 通过订阅特定的 Topic(主题) 来消费消息。</li>
<li><strong>Partition（分区）</strong> : Partition 属于 Topic 的一部分。一个 Topic 可以有多个 Partition ，并且同一 Topic 下的 Partition 可以分布在不同的 Broker 上，这也就表明一个 Topic 可以横跨多个 Broker 。</li>
</ul>
<blockquote>
<p>划重点：<strong>Kafka 中的 Partition（分区） 实际上可以对应成为消息队列中的队列。每个分区都是一个日志文件，消息以只追加的方式写入其中。⼀个分区只能被⼀个消费组下⾯的⼀个消费者消费（不同消费者组可以消费同一个topic的所有消息）。通常情况下，在一个 Kafka 集群中，<code>partition</code>的数量越多，意味着可以到达的吞吐量越大</strong>。</p>
<p>分区数配置：server.properties配置文件 num.partitions</p>
</blockquote>
<ul>
<li><strong>segment</strong>：分段。宏观上看，一个 partition 对应一个日志（Log）。由于生产者生产的消息会不断<strong>追加到 log 文件末尾</strong>，为防止 log 文件过大导致数据检索效率低下，<strong>Kafka 采取了分段和索引机制，将每个 partition 分为多个 segment，同时也便于消息的维护和清理</strong>。每个 segment 包含一个.log 日志文件、两个索引(.index、timeindex)文件以及其他可能的文件。每个 Segment 的数据文件以该段中最小的 offset 为文件名，当查找 offset 的 Message 的时候，通过二分查找快找到 Message 所处于的 Segment 中。</li>
<li><strong>offset</strong>：消息在日志中的位置，消息在被追加到分区日志文件的时候都会分配一个特定的偏移量。Kafka 服务器会将偏移量保存在内部的 __consumer_offsets 主题中。offset 是消息在分区中的唯一标识，是一个单调递增且不变的值。Kafka 通过它来保证消息在分区内的顺序性，不过 offset 并不跨越分区，也就是说，<strong>Kafka 保证的是分区有序而不是主题有序</strong>。<ol>
<li>自动提交：消费者可以通过设置 enable.auto.commit 参数为 true 来启用自动提交偏移量功能。当消费者消费完一批消息后，会自动将偏移量提交到 Kafka 服务器中。自动提交偏移量的缺点是可能会出现消息<strong>重复消费或漏消费</strong>的情况。</li>
<li>手动提交：消费者可以通过调用 commitSync() 或 commitAsync() 方法手动提交偏移量。手动提交偏移量的优点是可以控制偏移量的提交时机，避免出现消息重复消费或漏消费的情况。</li>
</ol>
</li>
</ul>
<h4 id="Kafka-的多副本机制了解吗？带来了什么好处？"><a href="#Kafka-的多副本机制了解吗？带来了什么好处？" class="headerlink" title="Kafka 的多副本机制了解吗？带来了什么好处？"></a>Kafka 的多副本机制了解吗？带来了什么好处？</h4><p>Kafka 为分区（Partition）引入了多副本（Replica）机制。分区（Partition）中的多个副本之间会有一个叫做 leader 的家伙，其他副本称为 follower。我们发送的消息会被发送到 leader 副本，然后 follower 副本才能从 leader 副本中拉取消息进行同步。</p>
<blockquote>
<p>生产者和消费者只与 leader 副本交互。你可以理解为其他副本只是 leader 副本的拷贝，它们的存在只是为了保证消息存储的安全性。当 leader 副本发生故障时会从 follower 中选举出一个 leader,但是 follower 中如果有和 leader 同步程度达不到要求的参加不了 leader 的竞选。</p>
</blockquote>
<p><strong>Kafka 的多分区（Partition）以及多副本（Replica）机制有什么好处呢？</strong></p>
<ol>
<li>Kafka 通过给特定 Topic 指定多个 Partition, 而各个 Partition 可以分布在不同的 Broker 上, 这样便能提供比较好的并发能力（负载均衡）。</li>
<li>Partition 可以指定对应的 Replica 数, 这也极大地提高了消息存储的安全性, 提高了容灾能力，不过也相应的增加了所需要的存储空间。</li>
</ol>
<p>注：分区可以增加，但不能减少。Kafka 分区增加后，Kafka 集群会立即重新平衡，使 Kafka 的消费者组(consumer group)重新分配消费者(consumer)的分区(partition)，但原来分区已有的消息是不会拆分迁移的。</p>
<h4 id="Kafka-如何保证消息的消费顺序？"><a href="#Kafka-如何保证消息的消费顺序？" class="headerlink" title="Kafka 如何保证消息的消费顺序？"></a>Kafka 如何保证消息的消费顺序？</h4><p>我们在使用消息队列的过程中经常有业务场景需要严格保证消息的消费顺序，比如我们同时发了 2 个消息，这 2 个消息对应的操作分别对应的数据库操作是：</p>
<ol>
<li>更改用户会员等级。</li>
<li>根据会员等级计算订单价格。</li>
</ol>
<p>假如这两条消息的消费顺序不一样造成的最终结果就会截然不同。</p>
<p>我们知道 Kafka 中 Partition(分区)是真正保存消息的地方，我们发送的消息都被放在了这里。而我们的 Partition(分区) 又存在于 Topic(主题) 这个概念中，并且我们可以给特定 Topic 指定多个 Partition。</p>
<p><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/KafkaTopicPartionsLayout.png" alt="img"></p>
<p>每次添加消息到 Partition(分区) 的时候都会采用尾加法，如上图所示。 <strong>Kafka 只能为我们保证 Partition(分区) 中的消息有序。</strong></p>
<blockquote>
<p>消息在被追加到 Partition(分区)的时候都会分配一个特定的偏移量（offset）。Kafka 通过偏移量（offset）来保证消息在分区内的顺序性。</p>
</blockquote>
<p>Kafka 中发送 1 条消息的时候，可以指定 topic, partition, key,data（数据） 4 个参数。如果你发送消息的时候指定了 Partition 的话，所有消息都会被发送到指定的 Partition。并且，<strong>同一个 key 的消息可以保证只发送到同一个 partition（通过hash）</strong>，这个我们可以采用表&#x2F;对象的 id 来作为 key 。</p>
<ul>
<li><strong>如果 key 不为 null</strong>：对 Key 值进行 Hash 计算，从<strong>所有分区</strong>中根据 Key 的 Hash 值计算出一个分区号；拥有相同 Key 值的消息被写入同一个分区，<strong>顺序消息实现的关键</strong>；</li>
<li><strong>如果 key 为 null</strong>：消息将以<strong>轮询</strong>的方式，在<strong>所有可用分区</strong>中分别写入消息。如果不想使用 Kafka 默认的分区器，用户可以实现 Partitioner 接口，自行实现分区方法。</li>
</ul>
<p>总结一下，对于如何保证 Kafka 中消息消费的顺序，有了下面两种方法：</p>
<ol>
<li><strong>1 个 Topic 只对应一个 Partition（并发性能差）。</strong></li>
<li><strong>（推荐）发送消息的时候指定 key&#x2F;Partition。</strong></li>
</ol>
<p>当然不仅仅只有上面两种方法，上面两种方法是我觉得比较好理解的，</p>
<p>对于 Kafka 来说，一个 topic 下同一个 partition 中的消息肯定是有序的，生产者在写的时候可以指定一个 key，通过我们会用订单号作为 key，这个 key 对应的消息都会发送到同一个 partition 中，所以消费者消费到的消息也一定是有序的。</p>
<p>那么为什么 Kafka 还会存在消息错乱的问题呢？问题就出在消费者身上。通常我们消费到同一个 key 的多条消息后，会使用多线程技术去并发处理来提高消息处理速度，否则一条消息的处理需要耗时几十 毫秒，1 秒也就只能处理几十条消息，吞吐量就太低了。而多线程并发处理的话，binlog 执行到数据库的时候就不一定还是原来的顺序了。</p>
<p>Kafka 从生产者到消费者消费消息这一整个过程其实都是可以保证有序的，<strong>导致最终乱序是由于消费者端需要使用多线程并发处理消息来提高吞吐量</strong>，比如消费者消费到了消息以后，开启 32 个线程处理消息，每个线程线程处理消息的快慢是不一致的，所以才会导致最终消息有可能不一致。</p>
<p>所以对于 Kafka 的消息顺序性保证，其实我们只需要保证同一个订单号的消息只被同一个线程处理的就可以了。由此我们可以在线程处理前增加个内存队列，每个线程只负责处理其中一个内存队列的消息，同一个订单号的消息发送到同一个内存队列中即可。</p>
<h4 id="Kafka-如何保证消息不丢失"><a href="#Kafka-如何保证消息不丢失" class="headerlink" title="Kafka 如何保证消息不丢失"></a>Kafka 如何保证消息不丢失</h4><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/kQRBSaGls7-a7VAUMepyBA">https://mp.weixin.qq.com/s/kQRBSaGls7-a7VAUMepyBA</a></p>
<h5 id="生产者丢失消息的情况"><a href="#生产者丢失消息的情况" class="headerlink" title="生产者丢失消息的情况"></a>生产者丢失消息的情况</h5><p>生产者(Producer) 调用<code>send</code>方法发送消息之后，消息可能因为网络问题并没有发送过去。</p>
<p>所以，我们不能默认在调用<code>send</code>方法发送消息之后消息发送成功了。为了确定消息是发送成功，我们要判断消息发送的结果。但是要注意的是 Kafka 生产者(Producer) 使用 <code>send</code> 方法发送消息实际上是<strong>异步</strong>的操作，我们可以通过 <code>get()</code>方法获取调用结果，但是这样也让它变为了同步操作，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SendResult&lt;String, Object&gt; sendResult = kafkaTemplate.send(topic, o).get();</span><br><span class="line"><span class="keyword">if</span> (sendResult.getRecordMetadata() != <span class="literal">null</span>) &#123;</span><br><span class="line">  logger.info(<span class="string">&quot;生产者成功发送消息到&quot;</span> + sendResult.getProducerRecord().topic() + </span><br><span class="line">              <span class="string">&quot;-&gt; &quot;</span> + sendResult.getProducerRecord().value().toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是一般不推荐这么做！可以采用为其添加回调函数的形式，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ListenableFuture&lt;SendResult&lt;String, Object&gt;&gt; future = kafkaTemplate.send(topic, o);</span><br><span class="line">future.addCallback(result -&gt; logger.info(<span class="string">&quot;生产者成功发送消息到topic:&#123;&#125; partition:&#123;&#125;的消息&quot;</span>, result.getRecordMetadata().topic(), result.getRecordMetadata().partition()),</span><br><span class="line">                ex -&gt; logger.error(<span class="string">&quot;生产者发送消失败，原因：&#123;&#125;&quot;</span>, ex.getMessage()));</span><br></pre></td></tr></table></figure>

<p>如果消息发送失败的话，我们检查失败的原因之后重新发送即可！</p>
<p><strong>设置 acks &#x3D; all（-1）</strong></p>
<p>acks 是 Producer 的参数，如果设置成 all，需要所有副本 Broker 都要接收到消息，该消息才算是“已提交”。这是最高等级的“已提交”定义。</p>
<p><strong>设置 retries 为一个较大的值。</strong></p>
<p>一般是 3 ，但是为了保证消息不丢失的话一般会设置比较大一点。设置完成之后，当出现网络问题之后能够自动重试消息发送，避免消息丢失。另外，建议还要设置重试间隔，因为间隔太小的话重试的效果就不明显了，网络波动一次你 3 次一下子就重试完了</p>
<p>message.send.max.retries 默认值：3，消息发送最大尝试次数。</p>
<p>retry.backoff.ms 默认值：300，每次尝试增加的额外的间隔时间。</p>
<h5 id="消费者丢失消息的情况"><a href="#消费者丢失消息的情况" class="headerlink" title="消费者丢失消息的情况"></a>消费者丢失消息的情况</h5><p>我们知道消息在被追加到 Partition(分区)的时候都会分配一个特定的偏移量（offset）。偏移量（offset)表示 Consumer 当前消费到的 Partition(分区)的所在的位置。Kafka 通过偏移量（offset）可以保证消息在分区内的顺序性。</p>
<p><strong>当消费者拉取到了分区的某个消息之后，消费者会自动提交 offset</strong>。自动提交的话会有一个问题，试想一下，当消费者刚拿到这个消息准备进行真正消费的时候，突然挂掉了，消息实际上并没有被消费，但是 offset 却被自动提交了；多线程消费消息，某个线程处理消息出现异常，还是会出现自动提交offset。</p>
<p>解决办法也比较粗暴，我们手动关闭自动提交 offset，每次在真正消费完消息之后再自己<strong>手动提交 offset</strong> 。 但是，这样会带来消息被重新消费的问题。比如你刚刚消费完消息之后，还没提交 offset，结果自己挂掉了（或重启），那么这个消息理论上就会被消费两次（如果没挂，那么这条消息不会重复消费）。</p>
<p> 1.如果在消费kafka的数据过程中，一直没有提交offset，那么在此程序运行的过程中它不会重复消费。但是如果重启之后，就会重复消费之前没有提交offset的数据。</p>
<p> 2.如果在消费的过程中有几条或者一批数据数据没有提交offset，后面其他的消息消费后正常提交offset，那么服务端会更新为消费后最新的offset，不会重新消费，就算重启程序也不会重新消费。</p>
<blockquote>
<p>注：修改enable-auto-commit: false后，必须手动提交</p>
<p>ACK模式	描述<br>MANUAL	poll()拉取一批消息，处理完业务后，手动调用Acknowledgment.acknowledge()先将offset存放到map本地缓存，在下一次poll之前从缓存拿出来批量提交<br>MANUAL_IMMEDIATE	每处理完业务手动调用Acknowledgment.acknowledge()后立即提交<br>RECORD	当每一条记录被消费者监听器（ListenerConsumer）处理之后提交<br>BATCH	当每一批poll()的数据被消费者监听器（ListenerConsumer）处理之后提交<br>TIME	当每一批poll()的数据被消费者监听器（ListenerConsumer）处理之后，距离上次提交时间大于TIME时提交<br>COUNT	当每一批poll()的数据被消费者监听器（ListenerConsumer）处理之后，被处理record数量大于等于COUNT时提交<br>COUNT_TIME	TIME或COUNT满足其中一个时提交</p>
</blockquote>
<h5 id="Kafka-（Broker）弄丢了消息"><a href="#Kafka-（Broker）弄丢了消息" class="headerlink" title="Kafka （Broker）弄丢了消息"></a>Kafka （Broker）弄丢了消息</h5><p>我们知道 Kafka 为分区（Partition）引入了多副本（Replica）机制。分区（Partition）中的多个副本之间会有一个叫做 leader 的家伙，其他副本称为 follower。我们发送的消息会被发送到 leader 副本，然后 follower 副本才能从 leader 副本中拉取消息进行同步。生产者和消费者只与 leader 副本交互。你可以理解为其他副本只是 leader 副本的拷贝，它们的存在只是为了保证消息存储的安全性。</p>
<p><strong>试想一种情况：假如 leader 副本所在的 broker 突然挂掉，那么就要从 follower 副本重新选出一个 leader ，但是 leader 的数据还有一些没有被 follower 副本的同步的话，就会造成消息丢失。</strong></p>
<p><strong>设置 acks &#x3D; all（-1）</strong></p>
<p>acks 的默认值即为 1，代表我们的消息被 leader 副本接收之后就算被成功发送。当我们配置 <strong>acks &#x3D; all</strong> 表示只有所有 ISR 列表的副本全部收到消息时，生产者才会接收到来自服务器的响应. 这种模式是最高级别的，也是最安全的，可以确保不止一个 Broker 接收到了消息. 该模式的延迟会很高.</p>
<p><strong>设置 min.insync.replicas &gt; 1</strong></p>
<p>一般情况下我们还需要设置 <strong>min.insync.replicas&gt; 1</strong> ，这样配置代表消息至少要被写入到 2 个副本才算是被成功发送。<strong>min.insync.replicas</strong> 的默认值为 1 ，在实际生产中应尽量避免默认值 1。</p>
<p><strong>设置 replication.factor &gt;&#x3D; 3</strong></p>
<p>为了保证 leader 副本能有 follower 副本能同步消息，我们一般会为 topic 设置 <strong>replication.factor &gt;&#x3D; 3</strong>。这样就可以保证每个 分区(partition) 至少有 3 个副本。虽然造成了数据冗余，但是带来了数据的安全性。</p>
<p>但是，为了保证整个 Kafka 服务的高可用性，你需要确保 <strong>replication.factor &gt; min.insync.replicas</strong> 。为什么呢？设想一下假如两者相等的话，只要是有一个副本挂掉，整个分区就无法正常工作了。这明显违反高可用性！一般推荐设置成 <strong>replication.factor &#x3D; min.insync.replicas + 1</strong>。</p>
<p><strong>设置 unclean.leader.election.enable &#x3D; false</strong></p>
<p>它控制的是哪些 Broker 有资格竞选分区的 Leader。如果一个 Broker 落后原先的 Leader 太多，那么它一旦成为新的 Leader，必然会造成消息的丢失。故一般都要将该参数设置成 false，即不允许这种情况的发生。</p>
<h4 id="Kafka-如何保证消息不重复消费（幂等性）"><a href="#Kafka-如何保证消息不重复消费（幂等性）" class="headerlink" title="Kafka 如何保证消息不重复消费（幂等性）"></a>Kafka 如何保证消息不重复消费（幂等性）</h4><p><strong>kafka 出现消息重复消费的原因：</strong></p>
<ul>
<li>服务端侧<strong>已经消费的数据没有成功提交 offset</strong>（根本原因）。</li>
<li>当一个消费者加入或退出消费者组时（或主题的分区数量发生变化），或由于服务端处理业务时间长或者网络链接等等原因让 Kafka 认为服务假死，会触发分区 <strong>rebalance</strong>。在 Rebalance 过程中，Kafka 会将所有分区重新分配给消费者，以确保每个消费者都能够处理一定数量的分区。</li>
</ul>
<p><strong>解决方案：</strong></p>
<ul>
<li><p>消费消息服务做幂等校验，比如 Redis 的 set、MySQL 的主键（防重表）等天然的幂等功能。这种方法最有效。</p>
</li>
<li><p>将 <code>enable.auto.commit</code>参数设置为 false，关闭自动提交，开发者在代码中手动提交 offset。那么这里会有个问题：</p>
<p>什么时候提交 offset 合适？</p>
<ul>
<li>处理完消息再提交：依旧有消息重复消费的风险，和自动提交一样</li>
<li>拉取到消息即提交：会有消息丢失的风险。允许消息延时的场景，一般会采用这种方式。然后，通过定时任务在业务不繁忙（比如凌晨）的时候做数据兜底。</li>
</ul>
<p>京东：幂等设计详解<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/_Nn5F98PvoWk_xjVrIpFNQ">https://mp.weixin.qq.com/s/_Nn5F98PvoWk_xjVrIpFNQ</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/p_khlkMFQsuK2w56tDrsOg">https://mp.weixin.qq.com/s/p_khlkMFQsuK2w56tDrsOg</a></p>
</li>
</ul>
<h4 id="当消费者在消费过程突然宕机了，重新恢复后是从哪里消费，会有什么问题"><a href="#当消费者在消费过程突然宕机了，重新恢复后是从哪里消费，会有什么问题" class="headerlink" title="当消费者在消费过程突然宕机了，重新恢复后是从哪里消费，会有什么问题?"></a>当消费者在消费过程突然宕机了，重新恢复后是从哪里消费，会有什么问题?</h4><p>消费者会记录offset，故障恢复后会从这里继续消费，那么这个offset记录在哪里呢?记录在zookeeper和本地，新版的默认将offset保证在kafka的内置topic中，名称为_consumer_offsets。在这个topic默认会有50个Partition，每一个Partition都有3个副本，分区数量就是由参数offset.topic.num.partition配置的。通过groupid的哈希值和该参数的取模方式来确定某个消费者组已消费的offset保存到_consumer_offsets主题的哪个分区中。这个由消费者组名+主题+分区，来确定唯一的offset的key，从而获取对应的值。</p>
<h4 id="事务消息"><a href="#事务消息" class="headerlink" title="事务消息"></a>事务消息</h4><p>Kafka的事务消息和RocketMQ有所不同。RocketMQ保证的是<strong>发消息和本地事务</strong>这两个操作的原子性，kafka的事务消息保证<strong>多条消息</strong>同时发送成功或失败。</p>
<p>如果Kafka发消息失败，会直接抛出异常，让用户自行处理。我们可以在业务代码中反复重试提交，直到提交成功。RocketMQ通过消息回查解决特殊情况下发送消息失败的问题。</p>
<h4 id="监控-运维"><a href="#监控-运维" class="headerlink" title="监控&#x2F;运维"></a>监控&#x2F;运维</h4><p><a target="_blank" rel="noopener" href="https://github.com/didi/KnowStreaming">https://github.com/didi/KnowStreaming</a></p>
<h4 id="Spring-Kafka"><a href="#Spring-Kafka" class="headerlink" title="Spring-Kafka"></a>Spring-Kafka</h4><p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-kafka/docs/2.9.10/reference/html">https://docs.spring.io/spring-kafka/docs/2.9.10/reference/html</a></p>
<h5 id="Retryable-topic"><a href="#Retryable-topic" class="headerlink" title="Retryable-topic"></a>Retryable-topic</h5><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/554967177">https://zhuanlan.zhihu.com/p/554967177</a></p>
<p>kafka本身并没有延迟消息功能</p>
<h5 id="Listener"><a href="#Listener" class="headerlink" title="Listener"></a>Listener</h5><ul>
<li><p>concurrency</p>
<p>举个例子 ： ****如果设置 <code>concurrency=2</code> 时，Spring-Kafka 就会为该 <code>@KafkaListener</code>标注的方法消费的消息 创建 2个线程，进行并发消费****。 当然了，这是有前置条件的。 <strong>不要超过 partitions 的大小</strong></p>
<ul>
<li><p>当concurrency &lt; partition 的数量，会出现消费不均的情况，一个消费者的线程可能消费多个partition 的数据</p>
</li>
<li><p>当concurrency &#x3D; partition 的数量，最佳状态，一个消费者的线程消费一个 partition 的数据</p>
</li>
<li><p>当concurrency &gt; partition 的数量，会出现有的消费者的线程没有可消费的partition， 造成资源的浪费</p>
<p><em><strong>*分布式情况：总consumer线程数&#x3D;concurrency*机器数量;*</strong></em></p>
</li>
</ul>
</li>
</ul>
<h4 id="Kafka-Stream"><a href="#Kafka-Stream" class="headerlink" title="Kafka Stream"></a>Kafka Stream</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u010349629/article/details/130931817">https://blog.csdn.net/u010349629/article/details/130931817</a></p>
<h3 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h3><p><a target="_blank" rel="noopener" href="https://rocketmq.apache.org/zh/docs/">https://rocketmq.apache.org/zh/docs/</a></p>
<h4 id="事务消息-1"><a href="#事务消息-1" class="headerlink" title="事务消息"></a>事务消息</h4><p>如果使用@Transactional + 发送普通消息，极端情况下，可能存在问题：</p>
<ol>
<li>发消息成功，但事务提交前突然宕机，下游收到消息就会误以为本地事务已经成功</li>
<li>发消息成功，但由于网络原因导致消息发送超时了，这种情况下你不知道到底消息有没有发出去，这样的话你接下来是要提交本地事务、还是回滚、还是重发，这个不确定。RocketMQ的事务消息提供了消息回查的机制，可以解决这个问题。</li>
</ol>
<p>事务消息可以保证本地事务和消息投递是原子操作，也就是说本地事务执行成功，消息一定能可靠投递。</p>
<ol>
<li>生产者将消息发送至Apache RocketMQ服务端。</li>
<li>Apache RocketMQ服务端将消息持久化成功之后，向生产者返回Ack确认消息已经发送成功，此时消息被标记为”暂不能投递”，这种状态下的消息即为半事务消息。</li>
<li>生产者开始执行本地事务逻辑。</li>
<li>生产者根据本地事务执行结果向服务端提交二次确认结果（Commit或是Rollback），服务端收到确认结果后处理逻辑如下：<ul>
<li>二次确认结果为Commit：服务端将半事务消息标记为可投递，并投递给消费者。</li>
<li>二次确认结果为Rollback：服务端将回滚事务，不会将半事务消息投递给消费者。</li>
</ul>
</li>
<li>在断网或者是生产者应用重启的特殊情况下，若服务端未收到发送者提交的二次确认结果，或服务端收到的二次确认结果为Unknown未知状态，经过固定时间后，服务端将对消息生产者即生产者集群中任一生产者实例发起<strong>消息回查</strong>。 服务端回查的间隔时间和最大回查次数，请参见<a target="_blank" rel="noopener" href="https://rocketmq.apache.org/zh/docs/introduction/03limits">参数限制</a>。</li>
<li>生产者收到消息回查后，需要检查对应消息的本地事务执行的最终结果。</li>
<li>生产者根据检查到的本地事务的最终状态再次提交二次确认，服务端仍按照步骤4对半事务消息进行处理。</li>
</ol>
<h3 id="Rabbitmq"><a href="#Rabbitmq" class="headerlink" title="Rabbitmq"></a>Rabbitmq</h3><ul>
<li>Producer(生产者)： 将消息发送到Exchange</li>
<li>Exchange(交换器)：将从生产者接收到的消息路由到Queue</li>
<li>Queue(队列)：存放供消费者消费的消息</li>
<li>BindingKey(绑定键)：建立Exchange与Queue之间的关系（个人看作是一种规则，也就是Exchange将什么样的消息路由到Queue）</li>
<li>RoutingKey(路由键)：Producer发送消息与路由键给Exchange，Exchange将判断RoutingKey是否符合BindingKey，如何则将该消息路由到绑定的Queue</li>
<li>Consumer(消费者)：从Queue中获取消息</li>
</ul>
<table>
<thead>
<tr>
<th>交换机类型</th>
<th>匹配RoutingKey</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>扇出 Fanout</td>
<td>不需要匹配；广播转发，可以发送到所有队列</td>
<td>不需要匹配</td>
</tr>
<tr>
<td>直接 Direct</td>
<td>完全匹配；只发到特定的队列</td>
<td>完全匹配</td>
</tr>
<tr>
<td>主题 Topic</td>
<td>选择匹配；按通配符发送到特定的队列</td>
<td>选择匹配</td>
</tr>
</tbody></table>
<h3 id="延时消息"><a href="#延时消息" class="headerlink" title="延时消息"></a>延时消息</h3><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/OmbyxkufVm-XzwIv_A514w">https://mp.weixin.qq.com/s/OmbyxkufVm-XzwIv_A514w</a></p>
<p><strong>Java Timer类</strong></p>
<p>Java中的Timer类是一个定时器，它可以用来实现延时消息的功能。Timer类提供了schedule()方法，可以用来安排任务在一定时间后执行。下面是一个简单的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Timer</span> <span class="variable">timer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timer</span>();</span><br><span class="line">timer.schedule(<span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="number">5000</span>);</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们创建了一个Timer对象，并使用schedule()方法安排了一个任务在5秒后执行。任务的具体实现是一个匿名内部类，它继承了TimerTask类，并重写了run()方法。当定时器到达指定的时间时，run()方法会被执行。</p>
<p>Timer类的使用非常简单，但是它存在一些问题。Timer类是单线程的，如果有多个任务需要执行，它们会被放到同一个队列中，按照先后顺序依次执行。如果某个任务的执行时间过长，会影响后续任务的执行。</p>
<p><strong>DelayQueue</strong></p>
<p>DelayQueue 是一个无界阻塞队列，队列中的元素只有在延迟期满后才能被取出。队列的头部存储的是最先到期的元素。添加进该队列的元素必须实现 Delayed 接口，指定延迟时间，元素过期的判断是根据 getDelay(TimeUnit unit) 方法的返回值，返回值小于等于 0，则认为元素过期。队列不允许存储空元素。</p>
<p><strong>RabbitMQ</strong></p>
<p><strong>1） TTL+ 死信队列</strong></p>
<p>RabbitMQ 是基于 TTL+ 死信队列的方式来实现的。具体来说，通过设置消息的 TTL，当达到 TTL 时消息还没有被消费，此时会投递到死信队列。TTL 分两种：</p>
<ul>
<li>Queue 级别的 TTL：所有消息统一的 TTL</li>
<li>Message 级别的 TTL：每条消息可以是不同的 TTL，但是存在队头阻塞问题</li>
</ul>
<p>该方案的优点是实现简单，但是延迟误差不确定。</p>
<p><strong>2） 插件</strong></p>
<p>Rabbitmq实现了一个插件x-delay-message来实现延时队列</p>
<p><strong>RocketMQ</strong></p>
<ul>
<li><p>4.x版本</p>
<p>基于定时调度+延迟等级的方式来实现的。具体来说，将延时消息发送到指定的延时等级队列（一共有 18 个等级，1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h），然后通过一个定时器进行轮询这些 ConsumeQueue 实现延时的效果。具体实现如下：</p>
<ul>
<li><p>修改消息 topic 名称和队列信息投递到对应等级的延时消息的 ConsumeQueue 中</p>
</li>
<li><p>ScheduleMessageService消费ConsumeQueue中的消息再重新投递到 CommitLog 中</p>
</li>
<li><p>将 CommitLog 中的消息投递到目标 topic 中，消费者消费目标 topic 中的消息</p>
</li>
</ul>
</li>
<li><p>5.x版本</p>
<p><a target="_blank" rel="noopener" href="https://rocketmq.apache.org/zh/docs/featureBehavior/02delaymessage">https://rocketmq.apache.org/zh/docs/featureBehavior/02delaymessage</a></p>
<p>定时消息的定时时长参数<strong>精确到毫秒级</strong>，但是默认精度为1000ms，即定时消息为秒级精度。定时时长最大值默认为24小时，不支持自定义修改，超过范围则服务端会立即投递消息。</p>
</li>
</ul>
<p><strong>Redis</strong></p>
<p>基于 Redis 实现延迟队列的方式有很多，在这里简单描述两种：</p>
<p><strong>1）定时轮询</strong></p>
<p>该方案的大致步骤如下：</p>
<ul>
<li>将消息的延时时间戳作为 zset 的 key，消息的 ID 作为 zset 的 value</li>
<li>消息 ID 作为 key，消息体序列化成 String 作为 value 存储在 Redis 中</li>
<li>定时轮询 zset，大于当前时间则投递到 Redis 的 List 中供消费者消费</li>
</ul>
<p><strong>2）Key 过期监听器</strong></p>
<p>每条消息设置一个过期时间，监听过期事件然后将消息投递到 target topic。</p>
<p>基于 Redis 实现延时队列的优点是实现简单，但是都可能存在丢消息的情况，并且存储成本高。</p>
<h2 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h2><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><h4 id="一致性Hash"><a href="#一致性Hash" class="headerlink" title="一致性Hash"></a>一致性Hash</h4><p>在移除或者添加一个服务器时，能够尽可能小地改变已存在的服务请求与处理请求的服务器之间的映射关系；</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/484756425">https://zhuanlan.zhihu.com/p/484756425</a></p>
<h3 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h3><p>微服务架构是一种将应用程序拆分成一组小型、独立的服务的架构风格，每个服务都运行在自己的进程中，通过轻量级的通信机制相互协作，以实现业务功能。相对于传统的单体应用架构，微服务架构有以下几个优点：</p>
<ol>
<li>高可用性：微服务架构将一个大型应用拆分成多个小型服务，每个服务都运行在自己的进程中，因此可以通过水平扩展来提高可用性。当某个服务出现故障时，只会影响到该服务，而不会影响整个应用的可用性。</li>
<li>易于维护和升级：由于每个服务都是独立的，因此可以<strong>单独对某个服务进行维护和升级，而不会影响到其他服务</strong>。同时，由于服务之间采用轻量级的通信机制，因此可以方便地添加、删除或替换服务，以满足不同的业务需求。</li>
<li>更快的开发和部署：微服务架构将应用程序拆分成多个小型服务，每个服务都负责一个特定的业务功能，因此可以通过团队之间的协作来加速开发和部署。同时，由于每个服务都是独立的，因此可以快速地进行部署和测试。</li>
<li>更好的可扩展性：由于<strong>每个服务都是独立的，因此可以根据业务需求来进行水平扩展</strong>。例如，当某个服务的负载增加时，可以通过添加更多的实例来提高性能。</li>
<li>更好的技术选型：由于每个服务都是独立的，因此可以<strong>根据业务需求来选择最合适的技术栈</strong>。例如，某个服务需要处理大量的数据时，可以选择使用分布式计算框架来提高性能。</li>
</ol>
<p>需要注意的是，微服务架构也存在一些挑战和复杂性，如<strong>服务之间的通信、服务发现和治理、分布式事务</strong>等。因此，在实践中需要根据具体的业务需求和技术能力来选择合适的架构风格。</p>
<p><strong>微服务架构的优点</strong></p>
<p>与传统单体应用架构相比，微服务架构有很多优点，具体表现如下：</p>
<ul>
<li><p>高可用</p>
<p>当架构中的某一组件发生故障时，在单一进程的传统架构下，故障很有可能在进程内扩散，导致整个应用不可用。在微服务架构下，故障会被隔离在单个服务中。若设计良好，其他服务可通过重试、平稳退化等机制实现应用层面的容错。</p>
</li>
<li><p>可扩展</p>
<p>单个服务应用也可以实现横向扩展，这种扩展可以通过将整个应用完整的复制到不同的节点中实现。当应用的不同组件在扩展需求上存在差异时，微服务架构便体现出其灵活性，因为每个服务可以根据实际需求独立进行扩展。</p>
</li>
</ul>
<p><strong>微服务的缺点</strong></p>
<ul>
<li><p>复杂度高</p>
<p>与单体式架构相比，微服务会导致复杂性上升，因为多个团队会在更多地方创建更多服务。若管理不当，则会导致开发速度和效率降低。</p>
</li>
<li><p>基础设施成本呈指数级增长</p>
<p>每个新的微服务都有自己的成本，例如测试工具、托管基础架构和监控工具等方面。</p>
</li>
<li><p>性能下降</p>
<p>微服务之间通过REST、RPC等形式进行交互，通信的时延会受到较大的影响。</p>
</li>
</ul>
<h4 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h4><ul>
<li>Dubbo</li>
<li>Feign：基于Http传输协议，短连接。性能略差，不适合高并发访问，但使用方便</li>
<li>gRPC</li>
</ul>
<h4 id="服务注册-配置"><a href="#服务注册-配置" class="headerlink" title="服务注册&amp;配置"></a>服务注册&amp;配置</h4><ul>
<li><p>Nacos</p>
<p>服务注册中心：也叫服务发现中心，微服务将自己注册到服务注册中心，服务间远程调用通过服务注册中心获取目标服务的地址，从而进行远程调用。</p>
<p>市面上的服务注册中心有：Zookeeper、Eureka、Nacos、Consul。</p>
<p>配置中心：统一管理微服务的配置文件。</p>
<p>市面上的配置中心有：Spring Cloud config、Apollo、Nacos。</p>
</li>
</ul>
<h4 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h4><ul>
<li><p>Spring Cloud Gateway</p>
<p>网关的作用是负载均衡、路由转发。前端请求到Nginx，通过负载均衡到Gateway网关，通过网关将请求转发至各个微服务。网关进行路由时需要知道每个微服务实例的地址，网关从nacos读取服务地址。</p>
<p>流程如下：</p>
<p>1、微服务启动，将自己注册到Nacos，Nacos记录了各微服务实例的地址。</p>
<p>2、网关从Nacos读取服务列表，包括服务名称、服务地址等。</p>
<p>3、请求到达网关，网关将请求路由到具体的微服务。</p>
<p>本项目网关还具有统一鉴权功能：</p>
<p>1、网站白名单</p>
<p>在白名单的中的地址不进行身份校验直接放行。</p>
<p>2、身份校验</p>
<p>校验请求合法性，令牌合法则继续访问，否则拒绝访问。</p>
</li>
</ul>
<h4 id="熔断降级"><a href="#熔断降级" class="headerlink" title="熔断降级"></a>熔断降级</h4><p>熔断：当下游服务异常而断开与上游服务的交互，它就相当于保险丝，下游服务异常触发了熔断，从而保证上游服务不受影响。</p>
<p>降级：当下游服务异常触发熔断后，上游服务就不再去调用异常的微服务而是执行了降级处理逻辑，这个降级处理逻辑可以是本地一个单独的方法。</p>
<h5 id="Hystrix与Sentinel"><a href="#Hystrix与Sentinel" class="headerlink" title="Hystrix与Sentinel"></a>Hystrix与Sentinel</h5><p><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="http://oss.ripplesu.top/blog/Typora/%E9%9D%A2%E8%AF%95%E9%A2%98/bVcXSr2" alt="Hystrix与Sentinel"></p>
<ul>
<li><p>Hystrix 最核心的一项功能就是资源隔离，支持线程池隔离和信号量隔离；Sentinel支持信号量隔离。</p>
</li>
<li><p>Sentinel与Hystrix都支持基于失败比率的熔断降级，在调用超过指定的数量并且失败比率达到设定阀值时触发熔断，并在下个时间窗口自动恢复。Sentinel也支持按失败总数熔断降级，但按失败总数的熔断降级固定时间窗口为1分钟，当1分钟内调用失败总数达到设定的阀值就会触发熔断。此外，Sentinel还支持基于平均响应时间的熔断降级，平均响应时间越长，说明服务的性能在持续下降，在响应时间持续飙高时自动熔断，可以防止调用慢造成级联阻塞。</p>
</li>
<li><p>Sentinel 和旧版本 Hystrix 的实时指标数据统计实现都是基于滑动窗口，指标数据统计指的是统计每个资源的当前窗口时间内的请求总数、处理成功总数、失败总数、总耗时、平均耗时、最大耗时、最小耗时、被降级总数等。</p>
</li>
<li><p>Sentinel 提供数据源接口可实现动态加载规则配置，结合 loadRules API 可灵活的运行时修改规则配置，并且随时修改随时生效。Hystrix 的资源模型设计上采用了命令模式，在创建 Command 时就需要指定隔离策略是线程池隔离还是信号量隔离，一但指定了隔离策略，运行期间便不能修改隔离策略，而在 Sentinel 中资源定义和规则配置是分离的，因此在配置的灵活性上 Sentinel 更具有优势。</p>
</li>
<li><p>Sentinel 支持系统自适应限流，Hystrix 所不支持的。当系统负载较高的时候，如果仍持续让请求进入，可能会导致系统崩溃，无法响应。在集群环境下，负载均衡把本应这台机器承载的流量转发到其它的机器上去，如果这个时候其它的机器也处在一个边缘状态的时候，这个增加的流量就会导致这台机器崩溃，最后导致整个集群不可用。针对这个情况，Sentinel 提供了对应的保护机制，让系统的入口流量和系统的负载达到一个平衡，保证系统在能力范围之内处理最多的请求。</p>
</li>
<li><p>在 QPS 过高的情况下，直接拒绝超出限制的请求是最常见的实现方式，但有些场景我们可能并不想直接拒绝请求，而是让请求排队等待处理，例如某一秒突增请求过多，但下一秒可能又没有请求或者请求很少的情况。Sentinel 的流量控制支持多种模式，例如直接拒绝模式、慢启动预热模式、匀速器模式。而慢启动预热模式和匀速器模式也是 Hystrix 所不支持的。介绍下Sentinel流量整形的三种模式：</p>
<blockquote>
<p><strong>直接拒绝</strong>：即超出的请求直接拒绝<br><strong>慢启动模式</strong>：当流量激增的时候控制流量通过的速率，让通过的流量缓慢增加，在一定时间内逐渐增加到阀值上限，给冷系统一个预热时间，避免冷系统被压跨。<br><strong>匀速器模式</strong>：利用Leaky Bucket算法实现的匀速模式，严格控制了请求通过的时间间隔，同时堆积的请求将会排队，超过超时时长的请求会被拒绝</p>
</blockquote>
</li>
<li><p>Sentinel 在框架的设计上使用了责任链模式和 SPI 机制提供扩展功能。使用SPI我们可以自定义降级功能ProcessorSlot。</p>
</li>
<li><p>Sentinel 还支持集群限流。除了轮询负载均衡算法外，其它的算法都会导致流量到集群的每个节点都不一样，有的多有的少。集群流控可以精确地控制整个集群的调用总量，结合单机限流兜底，可以更好地发挥流量控制的效果。Sentinel集群分嵌入模式（Embedded）与独立模式（Alone）。</p>
<blockquote>
<p><strong>嵌入模式</strong>：集群限流服务端作为应用的内置服务同应用一起启动，与应用在同一个进程，可动态的挑选其中一个节点作为集群限流服务端<br><strong>独立模式</strong>：集群限流服务端作为一个独立的应用部署</p>
</blockquote>
</li>
<li><p>黑白名单限流和热点参数限流也是 Sentinel 的一大特色，黑白名单限流，可根据请求来源判断来源是否在黑名单中，如果在黑名单中则拒绝请求，否则放行，结合 Sentinel 的灵活动态配置，黑白名单可用于高峰期间对某些服务限流。</p>
</li>
</ul>
<h3 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h3><h4 id="基于XA协议（强一致性）的两阶段提交-2PC-2-phase-commit-protocol"><a href="#基于XA协议（强一致性）的两阶段提交-2PC-2-phase-commit-protocol" class="headerlink" title="基于XA协议（强一致性）的两阶段提交 2PC(2-phase commit protocol)"></a>基于XA协议（强一致性）的两阶段提交 2PC(2-phase commit protocol)</h4><h4 id="事务补偿TCC模式（弱一致性）"><a href="#事务补偿TCC模式（弱一致性）" class="headerlink" title="事务补偿TCC模式（弱一致性）"></a>事务补偿TCC模式（弱一致性）</h4><h4 id="最终一致性方案-Eventual-cnsisteney"><a href="#最终一致性方案-Eventual-cnsisteney" class="headerlink" title="最终一致性方案(Eventual cnsisteney)"></a>最终一致性方案(Eventual cnsisteney)</h4><p>最终一致性是一种通过异步方式解决数据一致性问题的方案。</p>
<h5 id="本地消息表-定时任务轮询"><a href="#本地消息表-定时任务轮询" class="headerlink" title="本地消息表 + 定时任务轮询"></a>本地消息表 + 定时任务轮询</h5><h5 id="MQ事务消息"><a href="#MQ事务消息" class="headerlink" title="MQ事务消息"></a>MQ事务消息</h5><p>以下来自<a target="_blank" rel="noopener" href="https://rocketmq.apache.org/zh/docs/featureBehavior/04transactionmessage">https://rocketmq.apache.org/zh/docs/featureBehavior/04transactionmessage</a></p>
<p>分布式系统调用的特点为一个核心业务逻辑的执行，同时需要调用多个下游业务进行处理。因此，如何保证核心业务和多个下游业务的执行结果完全一致，是分布式事务需要解决的主要问题。</p>
<p>以电商交易场景为例，用户支付订单这一核心操作的同时会涉及到下游物流发货、积分变更、购物车状态清空等多个子系统的变更。当前业务的处理分支包括：</p>
<ul>
<li>主分支订单系统状态更新：由未支付变更为支付成功。</li>
<li>物流系统状态新增：新增待发货物流记录，创建订单物流记录。</li>
<li>积分系统状态变更：变更用户积分，更新用户积分表。</li>
<li>购物车系统状态变更：清空购物车，更新用户购物车记录。</li>
</ul>
<p><strong>传统XA事务方案：性能不足</strong></p>
<p>为了保证上述四个分支的执行结果一致性，典型方案是基于XA协议的分布式事务系统来实现。将四个调用分支封装成包含四个独立事务分支的大事务。基于XA分布式事务的方案可以满足业务处理结果的正确性，但最大的缺点是多分支环境下资源锁定范围大，并发度低，随着下游分支的增加，系统性能会越来越差。</p>
<p><strong>基于普通消息方案：一致性保障困难</strong></p>
<p>将上述基于XA事务的方案进行简化，将订单系统变更作为本地事务，剩下的系统变更作为普通消息的下游来执行，事务分支简化成普通消息+订单表事务，充分利用消息异步化的能力缩短链路，提高并发度。</p>
<p>该方案中消息下游分支和订单系统变更的主分支很容易出现不一致的现象，例如：</p>
<ul>
<li>消息发送成功，订单没有执行成功，需要回滚整个事务。</li>
<li>订单执行成功，消息没有发送成功，需要额外补偿才能发现不一致。</li>
<li>消息发送超时未知，此时无法判断需要回滚订单还是提交订单变更。</li>
</ul>
<p><strong>基于Apache RocketMQ分布式事务消息：支持最终一致性</strong></p>
<p>上述普通消息方案中，普通消息和订单事务无法保证一致的原因，本质上是由于普通消息无法像单机数据库事务一样，具备提交、回滚和统一协调的能力。</p>
<p>而基于Apache RocketMQ实现的分布式事务消息功能，在普通消息基础上，支持二阶段的提交能力。将二阶段提交和本地事务绑定，实现全局提交结果的一致性。</p>
<h2 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h2><h3 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h3><p><code>java.util.Timer</code>是 JDK 1.3 开始就已经支持的一种定时任务的实现方式。</p>
<p><code>Timer</code> 内部使用一个叫做 <code>TaskQueue</code> 的类存放定时任务，它是一个基于最小堆实现的优先级队列。<code>TaskQueue</code> 会按照任务距离下一次执行时间的大小将任务排序，保证在堆顶的任务最先执行。这样在需要执行任务时，每次只需要取出堆顶的任务运行即可。</p>
<p>不过其缺陷较多，比如一个 <code>Timer</code> 一个线程，这就导致 <code>Timer</code> 的任务的执行只能串行执行，一个任务执行时间过长的话会影响其他任务（性能非常差），再比如发生异常时任务直接停止（<code>Timer</code> 只捕获了 <code>InterruptedException</code> ）。</p>
<h3 id="ScheduledExecutorService"><a href="#ScheduledExecutorService" class="headerlink" title="ScheduledExecutorService"></a>ScheduledExecutorService</h3><p><code>ScheduledExecutorService</code> 是一个接口，有多个实现类，比较常用的是 <code>ScheduledThreadPoolExecutor</code> 。<code>ScheduledThreadPoolExecutor</code> 本身就是一个线程池，支持任务并发执行。并且，其内部使用 <code>DelayedWorkQueue</code> 作为任务队列。</p>
<p>JDK自带的不论是使用 <code>Timer</code> 还是 <code>ScheduledExecutorService</code> 都仅支持按照指定频率，无法使用 Cron 表达式指定任务执行的具体时间。</p>
<blockquote>
<p>Cron表达式在线生成<a target="_blank" rel="noopener" href="http://cron.qqe2.com/">http://cron.qqe2.com/</a> </p>
</blockquote>
<h3 id="Spring-Task"><a href="#Spring-Task" class="headerlink" title="Spring Task"></a>Spring Task</h3><p>直接通过 Spring 提供的 <code>@Scheduled</code> 注解即可定义定时任务。支持 <strong>Cron 表达式</strong> 。Cron 表达式主要用于定时作业(定时任务)系统定义执行时间或执行频率的表达式。</p>
<p>但是，Spring 自带的定时调度只支持单机，并且提供的功能比较单一，不够灵活。</p>
<p>​	1.单线程执行，多个定时任务不能同时执行</p>
<p>​    2.如果当前定时任务还没有结束，那么下一次定时任务的时间到了也不会触发。</p>
<p>Spring Task 底层是基于 JDK 的 <code>ScheduledThreadPoolExecutor</code> 线程池来实现的。</p>
<p>上面提到的一些定时任务的解决方案都是在单机下执行的，适用于比较简单的定时任务场景比如每天凌晨备份一次数据。如果我们需要一些高级特性比如支持任务在分布式场景下的分片和高可用的话，我们就需要用到分布式任务调度框架了。</p>
<h3 id="Quartz"><a href="#Quartz" class="headerlink" title="Quartz"></a>Quartz</h3><p>通常情况下，一个定时任务的执行往往涉及到下面这些角色：</p>
<ul>
<li><strong>任务</strong>：首先肯定是要执行的任务，这个任务就是具体的业务逻辑比如定时发送文章。</li>
<li><strong>调度器</strong>：其次是调度中心，调度中心主要负责任务管理，会分配任务给执行器。</li>
<li><strong>执行器</strong>：最后就是执行器，执行器接收调度器分派的任务并执行。</li>
</ul>
<h4 id="Quartz集群如何分派任务"><a href="#Quartz集群如何分派任务" class="headerlink" title="Quartz集群如何分派任务"></a>Quartz集群如何分派任务</h4><p>在通常情况下，我们都是希望任务<strong>仅在集群中某一台机器中执行</strong>，而非并发执行带来难以预期的后果，这种情况下，就存在着如何分派任务的问题。</p>
<p>Quartz中存在两种行锁STATE_ACCESS和TRIGGER_ACCESS，分别代表着状态访问锁和触发器访问锁。</p>
<p>我们需要明确的一点是，集群中的Quartz都是同构的。在这个前提下，任务会在各个集群服务器同一时刻被唤起（当然，需要保证服务器之间的时间同步），<strong>抢占共享数据库中触发器访问锁</strong>，抢到锁的服务器拥有本次任务的执行权限，为获取到锁的服务器退出本次任务的执行。</p>
<h4 id="Quartz与XXL-job对比"><a href="#Quartz与XXL-job对比" class="headerlink" title="Quartz与XXL-job对比"></a>Quartz与XXL-job对比</h4><p>quartz是一款开源的使用非常广泛的定时任务框架。其可以说是定时任务的鼻祖，很多理念都与xxl-job类似。</p>
<p><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="http://oss.ripplesu.top/blog/Typora/%E9%9D%A2%E8%AF%95%E9%A2%98/v2-d65c823532738779d19c92d70588e0df_r.jpg" alt="Quartz与XXL-JOB对比"></p>
<p>整体来说，xxl-job就是quartz的一个增强版，其弥补了quartz不支持并行调度，不支持失败处理策略和动态分片的策略等诸多不足，同时其有管理界面，上手比较容易，支持分布式，适用于分布式场景下的使用。两者相同的是都是通过数据库锁来控制任务不能重复执行。</p>
<h3 id="XXL-job"><a href="#XXL-job" class="headerlink" title="XXL-job"></a>XXL-job</h3><p>优点：</p>
<ul>
<li>社区活跃：GitHub20+kstar，1000+issue；相较quartz和elasticjob活跃的多</li>
<li>开箱即用（学习成本比较低）、与 Spring 集成。</li>
<li>分布式支持：XXL-Job 可以支持分布式部署，可以在多台机器上运行任务，并且可以通过注册中心进行任务调度和监控。只依赖数据库作为集群注册中心，不需要ZK</li>
<li>高可靠性和容错性：XXL-Job 支持任务的失败重试和任务的失效转移（系统会自动将该节点上的任务转移到其他节点上执行），可以保证任务的高可靠性和容错性。</li>
<li>可视化管理界面：XXL-Job 提供了一个可视化的管理界面，可以方便地进行任务管理、任务调度和任务监控。</li>
<li>执行日志记录：XXL-Job 可以记录任务的执行日志，方便用户进行问题排查和分析。</li>
</ul>
<h3 id="Elastic-job"><a href="#Elastic-job" class="headerlink" title="Elastic-job"></a>Elastic-job</h3><p>当当网开源的一个面向互联网生态和海量任务的分布式调度解决方案，由两个相互独立的子项目 ElasticJob-Lite 和 ElasticJob-Cloud 组成。</p>
<p>使用 ZooKeeper 作为注册中心，注册中心负责协调分配任务到不同的节点上。</p>
<p>Elastic-Job 中的定时调度都是由执行器自行触发，这种设计也被称为去中心化设计（调度和处理都是执行器单独完成）。</p>
<ul>
<li>优点：可以与 Spring集成、支持分布式、支持集群、性能不错</li>
<li>缺点：依赖了额外的中间件比如 Zookeeper（复杂度增加，可靠性降低、维护成本变高）</li>
</ul>
<h2 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a>计算机基础</h2><h3 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h3><h4 id="网络体系结构"><a href="#网络体系结构" class="headerlink" title="网络体系结构"></a>网络体系结构</h4><h5 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h5><p>从下到上分别是<strong>物理层、数据链路层、网络层、传输层、会话层、表示层和应用层</strong>。</p>
<ul>
<li><p>物理层</p>
<ul>
<li><p>任务：<strong>透明（透明传输指的是，无论上层交付给数据链路层什么数据，数据链路层都好像是看不见这个数据一样将这个数据传输出去。）地传输比特流</strong>。尽可能屏蔽掉具体传输介质和物理设备的差异。使其上面的数据链路层不必考虑网络的具体传输介质是什么。</p>
</li>
<li><p>功能：为数据段设备提供传送数据通路</p>
</li>
<li><p>传输单位：比特</p>
</li>
<li><p>所实现的硬件：集线器，中继器</p>
</li>
</ul>
</li>
<li><p>数据链路层</p>
<ul>
<li><p>任务：<strong>将网络层传输下来的IP数据报组装成帧</strong>，通过差错控制、流量控制方法，使有差错的物理线路变为无差错的数据链路，即提供可靠的通过物理介质传输数据的方法。</p>
</li>
<li><p>功能：a. 链路连接的建立、拆除和分离</p>
<p>​            b. 帧定界和帧同步</p>
<p>​            c.差错检测</p>
</li>
<li><p>传输单位：帧</p>
</li>
<li><p>所实现的硬件：交换机、网桥</p>
</li>
<li><p>协议：PPP,HDLC、SDLC、STP、ARQ</p>
</li>
</ul>
</li>
<li><p>网络层</p>
<ul>
<li><p>任务：a. 将传输层传下来的报文段封装成分组</p>
<p>​            b.选择合适的路由，使得传输层传下来的分组能够交付到目的主机</p>
</li>
<li><p>功能：a. 为传输层提供服务</p>
<p>​            b. 组包和拆包</p>
<p>​            c. 路由选择</p>
<p>​            d.拥塞控制</p>
</li>
<li><p>传输单位：数据段</p>
</li>
<li><p>所实现的硬件：路由器</p>
</li>
<li><p>协议：ICMP、ARP、RARP、IP、IGMP、OSPF</p>
</li>
</ul>
</li>
<li><p>传输层</p>
<ul>
<li><p>任务：<strong>负责主机中两个进程之间的通信</strong></p>
</li>
<li><p>功能：</p>
<p>​      a. 为端到端连接提供可靠的服务</p>
<p>​      b. 为端到端连接提供流量控制、差错控制、服务质量等管理服务</p>
</li>
<li><p>传输单位：报文段（TCP）或用户数据报（UDP）</p>
</li>
<li><p><strong>协议：TCP、UDP</strong></p>
</li>
</ul>
</li>
<li><p>会话层</p>
<ul>
<li><p>任务：<strong>不同主机上各进程间的对话</strong></p>
</li>
<li><p>功能：管理主机间的会话进程，包括建立、管理以及终止进程间的会话。是一种端到端的服务</p>
</li>
</ul>
</li>
<li><p>表示层</p>
<p><strong>负责处理在两个内部数据表示结构不同的通信系统之间交换信息的表示格式</strong>（把应用层提供的信息变换为能够共同理解的形式），为数据<em>加密和解密</em>以及为提高传输效率提供必需的数据<em>压缩以及解压</em>等功能。</p>
<p> ①数据格式处理：协商和建立数据交换的格式，解决各应用程序之间在数据格式表示上的差异。   </p>
<p>②数据的编码：处理字符集和数字的转换。   </p>
<p>③压缩和解压缩：为了减少数据的传输量，这一层还负责数据的压缩与恢复。   </p>
<p>④数据的加密和解密：可以提高网络的安全性。</p>
</li>
<li><p>应用层</p>
<ul>
<li><p>任务：<strong>提供系统与用户程序的接口</strong>，使用户程序能够使用网络服务</p>
</li>
<li><p>功能：</p>
<p>​      a.文件传输</p>
<p>​      b. 访问和管理</p>
<p>​      c. 电子邮件服务</p>
</li>
<li><p>协议：FTP（20）、SMTP（25）、POP3、HTTP（80）、DNS（53）、TELnet</p>
</li>
</ul>
</li>
</ul>
<h5 id="TCP-IP协议簇四层模型"><a href="#TCP-IP协议簇四层模型" class="headerlink" title="TCP&#x2F;IP协议簇四层模型"></a>TCP&#x2F;IP协议簇四层模型</h5><p><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="https://s2.loli.net/2023/06/08/Udx5HGbC64lT3cg.png" alt="image-20230608152155503"></p>
<ol>
<li><p><strong>应用层</strong>(application layer)</p>
<p>(1) 应用层(application layer)：是体系结构中的最高。<strong>直接为用户的应用进程提供服务</strong>。应用层是不用去关心数据是如何传输的，当两个不同设备的应用需要通信的时候，应用就把应用数据传给下一层，也就是传输层。</p>
<p>(2) 在因特网中的应用层协议很多，如支持万维网应用的<strong>HTTP</strong>协议，支持电子邮件的<strong>SMTP</strong>协议，支持文件传送的<strong>FTP</strong>协议等等。</p>
</li>
<li><p><strong>传输层</strong>(transport layer)</p>
<ul>
<li><p><strong>传输控制协议TCP(Transmission Control Protocol)：</strong>面向连接的，数据传输的单位是报文段，能够提供可靠的交付（流量控制、超时重传、拥塞控制等）。   </p>
</li>
<li><p><strong>用户数据包协议UDP(User Datagram Protocol)：</strong>无连接的，数据传输的单位是用户数据报，不保证提供可靠的交付，只能提供“尽最大努力交付”。实时性相对更好，传输效率也高。</p>
</li>
</ul>
</li>
<li><p><strong>网络层</strong>(network layer)</p>
<p>对于 IPv4 协议， IP 地址共 32 位，每段是 8 位。只有一个单纯的 IP 地址虽然做到了区分设备，但是寻址起来就特别麻烦，全世界那么多台设备，难道一个一个去匹配？这显然不科学。</p>
<p>因此，需要将 IP 地址分成两种意义：</p>
<ul>
<li>一个是<strong>网络号</strong>，负责标识该 IP 地址是属于哪个「子网」的；</li>
<li>一个是<strong>主机号</strong>，负责标识同一「子网」下的不同主机；</li>
</ul>
<p>怎么分的呢？这需要配合<strong>子网掩码</strong>才能算出 IP 地址 的网络号和主机号。</p>
</li>
<li><p>网络接口层</p>
<p>生成了 IP 头部之后，接下来要交给<strong>网络接口层</strong>（<em>Link Layer</em>）在 IP 头部的前面加上 MAC 头部，并封装成数据帧（Data frame）发送到网络上。</p>
</li>
</ol>
<h5 id="五层模型"><a href="#五层模型" class="headerlink" title="五层模型"></a>五层模型</h5><p>五层网络体系结构分分别为：<strong>应用层、运输层、网络层、数据链路层、物理层</strong>。各层功能分别如下：</p>
<ol>
<li><p>第五层——<strong>应用层</strong>(application layer)</p>
<p>(1) 应用层(application layer)：是体系结构中的最高。直接为用户的应用进程提供服务。</p>
<p>(2) 在因特网中的应用层协议很多，如支持万维网应用的HTTP协议，支持电子邮件的SMTP协议，支持文件传送的FTP协议等等。</p>
</li>
<li><p>第四层——<strong>运输层</strong>(transport layer)</p>
<p>(1) 运输层(transport layer)：负责向两个主机中进程之间的通信提供服务。由于一个主机可同时运行多个进程，因此运输层有<strong>复用</strong>和<strong>分用</strong>的功能。</p>
<p>  a. 复用，就是多个应用层进程可同时使用下面运输层的服务。</p>
<p>  b. 分用，就是把收到的信息分别交付给上面应用层中相应的进程。</p>
<p>(2) <strong>运输层主要使用以下两种协议：</strong>   <strong>(1) 传输控制协议TCP(Transmission Control Protocol)：</strong>面向连接的，数据传输的单位是报文段，能够提供可靠的交付。   <strong>(2) 用户数据包协议UDP(User Datagram Protocol)：</strong>无连接的，数据传输的单位是用户数据报，不保证提供可靠的交付，只能提供“尽最大努力交付”。</p>
</li>
<li><p>第三层——<strong>网络层</strong>(network layer)</p>
<p>网络层(network layer)主要包括以下两个任务：</p>
<p>(1) 负责为分组交换网上的不同主机提供通信服务。在发送数据时，网络层把运输层残生的报文段或用户数据报封装成分组或包进行传送。在TCP&#x2F;IP体系中，由于网络层使用IP协议，因此分组也叫做IP数据报，或简称为数据报。</p>
<p>(2) 选中合适的路由，使源主机运输层所传下来的分组，能够通过网络中的路由器找到目的主机。</p>
</li>
<li><p>第二层——<strong>数据链路层</strong>(data link layer)</p>
<p><strong>数据链路层(data link layer)：</strong>常简称为链路层，我们知道，两个主机之间的数据传输，总是在一段一段的链路上传送的，也就是说，在两个相邻结点之间传送数据是直接传送的(点对点)，这时就需要使用专门的链路层的协议。</p>
<p>在两个相邻结点之间传送数据时，数据链路层将网络层交下来的IP数据报组装成帧(framing)，在两个相邻结点之间的链路上“透明”地传送帧中的数据。</p>
<p>每一帧包括数据和必要的控制信息(如同步信息、地址信息、差错控制等)。典型的帧长是几百字节到一千多字节。</p>
<p><strong>注意</strong>：”透明”是一个很重要的术语。它表示，某一个实际存在的事物看起来却好像不存在一样。”在数据链路层透明传送数据”表示无力什么样的比特组合的数据都能够通过这个数据链路层。因此，对所传送的数据来说，这些数据就“看不见”数据链路层。或者说，数据链路层对这些数据来说是透明的。   (1) 在接收数据时，控制信息使接收端能知道一个帧从哪个比特开始和到哪个比特结束。这样，数据链路层在收到一个帧后，就可从中提取出数据部分，上交给网络层。   (2) 控制信息还使接收端能检测到所收到的帧中有无差错。如发现有差错，数据链路层就简单地丢弃这个出了差错的帧，以免继续传送下去白白浪费网络资源。如需改正错误，就由运输层的TCP协议来完成。</p>
<p>相关题目：数据链路层采用后退N帧（GBN）协议，发送方已经发送了编号为0～7的帧。当计时器超时时，若发送方只收到0、2、3号帧的确认，则发送方需要重发的帧数是多少？分别是那几个帧？</p>
<p>根据GBN协议工作原理，GBN协议的确认是累积确认，不会管中间所丢的数据包，所以，此时发送端需要重发的帧数是4个，依次分别是4、5、6、7号帧</p>
</li>
<li><p>第一层——<strong>物理层</strong>(physical layer)</p>
<p><strong>物理层(physical layer)：</strong>在物理层上所传数据的单位是比特。物理层的任务就是透明地传送比特流。</p>
</li>
</ol>
<h4 id="TCP与UDP"><a href="#TCP与UDP" class="headerlink" title="TCP与UDP"></a>TCP与UDP</h4><h5 id="TCP与UDP区别"><a href="#TCP与UDP区别" class="headerlink" title="TCP与UDP区别"></a>TCP与UDP区别</h5><p><strong>是否面向连接</strong>：UDP 在传送数据之前不需要先建立连接。而 TCP 提供面向连接的服务，在传送数据之前必须先建立连接，数据传送结束后要释放连接。</p>
<p><strong>是否是可靠传输</strong>：远地主机在收到 UDP 报文后，不需要给出任何确认，并且不保证数据不丢失，不保证是否顺序到达（尽最大努力交付）。TCP 提供可靠的传输服务，TCP 在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、超时重传、拥塞控制等机制。通过 TCP 连接传输的数据，无差错、不丢失、不重复、并且按序到达。</p>
<p><strong>是否有状态</strong>：这个和上面的“是否可靠传输”相对应。TCP 传输是有状态的，这个有状态说的是 TCP 会去记录自己发送消息的状态比如消息是否发送了、是否被接收了等等。为此 ，TCP 需要维持复杂的连接状态表。而 UDP 是无状态服务，简单来说就是不管发出去之后的事情了。</p>
<p><strong>传输效率</strong>：由于使用 TCP 进行传输的时候多了连接、确认、重传等机制，所以 TCP 的传输效率要比 UDP 低很多。</p>
<p><strong>传输形式</strong>：TCP 是面向字节流的：TCP与应用程序的交互是一次一个数据块,但是TCP把应用程序交下来的数据看成仅仅是一连串的无结构的字节流。TCP不保证接收方应用程序所收到的数据块和发送方应用程序所发出的数据块具有对应大小的关系,但是接收方应用程序收到的字节流必须和发送方应用程序发出的字节流完全一样</p>
<p>UDP 是面向报文的：发送方 UDP 对应用程序交下来的报文,在添加首部后就向下交付 IP 层。UDP 对应用层交下来的报文,既不合并,也不拆分,而是保留这些报文的边界。接收方 UDP 对 IP 层交上来的 UDP 用户数据报,在去除首部后就原封不动地交付上层的应用进程,一次交付一个完整的报文。 </p>
<p><strong>首部开销</strong>：TCP 首部开销（20 ～ 60 字节）比 UDP 首部开销（8 字节）要大。</p>
<p><strong>是否提供广播或多播服务</strong>：TCP 只支持点对点通信，UDP 支持一对一、一对多、多对一、多对多；</p>
<h5 id="什么时候选择-TCP，什么时候选-UDP"><a href="#什么时候选择-TCP，什么时候选-UDP" class="headerlink" title="什么时候选择 TCP，什么时候选 UDP?"></a>什么时候选择 TCP，什么时候选 UDP?</h5><ul>
<li><strong>UDP 一般用于即时通信</strong>，比如：语音、 视频、直播等等。这些场景对传输数据的准确性要求不是特别高，比如你看视频即使少个一两帧，实际给人的感觉区别也不大。</li>
<li><strong>TCP 用于对传输准确性要求特别高的场景</strong>，比如文件传输、发送和接收邮件、远程登录等等</li>
</ul>
<h5 id="TCP格式"><a href="#TCP格式" class="headerlink" title="TCP格式"></a>TCP格式</h5><p><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="https://s2.loli.net/2023/06/10/kgJKHqFNV3fxci5.png" alt="TCP 头格式"></p>
<p><strong>序列号</strong>：在建立连接时由计算机生成的随机数作为其初始值，通过 SYN 包传给接收端主机，每发送一次数据，就「累加」一次该「数据字节数」的大小。<strong>用来解决网络包乱序问题。</strong></p>
<p><strong>确认应答号</strong>：指<strong>下一次「期望」收到的数据的序列号</strong>，发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。<strong>用来解决丢包的问题。</strong></p>
<p><strong>控制位：</strong></p>
<ul>
<li><em>ACK</em>：该位为 <code>1</code> 时，「确认应答」的字段变为有效，TCP 规定除了最初建立连接时的 <code>SYN</code> 包之外该位必须设置为 <code>1</code> 。</li>
<li><em>RST</em>：该位为 <code>1</code> 时，表示 TCP 连接中出现异常必须强制断开连接。</li>
<li><em>SYN</em>：该位为 <code>1</code> 时，表示希望建立连接，并在其「序列号」的字段进行序列号初始值的设定。</li>
<li><em>FIN</em>：该位为 <code>1</code> 时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换 <code>FIN</code> 位为 1 的 TCP 段。</li>
</ul>
<h5 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h5><p><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="https://s2.loli.net/2023/06/10/UVHMpqJlN46RISd.png" alt="TCP 三次握手"></p>
<ul>
<li>一开始，客户端和服务端都处于 <code>CLOSE</code> 状态。先是服务端主动监听某个端口，处于 <code>LISTEN</code> 状态</li>
<li>客户端会随机初始化序号（<code>client_isn</code>），将此序号置于 TCP 首部的「序号」字段中，同时把 <code>SYN</code> 标志位置为 <code>1</code>，表示 <code>SYN</code> 报文。接着把第一个 SYN 报文发送给服务端，表示向服务端发起连接，该报文不包含应用层数据，之后客户端处于 <code>SYN-SENT</code> 状态。</li>
<li>服务端收到客户端的 <code>SYN</code> 报文后，首先服务端也随机初始化自己的序号（<code>server_isn</code>），将此序号填入 TCP 首部的「序号」字段中，其次把 TCP 首部的「确认应答号」字段填入 <code>client_isn + 1</code>, 接着把 <code>SYN</code> 和 <code>ACK</code> 标志位置为 <code>1</code>。最后把该报文发给客户端，该报文也不包含应用层数据，之后服务端处于 <code>SYN-RCVD</code> 状态。</li>
<li>客户端收到服务端报文后，还要向服务端回应最后一个应答报文，首先该应答报文 TCP 首部 <code>ACK</code> 标志位置为 <code>1</code> ，其次「确认应答号」字段填入 <code>server_isn + 1</code> ，最后把报文发送给服务端，这次报文可以携带客户到服务端的数据，之后客户端处于 <code>ESTABLISHED</code> 状态。</li>
<li>服务端收到客户端的应答报文后，也进入 <code>ESTABLISHED</code> 状态。</li>
</ul>
<h6 id="（了解）为什么是三次？"><a href="#（了解）为什么是三次？" class="headerlink" title="（了解）为什么是三次？"></a>（了解）为什么是三次？</h6><p>RFC 793 指出的 TCP 连接使用三次握手的<strong>首要原因</strong>：</p>
<blockquote>
<p><em>The principle reason for the three-way handshake is to prevent old duplicate connection initiations from causing confusion.</em></p>
</blockquote>
<p>简单来说，三次握手的<strong>首要原因是为了防止旧的重复连接初始化造成混乱。</strong></p>
<p>我们考虑一个场景，客户端先发送了 SYN（seq &#x3D; 90）报文，然后客户端宕机了，而且这个 SYN 报文还被网络阻塞了，服务端并没有收到，接着客户端重启后，又重新向服务端建立连接，发送了 SYN（seq &#x3D; 100）报文（<em>注意！不是重传 SYN，重传的 SYN 的序列号是一样的</em>）。</p>
<p><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="https://s2.loli.net/2023/06/10/uCQoa1Xs3Zm92rI.png" alt="三次握手避免历史连接"></p>
<p>客户端连续发送多次 SYN（都是同一个四元组）建立连接的报文，在<strong>网络拥堵</strong>情况下：</p>
<ul>
<li>一个「旧 SYN 报文」比「最新的 SYN」 报文早到达了服务端，那么此时服务端就会回一个 <code>SYN + ACK</code> 报文给客户端，此报文中的确认号是 91（90+1）。</li>
<li>客户端收到后，发现自己期望收到的确认号应该是 100 + 1，而不是 90 + 1，于是就会回 RST 报文。</li>
<li>服务端收到 RST 报文后，就会释放连接。</li>
<li>后续最新的 SYN 抵达了服务端后，客户端与服务端就可以正常的完成三次握手了。</li>
</ul>
<p>上述中的「旧 SYN 报文」称为历史连接，TCP 使用三次握手建立连接的<strong>最主要原因就是防止「历史连接」初始化了连接</strong>。</p>
<p><a target="_blank" rel="noopener" href="https://www.xiaolincoding.com/network/3_tcp/tcp_interview.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B-%E4%B8%8D%E6%98%AF%E4%B8%A4%E6%AC%A1%E3%80%81%E5%9B%9B%E6%AC%A1">https://www.xiaolincoding.com/network/3_tcp/tcp_interview.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B-%E4%B8%8D%E6%98%AF%E4%B8%A4%E6%AC%A1%E3%80%81%E5%9B%9B%E6%AC%A1</a></p>
<h6 id="握手丢失了会发生什么"><a href="#握手丢失了会发生什么" class="headerlink" title="握手丢失了会发生什么"></a>握手丢失了会发生什么</h6><ul>
<li><p>第一次握手丢失</p>
<p>当客户端想和服务端建立 TCP 连接的时候，首先第一个发的就是 SYN 报文，然后进入到 <code>SYN_SENT</code> 状态。</p>
<p>在这之后，如果客户端迟迟收不到服务端的 SYN-ACK 报文（第二次握手），就会触发「<strong>超时重传</strong>」机制，重传 SYN 报文，而且<strong>重传的 SYN 报文的序列号都是一样的</strong>。</p>
<p><strong>每次超时的时间是上一次的 2 倍，有次数限制（Linux中默认为5）。</strong></p>
<p>达到最大重传次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到服务端的第二次握手（SYN-ACK 报文），那么客户端就会断开连接。</p>
</li>
<li><p>第二次握手丢失</p>
<p>当服务端收到客户端的第一次握手后，就会回 SYN-ACK 报文给客户端，这个就是第二次握手，此时服务端会进入 <code>SYN_RCVD</code> 状态。</p>
<p>第二次握手的 <code>SYN-ACK</code> 报文其实有两个目的 ：</p>
<ul>
<li>第二次握手里的 ACK， 是对第一次握手的确认报文；</li>
<li>第二次握手里的 SYN，是服务端发起建立 TCP 连接的报文；</li>
</ul>
<p>因为第二次握手报文里是包含对客户端的第一次握手的 ACK 确认报文，所以，如果客户端迟迟没有收到第二次握手，那么<em>客户端就觉得可能自己的 SYN 报文（第一次握手）丢失了</em>，于是<strong>客户端就会触发超时重传机制，重传 SYN 报文</strong>。</p>
<p>然后，因为第二次握手中包含服务端的 SYN 报文，所以当客户端收到后，需要给服务端发送 ACK 确认报文（第三次握手），服务端才会认为该 SYN 报文被客户端收到了。</p>
<p>那么，如果第二次握手丢失了，服务端就收不到第三次握手，于是<strong>服务端这边会触发超时重传机制，重传 SYN-ACK 报文</strong>。</p>
</li>
<li><p>第三次握手丢失了，会发生什么？</p>
<p>客户端收到服务端的 SYN-ACK 报文后，就会给服务端回一个 ACK 报文，也就是第三次握手，此时客户端状态进入到 <code>ESTABLISH</code> 状态。</p>
<p>因为这个第三次握手的 ACK 是对第二次握手的 SYN 的确认报文，所以当第三次握手丢失了，如果服务端那一方迟迟收不到这个确认报文，就会触发超时重传机制，<strong>重传 SYN-ACK 报文</strong>，直到收到第三次握手，或者达到最大重传次数。</p>
<p>注意，<strong>ACK 报文是不会有重传的，当 ACK 丢失了，就由对方重传对应的报文</strong>。</p>
</li>
</ul>
<h5 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h5><p>双方都可以主动断开连接，断开连接后主机中的资源将被释放，四次挥手的过程如下图：</p>
<p><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="https://s2.loli.net/2023/06/10/3vrqMIiLT2khS4J.png" alt="客户端主动关闭连接 —— TCP 四次挥手"></p>
<ul>
<li>第一次：客户端打算关闭连接，此时会发送一个 TCP 首部 <code>FIN</code> 标志位被置为 <code>1</code> 的报文，也即 <code>FIN</code> 报文，之后客户端进入 <code>FIN_WAIT_1</code> 状态。</li>
<li>第二次：服务端收到该报文后，就向客户端发送 <code>ACK</code> 应答报文，接着服务端进入 <code>CLOSE_WAIT</code> 状态。</li>
<li>客户端收到服务端的 <code>ACK</code> 应答报文后，之后进入 <code>FIN_WAIT_2</code> 状态。</li>
<li>第三次：等待服务端处理完数据后，也向客户端发送 <code>FIN</code> 报文，之后服务端进入 <code>LAST_ACK</code> 状态。</li>
<li>第四次：客户端收到服务端的 <code>FIN</code> 报文后，回一个 <code>ACK</code> 应答报文，之后进入 <code>TIME_WAIT</code> 状态</li>
<li>服务端收到了 <code>ACK</code> 应答报文后，就进入了 <code>CLOSE</code> 状态，至此服务端已经完成连接的关闭。</li>
<li>客户端在经过 <code>2MSL</code> 一段时间后，自动进入 <code>CLOSE</code> 状态，至此客户端也完成连接的关闭</li>
</ul>
<h6 id="为什么是四次？"><a href="#为什么是四次？" class="headerlink" title="为什么是四次？"></a>为什么是四次？</h6><ul>
<li>关闭连接时，客户端向服务端发送 <code>FIN</code> 时，仅仅表示客户端不再发送数据了但是还能接收数据。</li>
<li>服务端收到客户端的 <code>FIN</code> 报文时，先回一个 <code>ACK</code> 应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 <code>FIN</code> 报文给客户端来表示同意现在关闭连接。</li>
</ul>
<p>从上面过程可知，服务端通常需要等待完成数据的发送和处理，所以服务端的 <code>ACK</code> 和 <code>FIN</code> 一般都会分开发送，因此是需要四次挥手。</p>
<blockquote>
<p>什么情况会出现三次挥手？</p>
<p>当被动关闭方（上图的服务端）在 TCP 挥手过程中，「<strong>没有数据要发送」并且「开启了 TCP 延迟确认机制」（默认开启），那么第二和第三次挥手就会合并传输，这样就出现了三次挥手。</strong></p>
<p>当发送没有携带数据的 ACK，它的网络效率也是很低的，因为它也有 40 个字节的 IP 头 和 TCP 头，但却没有携带数据报文。 为了解决 ACK 传输效率低问题，所以就衍生出了 <strong>TCP 延迟确认</strong>。 TCP 延迟确认的策略：</p>
<ul>
<li>当有响应数据要发送时，ACK 会随着响应数据一起立刻发送给对方</li>
<li>当没有响应数据要发送时，ACK 将会延迟一段时间，以等待是否有响应数据可以一起发送</li>
<li>如果在延迟等待发送 ACK 期间，对方的第二个数据报文又到达了，这时就会立刻发送 ACK</li>
</ul>
</blockquote>
<h6 id="握手丢失"><a href="#握手丢失" class="headerlink" title="握手丢失"></a>握手丢失</h6><ul>
<li><p>第一次丢失：客户端（发送方）重传，每次重传间隔时间是上次2倍，有次数限制</p>
</li>
<li><p>第二次丢失：ACK不会重传，故与第一次一致</p>
</li>
<li><p>第三次丢失：重传FIN</p>
</li>
<li><p>第四次丢失：重传FIN</p>
<p>具体过程：</p>
<ul>
<li>当服务端重传第三次挥手报文达到 2 时，由于 tcp_orphan_retries 为 2（假设）， 达到了最大重传次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到客户端的第四次挥手（ACK 报文），那么服务端就会断开连接。</li>
<li>客户端在收到第三次挥手后，就会进入 TIME_WAIT 状态，开启时长为 2MSL 的定时器，如果途中再次收到第三次挥手（FIN 报文）后，就会重置定时器，当等待 2MSL 时长后，客户端就会断开连接。</li>
</ul>
</li>
</ul>
<h6 id="为什么TIME-WAIT等待2MSL"><a href="#为什么TIME-WAIT等待2MSL" class="headerlink" title="为什么TIME_WAIT等待2MSL"></a>为什么TIME_WAIT等待2MSL</h6><p><strong>等待足够的时间以确保最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭。</strong></p>
<p>如果客户端（主动关闭方）最后一次 ACK 报文（第四次挥手）在网络中丢失了，那么按照 TCP 可靠性原则，服务端（被动关闭方）会重发 FIN 报文。</p>
<p>假设客户端没有 TIME_WAIT 状态，而是在发完最后一次回 ACK 报文就直接进入 CLOSE 状态，如果该 ACK 报文丢失了，服务端则重传的 FIN 报文，而这时客户端已经进入到关闭状态了，在收到服务端重传的 FIN 报文后，就会回 RST 报文。</p>
<p>服务端收到这个 RST 就会异常关闭连接。</p>
<p>为了防止这种情况出现，客户端必须等待足够长的时间，确保服务端能够收到 ACK，如果服务端没有收到 ACK，那么就会触发 TCP 重传机制，服务端会重新发送一个 FIN，这样一去一来刚好两个 MSL 的时间。</p>
<p>客户端在收到服务端重传的 FIN 报文时，TIME_WAIT 状态的等待时间，会重置回 2MSL。</p>
<p><strong>防止历史连接中的数据，被后面相同四元组的连接错误的接收</strong></p>
<p>TCP使用四元组区分一个连接（源端口、目的端口、源IP、目的IP），如果新、旧连接的IP与端口号完全一致，则内核协议栈无法区分这两条连接。</p>
<p>如果旧链接发送的报文由于某些原因被网络延迟了，服务端以相同的四元组打开了新连接，就可能接收前面被延迟的报文，这就会导致数据错乱的问题。</p>
<p>为了防止这个问题， TCP 设计了 TIME_WAIT 状态，状态会持续 <code>2MSL</code> 时长，这个时间<strong>足以让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都自然消失，再出现的数据包一定都是新建立连接所产生的。</strong></p>
<h6 id="TIME-WAIT太多？"><a href="#TIME-WAIT太多？" class="headerlink" title="TIME_WAIT太多？"></a>TIME_WAIT太多？</h6><p>当连接处于TIME_WAIT状态时仍会占用系统资源（fd（文件描述符，单文件最大1024个）、端口、内存），TIME_WAIT太多就会占用大量的系统资源</p>
<h4 id="访问一个页面的过程？"><a href="#访问一个页面的过程？" class="headerlink" title="访问一个页面的过程？"></a>访问一个页面的过程？</h4><h4 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h4><h5 id="HTTP（超文本传输协议）简介"><a href="#HTTP（超文本传输协议）简介" class="headerlink" title="HTTP（超文本传输协议）简介"></a>HTTP（超文本传输协议）简介</h5><p>（1）HTTP协议的特性</p>
<p>  HTTP 协议一共有<strong>五大特点</strong>：a. 支持客户&#x2F;服务器模式；b. 简单快速；c. 灵活；d. 无连接；e. 无状态。</p>
<p>  <strong>无连接含义：</strong>限制每次连接只处理一个请求。服务器<strong>处理完客户的请求，并收到客户的应答后，即断开连接</strong>。采用这种方式可以节省传输时间。</p>
<p>  <strong>无状态含义：</strong>指协议对于事务处理没有记忆能力，<strong>服务器不知道客户端是什么状态</strong>。即我们给服务器发送 HTTP 请求之后，服务器根据请求，会给我们发送数据过来，但是，发送完，不会记录任何信息。</p>
<p>（2）HTTP 客户机及服务器</p>
<p>  HTTP 客户机：web 浏览器</p>
<p>  HTTP 服务器：web 服务器，包含 web 对象（HTML 文件、JPEG 文件、java 小程序、视频片段等）</p>
<p>（3）HTTP 方法字段：</p>
<p>  <strong>GET</strong>：绝大部分 HTTP 请求报文使用 GET 方法</p>
<p>  <strong>POST</strong>：用户提交表单时（如向搜索引擎提供关键字），但提交表单不一定要用 POST 方法</p>
<p>  <strong>HEAD</strong>：类似于 GET，区别在于服务器返回的响应报文中不包含请求对象（常用于故障跟踪）</p>
<p>  <strong>PUT</strong>：用于向服务器上传对象</p>
<p>  <strong>DELETE</strong>：用于删除服务器上的对象</p>
<p>（4）HTTP 状态信息</p>
<p><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="/../../../ProgramData/Typora/Blog/%E9%9D%A2%E8%AF%95%E9%A2%98/6-%E4%BA%94%E5%A4%A7%E7%B1%BBHTTP%E7%8A%B6%E6%80%81%E7%A0%81.png" alt=" 五大类 HTTP 状态码 "></p>
<p>  <strong>200 OK</strong> 表示从客户端发来的请求在服务器端被正确处理  </p>
<p>  <strong>301 Permanently Moved</strong> 被请求的资源已永久移动到新位置，新的URL在Location头中给出，浏览器应该自动地访问新的URL。</p>
<p>  <strong>302 Found</strong> 请求的资源现在临时从不同的URL响应请求。301是永久重定向，而302是临时重定向。</p>
<p>  <strong>304 Not Modified</strong> 304状态码是告诉浏览器可以从缓存中获取所请求的资源。</p>
<p>  <strong>400 bad request</strong> 请求报文存在语法错误</p>
<p>  <strong>403 forbidden</strong> 表示对请求资源的访问被服务器拒绝</p>
<p>  <strong>404 not found</strong> 表示在服务器上没有找到请求的资源</p>
<p>  <strong>500 internal sever error</strong> 表示服务器端在执行请求时发生了错误</p>
<p>  <strong>503 service unavailable</strong> 表明服务器暂时处于超负载或正在停机维护，无法处理请求</p>
<p>（4）HTTP中常见的文件格式</p>
<p>  text&#x2F;html： HTML格式</p>
<p>  text&#x2F;plain：纯文本格式</p>
<p>  image&#x2F;jpeg：jpg图片格式</p>
<p>  application&#x2F;json： JSON数据格式</p>
<p>  application&#x2F;x-www-form-urlencoded： form表单数据被编码为key&#x2F;value格式发送到服务器（表单默认的提交数据格式）</p>
<p>  multipart&#x2F;form-data： 在表单中进行文件上传时使用</p>
<ul>
<li><p>get请求与post请求有什么区别？</p>
<ul>
<li><p>一般<strong>get是幂等的，post不是</strong>。幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。</p>
<p>GET 只是查询数据，所以不会影响服务器的资源，所以<strong>GET是幂等性的</strong>。</p>
<p>POST因为每次调用都会生在后台新建资源，所以<strong>POST不是幂等性的。</strong></p>
<p>相关问题：一个用户下单点外卖，此时进入了高铁隧道没信号了，于是多点了几下，如何处理这种重复的请求？</p>
<p>用 Token 的机制实现防止重复提交。</p>
<p>简单的说就是调用方在调用接口的时候先向后端请求一个全局 ID（Token），请求的时候携带这个全局 ID 一起请求（Token 最好将其放到 Headers 中），后端把 Token 作为 Key存入redis；服务端接收到请求后根据 Token 到 Redis 中查找该 key 是否存在，如果 Key 存在就执行删除命令，然后正常执行后面的业务逻辑；不存在就是重复提交。</p>
</li>
</ul>
<ul>
<li><p>GET请求会被浏览器主动cache，而且在浏览器中 GET 请求可以保存为书签（因为幂等），而POST不会，除非手动设置（cache）。</p>
</li>
<li><p>对参数的数据类型，GET只接受ASCII字符，而POST没有限制。</p>
</li>
<li><p>GET参数通过URL传递，传送的参数是有长度限制的，POST放在Request body中，无长度限制。</p>
</li>
<li><p>get请求产生一个TCP数据包；post请求产生两个TCP数据包（get请求，浏览器会把http header和data一并发送出去，服务器响应200返回数据；post请求，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 返回数据）</p>
</li>
</ul>
</li>
</ul>
<h5 id="HTTP和HTTPS"><a href="#HTTP和HTTPS" class="headerlink" title="HTTP和HTTPS"></a>HTTP和HTTPS</h5><ul>
<li>HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL&#x2F;TLS 安全协议，使得报文能够加密传输。</li>
<li>HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL&#x2F;TLS 的握手过程，才可进入加密报文传输。</li>
<li>两者的默认端口不一样，HTTP 默认端口号是 80，HTTPS 默认端口号是 443。</li>
<li>HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。</li>
</ul>
<h4 id="Cookie和Session"><a href="#Cookie和Session" class="headerlink" title="Cookie和Session"></a>Cookie和Session</h4><ul>
<li><p>cookie和session的区别是什么？</p>
<ol>
<li>存储位置不同：cookie存放于客户端；session存放于服务端，占用服务器内存。</li>
<li>存储容量不同：单个cookie保存的数据&lt;&#x3D;4KB，一个站点最多保存20个cookie；而session并没有上限。</li>
<li>隐私策略不同：cookie对客户端是可见的，别有用心的人可以分析存放在本地的cookie并进行cookie欺骗，所以它是不安全的；session存储在服务器上，对客户端是透明的，不存在敏感信息泄露的风险。</li>
<li>生命周期不同：可以通过设置cookie的属性，达到cookie长期有效的效果；session依赖于名为JSESSIONID的cookie，而该cookie的默认过期时间为-1，只需关闭窗口该session就会失效，因此session不能长期有效。</li>
<li>浏览器支持不同：cookie是需要浏览器支持的，如果客户端禁用了cookie，则会话跟踪就会失效；运用session就需要使用URL重写的方式，所有用到session的URL都要进行重写，否则session会话跟踪也会失效。</li>
<li>跨域支持不同：cookie支持跨域访问，session不支持跨域访问。</li>
</ol>
</li>
<li><p>session的工作原理</p>
<p>session依赖于cookie。</p>
<p>当客户端首次访问服务器时，服务器会为其创建一个session对象，该对象具有一个唯一标识SESSIONID。并且在响应阶段，服务器会创建一个cookie，并将SESSIONID存入其中。</p>
<p>客户端通过响应的cookie而持有SESSIONID，所以当它再次访问服务器时，会通过cookie携带这个SESSIONID。服务器获取到SESSIONID后，就可以找到与之对应的session对象，进而从这个session中获取该客户端的状态。</p>
</li>
</ul>
<h4 id="消息推送"><a href="#消息推送" class="headerlink" title="消息推送"></a>消息推送</h4><h5 id="短轮询"><a href="#短轮询" class="headerlink" title="短轮询"></a>短轮询</h5><p><strong>轮询(polling)</strong> 应该是实现消息推送方案中最简单的一种，这里我们暂且将轮询分为短轮询和长轮询。</p>
<p>短轮询很好理解，指定的时间间隔，由浏览器向服务器发出 HTTP 请求，服务器实时返回未读消息数据给客户端，浏览器再做渲染显示。</p>
<p>一个简单的 JS 定时器就可以搞定，每秒钟请求一次未读消息数接口，返回的数据展示即可。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 方法请求</span></span><br><span class="line">  <span class="title function_">messageCount</span>().<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (res.<span class="property">code</span> === <span class="number">200</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">messageCount</span> = res.<span class="property">data</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<p>效果还是可以的，短轮询实现固然简单，缺点也是显而易见，由于推送数据并不会频繁变更，无论后端此时是否有新的消息产生，客户端都会进行请求，势必会对服务端造成很大压力，浪费带宽和服务器资源。</p>
<h5 id="长轮询"><a href="#长轮询" class="headerlink" title="长轮询"></a>长轮询</h5><p>长轮询是对上边短轮询的一种改进版本，在尽可能减少对服务器资源浪费的同时，保证消息的相对实时性。长轮询在中间件中应用的很广泛，比如 Nacos 和 Apollo 配置中心，消息队列 Kafka、RocketMQ 中都有用到长轮询。</p>
<p>长轮询其实原理跟轮询差不多，都是采用轮询的方式。不过，如果服务端的数据没有发生变更，会 <strong>一直 hold 住请求</strong>，直到服务端的数据发生变化，或者等待一定时间超时才会返回。返回后，客户端又会立即再次发起下一次长轮询。</p>
<p>缺点：</p>
<p>1、保持连接会消耗资源。</p>
<p>2、服务器没有返回有效数据，程序超时</p>
<h5 id="SSE-Server-Send-Events"><a href="#SSE-Server-Send-Events" class="headerlink" title="SSE(Server-Send Events)"></a>SSE(Server-Send Events)</h5><p><a target="_blank" rel="noopener" href="https://html.spec.whatwg.org/multipage/server-sent-events.html#server-sent-events">HTML Standard (whatwg.org)</a></p>
<p>SSE 是 HTML5 遵循 W3C 标准提出的客户端和服务端之间进行实时通信的协议。与 WebSocket 作用相似，都可以建立服务端与浏览器之间的通信，实现服务端向客户端推送消息，但还是有些许不同：</p>
<ul>
<li>SSE 是<strong>基于 HTTP 协议</strong>的，它们不需要特殊的协议或服务器实现即可工作（不需要额外部署）；WebSocket <strong>需单独服务器</strong>来处理协议。</li>
<li>SSE 单向通信，<strong>只能由服务端向客户端单向通信</strong>；WebSocket 全双工通信，即通信的双方可以同时发送和接受信息。</li>
<li>SSE <strong>实现简单</strong>开发成本低，无需引入其他组件；WebSocket 传输数据需做二次解析，开发门槛高一些。</li>
<li>SSE 默认<strong>支持断线重连</strong>，如果连接断开，浏览器会尝试重新连接；WebSocket 则需要自己实现。</li>
<li>SSE <strong>只能传送文本消息</strong>，二进制数据需要经过编码后传送；WebSocket 默认支持传送二进制数据。</li>
<li>SSE单个浏览器单个域名只能打开6个链接</li>
</ul>
<p>SSE 好像一直不被大家所熟知，一部分原因是出现了 WebSocket，这个提供了更丰富的协议来执行双向、全双工通信。对于游戏、即时通信以及需要双向近乎实时更新的场景，拥有双向通道更具吸引力。</p>
<p>但是，在某些情况下，不需要从客户端发送数据。而你只需要一些服务器操作的更新。比如：站内信、未读消息数、状态更新、股票行情、监控数量等场景（Chat-GPT网页端流式数据推送、百度的文心一言也是用SSE实现），SSE 不管是从实现的难易(Spring MVC内置支持，<strong>轻量级</strong>)和成本上都更加有优势。此外，SSE 具有 WebSocket 在设计上缺乏的多种功能，例如：<strong>自动重新连接</strong>、事件 ID 和发送任意事件的能力。</p>
<p>SSE 在服务器和客户端之间打开一个单向通道，本质其实就是一个HTTP的长连接，但服务端响应的不再是一次性的数据包而是<code>Content-Type: text/event-stream</code>类型的数据流信息，在有数据变更时从服务器流式传输到客户端。客户端可以在不同的页面上使用同一个连接来接收事件流。这意味着无论客户端打开了多少个页面，<strong>只需要维护一个连接</strong>即可。</p>
<p>轮询是 请求-响应-请求-响应</p>
<p>SSE是 请求-响应-响应-响应</p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/2280164?areaSource=102001.9&traceId=uLgnP3DiUuqDeR9Jnubjz">https://cloud.tencent.com/developer/article/2280164?areaSource=102001.9&amp;traceId=uLgnP3DiUuqDeR9Jnubjz</a></p>
<blockquote>
<p>SSE（Server-Sent Events）连接在客户端关闭连接或者服务器关闭连接时会自动释放。</p>
<p>当客户端关闭连接时，浏览器会发送一个 <code>close</code> 事件给服务器，服务器在收到该事件后会关闭连接并释放资源。</p>
<p>当服务器关闭连接时，服务器会发送一个 <code>close</code> 事件给客户端，客户端在收到该事件后会关闭连接并释放资源。</p>
<p>需要注意的是，SSE 连接是一种长连接，它可以持续地向客户端推送数据。因此，在使用 SSE 连接时需要注意定时发送心跳包，以保持连接的稳定性。如果长时间没有数据传输，可能会导致连接被关闭。</p>
</blockquote>
<h5 id="Websocket"><a href="#Websocket" class="headerlink" title="Websocket"></a>Websocket</h5><p>Websocket是一种在 TCP 连接上进行全双工通信的协议，建立客户端和服务器之间的通信渠道。浏览器和服务器仅需一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。</p>
<p>SpringBoot 整合 Websocket，先引入 Websocket 相关的工具包，和 SSE 相比额外的开发成本。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引入websocket --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-websocket<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Websocket与SSE性能对比：很接近，体现不出差距，ws要略微好一点</p>
<p><a target="_blank" rel="noopener" href="https://www.timeplus.com/post/websocket-vs-sse">https://www.timeplus.com/post/websocket-vs-sse</a></p>
<h3 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h3><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><ul>
<li><strong>内部排序</strong>：数据记录在内存中进行排序。</li>
<li>**<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%A4%96%E6%8E%92%E5%BA%8F">外部排序open in new window</a>**：因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。</li>
<li><strong>稳定性</strong>：排序前后两个大小相同的元素的相对位置不变</li>
</ul>
<p><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="https://oss.javaguide.cn/github/javaguide/cs-basics/sorting-algorithms/sort1.png" alt="十大排序算法"></p>
<ol>
<li>插入排序的最好时间复杂度为 O(n) 而不是 O(n^2) 。</li>
<li>希尔排序的平均时间复杂度为 O(nlogn)</li>
</ol>
<h5 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h5><p>简言之，两重循环，不断比较相邻两个元素，让这两个元素相对有序。</p>
<ol>
<li><p>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</p>
</li>
<li><p>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</p>
</li>
<li><p>针对所有的元素重复以上的步骤，除了最后一个；</p>
</li>
<li><p>重复步骤 1~3，直到排序完成。</p>
</li>
</ol>
<ul>
<li><strong>稳定性</strong>：稳定</li>
<li><strong>时间复杂度</strong>：最佳：O(n) ，最差：O(n2)， 平均：O(n2)</li>
<li><strong>空间复杂度</strong>：O(1)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 升序排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 当数组已经有序，无需二重循环</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                swap(arr, j, j + <span class="number">1</span>);</span><br><span class="line">                <span class="comment">// Change flag</span></span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h5><p>简言之，不断选择最小&#x2F;最大的元素，交换到已排序序列的末尾</p>
<ol>
<li>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置</li>
<li>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</li>
<li>重复第 2 步，直到所有元素均排序完毕。</li>
</ol>
<ul>
<li><strong>稳定性</strong>：稳定</li>
<li><strong>时间复杂度</strong>：最佳：O(n) ，最差：O(n2)， 平均：O(n2)</li>
<li><strong>空间复杂度</strong>：O(1)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 升序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">selectionSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">minIndex</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[minIndex]) &#123;</span><br><span class="line">                minIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (minIndex != i) &#123;</span><br><span class="line">            swap(arr, minIndex, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h5><p>简言之，不断选择下一个元素，插入到已排序序列中合乎顺序的指定位置</p>
<ol>
<li><p>从第一个元素开始，该元素可以认为已经被排序；</p>
</li>
<li><p>取出下一个元素，在已经排序的元素序列中从后向前扫描；</p>
</li>
<li><p>如果该元素（已排序）大于新元素，将该元素移到下一位置；</p>
</li>
<li><p>重复步骤 3，直到找到已排序的元素小于或者等于新元素的位置；</p>
</li>
<li><p>将新元素插入到该位置后；</p>
</li>
<li><p>重复步骤 2~5。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">insertionSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">preIndex</span> <span class="operator">=</span> i - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        <span class="keyword">while</span> (preIndex &gt;= <span class="number">0</span> &amp;&amp; current &lt; arr[preIndex]) &#123;</span><br><span class="line">            arr[preIndex + <span class="number">1</span>] = arr[preIndex];</span><br><span class="line">            preIndex -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[preIndex + <span class="number">1</span>] = current;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h5><p>快速排序用到了分治思想，同样的还有归并排序。乍看起来快速排序和归并排序非常相似，都是将问题变小，先排序子串，最后合并。不同的是快速排序在划分子问题的时候经过多一步处理，将划分的两组数据划分为一大一小，这样在最后合并的时候就不必像归并排序那样再进行比较。但也正因为如此，划分的不定性使得快速排序的时间复杂度并不稳定。</p>
<p>快速排序的基本思想：通过一趟排序将待排序列分隔成独立的两部分，其中一部分记录的元素均比另一部分的元素小，则可分别对这两部分子序列继续进行排序，以达到整个序列有序。</p>
<p><strong>算法步骤</strong></p>
<p>快速排序使用<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%88%86%E6%B2%BB%E6%B3%95">分治法open in new window</a>（Divide and conquer）策略来把一个序列分为较小和较大的 2 个子序列，然后递回地排序两个子序列。具体算法描述如下：</p>
<ol>
<li>从序列中<strong>随机</strong>挑出一个元素，做为 “基准”(<code>pivot</code>)；</li>
<li>重新排列序列，将所有比基准值小的元素摆放在基准前面，所有比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个操作结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li>
<li>递归地把小于基准值元素的子序列和大于基准值元素的子序列进行快速排序.</li>
</ol>
<ul>
<li><strong>稳定性</strong>：不稳定（意义：初始顺序有意义，比如按多个字段排序）</li>
<li><strong>时间复杂度</strong>：最佳：O(nlogn)， 最差：O(nlogn)，平均：O(nlogn)（每次划分代价n，递归深度nlogn）</li>
<li><strong>空间复杂度</strong>：O(logn)（主要的空间消耗来自于递归调用和分区操作。每次递归调用都需要在栈上保存一些信息，包括递归函数的参数、返回地址等。而分区操作需要使用额外的空间来存储左右子数组的临时数据。递归树高度logn）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> low, <span class="type">int</span> high)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> partition(arr, low, high);</span><br><span class="line">        quickSort(arr, low, pivot-<span class="number">1</span>);</span><br><span class="line">        quickSort(arr, pivot+<span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 左边比pivot小，右边比pivot大，返回pivot位置</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> low, <span class="type">int</span> high)</span>&#123;</span><br><span class="line">    <span class="comment">// 取最左元素为基准</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> arr[low];</span><br><span class="line">    <span class="keyword">while</span> (low &lt; high)&#123;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; arr[high] &gt;= pivot) &#123;</span><br><span class="line">            --high;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[low] = arr[high];</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; arr[low] &lt;= pivot) &#123;</span><br><span class="line">            ++low;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[high] = arr[low];</span><br><span class="line">    &#125;</span><br><span class="line">    arr[low] = pivot;</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>在数据基本有序的情况下，快排的时间复杂度会退化为O(n^2)，如何优化？</p>
<ul>
<li>三数取中法：在选择枢轴元素时，不是简单地选择第一个或最后一个元素，而是选择中间的元素。具体做法是，从待排序数组的头、尾、中间三个位置分别取出一个元素，然后选择这三个元素的中位数作为枢轴元素。这样可以尽可能地避免选择到极端的元素，从而提高快排的效率。</li>
</ul>
<ul>
<li>插入排序：在快排的递归过程中，当待排序数组的大小小于一个阈值时（比如10），可以采用插入排序来代替快排。因为在数据规模较小的情况下，快排可能还要递归好几次，相比之下插入排序的时间复杂度更低，而且插入排序对于基本有序的数据排序效果更好。这样可以避免递归深度过深，提高快排的效率。</li>
</ul>
</li>
<li><p>第k小 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/kth-largest-element-in-an-array/">https://leetcode.cn/problems/kth-largest-element-in-an-array/</a></p>
<p>我们对数组 <code>a[l⋯r] </code>做快速排序的过程是：</p>
<ul>
<li>分解： 将数组<code>a[l⋯r]</code>「划分」成两个子数组<code> a[l⋯q−1]、a[q+1⋯r]</code>，使得 <code>a[l⋯q−1] </code>中的每个元素小于等于 <code>a[q]</code>，且<code>a[q]</code>小于等于 <code>a[q+1⋯r] </code>中的每个元素。其中，计算下标 q 也是「划分」过程的一部分。</li>
<li>解决： 通过递归调用快速排序，对子数组 <code>a[l⋯q−1] </code>和<code>a[q+1⋯r]</code>进行排序。</li>
<li>合并： 因为子数组都是原址排序的，所以不需要进行合并操作，<code>a[l⋯r]</code> 已经有序。</li>
<li>上文中提到的 「划分」 过程是：从子数组 <code>a[l⋯r] </code>中选择任意一个元素 x 作为主元，调整子数组的元素使得左边的元素都小于等于它，右边的元素都大于等于它， x 的最终位置就是 q。</li>
</ul>
<p>由此可以发现每次经过「划分」操作后，我们一定可以确定一个元素的最终位置，即 x 的最终位置为 q，并且保证<code>a[l⋯q−1]</code>中的每个元素小于等于 <code>a[q]</code>，且 <code>a[q]</code> 小于等于 <code>a[q+1⋯r]</code> 中的每个元素。所以只要某次划分的 q 为倒数第 k 个下标的时候，我们就已经找到了答案。 我们只关心这一点，至于 <code>a[l⋯q−1] </code>和 ⋯<code>a[q+1⋯r] </code>是否是有序的，我们不关心。</p>
<p>因此我们可以改进快速排序算法来解决这个问题：在分解的过程当中，我们会对子数组进行划分，如果划分得到的 q 正好就是我们需要的下标，就直接返回 a[q]；否则，如果 q 比目标下标小，就递归右子区间，否则递归左子区间。这样就可以把原来递归两个区间变成只递归一个区间，提高了时间效率。这就是「快速选择」算法。</p>
<p>我们知道快速排序的性能和「划分」出的子数组的长度密切相关。直观地理解如果每次规模为 n 的问题我们都划分成 1 和 n−1，每次递归的时候又向 n−1 的集合中递归，这种情况是最坏的，时间代价是 O(n^2)。我们可以引入随机化来加速这个过程，它的时间代价的期望是 O(n)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">kthSmall</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> low, <span class="type">int</span> high, <span class="type">int</span> k)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> partition(arr, low, high);</span><br><span class="line">    <span class="keyword">if</span>(pivot == k)&#123;</span><br><span class="line">        <span class="keyword">return</span> arr[pivot];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pivot &gt; k)&#123;</span><br><span class="line">        <span class="keyword">return</span> kthSmall(arr, low, pivot - <span class="number">1</span>, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> kthSmall(arr, pivot + <span class="number">1</span>, high, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> low, <span class="type">int</span> high)</span>&#123;</span><br><span class="line">    <span class="comment">// 取最左元素为基准</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> arr[low];</span><br><span class="line">    <span class="keyword">while</span> (low &lt; high)&#123;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; arr[high] &gt;= pivot) &#123;</span><br><span class="line">            --high;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[low] = arr[high];</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; arr[low] &lt;= pivot) &#123;</span><br><span class="line">            ++low;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[high] = arr[low];</span><br><span class="line">    &#125;</span><br><span class="line">    arr[low] = pivot;</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><h5 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h5><p>完全二叉树的数组表示。</p>
<ul>
<li>所有的节点都大于（或小于）等于它的子节点</li>
<li>左侧子节点的位置是 2 * index + 1</li>
<li>右侧子节点的位置是 2 * index + 2 （也就是在左子节点的基础上 + 1）</li>
<li>父节点的位置是 (index - 1) &#x2F; 2</li>
</ul>
<h4 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h4><h5 id="如何判断某-URL-是否存在于-100-亿条数据中"><a href="#如何判断某-URL-是否存在于-100-亿条数据中" class="headerlink" title="如何判断某 URL 是否存在于 100 亿条数据中"></a>如何判断某 URL 是否存在于 100 亿条数据中</h5><p>现在想要实现一个网页过滤系统，利用该系统可以根据网页的 URL 判断该网页是否在黑名单上，黑名单现在已经包含 100 亿个不安全网页的 URL，每个网页的 URL 最多占用 64B（字节） 大小。</p>
<p>请设计该系统， 要求：</p>
<ol>
<li>该系统允许有万分之一以下的判断失误率 </li>
<li>使用的额外空间不要超过 30GB</li>
</ol>
<p><strong>布隆过滤器</strong>。</p>
<p>布隆过滤器的基本构造，其实就是一个 BitMap（更简单点来说其实就是一个数组），BitMap 中每个位上的元素由若干个哈希函数进行赋值。布隆过滤器的优势在于<strong>使用很少的空间就可以将准确率做到很高的程度</strong>（但想做到完全正确是不可能的）。</p>
<p>那么假设这时又来了一个新值，如何判断这个新值之前是否已经存在呢？（如何判断某个网页的 URL 是否在黑名单上呢？）</p>
<p>记这个网页的 URL 为 <code>input</code>，想检查它是否是存在于黑名单（BitMap）中，就把 <code>input</code> 通过同样的 k 个哈希函数，得到 k 个值，然后继续同样地把 k 个值取余（%m），就得到在 [0, m-1] 范围上的 k 个值，接下来在 BitMap 上看这些位置是不是都为黑：</p>
<ul>
<li>如果有一个<strong>不为</strong>黑，说明 <code>input</code> <strong>一定不在</strong>这个 BitMap 里 </li>
<li>如果都<strong>为</strong>黑，说明 a <strong>可能</strong>在这个 BitMap 里，也就是说存在误判的可能性</li>
</ul>
<p>解释具体一点，如果 <code>input</code> 的确是之前已经处理过的 URL，那么在生成布隆过滤器时，BitMap 中相应的 k 个位置一定已经涂黑了，所以在检查阶段，<code>input</code> 执行一遍相同的操作，肯定不会产生误判的。</p>
<p>会产生误判的是，<code>input</code> 明明<strong>不是</strong>之前已经处理过的输入对象，但由于哈希冲突的存在，可能就那么巧，两个不同的输入得到的 k 个哈希输出都是一样的（当然概率会非常小），那么在检查 <code>input</code> 时，可能 <code>input</code> 对应的 k 个位置都是黑的，从而错误地认为 <code>input</code> 是输入对象。</p>
<p>所以用布隆过滤器设计的系统，总结来说就是：<strong>黑名单中存在的 URL，一定能够检查出来，黑名单中不存在的 URL，有比较小的可能性被误判</strong>。</p>
<p>对于这种误判，其实也有解决方案，那就是白名单，<strong>对已经发现的误报数据我们可以通过建立白名单来防止再次误报</strong>。</p>
<p>比如，已经发现 <code>www.baidu.com</code> 这个样本不在布隆过滤器（黑名单）中，但是每次计算后的结果都显示其在布隆过滤器中，那么就可以把这个样本加入白名单中，以后这个样本再次输入的时候，就不会进入布隆过滤器的逻辑进行判断了。</p>
<h5 id="只用2GB内存在20亿个整数中找到出现次数top100的数"><a href="#只用2GB内存在20亿个整数中找到出现次数top100的数" class="headerlink" title="只用2GB内存在20亿个整数中找到出现次数top100的数"></a>只用2GB内存在20亿个整数中找到出现次数top100的数</h5><p>想要在很多整数中找到出现次数最多的数，通常的做法是使用哈希表对出现的每一个数做词频统计。</p>
<p>哈希表的key需要占用4B，value也是4B。</p>
<p>本题共有20亿个数，用32位的整数就可以表示其出现的次数，而不会产生溢出，但哈希表的一条记录(key, value)需要占用8B，当哈希表记录数为2亿个时需要至少1.6GB的内存。极端情况下20亿个数都不同，这样内存可能会不够用。</p>
<p>解决办法是把包含20亿个数的大文件用<strong>足够好的哈希函数分成21个小文件，根据哈希函数的性质，相同的数一定会在同一个文件中，我们这个时候就可以统计每个文件中出现次数最多的数，然后再从这些数中再次选出最多的数</strong>。</p>
<ol>
<li>最开始还是用哈希分流的思路来处理，把包含百亿数据量的词汇文件分流到不同的机器上；</li>
<li>如果对每一台机器来说分到的数据量依然很大，可以再用哈希函数把每台机器的分流文件拆成更小的文件处理；</li>
<li>处理每一个小文件的时候，哈希表统计每种词及其词频后再遍历。在遍历的过程中使用大小为100的小根堆来选出每一个小文件的top100，再将小根堆里的词按照词频排序，就得到了每个小文件的排序后top100；</li>
<li>然后把各个小文件排序后的top100进行外排序或者继续利用小根堆，选出每台机器上的top100；</li>
<li>不同机器之间的top100再进行外排序或者继续利用小根堆，最终求出整个百亿数据量中的top100。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> test200亿URL() <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\inputFilePath.txt&quot;</span>);</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(file));</span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">while</span> ((line = reader.readLine()) != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 按hash分为20个文件</span></span><br><span class="line">            <span class="type">FileWriter</span> <span class="variable">fileWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(file.getParent() + <span class="string">&quot;\\&quot;</span> +</span><br><span class="line">                    <span class="comment">// String 的Hashcode可能是负数</span></span><br><span class="line">                    (line.hashCode() &amp; Integer.MAX_VALUE % <span class="number">20</span>) + <span class="string">&quot;.txt&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">            <span class="comment">// \r\n表示回车换行</span></span><br><span class="line">            fileWriter.write(line + <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">            fileWriter.flush();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 小顶堆,TreeMap按key排序，所以这里用优先队列</span></span><br><span class="line">        PriorityQueue&lt;Map.Entry&lt;String, Integer&gt;&gt; priorityQueue =</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; a.getValue() - b.getValue());</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i++ &lt; <span class="number">20</span>)&#123;</span><br><span class="line">            <span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(file.getParent() + <span class="string">&quot;\\&quot;</span> + i + <span class="string">&quot;.txt&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>(!file1.exists())&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">FileReader</span> <span class="variable">fileReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(file1);</span><br><span class="line">            <span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(fileReader);</span><br><span class="line">            String line1;</span><br><span class="line">            Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">            <span class="comment">// 用hashmap统计当前文件的词频</span></span><br><span class="line">            <span class="keyword">while</span> ((line1 = bufferedReader.readLine()) != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(map.containsKey(line1))&#123;</span><br><span class="line">                    map.put(line1, map.get(line1) + <span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    map.put(line1, <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            map.entrySet().stream().forEach(entry -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (priorityQueue.size() &lt; <span class="number">100</span>)&#123;</span><br><span class="line">                    priorityQueue.add(entry);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span>(entry.getValue() &gt; priorityQueue.element().getValue())&#123;</span><br><span class="line">                        priorityQueue.remove();</span><br><span class="line">                        priorityQueue.add(entry);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(file.getParent() + <span class="string">&quot;\\&quot;</span> + <span class="string">&quot;result.txt&quot;</span>,<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : priorityQueue) &#123;</span><br><span class="line">            System.out.println();</span><br><span class="line">            fw.write(entry.getKey() + <span class="string">&quot; &quot;</span> + entry.getValue() + <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        fw.flush();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="两个栈模拟队列"><a href="#两个栈模拟队列" class="headerlink" title="两个栈模拟队列"></a>两个栈模拟队列</h5><p>从栈的数据结构出发，元素item1和元素item2分别进入inStack再出栈进入outStack，因为栈后进先出的特点，两次入栈出栈操作刚好能满足队列的先出先出，但很重要的一个点在于，每次元素item入队和出队时，都需考虑到inStack和outStack的情况：入队时确保outStack为空，所有元素再inStack栈中，出队时确保inStack为空，所有元素再outStack中，以保证队列的结构正确。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span>&lt;E&gt;&#123;</span><br><span class="line">	<span class="comment">//定义两个栈，分别用于入队和出队</span></span><br><span class="line">	<span class="keyword">private</span> Stack&lt;E&gt; inStack;</span><br><span class="line">	<span class="keyword">private</span> Stack&lt;E&gt; outStack;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">MyQueue</span><span class="params">()</span> &#123;</span><br><span class="line">		inStack =<span class="keyword">new</span> <span class="title class_">Stack</span>&lt;E&gt;();</span><br><span class="line">		outStack =<span class="keyword">new</span> <span class="title class_">Stack</span>&lt;E&gt;();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//入队</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">offer</span><span class="params">(E item)</span> &#123;</span><br><span class="line">		<span class="keyword">while</span>(!outStack.isEmpty()) &#123;</span><br><span class="line">			inStack.push(outStack.pop());</span><br><span class="line">		&#125;</span><br><span class="line">		inStack.push(item);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//出队</span></span><br><span class="line">	<span class="keyword">public</span> E <span class="title function_">poll</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">while</span>(!inStack.isEmpty()) &#123;</span><br><span class="line">			outStack.push(inStack.pop());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> outStack.pop();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//判空</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> inStack.size()==outStack.size();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h5><p>Java中可以用<code>Arrays.binarySearch</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="comment">// 或者(left + right) &gt;&gt;&gt; 1无符号右移，防止溢出。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid; <span class="comment">// 找到目标元素，返回索引</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>; <span class="comment">// 目标元素在右半部分，更新左边界</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>; <span class="comment">// 目标元素在左半部分，更新右边界</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// 目标元素不存在，返回 -1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><ul>
<li><p>CPU 占用高怎么排查？（以下来自Chat-GPT）</p>
<p>可能是由于系统负载高、进程<strong>死循环</strong>、进程阻塞等原因引起的。下面是一些排查高 CPU 占用的方法：</p>
<ol>
<li>查看系统负载：使用 <code>top</code> 命令可以查看系统的负载情况，如果系统负载较高，说明系统资源已经达到极限，需要考虑优化或升级硬件。</li>
<li>查看进程占用情况：使用 <code>top</code> 命令或者 <code>ps</code> 命令可以查看进程的 CPU 占用情况，如果某个进程的 CPU 占用较高，说明该进程可能存在问题，需要进一步排查。</li>
<li>查看进程调用栈：用jps查看java进程，使用 <code>jstack</code> 命令可以查看 Java 进程的调用栈信息，如果发现某个线程在死循环或者阻塞等情况，可以定位到具体的代码位置进行排查</li>
<li>使用性能分析工具：使用性能分析工具，如 <code>jstat</code>、<code>jprofiler</code>、<code>perf</code> 、<code>Arthas</code>等，可以对进程的性能进行详细分析，找出性能瓶颈所在。</li>
</ol>
<ul>
<li><p>CPU飙升？</p>
<p>可能是死循环。可以用Arthas的thread命令查看每个线程cpu占用，例如：</p>
<p><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="http://oss.ripplesu.top/blog/Typora/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20231101155757756.png" alt="Arthas排查thread"></p>
<p><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="http://oss.ripplesu.top/blog/Typora/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20231101160152955.png" alt="image-20231101160152955"></p>
</li>
</ul>
</li>
</ul>
<h4 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h4><ul>
<li><p>统计文件中某个单词出现的次数</p>
<p>grep -o ‘单词’ 文件路径 | wc -w</p>
<p>注：’|’为管道，前者命令的输出将作为后者的输入</p>
<p>查看大日志某个关键词的上下五行</p>
<p>grep -A 5 -B 5 “关键词” 文件名</p>
</li>
</ul>
<ul>
<li><p>目录</p>
<ul>
<li><p><code>ls</code>：显示目录中的文件和子目录的列表。</p>
</li>
<li><p><code>mkdir [选项] 目录名</code>：创建新目录（增）。</p>
</li>
<li><p><code>find [路径] [表达式]</code>：在指定目录及其子目录中搜索文件或目录（查），非常强大灵活。</p>
<p>例如：① 列出当前目录及子目录下所有文件和文件夹: <code>find .</code>；</p>
<p>② 在<code>/home</code>目录下查找以 <code>.txt</code> 结尾的文件名:<code>find /home -name &quot;*.txt&quot;</code> ,忽略大小写: <code>find /home -i name &quot;*.txt&quot;</code> ；</p>
<p>③ 当前目录及子目录下查找所有以 <code>.txt</code> 和 <code>.pdf</code> 结尾的文件:<code>find . \( -name &quot;*.txt&quot; -o -name &quot;*.pdf&quot; \)</code>或<code>find . -name &quot;*.txt&quot; -o -name &quot;*.pdf&quot;</code>。</p>
</li>
<li><p><code>pwd</code>：显示当前工作目录的路径。</p>
</li>
<li><p><code>rmdir [选项] 目录名</code>：删除空目录（删）。例如：<code>rmdir -p my_directory</code>，删除名为 <code>my_directory</code> 的空目录，并且会递归删除<code>my_directory</code>的空父目录，直到遇到非空目录或根目录。</p>
</li>
<li><p><code>rm [选项] 文件或目录名</code>：删除文件&#x2F;目录（删）。例如：<code>rm -r my_directory</code>，删除名为 <code>my_directory</code> 的目录，<code>-r</code>(recursive,递归) 表示会递归删除指定目录及其所有子目录和文件。</p>
</li>
<li><p><code>cp [选项] 源文件/目录 目标文件/目录</code>：复制文件或目录（移）。</p>
</li>
<li><p><code>mv [选项] 源文件/目录 目标文件/目录</code>：移动文件或目录（移），也可以用于重命名文件或目录。</p>
</li>
</ul>
</li>
<li><p>文件操作</p>
<ul>
<li><p><code>touch [选项] 文件名..</code>：创建新文件或更新已存在文件（增）。</p>
</li>
<li><p><code>ln [选项] &lt;源文件&gt; &lt;硬链接/软链接文件&gt;</code>：创建硬链接&#x2F;软链接。</p>
</li>
<li><p><code>cat/more/less/tail 文件名</code>：文件的查看（查） 。命令 <code>tail -f 文件</code> 可以对某个文件进行动态监控，例如 Tomcat 的日志文件， 会随着程序的运行，日志会变化，可以使用 <code>tail -f catalina-2016-11-11.log</code> 监控 文 件的变化 ；tail -n 指定行数，默认为10</p>
</li>
<li><p><code>vim 文件名</code>：修改文件的内容（改）。在实际开发中，使用 vim 编辑器主要作用就是修改配置文件，下面是一般步骤：<code>vim 文件------&gt;进入文件-----&gt;命令模式------&gt;按i进入编辑模式-----&gt;编辑文件 -------&gt;按Esc进入底行模式-----&gt;输入：wq/q!</code> （输入 wq 代表写入内容并退出，即保存；输入 q!代表强制退出不保存）。</p>
</li>
<li><p><code>tar -czvf 打包压缩后的文件名 要打包压缩的文件</code> ：压缩。其中：</p>
<ul>
<li>z：调用 gzip 压缩命令</li>
<li>c：打包文件</li>
<li>v：显示运行过程</li>
<li>f：指定文件名</li>
</ul>
<p><code>tar [-xzvf] 压缩文件</code></p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>系统状态</p>
<p><code>top [选项]</code>：用于实时查看系统的 <strong>CPU 使用率、内存使用率、进程信息</strong>等。</p>
<ul>
<li>-Hp Pid 查看某个进程的线程资源占用</li>
</ul>
<p><code>uptime [选项]</code>：用于查看系统总共运行了多长时间、系统的平均负载等信息。</p>
<p><code>vmstat [间隔时间] [重复次数]</code>：vmstat （Virtual Memory Statistics） 的含义为显示虚拟内存状态，但是它可以报告关于进程、内存、I&#x2F;O 等系统整体运行状态。</p>
<p><code>free [选项]</code>：用于查看系统的<strong>内存使用情况</strong>，包括已用内存、可用内存、缓冲区和缓存等。</p>
<p><code>df [选项] [文件系统]</code>：用于查看系统的<strong>磁盘空间使用情况</strong>，包括磁盘空间的总量、已使用量和可用量等，可以指定文件系统上。例如：<code>df -a</code>，查看全部文件系统。</p>
<p><code>du [选项] [文件]</code>：用于查看指定目录或文件的磁盘空间使用情况，可以指定不同的选项来控制输出格式和单位。</p>
<p><code>ps [选项]</code>：用于查看系统中的进程信息，包括进程的 ID、状态、资源使用情况等。<code>ps -ef</code>（“-e ”参数代表显示所有进程，“-f”参数代表全格式。）&#x2F;<code>ps -aux</code>：这两个命令都是查看当前系统正在运行进程，两者的区别是展示格式不同。如果想要查看特定的进程可以使用这样的格式：<code>ps aux|grep redis</code> （查看包括 redis 字符串的进程），也可使用 <code>pgrep redis -a</code>。</p>
<p><code>systemctl [命令] [服务名称]</code>：用于管理系统的服务和单元，可以查看系统服务的状态、启动、停止、重启等。</p>
</li>
<li><p>网络</p>
<p><code>ifconfig</code> 或 <code>ip</code>：用于查看系统的网络接口信息，包括网络接口的 IP 地址、MAC 地址、状态等。</p>
<p><code>netstat [选项]</code>：用于查看系统的网络连接状态和网络统计信息，可以查看当前的网络连接情况、监听端口、网络协议等</p>
<p><code>telnet</code>命令用于远端登入。执行telnet指令开启终端机阶段作业，并登入远端主机。</p>
<p><code>curl</code>命令: curl [ -O ] url   发送http网络请求。可以下载文件，获取信息（网页源码）</p>
<p>​	-O 用于下载文件，当url是下载链接时，可以使用选项保存文件</p>
</li>
<li><p>权限</p>
<p><strong>修改文件&#x2F;目录的权限的命令：<code>chmod</code></strong></p>
<p>示例：修改&#x2F;test 下的 aaa.txt 的权限为文件所有者有全部权限，文件所有者所在的组有读写权限，其他用户只有读的权限。</p>
<p><strong><code>chmod u=rwx,g=rw,o=r aaa.txt</code></strong> 或者 <strong><code>chmod 764 aaa.txt</code></strong></p>
<p><strong>Linux 用户管理相关命令:</strong></p>
<ul>
<li><code>useradd [选项] 用户名</code>:创建用户账号。使用<code>useradd</code>指令所建立的帐号，实际上是保存在 <code>/etc/passwd</code>文本文件中。</li>
<li><code>userdel [选项] 用户名</code>:删除用户帐号。</li>
<li><code>usermod [选项] 用户名</code>:修改用户账号的属性和配置比如用户名、用户 ID、家目录。</li>
<li><code>passwd [选项] 用户名</code>: 设置用户的认证信息，包括用户密码、密码过期时间等。。例如：<code>passwd -S 用户名</code> ，显示用户账号密码信息。<code>passwd -d 用户名</code>: 清除用户密码，会导致用户无法登录。<code>passwd 用户名</code>，修改用户密码，随后系统会提示输入新密码并确认密码。</li>
<li><code>su [选项] 用户名</code>（su 即 Switch User，切换用户）：在当前登录的用户和其他用户之间切换身份。</li>
</ul>
</li>
<li><p>其他</p>
<ul>
<li><p>nohup ： 不挂断的运行，注意并没有后台运行的功能。：终端会话关闭时，会发送挂起信号（SIGHUP）给与终端相关联的进程。而使用 <code>nohup</code> 命令后，程序会忽略挂起信号，从而保证程序的持续运行。&amp;才是后台运行</p>
</li>
<li><p>配置文件 &#x2F;etc&#x2F;profile 重新加载：source &#x2F;etc&#x2F;profile</p>
</li>
<li><p>kill </p>
<p>默认-15 优雅关闭线程；有些时候，进程可能无法正常退出，此时使用kill命令可能无法终止进程。-9强制终止。</p>
</li>
</ul>
</li>
</ul>
<h5 id="相关面试题-1"><a href="#相关面试题-1" class="headerlink" title="相关面试题"></a>相关面试题</h5><ul>
<li><p>你应该常看日志吧，如何从Linux日志里面取出userId&#x3D;xxx，把xxx信息取出来</p>
<p><code>cat log | grep userId=xxx</code></p>
</li>
</ul>
<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><p>见博客</p>
<h3 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h3><p><a target="_blank" rel="noopener" href="https://javaguide.cn/tools/maven/maven-core-concepts.html">https://javaguide.cn/tools/maven/maven-core-concepts.html</a></p>
<p><a target="_blank" rel="noopener" href="http://www.mvnbook.com/maven-dependency-conflict.html">http://www.mvnbook.com/maven-dependency-conflict.html</a></p>
<p>clean 命令可以清除 Maven 构建生成的目录和文件，以便重新构建项目。执行 clean 命令将删除 target 目录和其他 Maven 生成的文件。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean</span><br></pre></td></tr></table></figure>

<p>compile 命令可以编译 Maven 项目中的源代码，生成编译后的类文件，并将其输出到 target 目录下的 classes 目录中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn compile</span><br></pre></td></tr></table></figure>

<p>package 命令可以将 Maven 项目打包为一个可分发的格式，如 JAR、WAR 或 EAR 文件，并将其输出到 target 目录中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn package</span><br></pre></td></tr></table></figure>

<p>install 命令可以将 Maven 项目打包并安装到本地 Maven 仓库中。安装到本地仓库后，其他 Maven 项目可以引用该项目作为依赖项。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn install</span><br></pre></td></tr></table></figure>

<p>test 命令可以执行 Maven 项目中的单元测试，确保代码的正确性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn test</span><br></pre></td></tr></table></figure>

<p>dependency:tree 命令可以显示 Maven 项目的依赖关系树，以便开发人员更好地了解项目中使用的依赖项。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn <span class="attr">dependency</span>:tree</span><br></pre></td></tr></table></figure>

<h4 id="版本冲突"><a href="#版本冲突" class="headerlink" title="版本冲突"></a>版本冲突</h4><p>多个jar包依赖同一个jar包的不同版本。解决：留一个都可以用的版本，把其他版本排除掉</p>
<h4 id="依赖传递性"><a href="#依赖传递性" class="headerlink" title="依赖传递性"></a>依赖传递性</h4><p>Maven 依赖传递性是指，当一个 Maven 项目依赖于其他的 Maven 项目或者第三方库时，这些依赖的传递关系会被自动处理。</p>
<p>具体来说，当一个 Maven 项目依赖于其他的 Maven 项目或者第三方库时，Maven 会自动下载这些依赖，并将它们加入到项目的 classpath 中。如果这些依赖本身还依赖于其他的项目或者库，那么这些依赖的传递关系也会被自动处理。</p>
<p>例如，假设项目 A 依赖于项目 B，而项目 B 又依赖于项目 C 和 D，那么当你在项目 A 中引入项目 B 的依赖时，Maven 会自动下载并加入项目 B、C 和 D 的依赖，从而构建出一个完整的 classpath。</p>
<p>Maven 依赖传递性的优点在于，它可以自动处理依赖关系，避免手动管理依赖关系的繁琐和错误。但是，如果依赖传递关系过于复杂，可能会导致依赖冲突或者版本不一致的问题，需要进行手动调整。此外，由于 Maven 依赖传递性是自动处理的，可能会导致一些依赖没有被显式地声明，从而增加了项目的不确定性和维护难度。</p>
<h3 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h3><p>Docker 是一种开源的容器化平台，用于构建、部署和运行应用程序。它允许开发者将应用程序及其依赖项打包到一个称为容器的独立运行环境中，以便在不同的计算机上进行部署。每个容器都是一个轻量级、可移植和自包含的单元，具有自己的文件系统、运行时环境和资源。</p>
<p><strong>容器虚拟化的是操作系统而不是硬件，容器之间是共享同一套操作系统资源的。虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统。因此容器的隔离级别会稍低一些。</strong></p>
<ol>
<li><p>镜像（Image）：镜像是应用程序及其依赖项的打包格式。它包含了运行应用程序所需的一切，如操作系统、应用程序代码、运行时环境、库和其他依赖项。镜像是只读的，可以被多个容器使用。镜像可以从 Docker Hub 或其他镜像仓库获取，也可以通过 Dockerfile 来定义和构建。</p>
</li>
<li><p>容器（Container）：容器是从镜像创建的运行实例。每个容器都是一个隔离的进程空间，具有自己的文件系统、网络和进程。容器可以独立运行，也可以与其他容器进行通信和组合。容器提供了一种轻量级、可移植和可隔离的方式来运行应用程序。容器可以启动、停止、删除和重新创建，而不会影响其他容器或主机系统。</p>
<p>与拥有自己内核的虚拟机不同，容器只包含与特定发行版相关的所需文件，并使用共享主机内核。</p>
<p>我们可以在共享相同内核空间的单个主机上运行基于不同 Linux 发行版的容器。例如，我们可以在 Ubuntu 服务器上运行 RHEL、CentOS、基于 SUSE 的容器。因为对于所有 Linux 发行版，只有用户空间不同，内核空间相同。</p>
</li>
</ol>
<p>理解镜像和容器的关系可以类比为面向对象编程中的类和对象的关系。镜像相当于类的定义，它描述了应用程序的结构和属性。而容器则相当于类的实例化对象，它是根据镜像创建的运行实例。</p>
<p>通过使用镜像，我们可以创建多个相同或不同的容器来运行应用程序。每个容器都是相互隔离的，具有自己的运行环境，但共享同一个镜像作为基础。这种隔离性使得容器可以在不同的环境中运行，而不会相互干扰或冲突。</p>
<p><a target="_blank" rel="noopener" href="https://javaguide.cn/tools/docker/docker-intro.html">https://javaguide.cn/tools/docker/docker-intro.html</a></p>
<h2 id="场景题与其他问题"><a href="#场景题与其他问题" class="headerlink" title="场景题与其他问题"></a>场景题与其他问题</h2><h3 id="系统日志规范"><a href="#系统日志规范" class="headerlink" title="系统日志规范"></a>系统日志规范</h3><p>系统日志规范及最佳实践：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/V-TIT1Cw5fH8xSYAEMyukQ">https://mp.weixin.qq.com/s/V-TIT1Cw5fH8xSYAEMyukQ</a></p>
<h3 id="正向代理与反向代理"><a href="#正向代理与反向代理" class="headerlink" title="正向代理与反向代理"></a>正向代理与反向代理</h3><p>正向代理（Forward Proxy）和反向代理（Reverse Proxy）是两种不同的代理服务器配置，它们在工作原理和使用方式上有着显著的区别。</p>
<ul>
<li>正向代理：</li>
</ul>
<p>　　客户端向代理服务器发送请求，并由代理服务器代表客户端与目标服务器通信。</p>
<p>　　<strong>代理服务器隐藏了客户端的真实身份和位置</strong>，目标服务器只能看到代理服务器的IP地址。</p>
<p>　　客户端通过配置代理服务器来访问外部资源，代理服务器可以绕过访问限制、提供缓存和性能优化，并增加访问安全性。</p>
<p>　　正向代理常见的应用场景包括：绕过网络限制、保护客户端隐私、提供缓存和优化、实施访问控制等。</p>
<ul>
<li>反向代理：</li>
</ul>
<p>　　反向代理的工作原理是，代理服务器来接受客户端的网络访问连接请求，然后服务器将请求有策略的转发给网络中实际工作的业务服务器，并将从业务服务器处理的结果，返回给网络上发起连接请求的客户端</p>
<p>　　反向代理<strong>隐藏了目标服务器的真实身份和位置</strong>，客户端只能看到反向代理的IP地址。</p>
<p>　　反向代理常见的应用场景包括：负载均衡、高可用性、缓存和加速、安全过滤和防护等。它可以提供可靠的请求分发、保护内部服务器、优化性能并增加安全性。</p>
<p>　　<strong>反向代理常用于Web应用部署中，将客户端的请求分发给多个内部服务器，以实现负载均衡和高可用性</strong>。</p>
<p>　　正向代理是代表客户端向目标服务器发送请求，隐藏客户端身份和位置的代理配置。它代表客户端与外部资源通信，常用于绕过访问限制、保护隐私、提供缓存和安全性。反向代理是代表目标服务器接收客户端请求，并将请求转发给内部服务器的代理配置。它隐藏了目标服务器身份和位置，常用于负载均衡、高可用性、缓存和安全防护。两者在代理方向、隐藏的对象和应用场景上有明显的区别。</p>
<h3 id="秒杀应该考虑哪些问题？"><a href="#秒杀应该考虑哪些问题？" class="headerlink" title="秒杀应该考虑哪些问题？"></a>秒杀应该考虑哪些问题？</h3><ol>
<li><p>超卖问题</p>
<p>分析秒杀的业务场景,最重要的有一点就是超卖问题，假如备货只有100个，但是最终超卖了200，一般来讲秒杀系统的价格都比较低，如果超卖将严重影响公司的财产利益，因此首当其冲的就是解决商品的超卖问题。</p>
</li>
<li><p>高并发</p>
<p>秒杀具有时间短、并发量大的特点，秒杀持续时间只有几分钟，而一般公司都为了制造轰动效应，会以极低的价格来吸引用户，因此参与抢购的用户会非常的多。短时间内会有大量请求涌进来，后端如何防止并发过高造成缓存击穿或者失效，击垮数据库都是需要考虑的问题。</p>
</li>
<li><p>接口防刷</p>
<p>现在的秒杀大多都会出来针对秒杀对应的软件，这类软件会模拟不断向后台服务器发起请求，一秒几百次都是很常见的，如何防止这类软件的重复无效请求，防止不断发起的请求也是需要我们针对性考虑的。</p>
</li>
<li><p>秒杀URL</p>
<p>对于普通用户来讲，看到的只是一个比较简单的秒杀页面，在未达到规定时间，秒杀按钮是灰色的，一旦到达规定时间，灰色按钮变成可点击状态。这部分是针对小白用户的，如果是稍微有点电脑功底的用户，会通过F12看浏览器的network看到秒杀的url，通过特定软件去请求也可以实现秒杀。或者提前知道秒杀url的人，一请求就直接实现秒杀了。这个问题我们需要考虑解决。</p>
</li>
</ol>
<p>秒杀系统的设计方案</p>
<ol>
<li><p>秒杀URL的设计</p>
<p>为了避免有程序访问经验的人通过下单页面url直接访问后台接口来秒杀货品，我们需要将秒杀的url实现动态化，即使是开发整个系统的人都无法在秒杀开始前知道秒杀的url。具体的做法就是通过md5加密一串随机字符作为秒杀的url，然后前端访问后台获取具体的url，后台校验通过之后才可以继续秒杀。</p>
</li>
<li><p>秒杀页面静态化</p>
<p>将商品的描述、参数、成交记录、图像、评价等全部写入到一个静态页面，用户请求不需要通过访问后端服务器，不需要经过数据库，直接在前台客户端生成，这样可以最大可能的减少服务器的压力。具体的方法可以使用freemarker模板技术，建立网页模板，填充数据，然后渲染网页。</p>
</li>
<li><p>单体redis升级为集群redis</p>
<p>秒杀是一个读多写少的场景，使用redis做缓存再合适不过。不过考虑到缓存击穿问题，我们应该构建redis集群，或采用哨兵模式，可以提升redis的性能和可用性。</p>
</li>
<li><p>使用Nginx(en-juhn-eks &#x2F; Engine-X)</p>
<p>nginx是一个高性能web服务器，它的并发能力可以达到几万，而tomcat只有几百。通过nginx映射客户端请求，再分发到后台tomcat服务器集群中可以大大提升并发能力。</p>
</li>
<li><p>精简SQL</p>
<p>典型的一个场景是在进行扣减库存的时候，传统的做法是先查询库存，再去update。这样的话需要两个sql，而实际上一个sql我们就可以完成的。可以用这样的做法：update miaosha_goods set stock&#x3D;stock-1 where goos_id&#x3D;</p>
</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://blog.ripplesu.top">RippleSu</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://blog.ripplesu.top/2023/12/06/%E9%9D%A2%E8%AF%95%E9%A2%98/">http://blog.ripplesu.top/2023/12/06/%E9%9D%A2%E8%AF%95%E9%A2%98/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://blog.ripplesu.top" target="_blank">RippleSu's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="http://img.ripplesu.top/random?dir=cover&amp;面试总结&amp;type=cover" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/01/04/Sharding-JDBC%E5%AE%9E%E7%8E%B0%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E4%B8%8E%E7%AE%80%E5%8D%95%E5%88%86%E8%A1%A8/" title="MySQL用Sharding-JDBC实现读写分离与简单分表"><img class="cover" src="http://oss.ripplesu.top/blog/loading.gif" data-original="http://img.ripplesu.top/random?dir=cover&amp;Sharding-JDBC实现读写分离与简单分表&amp;type=cover" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">MySQL用Sharding-JDBC实现读写分离与简单分表</div></div></a></div><div class="next-post pull-right"><a href="/2023/11/18/GitHub%20Pages%E9%85%8D%E7%BD%AE%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D/" title="GitHub Pages配置自定义域名并利用Cloudflare CDN加速"><img class="cover" src="http://oss.ripplesu.top/blog/loading.gif" data-original="http://img.ripplesu.top/random?dir=cover&amp;GitHub Pages配置自定义域名并利用Cloudflare CDN加速&amp;type=cover" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">GitHub Pages配置自定义域名并利用Cloudflare CDN加速</div></div></a></div></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div class="comment-switch"><span class="first-comment">Valine</span><span id="switch-btn"></span><span class="second-comment">Disqus</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div><div><div id="disqus_thread"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="http://121.41.55.70:9000/image-lib/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">RippleSu</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">17</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">19</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/S-Lucien" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:syp@ripplesu.top" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Welcome to my Blog!</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E5%9F%BA%E7%A1%80"><span class="toc-number">1.</span> <span class="toc-text">Java基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Object"><span class="toc-number">1.1.</span> <span class="toc-text">Object</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String"><span class="toc-number">1.2.</span> <span class="toc-text">String</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8"><span class="toc-number">1.3.</span> <span class="toc-text">异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#static-final"><span class="toc-number">1.4.</span> <span class="toc-text">static&#x2F;final</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B"><span class="toc-number">1.5.</span> <span class="toc-text">泛型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84"><span class="toc-number">1.6.</span> <span class="toc-text">反射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">1.7.</span> <span class="toc-text">序列化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3"><span class="toc-number">1.8.</span> <span class="toc-text">注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E7%B3%96"><span class="toc-number">1.9.</span> <span class="toc-text">语法糖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98"><span class="toc-number">1.10.</span> <span class="toc-text">其他常见问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java8%E7%89%B9%E6%80%A7"><span class="toc-number">1.11.</span> <span class="toc-text">Java8特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Stream"><span class="toc-number">1.11.1.</span> <span class="toc-text">Stream</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-IO"><span class="toc-number">2.</span> <span class="toc-text">Java IO</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#IO%E6%B5%81"><span class="toc-number">2.1.</span> <span class="toc-text">IO流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E6%B5%81"><span class="toc-number">2.1.1.</span> <span class="toc-text">字节流</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#InputStream%EF%BC%88%E5%AD%97%E8%8A%82%E8%BE%93%E5%85%A5%E6%B5%81%EF%BC%89"><span class="toc-number">2.1.1.1.</span> <span class="toc-text">InputStream（字节输入流）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#OutputStream"><span class="toc-number">2.1.1.2.</span> <span class="toc-text">OutputStream</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E6%B5%81"><span class="toc-number">2.1.2.</span> <span class="toc-text">字符流</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Reader%EF%BC%88%E5%AD%97%E7%AC%A6%E8%BE%93%E5%85%A5%E6%B5%81%EF%BC%89"><span class="toc-number">2.1.2.1.</span> <span class="toc-text">Reader（字符输入流）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Writer%EF%BC%88%E5%AD%97%E7%AC%A6%E8%BE%93%E5%87%BA%E6%B5%81%EF%BC%89"><span class="toc-number">2.1.2.2.</span> <span class="toc-text">Writer（字符输出流）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E7%BC%93%E5%86%B2%E6%B5%81"><span class="toc-number">2.1.3.</span> <span class="toc-text">字节缓冲流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E7%BC%93%E5%86%B2%E6%B5%81"><span class="toc-number">2.1.4.</span> <span class="toc-text">字符缓冲流</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IO%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.2.</span> <span class="toc-text">IO模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#BIO%E3%80%81NIO%E3%80%81AIO"><span class="toc-number">2.2.1.</span> <span class="toc-text">BIO、NIO、AIO</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AIO-Asynchronous-I-O"><span class="toc-number">2.3.</span> <span class="toc-text">AIO (Asynchronous I&#x2F;O)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E9%9B%86%E5%90%88"><span class="toc-number">3.</span> <span class="toc-text">Java集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#List"><span class="toc-number">3.1.</span> <span class="toc-text">List</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ArrayList-%E5%92%8C-Array%EF%BC%88%E6%95%B0%E7%BB%84%EF%BC%89%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">3.1.1.</span> <span class="toc-text">ArrayList 和 Array（数组）的区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ArrayList-%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%9F"><span class="toc-number">3.1.2.</span> <span class="toc-text">ArrayList 插入和删除元素的时间复杂度？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LinkedList-%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%9F"><span class="toc-number">3.1.3.</span> <span class="toc-text">LinkedList 插入和删除元素的时间复杂度？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LinkedList-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E5%AE%9E%E7%8E%B0-RandomAccess-%E6%8E%A5%E5%8F%A3%EF%BC%9F"><span class="toc-number">3.1.4.</span> <span class="toc-text">LinkedList 为什么不能实现 RandomAccess 接口？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ArrayList-%E4%B8%8E-LinkedList-%E5%8C%BA%E5%88%AB"><span class="toc-number">3.1.5.</span> <span class="toc-text">ArrayList 与 LinkedList 区别?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%88%E8%B0%88CopyOnWriteArrayList%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">3.1.6.</span> <span class="toc-text">谈谈CopyOnWriteArrayList的原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Set"><span class="toc-number">3.2.</span> <span class="toc-text">Set</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AF%94%E8%BE%83-HashSet%E3%80%81LinkedHashSet-%E5%92%8C-TreeSet-%E4%B8%89%E8%80%85%E7%9A%84%E5%BC%82%E5%90%8C"><span class="toc-number">3.2.1.</span> <span class="toc-text">比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E5%88%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">3.2.2.</span> <span class="toc-text">定制排序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Queue"><span class="toc-number">3.3.</span> <span class="toc-text">Queue</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ArrayDeque-%E4%B8%8E-LinkedList-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.3.1.</span> <span class="toc-text">ArrayDeque 与 LinkedList 的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BlockingQueue"><span class="toc-number">3.3.2.</span> <span class="toc-text">BlockingQueue</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Map"><span class="toc-number">3.4.</span> <span class="toc-text">Map</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.4.1.</span> <span class="toc-text">HashMap底层实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="toc-number">3.4.2.</span> <span class="toc-text">为什么用红黑树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%91%E5%8C%96%E9%98%88%E5%80%BC%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF8"><span class="toc-number">3.4.3.</span> <span class="toc-text">树化阈值为什么是8</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Hash%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">3.4.4.</span> <span class="toc-text">Hash方法的作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap%E7%9A%84put%E6%B5%81%E7%A8%8B"><span class="toc-number">3.4.5.</span> <span class="toc-text">HashMap的put流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap%E7%9A%84get%E6%B5%81%E7%A8%8B"><span class="toc-number">3.4.6.</span> <span class="toc-text">HashMap的get流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap%E9%95%BF%E5%BA%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF2%E7%9A%84%E5%B9%82%E6%AC%A1"><span class="toc-number">3.4.7.</span> <span class="toc-text">HashMap长度为什么是2的幂次</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8"><span class="toc-number">3.4.8.</span> <span class="toc-text">HashMap为什么线程不安全</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap%E9%81%8D%E5%8E%86"><span class="toc-number">3.4.9.</span> <span class="toc-text">HashMap遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap%E6%89%A9%E5%AE%B9%EF%BC%88rehash%EF%BC%89%E6%9C%BA%E5%88%B6"><span class="toc-number">3.4.10.</span> <span class="toc-text">HashMap扩容（rehash）机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B4%9F%E8%BD%BD%E5%9B%A0%E5%AD%90%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF0-75"><span class="toc-number">3.4.11.</span> <span class="toc-text">负载因子为什么是0.75</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap-%E5%92%8C-Hashtable-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.4.12.</span> <span class="toc-text">HashMap 和 Hashtable 的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ConcurrentHashMap-%E5%92%8C-Hashtable-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.4.13.</span> <span class="toc-text">ConcurrentHashMap 和 Hashtable 的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ConcurrentHashMap-%E5%92%8C-Hashtable-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E5%AD%98null%EF%BC%9F"><span class="toc-number">3.4.14.</span> <span class="toc-text">ConcurrentHashMap 和 Hashtable 为什么不能存null？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JDK-1-7-%E5%92%8C-JDK-1-8-%E7%9A%84-ConcurrentHashMap-%E5%AE%9E%E7%8E%B0%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="toc-number">3.4.15.</span> <span class="toc-text">JDK 1.7 和 JDK 1.8 的 ConcurrentHashMap 实现有什么不同？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E8%AF%B4%E4%BD%A0%E5%AF%B9LinkedHashMap%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">3.4.16.</span> <span class="toc-text">说一说你对LinkedHashMap的理解</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM"><span class="toc-number">4.</span> <span class="toc-text">JVM</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%EF%BC%88%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%89"><span class="toc-number">4.1.</span> <span class="toc-text">内存结构（运行时数据区）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="toc-number">4.2.</span> <span class="toc-text">垃圾回收机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E7%94%A8"><span class="toc-number">4.2.1.</span> <span class="toc-text">引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA"><span class="toc-number">4.2.2.</span> <span class="toc-text">内存溢出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="toc-number">4.2.3.</span> <span class="toc-text">内存泄漏</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6"><span class="toc-number">4.3.</span> <span class="toc-text">类加载机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="toc-number">4.3.1.</span> <span class="toc-text">类加载过程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88JUC%EF%BC%89"><span class="toc-number">5.</span> <span class="toc-text">并发编程（JUC）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%89%E4%B8%AA%E9%87%8D%E8%A6%81%E7%89%B9%E6%80%A7"><span class="toc-number">5.1.</span> <span class="toc-text">并发编程三个重要特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E5%BA%8F"><span class="toc-number">5.2.</span> <span class="toc-text">指令重排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ThreadLocal%EF%BC%88java-lang%EF%BC%89"><span class="toc-number">5.3.</span> <span class="toc-text">ThreadLocal（java.lang）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ThreadLocal%E5%8E%9F%E7%90%86"><span class="toc-number">5.3.1.</span> <span class="toc-text">ThreadLocal原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Synchronize"><span class="toc-number">5.4.</span> <span class="toc-text">Synchronize</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#synchronized%E5%8F%AF%E4%BB%A5%E4%BF%AE%E9%A5%B0%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E5%92%8C%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97%E5%90%97%EF%BC%9F"><span class="toc-number">5.4.1.</span> <span class="toc-text">synchronized可以修饰静态方法和静态代码块吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">5.4.2.</span> <span class="toc-text">原理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E8%AF%AD%E5%8F%A5%E5%9D%97"><span class="toc-number">5.4.2.1.</span> <span class="toc-text">同步语句块</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95"><span class="toc-number">5.4.2.2.</span> <span class="toc-text">同步方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Synchronize%E4%BF%9D%E8%AF%81%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-number">5.4.2.3.</span> <span class="toc-text">Synchronize保证的特性</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9B%E7%A7%8D%E7%8A%B6%E6%80%81"><span class="toc-number">5.4.3.</span> <span class="toc-text">四种状态</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lock"><span class="toc-number">5.5.</span> <span class="toc-text">Lock</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ReentrantReadWriteLock"><span class="toc-number">5.5.1.</span> <span class="toc-text">ReentrantReadWriteLock</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%81%E5%8D%8F%E7%A8%8B"><span class="toc-number">5.6.</span> <span class="toc-text">进程、线程、协程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-number">5.7.</span> <span class="toc-text">线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="toc-number">5.7.1.</span> <span class="toc-text">线程状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F"><span class="toc-number">5.7.2.</span> <span class="toc-text">线程创建方式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#start%E5%92%8Crun"><span class="toc-number">5.7.2.1.</span> <span class="toc-text">start和run</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%88%E6%AD%A2%E7%BA%BF%E7%A8%8B"><span class="toc-number">5.7.2.2.</span> <span class="toc-text">终止线程</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Fork-Join"><span class="toc-number">5.7.3.</span> <span class="toc-text">Fork&#x2F;Join</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">5.8.</span> <span class="toc-text">线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">5.8.1.</span> <span class="toc-text">如何创建线程池</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8%E5%86%85%E7%BD%AE%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%88%E9%98%BF%E9%87%8CJava%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C%EF%BC%89"><span class="toc-number">5.8.2.</span> <span class="toc-text">为什么不推荐使用内置线程池（阿里Java开发手册）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8F%82%E6%95%B0%EF%BC%88%E5%8F%AF%E9%80%9A%E8%BF%87set%E6%96%B9%E6%B3%95%E5%8A%A8%E6%80%81%E4%BF%AE%E6%94%B9%EF%BC%89"><span class="toc-number">5.8.3.</span> <span class="toc-text">线程池参数（可通过set方法动态修改）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%AE%BE%E5%AE%9A%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%A4%A7%E5%B0%8F"><span class="toc-number">5.8.4.</span> <span class="toc-text">如何设定线程池大小</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A5%B1%E5%92%8C-%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5"><span class="toc-number">5.8.5.</span> <span class="toc-text">饱和&#x2F;拒绝策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97"><span class="toc-number">5.8.6.</span> <span class="toc-text">阻塞队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%8A%B6%E6%80%81"><span class="toc-number">5.8.7.</span> <span class="toc-text">线程池状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98"><span class="toc-number">5.8.8.</span> <span class="toc-text">相关问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Future"><span class="toc-number">5.9.</span> <span class="toc-text">Future</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Callable-%E5%92%8C-Future-%E6%9C%89%E4%BB%80%E4%B9%88%E5%85%B3%E7%B3%BB%EF%BC%9F"><span class="toc-number">5.9.1.</span> <span class="toc-text">Callable 和 Future 有什么关系？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CompletableFuture-%E7%B1%BB%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F"><span class="toc-number">5.9.2.</span> <span class="toc-text">CompletableFuture 类有什么用？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-1"><span class="toc-number">5.9.2.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8"><span class="toc-number">5.9.2.2.</span> <span class="toc-text">使用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AQS"><span class="toc-number">5.10.</span> <span class="toc-text">AQS</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CountDownLatch"><span class="toc-number">5.10.1.</span> <span class="toc-text">CountDownLatch</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CyclicBarrier"><span class="toc-number">5.10.2.</span> <span class="toc-text">CyclicBarrier</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E4%B8%AD%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">5.11.</span> <span class="toc-text">Java中乐观锁和悲观锁的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B9%90%E8%A7%82%E9%94%81%EF%BC%9F"><span class="toc-number">5.11.1.</span> <span class="toc-text">如何实现乐观锁？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%89%88%E6%9C%AC%E5%8F%B7%E6%9C%BA%E5%88%B6"><span class="toc-number">5.11.1.1.</span> <span class="toc-text">版本号机制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#CAS-%E7%AE%97%E6%B3%95"><span class="toc-number">5.11.1.2.</span> <span class="toc-text">CAS 算法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">5.12.</span> <span class="toc-text">相关面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B0"><span class="toc-number">5.12.1.</span> <span class="toc-text">线程交替打印</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E4%BE%8B%E5%AD%90"><span class="toc-number">5.12.2.</span> <span class="toc-text">死锁例子</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">6.</span> <span class="toc-text">面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SOLID%E5%8E%9F%E5%88%99"><span class="toc-number">6.1.</span> <span class="toc-text">SOLID原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.2.</span> <span class="toc-text">设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.2.1.</span> <span class="toc-text">单例模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.2.2.</span> <span class="toc-text">代理模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.2.3.</span> <span class="toc-text">工厂模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.2.4.</span> <span class="toc-text">装饰器模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.2.5.</span> <span class="toc-text">策略模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95"><span class="toc-number">6.2.6.</span> <span class="toc-text">模板方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B4%A3%E4%BB%BB%E9%93%BE"><span class="toc-number">6.2.7.</span> <span class="toc-text">责任链</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E8%81%9A%E3%80%81%E8%80%A6%E5%90%88"><span class="toc-number">6.3.</span> <span class="toc-text">内聚、耦合</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">7.</span> <span class="toc-text">MySQL数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80"><span class="toc-number">7.1.</span> <span class="toc-text">数据库基础</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sql%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="toc-number">7.2.</span> <span class="toc-text">sql执行顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-number">7.3.</span> <span class="toc-text">存储引擎</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95"><span class="toc-number">7.4.</span> <span class="toc-text">索引</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%88%86%E7%B1%BB"><span class="toc-number">7.4.1.</span> <span class="toc-text">索引分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96"><span class="toc-number">7.4.2.</span> <span class="toc-text">索引优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88"><span class="toc-number">7.4.3.</span> <span class="toc-text">避免索引失效</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8B-%E6%A0%91"><span class="toc-number">7.4.4.</span> <span class="toc-text">为什么用B+树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MySQL%E4%BC%98%E5%8C%96%E5%99%A8%E6%80%8E%E4%B9%88%E9%80%89%E6%8B%A9%E7%B4%A2%E5%BC%95"><span class="toc-number">7.4.5.</span> <span class="toc-text">MySQL优化器怎么选择索引</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SQL%E4%BC%98%E5%8C%96"><span class="toc-number">7.5.</span> <span class="toc-text">SQL优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%85%A2%E6%9F%A5%E8%AF%A2"><span class="toc-number">7.5.1.</span> <span class="toc-text">慢查询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MySQL%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92"><span class="toc-number">7.5.2.</span> <span class="toc-text">MySQL执行计划</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8SQL%E4%BC%98%E5%8C%96"><span class="toc-number">7.5.3.</span> <span class="toc-text">常用SQL优化</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-number">7.5.3.1.</span> <span class="toc-text">设计原则</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1"><span class="toc-number">7.6.</span> <span class="toc-text">事务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A5%E5%BF%97"><span class="toc-number">7.7.</span> <span class="toc-text">日志</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81"><span class="toc-number">7.8.</span> <span class="toc-text">锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8"><span class="toc-number">7.9.</span> <span class="toc-text">分库分表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%BA%93"><span class="toc-number">7.9.1.</span> <span class="toc-text">分库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E8%A1%A8"><span class="toc-number">7.9.2.</span> <span class="toc-text">分表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB"><span class="toc-number">7.10.</span> <span class="toc-text">读写分离</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0"><span class="toc-number">7.11.</span> <span class="toc-text">参数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring"><span class="toc-number">8.</span> <span class="toc-text">Spring</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#IOC"><span class="toc-number">8.1.</span> <span class="toc-text">IOC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AOP"><span class="toc-number">8.2.</span> <span class="toc-text">AOP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">8.2.1.</span> <span class="toc-text">应用场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1-1"><span class="toc-number">8.3.</span> <span class="toc-text">事务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-1"><span class="toc-number">8.4.</span> <span class="toc-text">设计模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Web"><span class="toc-number">9.</span> <span class="toc-text">Web</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-MVC"><span class="toc-number">9.1.</span> <span class="toc-text">Spring MVC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-Session"><span class="toc-number">9.2.</span> <span class="toc-text">Spring Session</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Nginx"><span class="toc-number">9.3.</span> <span class="toc-text">Nginx</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#max-fails-number"><span class="toc-number">9.3.0.1.</span> <span class="toc-text">max_fails&#x3D;number</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#fail-timeout-time"><span class="toc-number">9.3.0.2.</span> <span class="toc-text">fail_timeout&#x3D;time</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%82%E7%AD%89%E6%80%A7"><span class="toc-number">9.4.</span> <span class="toc-text">幂等性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SpringBoot"><span class="toc-number">10.</span> <span class="toc-text">SpringBoot</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D"><span class="toc-number">10.0.1.</span> <span class="toc-text">自动装配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B"><span class="toc-number">10.0.2.</span> <span class="toc-text">启动流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3"><span class="toc-number">10.0.3.</span> <span class="toc-text">常用注解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">10.0.4.</span> <span class="toc-text">配置文件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98"><span class="toc-number">10.1.</span> <span class="toc-text">常见问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-Security"><span class="toc-number">11.</span> <span class="toc-text">Spring Security</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RBAC"><span class="toc-number">11.1.</span> <span class="toc-text">RBAC</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MyBatis"><span class="toc-number">12.</span> <span class="toc-text">MyBatis</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%B9%E9%87%8F%E6%8F%90%E4%BA%A4%E7%9A%84%E8%8B%A5%E5%B9%B2%E9%97%AE%E9%A2%98"><span class="toc-number">12.1.</span> <span class="toc-text">批量提交的若干问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81BUG"><span class="toc-number">12.2.</span> <span class="toc-text">常见BUG</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis"><span class="toc-number">13.</span> <span class="toc-text">Redis</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4"><span class="toc-number">13.1.</span> <span class="toc-text">基本命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">13.2.</span> <span class="toc-text">基本数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">13.3.</span> <span class="toc-text">特殊数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-Redis7-0-listpack%E5%8F%96%E4%BB%A3%E4%BA%86%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8ziplist"><span class="toc-number">13.4.</span> <span class="toc-text">数据结构(Redis7.0,listpack取代了压缩列表ziplist)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#skiplist%E8%B7%B3%E8%A1%A8"><span class="toc-number">13.4.0.1.</span> <span class="toc-text">skiplist跳表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ziplist%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8"><span class="toc-number">13.4.0.2.</span> <span class="toc-text">ziplist压缩列表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#quicklist"><span class="toc-number">13.4.0.3.</span> <span class="toc-text">quicklist</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#listpack"><span class="toc-number">13.4.0.4.</span> <span class="toc-text">listpack</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Dict-%E4%B8%A4%E4%B8%AAHashtable"><span class="toc-number">13.4.0.5.</span> <span class="toc-text">Dict(两个Hashtable)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A9%E5%B1%95"><span class="toc-number">13.5.</span> <span class="toc-text">扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#RedisBloom"><span class="toc-number">13.5.1.</span> <span class="toc-text">RedisBloom</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">13.6.</span> <span class="toc-text">线程模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E3%80%81pipeline%E3%80%81Lua%E8%84%9A%E6%9C%AC"><span class="toc-number">13.7.</span> <span class="toc-text">事务、pipeline、Lua脚本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%87%E6%9C%9F%E5%88%A0%E9%99%A4%E4%B8%8E%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0"><span class="toc-number">13.8.</span> <span class="toc-text">过期删除与内存淘汰</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%87%E6%9C%9F%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5"><span class="toc-number">13.8.1.</span> <span class="toc-text">过期删除策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0"><span class="toc-number">13.8.2.</span> <span class="toc-text">内存淘汰</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">13.9.</span> <span class="toc-text">持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#AOF-%E6%97%A5%E5%BF%97"><span class="toc-number">13.9.1.</span> <span class="toc-text">AOF 日志</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RDB-%E5%BF%AB%E7%85%A7"><span class="toc-number">13.9.2.</span> <span class="toc-text">RDB 快照</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%B7%E5%90%88%E6%8C%81%E4%B9%85%E5%8C%96%E6%96%B9%E5%BC%8F"><span class="toc-number">13.9.3.</span> <span class="toc-text">混合持久化方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RDB%E4%B8%8EAOF%E5%AF%B9%E6%AF%94"><span class="toc-number">13.9.4.</span> <span class="toc-text">RDB与AOF对比</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1"><span class="toc-number">13.10.</span> <span class="toc-text">缓存设计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98-1"><span class="toc-number">13.10.1.</span> <span class="toc-text">常见问题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%A7key%E4%B8%8E%E7%83%ADkey"><span class="toc-number">13.10.1.1.</span> <span class="toc-text">大key与热key</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-hotkey%EF%BC%9F"><span class="toc-number">13.10.2.</span> <span class="toc-text">什么是 hotkey？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3-hotkey%EF%BC%9F"><span class="toc-number">13.10.3.</span> <span class="toc-text">如何解决 hotkey？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%85%A2%E6%9F%A5%E8%AF%A2-1"><span class="toc-number">13.10.3.1.</span> <span class="toc-text">慢查询</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E5%8C%96"><span class="toc-number">13.10.3.2.</span> <span class="toc-text">优化</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5"><span class="toc-number">13.10.4.</span> <span class="toc-text">缓存更新策略</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Cache-Aside%EF%BC%88%E6%97%81%E8%B7%AF%E7%BC%93%E5%AD%98%EF%BC%89%E7%AD%96%E7%95%A5"><span class="toc-number">13.10.4.1.</span> <span class="toc-text">Cache Aside（旁路缓存）策略</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%86%99%E5%85%A5%E6%95%B0%E6%8D%AE%E5%BA%93%E6%97%B6%EF%BC%8C%E6%98%AF%E5%88%A0%E9%99%A4%E7%BC%93%E5%AD%98%E8%BF%98%E6%98%AF%E6%9B%B4%E6%96%B0%E7%BC%93%E5%AD%98%EF%BC%9F"><span class="toc-number">13.10.4.2.</span> <span class="toc-text">数据写入数据库时，是删除缓存还是更新缓存？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%88%E6%93%8D%E4%BD%9C%E7%BC%93%E5%AD%98%E8%BF%98%E6%98%AF%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9F"><span class="toc-number">13.10.4.3.</span> <span class="toc-text">先操作缓存还是数据库？</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%85%88%E5%88%A0%E7%BC%93%E5%AD%98%EF%BC%8C%E5%86%8D%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">13.10.4.3.1.</span> <span class="toc-text">先删缓存，再操作数据库</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%85%88%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%8C%E5%86%8D%E5%88%A0%E9%99%A4%E7%BC%93%E5%AD%98"><span class="toc-number">13.10.4.3.2.</span> <span class="toc-text">先操作数据库，再删除缓存</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%BA%E4%B8%80%E8%87%B4%E6%80%A7%E7%AD%96%E7%95%A5"><span class="toc-number">13.10.5.</span> <span class="toc-text">强一致性策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">13.10.6.</span> <span class="toc-text">Redis分布式锁</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%94%A8setnx%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">13.10.6.1.</span> <span class="toc-text">用setnx实现简单分布式锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E5%88%A0%E9%99%A4%E9%94%81%E6%97%B6%E5%8F%AF%E8%83%BD%E5%AF%BC%E8%87%B4%E8%AF%AF%E5%88%A0%E9%97%AE%E9%A2%98"><span class="toc-number">13.10.6.2.</span> <span class="toc-text">直接删除锁时可能导致误删问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%94%81%E7%9A%84%E5%88%A4%E6%96%AD%E4%B8%8E%E5%88%A0%E9%99%A4%E7%9A%84%E5%8E%9F%E5%AD%90%E6%80%A7%E9%97%AE%E9%A2%98"><span class="toc-number">13.10.6.3.</span> <span class="toc-text">锁的判断与删除的原子性问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">13.10.6.4.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="toc-number">13.10.6.5.</span> <span class="toc-text">存在的问题（了解）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Redisson%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">13.10.6.6.</span> <span class="toc-text">Redisson分布式锁</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85"><span class="toc-number">13.11.</span> <span class="toc-text">发布订阅</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E5%8F%AF%E7%94%A8"><span class="toc-number">13.12.</span> <span class="toc-text">高可用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E"><span class="toc-number">13.12.1.</span> <span class="toc-text">主从</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%A8%E5%85%B5"><span class="toc-number">13.12.2.</span> <span class="toc-text">哨兵</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4"><span class="toc-number">13.12.3.</span> <span class="toc-text">集群</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Caffeine"><span class="toc-number">13.13.</span> <span class="toc-text">Caffeine</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%98%E6%B1%B0%E7%AE%97%E6%B3%95"><span class="toc-number">13.13.1.</span> <span class="toc-text">淘汰算法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95"><span class="toc-number">13.13.1.1.</span> <span class="toc-text">常见算法</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-number">14.</span> <span class="toc-text">消息队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%BD%9C%E7%94%A8"><span class="toc-number">14.1.</span> <span class="toc-text">消息队列作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%BC%9A%E5%B8%A6%E6%9D%A5%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">14.2.</span> <span class="toc-text">使用消息队列会带来哪些问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Kafka"><span class="toc-number">14.3.</span> <span class="toc-text">Kafka</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85%E6%A8%A1%E5%9E%8B-Kafka-%E6%B6%88%E6%81%AF%E6%A8%A1%E5%9E%8B"><span class="toc-number">14.3.1.</span> <span class="toc-text">发布-订阅模型:Kafka 消息模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9Kafka%EF%BC%9F"><span class="toc-number">14.3.2.</span> <span class="toc-text">为什么选择Kafka？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9"><span class="toc-number">14.3.2.1.</span> <span class="toc-text">缺点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">14.3.2.2.</span> <span class="toc-text">使用场景</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Kafka%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%BF%AB%EF%BC%9F"><span class="toc-number">14.3.3.</span> <span class="toc-text">Kafka为什么这么快？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Producer%E3%80%81Consumer%E3%80%81Broker%E3%80%81Topic%E3%80%81Partition%EF%BC%9F"><span class="toc-number">14.3.4.</span> <span class="toc-text">什么是 Producer、Consumer、Broker、Topic、Partition？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Kafka-%E7%9A%84%E5%A4%9A%E5%89%AF%E6%9C%AC%E6%9C%BA%E5%88%B6%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F%E5%B8%A6%E6%9D%A5%E4%BA%86%E4%BB%80%E4%B9%88%E5%A5%BD%E5%A4%84%EF%BC%9F"><span class="toc-number">14.3.5.</span> <span class="toc-text">Kafka 的多副本机制了解吗？带来了什么好处？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Kafka-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E7%9A%84%E6%B6%88%E8%B4%B9%E9%A1%BA%E5%BA%8F%EF%BC%9F"><span class="toc-number">14.3.6.</span> <span class="toc-text">Kafka 如何保证消息的消费顺序？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Kafka-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E4%B8%8D%E4%B8%A2%E5%A4%B1"><span class="toc-number">14.3.7.</span> <span class="toc-text">Kafka 如何保证消息不丢失</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E4%B8%A2%E5%A4%B1%E6%B6%88%E6%81%AF%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">14.3.7.1.</span> <span class="toc-text">生产者丢失消息的情况</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B6%88%E8%B4%B9%E8%80%85%E4%B8%A2%E5%A4%B1%E6%B6%88%E6%81%AF%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">14.3.7.2.</span> <span class="toc-text">消费者丢失消息的情况</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Kafka-%EF%BC%88Broker%EF%BC%89%E5%BC%84%E4%B8%A2%E4%BA%86%E6%B6%88%E6%81%AF"><span class="toc-number">14.3.7.3.</span> <span class="toc-text">Kafka （Broker）弄丢了消息</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Kafka-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E4%B8%8D%E9%87%8D%E5%A4%8D%E6%B6%88%E8%B4%B9%EF%BC%88%E5%B9%82%E7%AD%89%E6%80%A7%EF%BC%89"><span class="toc-number">14.3.8.</span> <span class="toc-text">Kafka 如何保证消息不重复消费（幂等性）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BD%93%E6%B6%88%E8%B4%B9%E8%80%85%E5%9C%A8%E6%B6%88%E8%B4%B9%E8%BF%87%E7%A8%8B%E7%AA%81%E7%84%B6%E5%AE%95%E6%9C%BA%E4%BA%86%EF%BC%8C%E9%87%8D%E6%96%B0%E6%81%A2%E5%A4%8D%E5%90%8E%E6%98%AF%E4%BB%8E%E5%93%AA%E9%87%8C%E6%B6%88%E8%B4%B9%EF%BC%8C%E4%BC%9A%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="toc-number">14.3.9.</span> <span class="toc-text">当消费者在消费过程突然宕机了，重新恢复后是从哪里消费，会有什么问题?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF"><span class="toc-number">14.3.10.</span> <span class="toc-text">事务消息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%91%E6%8E%A7-%E8%BF%90%E7%BB%B4"><span class="toc-number">14.3.11.</span> <span class="toc-text">监控&#x2F;运维</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Spring-Kafka"><span class="toc-number">14.3.12.</span> <span class="toc-text">Spring-Kafka</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Retryable-topic"><span class="toc-number">14.3.12.1.</span> <span class="toc-text">Retryable-topic</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Listener"><span class="toc-number">14.3.12.2.</span> <span class="toc-text">Listener</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Kafka-Stream"><span class="toc-number">14.3.13.</span> <span class="toc-text">Kafka Stream</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RocketMQ"><span class="toc-number">14.4.</span> <span class="toc-text">RocketMQ</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF-1"><span class="toc-number">14.4.1.</span> <span class="toc-text">事务消息</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Rabbitmq"><span class="toc-number">14.5.</span> <span class="toc-text">Rabbitmq</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%B6%E6%97%B6%E6%B6%88%E6%81%AF"><span class="toc-number">14.6.</span> <span class="toc-text">延时消息</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F"><span class="toc-number">15.</span> <span class="toc-text">分布式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="toc-number">15.1.</span> <span class="toc-text">负载均衡</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7Hash"><span class="toc-number">15.1.1.</span> <span class="toc-text">一致性Hash</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1"><span class="toc-number">15.2.</span> <span class="toc-text">微服务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#RPC"><span class="toc-number">15.2.1.</span> <span class="toc-text">RPC</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C-%E9%85%8D%E7%BD%AE"><span class="toc-number">15.2.2.</span> <span class="toc-text">服务注册&amp;配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BD%91%E5%85%B3"><span class="toc-number">15.2.3.</span> <span class="toc-text">网关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%86%94%E6%96%AD%E9%99%8D%E7%BA%A7"><span class="toc-number">15.2.4.</span> <span class="toc-text">熔断降级</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Hystrix%E4%B8%8ESentinel"><span class="toc-number">15.2.4.1.</span> <span class="toc-text">Hystrix与Sentinel</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="toc-number">15.3.</span> <span class="toc-text">分布式事务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8EXA%E5%8D%8F%E8%AE%AE%EF%BC%88%E5%BC%BA%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%89%E7%9A%84%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4-2PC-2-phase-commit-protocol"><span class="toc-number">15.3.1.</span> <span class="toc-text">基于XA协议（强一致性）的两阶段提交 2PC(2-phase commit protocol)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E8%A1%A5%E5%81%BFTCC%E6%A8%A1%E5%BC%8F%EF%BC%88%E5%BC%B1%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%89"><span class="toc-number">15.3.2.</span> <span class="toc-text">事务补偿TCC模式（弱一致性）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7%E6%96%B9%E6%A1%88-Eventual-cnsisteney"><span class="toc-number">15.3.3.</span> <span class="toc-text">最终一致性方案(Eventual cnsisteney)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E6%B6%88%E6%81%AF%E8%A1%A8-%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E8%BD%AE%E8%AF%A2"><span class="toc-number">15.3.3.1.</span> <span class="toc-text">本地消息表 + 定时任务轮询</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#MQ%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF"><span class="toc-number">15.3.3.2.</span> <span class="toc-text">MQ事务消息</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1"><span class="toc-number">16.</span> <span class="toc-text">定时任务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Timer"><span class="toc-number">16.1.</span> <span class="toc-text">Timer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ScheduledExecutorService"><span class="toc-number">16.2.</span> <span class="toc-text">ScheduledExecutorService</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-Task"><span class="toc-number">16.3.</span> <span class="toc-text">Spring Task</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Quartz"><span class="toc-number">16.4.</span> <span class="toc-text">Quartz</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Quartz%E9%9B%86%E7%BE%A4%E5%A6%82%E4%BD%95%E5%88%86%E6%B4%BE%E4%BB%BB%E5%8A%A1"><span class="toc-number">16.4.1.</span> <span class="toc-text">Quartz集群如何分派任务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Quartz%E4%B8%8EXXL-job%E5%AF%B9%E6%AF%94"><span class="toc-number">16.4.2.</span> <span class="toc-text">Quartz与XXL-job对比</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#XXL-job"><span class="toc-number">16.5.</span> <span class="toc-text">XXL-job</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Elastic-job"><span class="toc-number">16.6.</span> <span class="toc-text">Elastic-job</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80"><span class="toc-number">17.</span> <span class="toc-text">计算机基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C"><span class="toc-number">17.1.</span> <span class="toc-text">计算机网络</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">17.1.1.</span> <span class="toc-text">网络体系结构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#OSI%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B"><span class="toc-number">17.1.1.1.</span> <span class="toc-text">OSI七层模型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#TCP-IP%E5%8D%8F%E8%AE%AE%E7%B0%87%E5%9B%9B%E5%B1%82%E6%A8%A1%E5%9E%8B"><span class="toc-number">17.1.1.2.</span> <span class="toc-text">TCP&#x2F;IP协议簇四层模型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%94%E5%B1%82%E6%A8%A1%E5%9E%8B"><span class="toc-number">17.1.1.3.</span> <span class="toc-text">五层模型</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP%E4%B8%8EUDP"><span class="toc-number">17.1.2.</span> <span class="toc-text">TCP与UDP</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#TCP%E4%B8%8EUDP%E5%8C%BA%E5%88%AB"><span class="toc-number">17.1.2.1.</span> <span class="toc-text">TCP与UDP区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E9%80%89%E6%8B%A9-TCP%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E9%80%89-UDP"><span class="toc-number">17.1.2.2.</span> <span class="toc-text">什么时候选择 TCP，什么时候选 UDP?</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#TCP%E6%A0%BC%E5%BC%8F"><span class="toc-number">17.1.2.3.</span> <span class="toc-text">TCP格式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-number">17.1.2.4.</span> <span class="toc-text">三次握手</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%89%E6%AC%A1%EF%BC%9F"><span class="toc-number">17.1.2.4.1.</span> <span class="toc-text">（了解）为什么是三次？</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%8F%A1%E6%89%8B%E4%B8%A2%E5%A4%B1%E4%BA%86%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88"><span class="toc-number">17.1.2.4.2.</span> <span class="toc-text">握手丢失了会发生什么</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-number">17.1.2.5.</span> <span class="toc-text">四次挥手</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E5%9B%9B%E6%AC%A1%EF%BC%9F"><span class="toc-number">17.1.2.5.1.</span> <span class="toc-text">为什么是四次？</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%8F%A1%E6%89%8B%E4%B8%A2%E5%A4%B1"><span class="toc-number">17.1.2.5.2.</span> <span class="toc-text">握手丢失</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88TIME-WAIT%E7%AD%89%E5%BE%852MSL"><span class="toc-number">17.1.2.5.3.</span> <span class="toc-text">为什么TIME_WAIT等待2MSL</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#TIME-WAIT%E5%A4%AA%E5%A4%9A%EF%BC%9F"><span class="toc-number">17.1.2.5.4.</span> <span class="toc-text">TIME_WAIT太多？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E4%B8%80%E4%B8%AA%E9%A1%B5%E9%9D%A2%E7%9A%84%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-number">17.1.3.</span> <span class="toc-text">访问一个页面的过程？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP"><span class="toc-number">17.1.4.</span> <span class="toc-text">HTTP</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#HTTP%EF%BC%88%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%EF%BC%89%E7%AE%80%E4%BB%8B"><span class="toc-number">17.1.4.1.</span> <span class="toc-text">HTTP（超文本传输协议）简介</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#HTTP%E5%92%8CHTTPS"><span class="toc-number">17.1.4.2.</span> <span class="toc-text">HTTP和HTTPS</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Cookie%E5%92%8CSession"><span class="toc-number">17.1.5.</span> <span class="toc-text">Cookie和Session</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81"><span class="toc-number">17.1.6.</span> <span class="toc-text">消息推送</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9F%AD%E8%BD%AE%E8%AF%A2"><span class="toc-number">17.1.6.1.</span> <span class="toc-text">短轮询</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%95%BF%E8%BD%AE%E8%AF%A2"><span class="toc-number">17.1.6.2.</span> <span class="toc-text">长轮询</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#SSE-Server-Send-Events"><span class="toc-number">17.1.6.3.</span> <span class="toc-text">SSE(Server-Send Events)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Websocket"><span class="toc-number">17.1.6.4.</span> <span class="toc-text">Websocket</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95"><span class="toc-number">17.2.</span> <span class="toc-text">数据结构与算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F"><span class="toc-number">17.2.1.</span> <span class="toc-text">排序</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-number">17.2.1.1.</span> <span class="toc-text">冒泡排序</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">17.2.1.2.</span> <span class="toc-text">选择排序</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">17.2.1.3.</span> <span class="toc-text">插入排序</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-number">17.2.1.4.</span> <span class="toc-text">快速排序</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">17.2.2.</span> <span class="toc-text">数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A0%86"><span class="toc-number">17.2.2.1.</span> <span class="toc-text">堆</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">17.2.3.</span> <span class="toc-text">常见面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E6%9F%90-URL-%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E4%BA%8E-100-%E4%BA%BF%E6%9D%A1%E6%95%B0%E6%8D%AE%E4%B8%AD"><span class="toc-number">17.2.3.1.</span> <span class="toc-text">如何判断某 URL 是否存在于 100 亿条数据中</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AA%E7%94%A82GB%E5%86%85%E5%AD%98%E5%9C%A820%E4%BA%BF%E4%B8%AA%E6%95%B4%E6%95%B0%E4%B8%AD%E6%89%BE%E5%88%B0%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0top100%E7%9A%84%E6%95%B0"><span class="toc-number">17.2.3.2.</span> <span class="toc-text">只用2GB内存在20亿个整数中找到出现次数top100的数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AA%E6%A0%88%E6%A8%A1%E6%8B%9F%E9%98%9F%E5%88%97"><span class="toc-number">17.2.3.3.</span> <span class="toc-text">两个栈模拟队列</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="toc-number">17.2.3.4.</span> <span class="toc-text">二分查找</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-number">17.3.</span> <span class="toc-text">操作系统</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Linux"><span class="toc-number">17.3.1.</span> <span class="toc-text">Linux</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98-1"><span class="toc-number">17.3.1.1.</span> <span class="toc-text">相关面试题</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A5%E5%85%B7"><span class="toc-number">18.</span> <span class="toc-text">工具</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Git"><span class="toc-number">18.1.</span> <span class="toc-text">Git</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Maven"><span class="toc-number">18.2.</span> <span class="toc-text">Maven</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%88%E6%9C%AC%E5%86%B2%E7%AA%81"><span class="toc-number">18.2.1.</span> <span class="toc-text">版本冲突</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E4%BC%A0%E9%80%92%E6%80%A7"><span class="toc-number">18.2.2.</span> <span class="toc-text">依赖传递性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker"><span class="toc-number">18.3.</span> <span class="toc-text">Docker</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%E9%A2%98%E4%B8%8E%E5%85%B6%E4%BB%96%E9%97%AE%E9%A2%98"><span class="toc-number">19.</span> <span class="toc-text">场景题与其他问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E6%97%A5%E5%BF%97%E8%A7%84%E8%8C%83"><span class="toc-number">19.1.</span> <span class="toc-text">系统日志规范</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86%E4%B8%8E%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86"><span class="toc-number">19.2.</span> <span class="toc-text">正向代理与反向代理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%92%E6%9D%80%E5%BA%94%E8%AF%A5%E8%80%83%E8%99%91%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">19.3.</span> <span class="toc-text">秒杀应该考虑哪些问题？</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/01/05/%E7%94%A8MyFlash%E6%81%A2%E5%A4%8D%E8%AF%AF%E5%88%A0%E7%9A%84MySQL%E6%95%B0%E6%8D%AE/" title="用MyFlash恢复误删的MySQL数据"><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="http://img.ripplesu.top/random?dir=cover&amp;用MyFlash恢复误删的MySQL数据&amp;type=cover" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="用MyFlash恢复误删的MySQL数据"/></a><div class="content"><a class="title" href="/2024/01/05/%E7%94%A8MyFlash%E6%81%A2%E5%A4%8D%E8%AF%AF%E5%88%A0%E7%9A%84MySQL%E6%95%B0%E6%8D%AE/" title="用MyFlash恢复误删的MySQL数据">用MyFlash恢复误删的MySQL数据</a><time datetime="2024-01-05T08:19:00.000Z" title="发表于 2024-01-05 16:19:00">2024-01-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/04/Sharding-JDBC%E5%AE%9E%E7%8E%B0%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E4%B8%8E%E7%AE%80%E5%8D%95%E5%88%86%E8%A1%A8/" title="MySQL用Sharding-JDBC实现读写分离与简单分表"><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="http://img.ripplesu.top/random?dir=cover&amp;Sharding-JDBC实现读写分离与简单分表&amp;type=cover" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MySQL用Sharding-JDBC实现读写分离与简单分表"/></a><div class="content"><a class="title" href="/2024/01/04/Sharding-JDBC%E5%AE%9E%E7%8E%B0%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E4%B8%8E%E7%AE%80%E5%8D%95%E5%88%86%E8%A1%A8/" title="MySQL用Sharding-JDBC实现读写分离与简单分表">MySQL用Sharding-JDBC实现读写分离与简单分表</a><time datetime="2024-01-04T12:44:00.000Z" title="发表于 2024-01-04 20:44:00">2024-01-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/12/06/%E9%9D%A2%E8%AF%95%E9%A2%98/" title="面试总结"><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="http://img.ripplesu.top/random?dir=cover&amp;面试总结&amp;type=cover" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="面试总结"/></a><div class="content"><a class="title" href="/2023/12/06/%E9%9D%A2%E8%AF%95%E9%A2%98/" title="面试总结">面试总结</a><time datetime="2023-12-06T14:22:04.000Z" title="发表于 2023-12-06 22:22:04">2023-12-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/11/18/GitHub%20Pages%E9%85%8D%E7%BD%AE%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D/" title="GitHub Pages配置自定义域名并利用Cloudflare CDN加速"><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="http://img.ripplesu.top/random?dir=cover&amp;GitHub Pages配置自定义域名并利用Cloudflare CDN加速&amp;type=cover" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="GitHub Pages配置自定义域名并利用Cloudflare CDN加速"/></a><div class="content"><a class="title" href="/2023/11/18/GitHub%20Pages%E9%85%8D%E7%BD%AE%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D/" title="GitHub Pages配置自定义域名并利用Cloudflare CDN加速">GitHub Pages配置自定义域名并利用Cloudflare CDN加速</a><time datetime="2023-11-18T12:44:00.000Z" title="发表于 2023-11-18 20:44:00">2023-11-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/16/%E5%B7%A5%E7%A8%8B%E7%BB%8F%E6%B5%8E%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/" title="工程经济期末复习"><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="http://img.ripplesu.top/random?dir=cover&amp;工程经济期末复习&amp;type=cover" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="工程经济期末复习"/></a><div class="content"><a class="title" href="/2023/06/16/%E5%B7%A5%E7%A8%8B%E7%BB%8F%E6%B5%8E%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/" title="工程经济期末复习">工程经济期末复习</a><time datetime="2023-06-16T06:44:08.000Z" title="发表于 2023-06-16 14:44:08">2023-06-16</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2024 By RippleSu</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (true){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"><script>(() => {
  const initValine = () => {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '',
      appKey: '',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  const loadValine = async () => {
    if (typeof Valine === 'function') initValine()
    else {
      await getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js')
      initValine()
    }
  }

  if ('Valine' === 'Valine' || !false) {
    if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script><script>(() => {
  const disqus_config = function () {
    this.page.url = 'http://blog.ripplesu.top/2023/12/06/%E9%9D%A2%E8%AF%95%E9%A2%98/'
    this.page.identifier = '/2023/12/06/%E9%9D%A2%E8%AF%95%E9%A2%98/'
    this.page.title = '面试总结'
  }

  const disqusReset = () => {
    window.DISQUS && window.DISQUS.reset({
      reload: true,
      config: disqus_config
    })
  }

  btf.addGlobalFn('themeChange', disqusReset, 'disqus')

  const loadDisqus = () =>{
    if (window.DISQUS) disqusReset()
    else {
      const script = document.createElement('script')
      script.src = 'https://.disqus.com/embed.js'
      script.setAttribute('data-timestamp', +new Date())
      document.head.appendChild(script)
    }
  }

  const getCount = async() => {
    try {
      const eleGroup = document.querySelector('#post-meta .disqus-comment-count')
      if (!eleGroup) return
      const cleanedLinks = eleGroup.href.replace(/#post-comment$/, '')

      const res = await fetch(`https://disqus.com/api/3.0/threads/set.json?forum=&api_key=&thread:link=${cleanedLinks}`,{
        method: 'GET'
      })
      const result = await res.json()

      const count = result.response.length ? result.response[0].posts : 0
      eleGroup.textContent = count
    } catch (err) {
      console.error(err)
    }
  }

  if ('Valine' === 'Disqus' || !false) {
    if (false) btf.loadComment(document.getElementById('disqus_thread'), loadDisqus)
    else {
      loadDisqus()
      
    }
  } else {
    window.loadOtherComment = loadDisqus
  }
})()</script></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div>
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(r){r.imageLazyLoadSetting.processImages=t;var e=r.imageLazyLoadSetting.isSPA,n=r.imageLazyLoadSetting.preloadRatio||1,c=a();function a(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(){e&&(c=a());for(var t,o=0;o<c.length;o++)0<=(t=(t=c[o]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(r.innerHeight*n||document.documentElement.clientHeight*n)&&function(){var t,e,n,a,i=c[o];e=function(){c=c.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(n=new Image,a=t.getAttribute("data-original"),n.onload=function(){t.src=a,t.removeAttribute("data-original"),e&&e()},t.src!==a&&(n.src=a))}()}function i(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",i),r.addEventListener("resize",i),r.addEventListener("orientationchange",i)}(this);</script></body></html>