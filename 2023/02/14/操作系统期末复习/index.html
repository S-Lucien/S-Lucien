<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>操作系统期末复习 | RippleSu's Blog</title><meta name="author" content="RippleSu"><meta name="copyright" content="RippleSu"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="操作系统概述教学目的 熟悉操作系统作用和定义，了解操作系统的历史。 熟练掌握多道程序设计技术的概念，掌握批处理系统、分时系统及实时系统三种操作系统基本类型，了解微机操作系统、网络操作系统、分布式操作系统和嵌入式操作系统。 掌握操作系统并发性、共享性、虚拟性和异步性等特征，了解现代操作系统特征，熟悉操作系统功能。  定义 从计算机系统组成观点――操作系统是系统软件   从资源管理程序观点――操作系统">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统期末复习">
<meta property="og:url" content="http://blog.ripplesu.top/2023/02/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/index.html">
<meta property="og:site_name" content="RippleSu&#39;s Blog">
<meta property="og:description" content="操作系统概述教学目的 熟悉操作系统作用和定义，了解操作系统的历史。 熟练掌握多道程序设计技术的概念，掌握批处理系统、分时系统及实时系统三种操作系统基本类型，了解微机操作系统、网络操作系统、分布式操作系统和嵌入式操作系统。 掌握操作系统并发性、共享性、虚拟性和异步性等特征，了解现代操作系统特征，熟悉操作系统功能。  定义 从计算机系统组成观点――操作系统是系统软件   从资源管理程序观点――操作系统">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://img.ripplesu.top/random?dir=cover&%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0&type=cover">
<meta property="article:published_time" content="2023-02-14T06:03:29.000Z">
<meta property="article:modified_time" content="2023-11-24T10:23:39.180Z">
<meta property="article:author" content="RippleSu">
<meta property="article:tag" content="操作系统">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://img.ripplesu.top/random?dir=cover&%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0&type=cover"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://blog.ripplesu.top/2023/02/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: RippleSu","link":"链接: ","source":"来源: RippleSu's Blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '操作系统期末复习',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-11-24 18:23:39'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.0.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (false) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="http://121.41.55.70:9000/image-lib/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">14</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">16</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('http://img.ripplesu.top/random?dir=wallpaper')"><nav id="nav"><span id="blog-info"><a href="/" title="RippleSu's Blog"><span class="site-name">RippleSu's Blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">操作系统期末复习</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-02-14T06:03:29.000Z" title="发表于 2023-02-14 14:03:29">2023-02-14</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-11-24T10:23:39.180Z" title="更新于 2023-11-24 18:23:39">2023-11-24</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/">学习总结</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">23.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>71分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="操作系统期末复习"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="操作系统概述"><a href="#操作系统概述" class="headerlink" title="操作系统概述"></a>操作系统概述</h2><h3 id="教学目的"><a href="#教学目的" class="headerlink" title="教学目的"></a>教学目的</h3><ul>
<li>熟悉<font color='blue'>操作系统作用和定义</font>，了解操作系统的历史。</li>
<li>熟练掌握<font color='red'>多道程序设计技术</font>的概念，掌握<font color='orange'>批处理系统、分时系统及实时系统</font>三种操作系统基本类型，了解微机操作系统、网络操作系统、分布式操作系统和嵌入式操作系统。</li>
<li>掌握操作系统<font color='orange'>并发性、共享性、虚拟性和异步性</font>等特征，了解现代操作系统特征，熟悉<font color='blue'>操作系统功能</font>。</li>
</ul>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a><font color='blue'>定义</font></h3><ul>
<li>从计算机系统组成观点――操作系统是系统软件  </li>
<li>从资源管理程序观点――操作系统是系统资源管理者  </li>
<li>从软件分层、扩充机器的观点――操作系统是扩充裸机的第一层系统软件  </li>
<li>从服务用户的观点――操作系统是用户与裸机之间接口<br>作业级接口：提供一组键盘命令<br>程序级接口：提供一组系统调用  </li>
<li>从进程的观点——操作系统是由若干个可以并发执行的进程和一个对进程进行控制和协调的核心（kernel）组成。</li>
</ul>
<h3 id="基本特征"><a href="#基本特征" class="headerlink" title="基本特征"></a><font color='orange'>基本特征</font></h3><ul>
<li>并发:是指两个或多个活动在同一给定的时间<br>间隔中进行。</li>
<li>共享:是指计算机系统中的资源被多个进程所<br>共用。</li>
<li>异步:进程以不可预知的速度向前推进</li>
<li>虚拟:把一个物理上的实体变为若干个逻辑上<br>的对应物。<br>最基本特征:并发、共享(两者互为存在条<br>件)</li>
</ul>
<h3 id="发展"><a href="#发展" class="headerlink" title="发展"></a>发展</h3><h4 id="串行处理（无操作系统）"><a href="#串行处理（无操作系统）" class="headerlink" title="串行处理（无操作系统）"></a>串行处理（无操作系统）</h4><p>程序员直接与硬件打交道。计算机系统串行工作。<br>缺点：人机速度矛盾、计算机资源利用率低</p>
<h4 id="批处理"><a href="#批处理" class="headerlink" title="批处理"></a><font color='orange'>批处理</font></h4><h5 id="简单批处理"><a href="#简单批处理" class="headerlink" title="简单批处理"></a>简单批处理</h5><p>目标：为了解决人工操作（无操作系统）严重降低了计算机资源利用率的问题，即解决CPU等待人工操作和高速CPU与低速I&#x2F;O间矛盾等问题。</p>
<h5 id="多道程序设计"><a href="#多道程序设计" class="headerlink" title="多道程序设计"></a><font color='red'>多道程序设计</font></h5><p>多程序设计是一种操作模式，它由一个处理器交替执行两个或多个计算机程序。<br>目标：为了进一步提高资源利用率，在硬件采用通道和中断技术支持并行操作的情况下，引入了多道程序设计技术，由此引入多道批处理系统。<br>宏观上并行执行，微观上串行，即多道程序轮流地使用部件，交替执行。  </p>
<ul>
<li>首先要考虑：周转时间和系统吞吐量</li>
</ul>
<h4 id="分时系统"><a href="#分时系统" class="headerlink" title="分时系统"></a><font color='orange'>分时系统</font></h4><p>多个用户分时共享使用同一台计算机，也就是说把计算机的系统资源（尤其是CPU时间）进行时间上分割，即将整个工作时间分成一个个的时间片，每个时间片分给一个用户使用，依次轮流使用一个时间片。  </p>
<ul>
<li>采用调进／调出的单道分时系统<br>单道分时系统内存中只驻留一道程序，其余程序都在外存上。每当内存中一个程序运行一个时间片后，便调至外存（称为调出）。</li>
<li>基于多道程序设计的多道分时系统<br>在<strong>内存</strong>中存放多道作业排成一个队列，依次轮流地获得一个时间片来运行。由于切换作业就在内存，不要花费大量时间用于调进调出，故多道分时系统具有较好的系统性能。</li>
<li>重要指标——响应时间T&#x3D;n*q<br>响应时间是分时系统的重要指标，它是用户发出终端命令到系统开始作出响应的时间间隔。<br>优点：提供人机交互<br>缺点：不能优先处理紧急事件  </li>
<li>首要考虑：交互性和响应时间</li>
</ul>
<h4 id="实时系统"><a href="#实时系统" class="headerlink" title="实时系统"></a><font color='orange'>实时系统</font></h4><p>目标：为了提高系统的响应时间，对随机发生的外部事件作出及时响应并对其进行处理。<br>分类：实时控制系统、实时信息处理系统<br>快速的响应时间、有限的交互能力（弱于分时）、高可靠性（高于分时），能优先处理紧急任务    </p>
<ul>
<li>首要考虑：实时性和可靠性</li>
</ul>
<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><h2 id="进程描述与控制"><a href="#进程描述与控制" class="headerlink" title="进程描述与控制"></a>进程描述与控制</h2><ul>
<li>熟悉<font color='blue'>进程引入的必要性</font>；</li>
<li>熟练掌握<font color='red'>进程的定义和特征</font>，</li>
<li>熟练掌握<font color='red'>进程的三个基本状态、状态转换的条件</font>；</li>
<li>熟练掌握<font color='red'>进程存在的唯一实体——进程控制块</font>；</li>
<li>熟悉<font color='blue'>进程上下文</font>。</li>
</ul>
<h3 id="进程引入的必要性"><a href="#进程引入的必要性" class="headerlink" title="进程引入的必要性"></a><font color='blue'>进程引入的必要性</font></h3><p>为了提高资源利用率，系统采用多道程序设计，程序执行环境由顺序执行变为并发执行。<br>由于程序在<strong>并发执行时</strong>，可能会造成<strong>执行结果的不可再现</strong>，所以用“程序”这个概念已无法描述程序的并发执行，所以必须引入新的概念—进程来<strong>描述程序的并发执行</strong>，并要对进程进行必要的管理，以<strong>保证进程在并发执行时结果可再现</strong>。</p>
<h3 id="进程的定义和特征"><a href="#进程的定义和特征" class="headerlink" title="进程的定义和特征"></a><font color='red'>进程的定义和特征</font></h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>进程是一个正在执行的程序，它被操作系统控制和调度。<br>可并发执行的程序在一个数据集合上的运行过程。  </p>
<ul>
<li>一段可执行的程序</li>
<li>计算机中正在运行的程序的一个实例</li>
<li>可以分配给处理器并由处理器执行的一个实体</li>
<li>由一个顺序的执行线程、一个当前的状态以及一组相关的系统资源所描述的活动单元</li>
</ul>
<h4 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h4><ul>
<li>动态性：动态性是进程的<strong>最基本特征</strong>，它是程序执行过程，它是有一定的生命期。它由创建而产生、由调度而执行，因得不到资源而暂停，并由撤消而死亡。而程序是静态的，它是存放在介质上一组有序指令的集合，无运动的含义。</li>
<li>并发性：并发性是进程的重要特征。并发性指多个进程实体同存于内存中，能在一段时间内同时运行。</li>
<li>独立性：进程是一个能独立运行的基本单位，即是一个独立获得资源和独立调度的单位。</li>
<li>异步性：进程按各自独立的不可预知的速度向前推进，即进程按异步方式进行，正是这一特征，将导致程序执行的不可再现性，因此OS必须采用某种措施来限制各进程推进序列以保证各程序间正常协调运行。</li>
<li>结构特征：从结构上，进程实体由<strong>程序段、数据段和进程控制块</strong>三部分组成。</li>
</ul>
<h3 id="进程控制块PCB——进程存在的唯一实体"><a href="#进程控制块PCB——进程存在的唯一实体" class="headerlink" title="进程控制块PCB——进程存在的唯一实体"></a><font color='red'>进程控制块PCB——进程存在的唯一实体</font></h3><ul>
<li>包含描述进程的基本信息<ul>
<li>标识符（Identifier ）</li>
<li>进程状态（State ）</li>
<li>优先级（Priority ）</li>
<li>程序计数器（Program counter ）</li>
<li>内存指针（Memory pointers ）</li>
<li>上下文数据（Context data ）</li>
<li>I&#x2F;O状态信息（I&#x2F;O status information ）</li>
<li>统计信息（Accounting information ）</li>
</ul>
</li>
<li>由操作系统创建并管理</li>
</ul>
<h3 id="五状态模型"><a href="#五状态模型" class="headerlink" title="五状态模型"></a><font color='red'>五状态模型</font></h3><ul>
<li>运行（Running）：占有CPU</li>
<li>就绪（Ready ）：除了CPU，其它所需资源都已占有，一旦得到处理机即可运行，则称此进程处于就绪状态</li>
<li>阻塞（Blocked ）：等待某些事件</li>
<li>新建（New ）: 已经创建了PCB并保存在主存中，但程序代码和相关数据还没有读入主存</li>
<li>退出（Exit ）<br><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/66a58bdc-d059-4f78-9241-79f69d31d8b8_repeat_1700459209057__806745.png" alt="image.png"></li>
</ul>
<h4 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h4><ul>
<li>就绪态――＞运行态：当处理机空闲时，进程调度程序必将处理机分配给一个处于就绪态的进程，该进程便由就绪态转换为运行态。</li>
<li>运行态――＞阻塞态：处于运行态的进程在运行过程中需要等待某一事件发生后，才能继续运行，则该进程放弃处理机，从运行态转换为阻塞态。</li>
<li>阻塞态――＞就绪态：处于阻塞态的进程，若其等待的事件已经发生，进程由阻塞态转换为就绪态。</li>
<li>运行态――＞就绪态：处于运行状态的进程在其运行过程中，因分给它的处理机时间片已用完，而不得不让出（被抢占）处理机，于是进程由运行态转换为就绪态。</li>
<li>阻塞态――＞运行态和就绪态――＞阻塞态这二种状态转换不可能发生。</li>
</ul>
<h4 id="挂起态"><a href="#挂起态" class="headerlink" title="挂起态"></a>挂起态</h4><p>处理器运行的速度远远地快于I&#x2F;O设备，运行一段时间后会出现所有进程都处于阻塞态（等待I&#x2F;O操作），就绪态进程数为0，此时处理器必须等待。<br>解决：</p>
<ol>
<li>扩充内存  </li>
<li>将进程交换到磁盘，释放内存空间<br>当进程被交换到磁盘上，则该进程从阻塞状态转换到挂起状态。<br>进程处于挂起状态是指该进程不在主存中。</li>
</ol>
<ul>
<li><p>进程不能立即执行；</p>
</li>
<li><p>进程可能在等待某个事件，也可能不等待事件，即进程挂起与否与进程阻塞与否没有必然的联系。</p>
</li>
<li><p>单挂起态<br><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/5b7c3132-2b6c-42d6-afb4-99c5e032468e_repeat_1700459257035__949762.png" alt="image.png"></p>
</li>
<li><p>双挂起态<br><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/4b91da04-ceb5-4d91-b77b-a15c8dfe3205_repeat_1700459264652__015256.png" alt="image.png"><br>阻塞&#x2F;挂起（Blocked&#x2F;Suspend ）<br>就绪&#x2F;挂起（Ready&#x2F;Suspend )</p>
</li>
</ul>
<h3 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h3><ul>
<li>用户模式（目态）<ul>
<li>通常在该模式下执行用户程序</li>
<li>权限较低</li>
</ul>
</li>
<li>系统模式、控制模式或内核模式（管态）<ul>
<li>在该模式下执行操作系统内核</li>
<li>可执行特权指令，权限更高</li>
</ul>
</li>
</ul>
<h4 id="三个问题"><a href="#三个问题" class="headerlink" title="三个问题"></a>三个问题</h4><ul>
<li>为什么需要两种执行模式?<br>保护操作系统和重要数据不受用户干扰</li>
<li>处理器如何知道当前系统处于哪个执行模式下?<br>程序状态字（PSW）中管理程序&#x2F;用户模式位记录了当前系统所处的模式信息</li>
<li>模式如何切换?<br>用户调用操作系统服务（<strong>系统调用</strong>）或发生<strong>中断</strong>时，执行模式从用户模式切换到内核模式<br>当系统服务返回或中断返回到用户进程时，执行模式从内核模式切换到用户模式</li>
</ul>
<h4 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h4><ul>
<li>给进程分配一个唯一的进程标识号</li>
<li>给进程分配空间</li>
<li>初始化进程控制块  </li>
<li>将进程控制块加入到正确的队列中</li>
<li>创建或扩充操作系统所需的其他数据结构</li>
</ul>
<h4 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h4><ul>
<li>何时切换<br>中断、陷阱（进程运行错误或异常）、系统调用</li>
<li>进程切换与模式切换<ul>
<li>模式切换是系统执行模式的改变，发生模式切换可以不改变正处于运行态的进程状态 </li>
<li>进程切换时，操作系统必须使其运行环境发生改变</li>
<li>进程切换必然会存在模式切换（只有在内核模式下才能实现进程调度），但模式切换不一定会发生进程切换</li>
<li>进程切换比模式切换更复杂</li>
</ul>
</li>
</ul>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>了解线程的概念、引入线程的好处和线程的应用 。</p>
<h3 id="并发进程的基本单位"><a href="#并发进程的基本单位" class="headerlink" title="并发进程的基本单位"></a>并发进程的基本单位</h3><ul>
<li>资源拥有者<br>一个进程包括一个存放进程映像的虚拟地址空间，进程需要申请并拥有系统资源，如主存、I&#x2F;O设备、文件等。</li>
<li>调度或执行的基本单位<br> 一个进程沿着其执行轨迹执行，在多道情况下，其执行过程可能与其他进程的执行过程交替进行<br>这两个基本属性使进程成为并发执行的基本单位。 大多数操作系统将这两个属性<strong>独立对待</strong>。</li>
</ul>
<h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p>操作系统在一个进程内支持多个线程的能力。  </p>
<ul>
<li>资源分配与保护以进程为单位</li>
<li>调度执行以线程为基本单位。<ul>
<li>线程只拥有一点在运行中必不可省的资源（程序计数器、一组寄存器和栈），但它可与同属一个进程的其它线程<strong>共享进程拥有的全部资源</strong></li>
<li>线程定义为进程内一个执行单元或一个可调度实体</li>
</ul>
</li>
</ul>
<h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><ul>
<li>执行状态 (running, ready等)</li>
<li>未运行时需保存线程的上下文（一个独立的程序计数器）</li>
<li>一个执行栈</li>
<li>每个线程一些局部变量的静态存储空间</li>
<li>和这个进程的其它线程共享对这个进程的存储器和资源的访问<br>进程内的所有线程驻留在同一块地址空间中，并且可以访问到相同的数据</li>
</ul>
<h3 id="引入线程的好处"><a href="#引入线程的好处" class="headerlink" title="引入线程的好处"></a>引入线程的好处</h3><ul>
<li>在一个已有进程中创建一个新线程比创建一个全新进程所需的时间更少</li>
<li>终止一个线程比终止一个进程花费的时间更少</li>
<li>在同一进程内二个线程间切换时间要比二个进程切换时间小得多</li>
<li>同一个进程内的所有线程共享存储器和文件，当一个线程修改了数据，其他线程都能访问到修改后的结果。因此，线程间通信不需要调用内核就可以实现。  </li>
<li>总结：提高并发执行的程度,减少管理的时空开销。</li>
</ul>
<h3 id="线程特性"><a href="#线程特性" class="headerlink" title="线程特性"></a>线程特性</h3><ul>
<li>线程与进程共享地址空间，故挂起线程将导致进程内所有线程被挂起</li>
<li>进程终止，所有线程随之终止</li>
<li>三个基本状态：运行、就绪、阻塞</li>
</ul>
<h3 id="两种实现方式"><a href="#两种实现方式" class="headerlink" title="两种实现方式"></a>两种实现方式</h3><h4 id="用户级线程（ULTs）"><a href="#用户级线程（ULTs）" class="headerlink" title="用户级线程（ULTs）"></a>用户级线程（ULTs）</h4><p>线程管理的所有工作都由应用程序来完成，内核并不知道线程的存在。</p>
<ul>
<li>优点  <ul>
<li><strong>不依赖于OS内核</strong>，应用进程利用线程库提供创建、同步、调度和管理线程的函数来控制用户线程，可以在任何操作系统中运行</li>
<li>调度由应用软件内部进行，通常采用非抢占式或更简单的规则，<strong>无需用户态&#x2F;核心态切换</strong>，所以速度特别快，用户线程调度算法可针对应用优化</li>
<li>同一进程内各<strong>线程的切换不需要内核参与</strong>，减少了模式切换的开销</li>
</ul>
</li>
<li>缺点<ul>
<li>当一个线程因系统调用而被阻塞时，该进程内的所有线程都被阻塞<br>——系统调用使得模式从用户模式切换到内核模式，操作系统只知道进程，故操作系统将进程置为阻塞状态，从而使得该进程内的所有线程都被阻塞</li>
<li>内核一次只把一个进程分配给一个处理器，因此一次进程中只有一个线程可以执行，使多线程技术不能得到应用</li>
</ul>
</li>
</ul>
<h4 id="内核级线程（KLTs）"><a href="#内核级线程（KLTs）" class="headerlink" title="内核级线程（KLTs）"></a>内核级线程（KLTs）</h4><p>有关线程管理的所有工作都由内核来完成；应用程序只调用内核级线程的API；操作系统基于线程进行调度。</p>
<ul>
<li>优点<ul>
<li>内核可以同时把同一个进程中的多个线程调度到多个处理器中，从而更好地利用多道程序设计技术</li>
<li>如果一个进程内的线程阻塞，内核可以调度同一进程内的其他线程运行，不会导致整个进程被阻塞</li>
<li>内核自身也可以使用多线程</li>
</ul>
</li>
<li>缺点<br>同一个进程内两个线程的切换需要内核模式的切换</li>
</ul>
<h1 id="并发：互斥与同步"><a href="#并发：互斥与同步" class="headerlink" title="并发：互斥与同步"></a>并发：互斥与同步</h1><ul>
<li>熟悉<font color='blue'>进程间制约关系</font>，掌握<font color='orange'>临界资源和临界区概念</font>，掌握<font color='orange'>进程同步和进程同步机制</font>，熟悉<font color='blue'>利用软件、硬件技术解决进程同步机制</font>。</li>
<li>熟练掌握<font color='red'>信号量机制(记录型信号量和wait、signal操作)的概念、定义和实质</font>，熟练掌握<font color='red'>利用信号量机制实现进程互斥和同步</font>。掌握<font color='orange'>利用信号量解决生产者-消费者等经典同步问题</font>，掌握<font color='orange'>进程同步分析方法</font>。</li>
</ul>
<h3 id="并发进程间的制约关系"><a href="#并发进程间的制约关系" class="headerlink" title="并发进程间的制约关系"></a><font color='blue'>并发进程间的制约关系</font></h3><p>在多道程序环境下，系统中各进程以不可预测的速度向前推进，进程的异步性会造成结果的不可再现性。为防止这种现象，异步的进程间推进受到两种限制：</p>
<ul>
<li>资源共享关系<br>多进程共享资源时，每次只允许一个进程使用资源，等该进程使用完毕后再将资源分配给其它进程。这种使用原则称为<strong>互斥</strong>使用。<br>进程之间竞争资源面临三个控制问题：<ul>
<li>互斥（mutual exclusion)指多个进程不能同时使用同一个资源；</li>
<li>死锁（ deadlock )指多个进程互不相让，都得不到足够的资源；</li>
<li>饥饿（ starvation )指一个进程一直得不到资源（其他进程可能轮流占用资源）</li>
</ul>
</li>
<li>相互合作关系<br>   在某些进程之间还存在合作关系，进程并发执行时推进序列受到限制，要保证其合作关系正确。进程间这种关系称为<strong>同步</strong>关系。</li>
</ul>
<h3 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h3><ul>
<li><font color='orange'>临界资源</font> —— 一次只允许一个进程使用的资源。</li>
<li><font color='orange'>临界区</font> —— 多个进程共享临界资源时必须互斥使用，将程序中使用临界资源的那一段代码称为临界区。</li>
<li>竞争条件 —— 多个进程或线程在读写一个共享数据时，结果依赖于它们执行的相对时间，这种情形叫竞争。</li>
</ul>
<h3 id="进程同步机制"><a href="#进程同步机制" class="headerlink" title="进程同步机制"></a><font color='orange'>进程同步机制</font></h3><p>进程在并发执行时为了保证结果的可再现性，各进程执行序列必须加以限制以保证互斥地使用临界资源，相互合作完成任务。<br><strong>多个相关进程在执行次序上的协调</strong>称为进程同步。用于保证多个进程在执行次序上的协调关系的相应机制称为进程同步机制。<br>所有的进程同步机制应遵循下述<strong>四条准则</strong>：  </p>
<ul>
<li>空闲让进<br>  当无进程进入临界区时，相应的临界资源处于空闲状态，因而允许一个请求进入临界区的进程立即进入自己的临界区。</li>
<li>忙则等待<br>   当已有进程进入自己的临界区时，即相应的临界资源正被访问，其它试图进入临界区的进程必须等待，以保证进程互斥地访问临界资源。    </li>
<li>有限等待<br>   对要求访问临界资源的进程，应保证进程能在有限时间进入临界区，以免陷入“饥饿”状态。</li>
<li>让权等待<br>   当进程不能进入自己的临界区时，应立即释放处理机，以免进程陷入忙等。<br>   进程同步机制在临界区前加上进入区，它负责对欲访问的临界资源状态进行检查，以决定是否允许该进程进入临界区还是等待。同时在临界区后加上退出区，它负责释放临界资源以便其它等待该临界资源的进程使用。</li>
</ul>
<h3 id="互斥的三种实现方法"><a href="#互斥的三种实现方法" class="headerlink" title="互斥的三种实现方法"></a>互斥的三种实现方法</h3><ul>
<li>软件方法：由进程本身负责实施互斥，不需要操作系统支持。<ul>
<li>增加一定的开销</li>
</ul>
</li>
<li>硬件方法：使用专门的机器指令来实现互斥。 <ul>
<li>可减少开销，但依赖于硬件，难以成为通用的解决办法</li>
</ul>
</li>
<li>操作系统层提供支持解决互斥 <ul>
<li>信号量机制、管程机制和消息传递机制</li>
</ul>
</li>
</ul>
<h3 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a><font color='red'>信号量机制</font></h3><p>Dijkstra</p>
<ul>
<li>基本原理：两个或多个进程可以通过简单的信号进行合作，一个进程可以被迫在某一个位置停止，直到它接收到一个特定的信号。</li>
</ul>
<h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><ul>
<li>特殊的变量，初始化为<strong>非负数</strong>，称为信号量，用于发送信号</li>
<li>一个进程为了通过信号量s发送信号,它需要执行原语 semSignal(s)&#x2F;V(s)。该操作使信号量值减1。如果信号量值变为负数，则执行该操作的进程被阻塞。</li>
<li>一个进程通过信号量s接收信号, 它需要执行原语semWait(s) &#x2F;P(s)。该操作使信号量值增1。如果值小于或等于零，表示之前有进程在等该信号，则需要在该信号量的阻塞队列中唤醒一个进程。</li>
<li>如果相应的信号没有接收到，该进程将被<strong>挂起</strong>，直到它所需的信号发送为止</li>
</ul>
<h4 id="二元信号量"><a href="#二元信号量" class="headerlink" title="二元信号量"></a>二元信号量</h4><p>只有0和1两个值。</p>
<h4 id="信号量的类型"><a href="#信号量的类型" class="headerlink" title="信号量的类型"></a>信号量的类型</h4><ul>
<li>互斥信号量（公用信号量）：它为一组需互斥共享临界资源的并发进程而设置，它代表永久性共享的临界资源，每个进程均可对它施加wait、signal操作，即可申请和释放该临界资源，其初始值置为1。</li>
<li>同步信号量（专用信号量）：它为一组需同步协作完成任务的并发进程而设置，它代表消耗性的专用资源，只有拥有该资源的进程才能对它施加wait操作（即可申请资源），而由其合作进程对它施加signal操作（即释放资源）。</li>
</ul>
<h4 id="使用信号量机制实现进程互斥"><a href="#使用信号量机制实现进程互斥" class="headerlink" title="使用信号量机制实现进程互斥"></a>使用信号量机制实现进程互斥</h4><p>为使多个进程能互斥地访问某临界资源，只需为该资源设置一个互斥信号量<strong>mutex</strong>, 其初值为1。<br>规定每个进程在<strong>进入临界区CS前</strong>必须申请资源，即对互斥信号量mutex进行<strong>semwait</strong>操作，在<strong>退出临界区CS后</strong>必须释放资源，即对互斥信号量mutex进行<strong>semsignal</strong>操作；即将各进程的临界区CS置于semwait（mutex）和semsignal(mutex)操作之间。<br><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/59fb6e49-2b14-4368-b6b7-46e7e61c2fa7_repeat_1700459269065__771836.png" alt="image.png">  </p>
<h4 id="使用信号量机制实现进程同步"><a href="#使用信号量机制实现进程同步" class="headerlink" title="使用信号量机制实现进程同步"></a>使用信号量机制实现进程同步</h4><p>例：进程p打印进程c计算后放入缓冲区的数据<br>两条规则：</p>
<ul>
<li>只有当C进程把数据送入Buffer后，P进程才能从Buffer中取出数据来打印，否则P进程只能等待。</li>
<li>只有当P进程从Buffer中取走数据后，C进程才能将新计算的数据再存入Buffer,否则C进程也只能等待。<br><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/3ee9319e-1c28-4e66-bd55-ec5d47ba7d3b_repeat_1700459272361__816461.png" alt="image.png">  </li>
<li>同步信号量full，它代表的消耗性的专用资源是缓冲器装满数据；  </li>
<li>同步信号量empty，它代表的消耗性的专用资源是缓冲器空。</li>
</ul>
<h5 id="同步的物理意义"><a href="#同步的物理意义" class="headerlink" title="同步的物理意义"></a>同步的物理意义</h5><p>先做动作的进程C在动作完成后对同步信号量施加signal操作，代表发送消息；后做动作的进程P在动作前对同步信号量施加wait操作，代表测试消息是否到达。</p>
<h4 id="利用信号量机制描述前驱关系"><a href="#利用信号量机制描述前驱关系" class="headerlink" title="利用信号量机制描述前驱关系"></a>利用信号量机制描述前驱关系</h4><p><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/d32274cb-d4ae-4a25-af54-517b961ed5fe_repeat_1700459282414__279457.png" alt="image.png"></p>
<h4 id="经典进程同步问题"><a href="#经典进程同步问题" class="headerlink" title="经典进程同步问题"></a><font color='orange'>经典进程同步问题</font></h4><h5 id="生产者-消费者问题"><a href="#生产者-消费者问题" class="headerlink" title="生产者&#x2F;消费者问题"></a>生产者&#x2F;消费者问题</h5><p>问题描述：<br>一个或多个生产者生产某种类型的数据（记录、字符），并放置在缓冲区中；<br>有一个消费者从缓冲区中取数据，每次取一项；<br>任何时候只有一个生产者或消费者可以访问缓冲区</p>
<ul>
<li><p>情况一：缓冲区无限大<br><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/16d9f92b-18f4-4caf-88c5-2deef1d1822f_repeat_1700459285427__215664.png" alt="image.png"></p>
</li>
<li><p>情况二：缓冲区有限  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">producer:  </span><br><span class="line">while (true) &#123;  </span><br><span class="line">/* produce item v */  </span><br><span class="line">while   </span><br><span class="line">((in + 1) % n == out)   </span><br><span class="line"> 	/* do nothing */;  </span><br><span class="line">b[in] = v;  </span><br><span class="line">in = (in + 1) % n  </span><br><span class="line">&#125;    </span><br><span class="line">consumer:  </span><br><span class="line">while (true) &#123;  </span><br><span class="line">while (in == out)  </span><br><span class="line">	/* do nothing */;   </span><br><span class="line">w = b[out];  </span><br><span class="line">out = (out + 1) % n;  </span><br><span class="line">/* consume item w */  </span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<p><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/0c52cfd8-e687-4f34-8752-130291ea6235_repeat_1700459489858__243453.png" alt="image.png"></p>
</li>
</ul>
<h5 id="读者-写者问题"><a href="#读者-写者问题" class="headerlink" title="读者&#x2F;写者问题"></a>读者&#x2F;写者问题</h5><p>问题描述：<br>有一个许多进程共享的数据区（文件、主存空间或处理器寄存器）；有一些进程只从该数据区中读数据，称为读者；有一些进程只往该数据区中写数据，称为写者。<br>任意多的读者可以同时读数据<br>一次只有一个写者可以往数据区写数据<br>如果写者正在写数据时，禁止任何读者读数据  </p>
<ul>
<li>解决方法一：读者优先  <ul>
<li>写者之间必须保证互斥，因此设置wsem 信号量，其初始值为1</li>
<li>写者只有在没有读者读数据时才能写数据，因此写进程可能会处于“饥饿”状态</li>
<li>写者在写数据时，不允许读者进来，因此第一个读者进程需要在wsem 信号量上等待</li>
<li>当有读者在读时，其他读者都可以进入数据区访问数据，不需要等待（因此称为读者优先）</li>
<li>为了记录读者的个数，定义readcount 变量，初始值为0</li>
<li>每个读者进程都会修改readcount变量，为了确保该共享变量修改的一致性，定义x信号量，初始值为1<br><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/c8204aca-27b9-488c-83cc-8f14f8939e79_repeat_1700459292233__505324.png" alt="image.png"></li>
</ul>
</li>
<li>解决方法二：写者优先<ul>
<li>当一个写者进程想写数据时，不允许新的读者进程访问数据区（解决饥饿的问题）</li>
<li>信号量 rsem ：当至少有一个写者进程准备访问数据区时，禁止所有的读进程 </li>
<li>writecount ： 记录写进程的个数，用于控制对信号量rsem的操作</li>
<li>信号量y ：用于确保对writecount的更新</li>
<li>信号量z：为了避免rsem阻塞队列太长，除了一个读者进程阻塞在rsem队列上，其它所有的读进程都阻塞在信号量z上<br><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/ab7519bb-5dfe-48ca-98da-88133c8307d8_repeat_1700459295039__352366.png" alt="image.png"></li>
</ul>
</li>
</ul>
<h4 id="进程操作总结"><a href="#进程操作总结" class="headerlink" title="进程操作总结"></a>进程操作总结</h4><ul>
<li>信号量的物理含义：<br> S&gt;0表示有S个资源可用；<br>S&#x3D;0表示无资源可用；<br>S&lt;0则| S |表示S等待队列中的进程个数。<br>信号量的初值应该大于等于0<br>wait(s)（P(S)）:表示申请(等待)一个资源<br>signal(s)（V(S)）:表示释放一个资源。  </li>
<li>wait(P)&#x2F;signal(V)操作必须成对出现，有一个wait(P)操作就一定有一个signal(V)操作<br>当为互斥操作时，它们同处于同一进程<br>当为同步操作时，则不在同一进程中出现<br>如果wait(S1)和wait(S2)两个操作在一起，那么wait操作的顺序至关重要,一个同步wait操作与一个互斥wait操作在一起时同步wait操作在互斥wait操作前；而两个signal操作无关紧要</li>
</ul>
<h4 id="例"><a href="#例" class="headerlink" title="例"></a>例</h4><ul>
<li>假定系统有三个并发进程read, move和print共享缓冲器B1和B2。进程read负责从输入设备上读信息，每读出一个记录后把它存放到缓冲器B1中。进程move从缓冲器B1中取出一记录，加工后存入缓冲器B2。进程print将B2中的记录取出打印输出。缓冲器B1和B2某个时刻只能被一个进程访问。要求三个进程协调完成任务，使打印出来的与读入的记录的个数，次序完全一样。请用wait&#x2F;signal操作，写出它们的并发程序。<br><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/0e29d14b-f956-4401-9918-7a8a12536b0a_repeat_1700459297678__021441.png" alt="image.png"><br><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/b8658aa3-5de1-49e0-b97b-3a285ef94c9d_repeat_1700459496666__050823.png" alt="image.png"></li>
</ul>
<h1 id="并发：死锁与饥饿"><a href="#并发：死锁与饥饿" class="headerlink" title="并发：死锁与饥饿"></a>并发：死锁与饥饿</h1><ul>
<li>掌握<font color='orange'>死锁的定义和产生死锁的原因</font>，掌握<font color='orange'>死锁的四个必要条件</font>；熟悉<font color='blue'>预防死锁的方法</font>，熟练掌握<font color='red'>银行家算法及其在死锁避免中的应用</font>；掌握<font color='orange'>资源分配图的简化及其死锁定理</font>，熟悉<font color='blue'>解除死锁的方法</font>。</li>
</ul>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a><font color='orange'>死锁</font></h3><p>死锁是指计算机系统和进程所处的一种状态。在系统中，两个或多个进程无限期地等待永远不会发生的条件，此时称系统处于死锁状态。 </p>
<h4 id="产生死锁的原因"><a href="#产生死锁的原因" class="headerlink" title="产生死锁的原因"></a><font color='orange'>产生死锁的原因</font></h4><ul>
<li>竞争资源<br>两个进程都在等待对方释放出自己所需要的资源，但它们又都因不能获得所需的资源而不能继续推进，从而也不能释放出自己占有的资源，以致进入死锁状态。<ul>
<li>资源分配图<br>可用资源分配图表示系统状态。资源分配图由结点和边组成。<br>结点有两类，一类是进程结点，用圆圈表示；另一类是资源结点，用小方框表示一类资源，方框中的小圈表示资源数。<br>边也有两类，一类是分配边，它由资源结点指向进程结点，另一类是申请边，它由进程结点指向资源结点。<br><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/8fb875e7-e2d0-438c-b21d-512aa4cf9bd1_repeat_1700459303828__410008.png" alt="image.png"></li>
</ul>
</li>
<li>进程推进顺序不当<br>在多道程序系统中，并发执行的进程推进序列不可预测，有些推进顺序会引起进程无限期地等待永远不会发生的条件而不能向前推进，造成了死锁。</li>
</ul>
<h4 id="死锁的条件"><a href="#死锁的条件" class="headerlink" title="死锁的条件"></a><font color='orange'>死锁的条件</font></h4><ul>
<li>互斥(Mutual exclusion)<br>一次只有一个进程可以使用资源</li>
<li>占有且等待 (Hold-and-wait)<br>当一个进程在等待分配得到其他资源时，将继续占有已分配到的资源</li>
<li>非剥夺 (No preemption )<br>不能强行抢占进程已占有的资源</li>
<li>循环等待 (Circular wait)<br>存在一个封闭的进程-资源链，每个进程至少占有一个该链中下一个进程所需要的资源</li>
</ul>
<h4 id="死锁的解决办法"><a href="#死锁的解决办法" class="headerlink" title="死锁的解决办法"></a>死锁的解决办法</h4><ul>
<li>死锁的预防<br>静态方法：在进程执行前采取的措施，通过设置某些限制条件，去破坏产生死锁的四个必要条件之一，防止发生死锁。  </li>
<li>死锁的避免<br>动态的方法：在进程执行过程中采取的措施，不需事先采取限制措施破坏产生死锁的必要条件，而是在进程申请资源时用某种方法去防止系统进入不安全状态，从而避免发生死锁。  </li>
<li>死锁的检测（Detection）和解除<br>这种方法预先并不采用任何限制措施，允许系统在运行过程中发生死锁，但可通过系统设置的检测机构及时检测死锁的发生（定期执行死锁检测算法），如检测到死锁，则采用撤消进程等死锁解除方法使系统恢复正常工作。</li>
</ul>
<h4 id="死锁的预防"><a href="#死锁的预防" class="headerlink" title="死锁的预防"></a><font color='blue'>死锁的预防</font></h4><p>预防死锁的方法是破坏四个产生死锁的必要条件之一。</p>
<ul>
<li>破坏互斥条件<br>互斥使用是资源本身特征所决定的。使用硬软件结合可改变资源本身特性。一般不破坏互斥条件。</li>
<li>破坏不可抢占条件<br>可采用<strong>抢占式调度</strong>，但抢占式调度法主要用于处理机和存储器资源调度，它们的状态容易保存和恢复。此法对外部设备和私有数据不宜使用。</li>
<li>破坏请求和保持条件<br>系统可采用<strong>资源静态预先全分配</strong>方式来破坏请求保持条件。系统要求所有进程<strong>一次性地申请在整个运行过程中全部资源</strong>，若系统有足够资源满足给进程，则在运行前，一次性将其所需要的所有资源分配给该进程。这样该进程在整个运行期间，便不再提出资源要求，从而摒弃了请求条件。<br>优点是简单、易于实现且很安全，但其资源利用率很低，进程也延迟运行。</li>
<li>破坏循环等待条件<br>有序资源使用法：<br>  该方法将所有的资源<strong>按类型进行线性排队，并赋予不同的序号</strong>。所有进程对资源的请求必须<strong>严格按资源序号递增的次序</strong>提出。这样在所形成的资源分配图中不可能再出现环路，因而摒弃了“循环等待”条件，在采用这种策略时总有一个进程占据了较高序号的资源，它继续请求的资源必然是空闲的，因而进程可以一直向前推进。<br>可提高资源利用率，但在进程使用各类资源的顺序与系统规定的顺序不同时会造成资源浪费的情况。</li>
</ul>
<h4 id="死锁的避免（Avoidance）"><a href="#死锁的避免（Avoidance）" class="headerlink" title="死锁的避免（Avoidance）"></a>死锁的避免（Avoidance）</h4><p>允许进程动态地申请资源，系统在进行资源分配之前，<strong>先计算资源分配的安全性</strong>。若此次分配不会导致系统从安全状态向不安全状态转换，便可将资源分配给进程；否则不分配资源，进程必须阻塞等待。从而避免发生死锁。<br>限制：  </p>
<ol>
<li>必须事先声明每个进程请求的最大资源数</li>
<li>考虑的进程必须是无关的，即进程之间不存在同步关系</li>
<li>分配的资源数目必须是固定的</li>
<li>在占有资源时，进程不能退出</li>
</ol>
<ul>
<li>资源分配拒绝  <ul>
<li>系统的安全状态是指系统的一种状态，在此状态下系统能按某种顺序（例如P1、P2……Pn）来为各个进程分配其所需资源，直至最大需求，使每个进程都可顺序地一个个地完成。这个序列（P1、P2…….Pn）称为安全序列。</li>
<li>若系统在某个状态下<strong>不存在一个安全序列</strong>，使所有进程能运行结束，则称系统处于不安全状态。不安全状态并不是死锁状态，而是<strong>存在死锁的可能性</strong>。</li>
</ul>
</li>
</ul>
<h5 id="银行家算法——Dijkstra"><a href="#银行家算法——Dijkstra" class="headerlink" title="银行家算法——Dijkstra"></a><font color='red'>银行家算法——Dijkstra</font></h5><ul>
<li>数据结构<br>考虑一个具有n个进程和 m 种不同类型资源系统。  <ul>
<li>Resource&#x3D;R&#x3D;(R1,R2,…,Rm)：向量，表示系统中<strong>每种资源的总量</strong> </li>
<li>Available&#x3D;V&#x3D;(V1,V2,…,Vm)：向量，未分配给进程的每种资源的总量，即<strong>可用的资源数</strong>  </li>
<li>Claim&#x3D;C：矩阵，Cij表示进程i对资源j的<strong>最大需求</strong></li>
<li>Allocation&#x3D;A：矩阵，Aij表示当前进程i<strong>已分配到的资源</strong>j的数量  </li>
<li>Need&#x3D;N：矩阵，表示每个进程<strong>尚需的各类资源数</strong>，Need[i,j]&#x3D;k 表示进程i还需要j类资源k个。Need[i,j]&#x3D;Claim[i,j]-Allocation[i,j]</li>
</ul>
</li>
<li>算法思想<br>假设在进程并发执行时，进程i提出请求j类资源k个后，表示为Request<del>i</del>[j]&#x3D;k。系统按下述步骤进行安全检查：</li>
</ul>
<ol>
<li>如果alloc[i,<em>]+Request[</em>]≤claim[i,*]，则继续以下检查，否则显示需求申请超出最大需求值的错误。</li>
<li>如果Request[<em>]≤Available[</em>]则继续以下检查，否则显示系统无足够资源，P<del>i</del>阻塞等待。</li>
<li>系统假设同意进程i的请求，将系统状态修改为满足请求之后的状态，然后对此状态执行安全性算法检测，判断在此次资源分配后，系统是否处于安全状态，若安全，才正式将资源分配给进程i，以完成本次分配；否则将恢复原来的资源分配状态，让进程P<del>i</del>等待，即进程P<del>i</del>置为阻塞状态。</li>
</ol>
<h5 id="例-1"><a href="#例-1" class="headerlink" title="例"></a>例</h5><p><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/509c51e1-4df9-45c8-8840-55cfe131c21b_repeat_1700459306266__927083.png" alt="image.png"></p>
<ul>
<li>T<del>0</del>时刻是否安全？<br><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/81bf2dff-a55f-43c0-a177-334eb8ff68ad_repeat_1700459502220__462474.png" alt="image.png"></li>
<li>P<del>1</del>请求资源Request<del>1</del>(1,0,2)可否允许？<ul>
<li>Request1(1,0,2)≤Need1(1,2,2)，P1请求在最大需求范围内。</li>
<li>Request1(1,0,2)≤ Available(3,3,2)，可用资源可满足P1请求需要。</li>
<li>试探把要求的资源分配给进程P1并修改有关数据结构的数值：<br>Available &#x3D; Available(3，3，2)－Request<del>1</del>(1,0,2)&#x3D;(2,3,0)；<br>Need<del>1</del> &#x3D; Need<del>1</del>(1,2,2)－Request<del>1</del>(1,0,2)&#x3D; (0,2,0)；<br>Allocation<del>1</del> &#x3D;Allocation<del>1</del>(2,0,0)+Request<del>1</del>(1,0,2) &#x3D;(3,0,2)；<br>利用安全性算法检查试探将资源分配后状态的安全性如下：<br><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/04b518f0-9297-4c94-b7e3-60a79944b4c1_repeat_1700459311309__846656.png" alt="image.png"><br>因为先分配资源给P1进程符合按安全序列{P1、P3、P4、P2、P0}分配资源，所以试探将资源分配给进程P1后的状态是安全的，可将资源分配给进程P1。</li>
</ul>
</li>
<li>P<del>4</del>请求资源Request<del>4</del>(3,3,0)是否允许？<br>Request<del>4</del>(3,3,0)≤Need<del>4</del>(4,3,1)，P<del>4</del>请求在最大需求范围内。<br>Request<del>4</del>(3,3,0)≤Available(2,3,0)不成立，即可用资源暂不能满足P4请求资源需要，P<del>4</del>阻塞等待。</li>
</ul>
<h4 id="死锁的检测（Detection）和解除"><a href="#死锁的检测（Detection）和解除" class="headerlink" title="死锁的检测（Detection）和解除 "></a><font color='blue'>死锁的检测（Detection）和解除 </font></h4><p>不限制资源访问或约束进程的行为;<br>只要系统资源能满足进程的请求就立即满足;<br>操作系统定期执行一个算法（死锁检测算法），检测当前系统是否满足了循环等待的条件，即当前系统是不是出现死锁;<br>若出现死锁，则进行相应的恢复。<br><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/f04b5ba1-cb40-41d0-9741-ecaef7be0d67_repeat_1700459313750__290804.png" alt="image.png"><br><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/f4b4a089-bd49-4a1b-b82f-96c5423f6590_repeat_1700459508199__508024.png" alt="image.png"></p>
<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><h3 id="教学要求"><a href="#教学要求" class="headerlink" title="教学要求"></a>教学要求</h3><ul>
<li>熟悉<font color='blue'>存储管理目的和功能</font>，掌握<font color='orange'>地址重定位的概念</font>。</li>
<li>熟悉<font color='blue'>固定分区分配、动态分区分配的实现原理</font>；掌握<font color='orange'>可变分区分配的数据结构和分配回收算法</font>，熟悉<font color='blue'>可变分区碎片和压缩技术</font>。</li>
<li>熟练掌握<font color='red'>分页存储管理原理</font>，熟练掌握<font color='red'>分页存储管理基本的地址变换机构</font>。</li>
<li>掌握<font color='orange'>分段存储管理原理和分段地址变换机构</font>，掌握<font color='orange'>分页和分段比较</font>，熟悉<font color='blue'>分页和分段的共享</font>。</li>
</ul>
<h3 id="目的和功能"><a href="#目的和功能" class="headerlink" title="目的和功能"></a><font color='blue'>目的和功能</font></h3><h4 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h4><p>程序的指令和数据只有被调入内存（RAM）里才能被CPU直接访问，程序才能够被执行。</p>
<h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><p>1.内存分配<br>内存分配的主要任务是：为每一道程序分配内存空间；程序撤消时，收回它占用的内存空间。分配时注意提高存储器的利用率。<br>2.地址映射<br>目标程序所访问的地址是逻辑地址集合的地址空间，而内存空间是内存中物理地址的集合，在多道程序环境下，这两者是不一致的，因此，存储管理必须提供地址映射功能，用于<strong>把程序地址空间中的逻辑地址转换为内存空间中对应的物理地址</strong>。<br>3.存储保护<br>内存保护的任务是确保每道程序都在自己的内存空间运行，互不干扰。保护系统程序区不被用户侵犯（有意或无意的），不允许用户程序读写不属于自己地址空间的数据（系统区地址空间，其他用户程序的地址空间）。<br>4.提高主存储器的利用率<br>减少不可用的存储空间（称为“碎片”、“零头”），允许多道程序动态共享主存。<br>5.内存扩充<br>内存扩充的任务是从<strong>逻辑上</strong>来扩充内存容量，使用户认为系统所拥有的内存空间远比其实际的内存空间（硬件RAM）大的多。  </p>
<h3 id="地址重定位"><a href="#地址重定位" class="headerlink" title="地址重定位"></a><font color='orange'>地址重定位</font></h3><p>地址重定位，也称地址映射（map），它将相对地址转换成内存中的绝对地址。按照重定位的时机，可分为静态重定位和动态重定位。  </p>
<ul>
<li>静态重定位<br>静态重定位是在程序执行之前进行重定位。它根据装配模块将要装入的内存起始地址，直接修改装配模块中的有关使用地址的指令。</li>
<li>动态重定位<br>动态重定位是指在程序执行过程中进行地址重定位，即在每次访问内存单元前才进行地址变换。</li>
</ul>
<h3 id="内存分区"><a href="#内存分区" class="headerlink" title="内存分区"></a><font color='blue'>内存分区</font></h3><p>内存管理最基本的操作是由处理器将程序装入主存中执行。<br>分区存储管理是能够满足多道程序运行的最简单的存储器管理方案，其基本思想是将内存划分成若干个连续的区域，称为分区。<br>每个分区只能存储一个程序，而且程序也只能在它所驻留的分区中运行。<br>分区存储管理根据分区个数及分区大小的可变性分为固定分区和动态分区两种。</p>
<h4 id="固定分区"><a href="#固定分区" class="headerlink" title="固定分区"></a>固定分区</h4><p>在作业装入之前，系统管理员或操作系统<strong>事先</strong>将内存划分成若干个分区。一旦划分完成，在系统运行期间不再重新划分，即分区的<strong>个数不可变</strong>，分区的<strong>大小不可变</strong>，所以，固定式分区又称为静态分区。<br>可划分为大小相等的分区 (Equal-size partitions) 和大小不等的分区(Unequal-size partitions) 任何小于或等于分区大小的进程都可以装入到任何可用的分区中。<br>如果所有的分区都满了，系统可以换出一个进程，将其所占用的分区分配给另一个进程使用。<br><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/fde5cf36-3770-4314-a1b1-d39f7e8b7c64_repeat_1700459319176__108479.png" alt="image.png"></p>
<h5 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h5><ul>
<li>程序可能太大而不能放到一个分区中，必须使用覆盖技术，使得在任何时候该程序只有一部分放到主存中。</li>
<li>主存的利用率不高。任何进程，即使很小，都需要<strong>占据一个完整的分区</strong>。 一个进程的大小不可能正好等于某个分区的大小，所以每个被分配的分区内总有一部分被浪费，我们把这部分被浪费的存储区称为<strong>内部碎片</strong>( fragmentation)或内零头。</li>
</ul>
<h5 id="放置算法"><a href="#放置算法" class="headerlink" title="放置算法"></a>放置算法</h5><ul>
<li>大小相等的分区<br>所有分区大小都相等，只要存在可用的分区，进程就可以装入</li>
<li>大小不等的分区<br>把每个进程指定到足够容纳它的最小分区</li>
</ul>
<h4 id="动态分区"><a href="#动态分区" class="headerlink" title="动态分区"></a><font color='orange'>动态分区</font></h4><p>动态分区是指在作业装入内存时，从可用的内存中划出一块连续的区域分配给它，且<strong>分区大小正好等于该作业的大小</strong>。<br>动态分区中分区的大小和分区的个数都是可变的，而且是根据作业的大小和多少动态地划分，因此又称可变分区。<br><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/896224c5-3f40-407c-b0aa-8d6e60596d1c_repeat_1700459322193__184774.png" alt="image.png"><br>在分配时，首先找到一个足够大的空闲分区，系统再将这个空闲分区分成两部分：一部分成为已分配的分区（大小正好等于作业要求的大小），剩余的部分仍作为空闲区。<br>回收撤除作业所占领的分区时，要检查回收的分区是否与前后空闲的分区相邻接，若是，则加以合并，使之成为一个连续的大空间。<br>随着作业的不断分配和撤除，内存中会产生越来越多的碎片（外部碎片），内存的利用率下降，因此，必须定期使用压缩技术(compaction)，移动进程，使进程所占用的空间连续，并且所有空闲空间连成一片。</p>
<h5 id="分配算法"><a href="#分配算法" class="headerlink" title="分配算法"></a>分配算法</h5><ul>
<li>最佳适应算法BF（Best Fit）：它从全部空闲区中找出能满足作业要求的、且大小最小的空闲分区，这种方法能使碎片尽量小。为适应这种算法，空闲分区表（空闲区链）中的空闲分区要<strong>按大小从小到大进行排序</strong>，自表头开始查找到第一个满足要求的自由分区分配。该算法保留大的空闲区，但造成许多小的空闲区。</li>
<li>首次适应算法FF（First Fit）：从空闲分区表的第一个表目起查找该表，把最先能够满足要求的空闲区分配给作业，这种方法目的在于减少查找时间。为适应这种算法，空闲分区表（空闲区链）中的空闲分区要<strong>按地址由低到高进行排序</strong>。该算法优先使用低址部分空闲区，在低址空间造成许多小的空闲区，在高地址空间保留大的空闲区。</li>
<li>循环首次适应算法&#x2F;邻近算法NF(Next Fit)：该算法是首次适应算法的变种，它把空闲分区表（空闲区链）中的空闲分区按<strong>地址递增</strong>构成一个循环链。在分配内存空间时，不再每次从表头（链首）开始查找，而是从<strong>上次找到的空闲区的下一个空闲区</strong>开始查找，直到找到第一个能满足要求的的空闲区为止，并从中划出一块与请求大小相等的内存空间分配给作业。该算法能使内存中的空闲区分布得比较均匀。</li>
<li>最坏适应法：从所有未分配的分区中挑选最大的且大于和等于作业大小的分区分给要求的作业；空闲分区按大小<strong>由大到小排序</strong>。该算法使小的空闲区减少，但造成大的空闲区不够大。</li>
</ul>
<h5 id="回收算法"><a href="#回收算法" class="headerlink" title="回收算法"></a>回收算法</h5><p>邻接则合并，否则新建条目并插入合适位置。<br>分区存储保护：选中作业运行时将其边界存入上下界寄存器，作业运行过程中超出范围则产生越界中断。</p>
<h5 id="伙伴系统"><a href="#伙伴系统" class="headerlink" title="伙伴系统"></a>伙伴系统</h5><p>可用于分配的整个内存空间看做一个大小为2U的块<br>如果请求分配的空间大小s满足2U-1 &lt; s &lt;&#x3D; 2U, 则分配整个空间块（2U）<br>否则，将2U 一分为二，分为两个大小相等的伙伴，大小均为2U-1<br>这个过程一直继续，直到产生大于或等于s的最小块，并分配给该请求。<br>可用二叉树来表示，树的叶节点表示内存中的当前分区。如果两个伙伴都是叶节点且都未分配，则必须将它们合成一个更大的块。<br><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/d78b2477-9d42-47ab-a9f4-a5e332155964_repeat_1700459324979__686508.png" alt="image.png"></p>
<h3 id="分页存储管理方式"><a href="#分页存储管理方式" class="headerlink" title="分页存储管理方式"></a><font color='red'>分页存储管理方式</font></h3><p>分页存储管理是将一个<strong>进程的地址空间</strong>划分成若干个<strong>大小相等的片</strong>，称为页面或<strong>页</strong>，相应地，将<strong>内存空间</strong>划分成<strong>与页相同大小</strong>的若干个块，称为（物理）<strong>帧</strong>（块）或页帧。在为进程分配内存时，将进程中的若干页离散地装入不相邻接的物理帧中。<br>页面的大小通常在512B到4KB之间，每块物理块可离散地分配给进程的一页，这样不断地分配，直到剩余的物理块数不能满足一个进程的要求为止。而对每个进程只有最后一页经常装不满一块，平均产生半页“页内碎片”。由此可知，分页存储管理<strong>解决了“碎片”问题，提高了存储器的利用率</strong>。</p>
<h4 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h4><p>系统在内存为每个进程建立了一张页面映射表，简称<strong>页表</strong>(page table)（<strong>有多少个进程就有多少个页表</strong>）。每个页在页表中占一个表项，记录该页在内存中对应的物理块号或帧号（页号可以省略，通常默认从0开始）。<br>进程在执行时，通过查找页表，就可以找到每页所对应的物理块号或帧号。<br>可见，页表的作用是实现从<strong>页号到物理块号的地址映射</strong>。 </p>
<h4 id="地址结构"><a href="#地址结构" class="headerlink" title="地址结构"></a>地址结构</h4><p>分页系统的地址结构如下图所示，它由两部分组成：前一部分为<strong>页号P</strong>；后一部分为<strong>页内位移量W</strong>，即页内地址，由页的大小决定。<br>图中的地址长度为16位，其中0～9位为页内地址（每页的大小为1KB），10～15位为页号，所以允许地址空间的大小最多为64个页（26）。<br><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/da703385-537b-43bb-9fcb-99f20bd5b4d7_repeat_1700459327568__540114.png" alt="image.png"></p>
<h4 id="地址变换"><a href="#地址变换" class="headerlink" title="地址变换"></a>地址变换</h4><p>基本任务：利用硬件实现查页表把用户程序中的逻辑地址变换成内存中的物理地址。<br>为了实现地址变换功能，在系统中设置页表寄存器，用来存放页表的始址和页表的长度。在进程未执行时，每个进程对应的页表的始址和长度存放在进程的PCB中，当该进程被调度时，就将它们装入页表寄存器。<br>在进行地址变换时，系统将逻辑地址截成页号和页内地址二部分，将页号与页表长度进行比较，如果<strong>页号大于等于</strong>页表寄存器中的<strong>页表长度</strong>，则访问越界，产生<strong>越界中断</strong>。如未出现越界，则根据页表寄存器中的页表始址和页号计算出该页在页表项中的位置，查页表得到该页的物理块号，<strong>将物理块号与逻辑地址中页内地址二者拼接成物理地址</strong>，这样便完成了从逻辑地址到物理地址的变换。<br><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/dc2f0f14-47d2-4493-97c6-dae3d0c71140_repeat_1700459329985__639592.png" alt="image.png"><br><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/5d88d5fc-2fef-4fd0-8a35-1ab4bdaf6f6a_repeat_1700459514557__570614.png" alt="image.png"></p>
<h3 id="分段"><a href="#分段" class="headerlink" title="分段"></a><font color='orange'>分段</font></h3><p>在分段存储管理方式中，作业的地址空间<strong>按逻辑信息完整性被划分为若干个段</strong>，每个段都有自己的名字，编译后都是从零开始编址的一段连续的地址空间，段的长度由相应逻辑信息组的长度决定，因而<strong>各段长度是不等的</strong>。每个段分配到一个连续的分区，而进程中的各个段可以离散地分配到内存中不同的分区中。<br>分段系统的地址结构由<strong>段号</strong>和<strong>段内地址</strong>两部分组成。<br><strong>取最大段的长度为段内地址位数</strong>。</p>
<h4 id="段表"><a href="#段表" class="headerlink" title="段表"></a>段表</h4><p>每个段在表中占有一表项，在其中记录了该段在内存中的起始地址（又称为“基址”）和段的长度。<br><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/f6d910ba-9c42-460c-aa71-17b3647b9a1e_repeat_1700459335095__308089.png" alt="image.png"></p>
<h4 id="地址变换-1"><a href="#地址变换-1" class="headerlink" title="地址变换"></a>地址变换</h4><p>段表寄存器，存放段表始址和段表长度。<br>逻辑地址中的段号S与段表长度TL进行比较。若 S≥TL，产生越界中断信号；<br>若未越界，则根据段表的始址和该段的段号，计算出该段对应段表项的位置，从中读出该段在内存中的起始地址，然后再检查段内地址d是否超过该段的段长SL。若超过，即d≥SL，同样发出越界中断信号；若未越界，则将该段的基址与段内地址d相加，得要访问的内存物理地址。<br><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/03f11728-90ae-4e06-ace5-bed36e8cbb71_repeat_1700459337644__615445.png" alt="image.png"></p>
<h4 id="共享"><a href="#共享" class="headerlink" title="共享"></a><font color='blue'>共享</font></h4><p>段是信息的逻辑单位,因此分段系统的一个突出的优点是易于实现段的共享。<br>下图为分段系统中共享 editor编辑程序的示意图。<br><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/d02af489-3904-4a07-a93f-0a4862084418_repeat_1700459340116__972054.png" alt="image.png"></p>
<h3 id="分页与分段对比"><a href="#分页与分段对比" class="headerlink" title="分页与分段对比"></a><font color='orange'>分页与分段对比</font></h3><p><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/c0cf0068-7958-4cb6-8e7f-9464ec9e94d6_repeat_1700459519735__882813.png" alt="image.png"><br><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/0d25a699-acfd-4c86-b886-2fb940f0a546_repeat_1700459343642__349734.png" alt="image.png"></p>
<h1 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h1><h3 id="教学要求-1"><a href="#教学要求-1" class="headerlink" title="教学要求"></a>教学要求</h3><ul>
<li>掌握<font color='orange'>虚拟存储器的理论基础和定义</font>，熟悉<font color='blue'>虚拟存储器实现方式和特征</font>。</li>
<li>掌握<font color='orange'>请求分页的页表机制、缺页中断机构和地址变换机构</font>，熟悉<font color='blue'>页面的分配和置换策略、页面的分配的算法</font>。</li>
<li>掌握<font color='orange'>请求分段的段表机制、缺段中断机构和地址变换机构</font>，熟悉<font color='blue'>分段的共享和保护</font>。</li>
<li>掌握<font color='orange'>段页式存储管理原理和地址变换机构</font>。</li>
<li>熟练掌握<font color='red'>最佳置换算法、先进先出（FIFO）置换算法、最近最久未使用置换算法LRU</font>，熟悉<font color='blue'>Clock置换算法和页面缓冲算法</font>；了解工作集概念。</li>
</ul>
<h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>前面的存储器管理方式，有一个共同的特点，即要求将一个作业<strong>全部装入内存</strong>才能运行。如果有的作业很大，其所要求的内存空间超过了内存总容量，作业就不能全部被装入内存，致使该作业无法运行；有时大量作业要求运行，但由于内存容量不足以容纳所有这些作业，只能将少数作业装入内存让它们先运行，而将其它大量的作业留在外存上等待。<br>显而易见的一种解决方法，是从物理上增加内存容量，但这往往会受到机器自身的限制，而且增加了系统成本。<br>另一种方法是从<strong>逻辑上扩充内存容量</strong>，这正是虚拟存储技术所要解决的主要问题。 </p>
<h4 id="虚拟存储的优点"><a href="#虚拟存储的优点" class="headerlink" title="虚拟存储的优点"></a>虚拟存储的优点</h4><ul>
<li>内存中可以容纳更多的进程  <ul>
<li>每个进程只有<strong>一部分</strong>的数据块读入内存，其他数据块仍保存在磁盘上</li>
<li>内存可以<strong>容纳更多的进程</strong>，并发性得到更大的提高，从而也使得处理器得到了更有效的利用</li>
</ul>
</li>
<li>进程可以比主存的全部空间还大<ul>
<li>实存 (Real memory)：内存</li>
<li>虚存 (Virtual memory)：磁盘的存储空间</li>
</ul>
</li>
</ul>
<h3 id="虚拟存储器理论基础"><a href="#虚拟存储器理论基础" class="headerlink" title="虚拟存储器理论基础"></a><font color='orange'>虚拟存储器理论基础</font></h3><h4 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h4><p>程序在执行时将呈现出局部性规律，即在一段时间内，程序的执行仅局限于某个部分；相应地，它所访问的存储空间也局限于某个区域内。</p>
<ul>
<li>时间局部性<br>如果程序中的某条指令一旦执行，则不久的将来该指令可能再次被执行；如果某个存储单元被访问，则不久以后该存储单元可能再次被访问。产生时间局限性的典型原因是在程序中存在着大量的<strong>循环</strong>操作。</li>
<li>空间局部性<br>一旦程序访问了某个存储单元，则在不久的将来，其附近的存储单元也最有可能被访问。 即程序在一段时间内所访问的地址，可能集中在一定的范围内，其典型原因是程序是<strong>顺序执行</strong>的。<br>局部性原理确保了虚拟存储机制的可行性。但利用局部性原理的同时，要避免系统出现抖动现象（thrashing），即处理器大部分时间都用于交换块，而不是执行指令。</li>
</ul>
<h4 id="软硬件支撑"><a href="#软硬件支撑" class="headerlink" title="软硬件支撑"></a>软硬件支撑</h4><h5 id="硬件支撑"><a href="#硬件支撑" class="headerlink" title="硬件支撑"></a>硬件支撑</h5><ul>
<li>有相当容量的辅存（磁盘）以存放所有并发作业的地址空间</li>
<li>有一定容量的内存来存放运行作业的部分程序</li>
<li>有支持分页或分段的硬件<ul>
<li>请求分页系统和请求分段系统</li>
<li>动态地址转换机构</li>
</ul>
</li>
</ul>
<h5 id="软件支撑"><a href="#软件支撑" class="headerlink" title="软件支撑"></a>软件支撑</h5><ul>
<li>操作系统能提供页或段在主存和辅存之间有效交换的管理模块</li>
</ul>
<h4 id="特征-1"><a href="#特征-1" class="headerlink" title="特征"></a>特征</h4><ul>
<li>离散性<br>指在内存分配时采用离散的分配方式，它是虚拟存储器的<strong>最基本</strong>的特征。</li>
<li>多次性<br>指一个作业被分成多次调入内存运行，即在作业运行时没有必要将其全部装入，只须将当前要运行的那部分程序和数据装入内存即可。多次性是虚拟存储器<strong>最重要</strong>的特征。</li>
<li>对换性<br>指允许在作业的运行过程中在内存和外存的对换区之间换进、换出。</li>
<li>虚拟性<br>指能够从逻辑上扩充内存容量，使用户所看到的内存容量远大于实际内存容量。</li>
</ul>
<h3 id="请求分页"><a href="#请求分页" class="headerlink" title="请求分页"></a><font color='orange'>请求分页</font></h3><p>请求分页存储管理系统是在纯分页系统的基础上，增加了<strong>请求调页</strong>功能、<strong>页面置换</strong>功能所形成的页式虚拟存储系统，它是目前常用的一种虚拟存储器的方式。<br>它允许只装入若干页(而非全部页)的用户程序和数据，便可启动运行。以后，再通过调页功能及页面置换功能，陆续地把即将要运行的页面调入内存，同时把暂不运行的页面换出到外存上，置换时以页面为单位。  </p>
<h4 id="硬件支持"><a href="#硬件支持" class="headerlink" title="硬件支持"></a>硬件支持</h4><h5 id="页表-1"><a href="#页表-1" class="headerlink" title="页表"></a>页表</h5><p><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/97ca00b8-5137-4724-90a3-7497e27a315f_repeat_1700459348613__844897.png" alt="image.png"><br>其中各字段说明如下：  </p>
<ul>
<li>状态位（中断位P）：用于指示该页<strong>是否已调入内存</strong>，供程序访问时参考。</li>
<li>访问字段A：用于记录本页在一段时间内被访问的次数，或最近已有多长时间未被访问，提供给置换算法选择换出页面时参考。</li>
<li>修改位M：表示该页在调入内存后是否被修改过。由于内存中的每一页都在外存上保留一份副本，因此，若未被修改，在置换该页时就不需将该页写回到外存上，以减少系统的开销和启动磁盘的次数；若已被修改，则必须将该页重写到外存上，以保证外存中所保留的始终是最新副本。</li>
<li>外存(辅存)地址：用于指出该页在外存上的地址，通常是物理块号，供调入该页时使用</li>
</ul>
<h5 id="缺页中断"><a href="#缺页中断" class="headerlink" title="缺页中断"></a>缺页中断</h5><p>在请求分页系统中，每当所要访问的页面不在内存时，便要产生缺页中断，请求OS将所缺页调入内存。</p>
<h4 id="请求分页带来的问题"><a href="#请求分页带来的问题" class="headerlink" title="请求分页带来的问题"></a>请求分页带来的问题</h4><ul>
<li>每个进程都有一个页表，页表保存在哪里？<br>一个2GB (2^31^ )的进程，如果页大小为512B(2^9^) ，则需要的页表项为2^22^<br>页表占据了大量的空间，应该保存在虚存上，可使用<strong>多级页表</strong>结构</li>
<li>每个虚存访问会引起<strong>两次</strong>物理内存访问，导致存储器访问时间加倍<br>第一次取相应的页表项，第二次取需要数据。<br>可使用<strong>快表</strong>机制来解决</li>
</ul>
<h4 id="快表-Translation-Lookaside-Buffer，TLB）"><a href="#快表-Translation-Lookaside-Buffer，TLB）" class="headerlink" title="快表(Translation Lookaside Buffer，TLB）"></a>快表(Translation Lookaside Buffer，TLB）</h4><p>为了提高地址变换的速度，增设了一个具有按内容查找、并行查询功能的特殊的<strong>高速缓冲存储器</strong>，称为 “快表”，或称为“关联存储器(TLB, 转换后备缓冲器)”，用以存放当前访问的那些页表项，每个页表项包括<strong>页号和相应的块号</strong>（页号不能省略）。<br>引入快表之后的存储访问修改如下：  </p>
<ul>
<li>处理器首先将逻辑地址中的页号与TLB中的各页表项的页号进行比较</li>
<li>如果有相同的 (TLB命中)， 则直接从TLB的输出寄存器输出相应的块号</li>
<li>如果没有找到(TLB不命中) ，则访问内存从该进程的页表中查找</li>
<li>检查该页是否在内存中(检查P位) 。如果不在，则发生缺页中断</li>
<li>页访问之后，++同时要将该页的页表项读入TLB++</li>
</ul>
<h4 id="例-2"><a href="#例-2" class="headerlink" title="例"></a>例</h4><p><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/4c69bf10-9885-46e8-a99d-ffa1ca04f2e4_repeat_1700459351096__291351.png" alt="image.png"><br><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/43c6d03f-f094-4dfe-bde7-a157d2f1a7b1_repeat_1700459526149__252103.png" alt="image.png"></p>
<h3 id="段页式存储"><a href="#段页式存储" class="headerlink" title="段页式存储"></a><font color='orange'>段页式存储</font></h3><p><strong>将内存空间划分成大小相同的若干个块，将用户程序先按逻辑完整性分为若干个段</strong>，并为每个段赋予一个段名，再把<strong>每个段划分成若干个与块大小相同的页</strong>，将这些页离散装入不相邻接的块中。<br>段页式系统中的地址结构由段号、段内页号和页内地址三部分组成。<br><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/fcbba89a-5d4d-4431-b5b8-7072cd02a7fb_repeat_1700459356211__143176.png" alt="image.png"><br>在段页式系统中，为了实现从逻辑地址到物理地址的变换，系统中必需同时配置段表和页表。由于将段中的页进行离散地分配，<strong>段表中的内容不再是段的内存始址和段长，而是页表始址和页表长度</strong>。</p>
<h4 id="地址变换-2"><a href="#地址变换-2" class="headerlink" title="地址变换"></a>地址变换</h4><ol>
<li>系统将逻辑地址截成段号S、段内页号P与页内地址W，先用段号S与段长TL（存在段表寄存器中）进行比较。若 S≥TL，表示段号太大，访问越界，于是产生越界中断信号；</li>
<li>若S＜TL，表示未越界，于是利用段表始址（存在段表寄存器中）和段号求出该段对应的段表项在段表中的位置，从中得到该段的页表始址；</li>
<li>利用逻辑地址中的段内页号P来获得对应页的页表项在页表中位置，判断状态P位，若P位为0表示该页不在内存中，产生缺页中断；</li>
<li>若P位为1，则从中读出该页所在的物理块号b，再用块号b和页内地址W拼成物理地址。</li>
</ol>
<ul>
<li>段页式系统中，为了获得一条指令或数据，需要访问几次内存？<br>需访问三次内存：<br>第一次访问内存中的段表，从中取得页表始址；<br>第二次访问内存中的页表，从中取出该页所在的物理块号，并将该块号与页内地址一起形成指令或数据的物理地址；<br>第三次访问才是真正根据所得的物理地址取出指令或数据。  <ul>
<li>如何提高速度？<br>在地址变换机构中增设一高速缓冲寄存器（如TLB），记录最近访问过的地址信息。每次访问它时，都同时利用段号和页号去检索高速缓存。</li>
</ul>
</li>
</ul>
<h3 id="替换策略"><a href="#替换策略" class="headerlink" title="替换策略"></a><font color='red'>替换策略</font></h3><ul>
<li>读取一个新页时，应该替换内存中的哪一页?<br>在进程运行过程中，如果发生缺页，此时内存中又无空闲块时，为了保证进程能正常运行，就必须从内存中调出一页到磁盘。<br>页面置换算法的性能指标：<strong>缺页率（ page fault rate ）&#x3D;“缺页次数 &#x2F; 内存访问次数” (比率)</strong></li>
</ul>
<h4 id="最佳替换（OPT）"><a href="#最佳替换（OPT）" class="headerlink" title="最佳替换（OPT）"></a>最佳替换（OPT）</h4><p><strong>选择那些永不使用的，或者是在最长时间内不再被访问的页面置换出去。</strong><br>它是一种理想化的算法，性能最好，但在实际上难于实现。<br><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/0c5ad9f3-a5ee-4f99-bd74-94e826266136_repeat_1700459358690__752195.png" alt="image.png"></p>
<h4 id="先进先出（FIFO）"><a href="#先进先出（FIFO）" class="headerlink" title="先进先出（FIFO）"></a>先进先出（FIFO）</h4><p>总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面予以淘汰。<br>是一种最直观的算法，但性能最差，有<strong>Belady异常</strong>现象。<br><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/2519d0a1-57e7-4676-bb99-956d8043c9c7_repeat_1700459531928__256827.png" alt="image.png"></p>
<h5 id="Belady现象"><a href="#Belady现象" class="headerlink" title="Belady现象"></a>Belady现象</h5><p>采用FIFO算法时，如果对一个进程未分配它所要求的全部页面，有时就会出现<strong>分配的页面数增多，缺页率反而提高的异常现象</strong>。<br>对页面访问序列A B C D A B E A B C D E ，分配3块物理块时，缺页次数为9次；分配4块物理块时，缺页次数反而为10次。<br>原因在于++刚换出去的页马上又被访问到++。 </p>
<h4 id="最近最久未使用（Least-Recently-Used，LRU）"><a href="#最近最久未使用（Least-Recently-Used，LRU）" class="headerlink" title="最近最久未使用（Least Recently Used，LRU）"></a>最近最久未使用（Least Recently Used，LRU）</h4><p>该算法是选择<strong>最近最久未使用</strong>的页面予以淘汰，这是局部性原理的合理近似，性能<strong>接近最佳</strong>算法。<br>但由于需要记录页面使用时间的先后关系，硬件开销太大。系统在每个页面设置一个访问字段，用以记录这个页面自上次被访问以来所经历的时间T，当要淘汰一个页面时，选择T最大的页面。但在实现时需要硬件的支持（寄存器或栈）。<br><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/caf33a80-2ed6-4df7-8916-7e315fe84bc0_repeat_1700459362384__409531.png" alt="image.png"></p>
<h4 id="Clock置换"><a href="#Clock置换" class="headerlink" title="Clock置换"></a><font color='blue'>Clock置换</font></h4><p>Clock置换算法是一种LRU的近似算法。该算法为每个页面设置一位<strong>访问位</strong>，将内存中的所有页面都通过链接指针链成一个<strong>循环队列</strong>，并设置一个<strong>循环替换指针</strong>，指向当前被置换页所在块。<br><strong>当页第一次读入内存时，其访问位为1；当某页被访问时，其访问位置1</strong>。<br>在选择一页淘汰时，沿循环替换指针检查页面，如其<strong>访问位是“0”，就选择该页换出；若为“1”，则重新置为“0”，暂不换出该页，在循环队列中检查下一个页面，直到访问位为“0”的页面为止</strong>。<br>由于该算法只有一位访问位，只能用它表示该页是否已经使用过，而置换时是将未使用过的页面换出去，所以把该算法称为最近未用算法NRC（Not Recently Used），又称第二次机会算法。<br><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/ed68301c-5f14-443b-893b-65f520b0adc6_repeat_1700459364712__065924.png" alt="image.png"></p>
<h3 id="例-3"><a href="#例-3" class="headerlink" title="例"></a>例</h3><h4 id="例1"><a href="#例1" class="headerlink" title="例1"></a>例1</h4><p><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/01d20b96-e391-40e6-af4b-3de0b1477ce3_repeat_1700459368605__015389.png" alt="image.png"><br><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/22ad2d00-64e2-4318-a222-09104a57b6c0_repeat_1700459370445__892849.png" alt="image.png"><br><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/697e0f9f-80b7-449c-98f2-c6689ae1f977_repeat_1700459390247__010186.png" alt="image.png"><br><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/cd5b4d5a-fbaa-40da-a156-898c3579bcc4_repeat_1700459538857__293361.png" alt="image.png"><br><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="http://oss.ripplesu.top/blog/Typora/7730d39f-a7da-4f6a-8719-b3014da70abb.png" alt="image.png"></p>
<h4 id="例2"><a href="#例2" class="headerlink" title="例2"></a>例2</h4><p><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/114fe841-c52b-42c3-a151-e06e7754517f_repeat_1700459396946__240115.png" alt="image.png"><br>驻留集：操作系统为进程分配的物理页框的集合（驻留在内存中）<br><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/4297c7c2-0ad2-4db1-a0e9-6241a7e3d4e1_repeat_1700459558415__931007.png" alt="image.png"></p>
<h1 id="单处理器调度"><a href="#单处理器调度" class="headerlink" title="单处理器调度"></a>单处理器调度</h1><h3 id="调度分类"><a href="#调度分类" class="headerlink" title="调度分类"></a>调度分类</h3><ul>
<li>长程调度<br><strong>决定哪一个程序可以进入到系统中被处理</strong>；<br>一个进程终止时可以执行该调度，选择某个程序加入到就绪队列或就绪&#x2F;挂起队列中，供短程调度或中程调度处理。</li>
<li>中程调度<br><strong>对换功能（内存管理）</strong>。<br>目的是为了提高主存利用率和系统吞吐量。<br>为了充分发挥内存的效能，需将那些暂时不能运行的进程从内存调到外存盘交换区去等待，而将那些在盘交换区的等待事件已经发生急需调度运行的进程从盘交换区调入内存。<br>有时内存中进程数目过多也需将处于就绪态的进程从内存调到盘交换区，当然在盘交换区等待时间过长的就绪态的进程也要调入内存。 </li>
<li>短程调度<br>通常称为分派程序，决定将处理器分配给哪个就绪进程。执行得最频繁，是最基本的调度，任何操作系统都有短程调度&#x2F;进程调度。<br>可由以下事件激发：  <ul>
<li>时钟中断</li>
<li>I&#x2F;O 中断</li>
<li>操作系统调用</li>
<li>信号<br><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/571f18da-1c29-451a-ad2a-f7eb43264cfa_repeat_1700459404670__341102.png" alt="image.png"></li>
</ul>
</li>
</ul>
<h3 id="调度方式的选择准则"><a href="#调度方式的选择准则" class="headerlink" title="调度方式的选择准则"></a>调度方式的选择准则</h3><h4 id="面向用户-User-oriented-的准则和评价"><a href="#面向用户-User-oriented-的准则和评价" class="headerlink" title="面向用户(User-oriented)的准则和评价"></a>面向用户(User-oriented)的准则和评价</h4><ul>
<li>周转时间(Turnaround Time)短<br>它是评价批处理系统的重要性能指标。作业周转时间Ti是指从<strong>作业提交给系统开始，到作业完成为止的这段时间间隔</strong>。<br><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/e4570ac3-76eb-454e-9ebc-86c38d76c78c_repeat_1700459407877__243925.png" alt="image.png"></li>
<li>响应时间(Response Time)快<br>响应时间是评价分时系统的性能指标。响应时间是从<strong>用户通过键盘提交一个请求开始，直至系统首次产生响应为止的时间</strong>。  </li>
<li>截止时间(Deadline)的保证<br>它是用来评价实时系统的重要指标，截止时间是某任务必须执行的最迟时间，或完成的最迟时间。</li>
<li>优先权(Enforcing Priorities)准则<br>在选择批处理、分时和实时系统的调度算法时，都可引用优先权准则，以便让那些紧急的作业（或事件），得到及时的处理。在要求较严格的场合，往往还需选择抢占调度方式，才能保证紧急作业得到及时的处理。</li>
</ul>
<h4 id="面向系统-System-oriented-的准则"><a href="#面向系统-System-oriented-的准则" class="headerlink" title="面向系统(System-oriented)的准则"></a>面向系统(System-oriented)的准则</h4><ul>
<li>达到系统设计目标<br>  系统的设计目标是选择算法的主要依据。例如批处理系统所追求的是充分发挥和提高计算机的效率，分时系统则侧重于保护用户的请求及时给予响应，实时系统所关心的是不要丢失实时信息并给予处理。</li>
<li>系统吞吐量(throughput)大<br>  这是用来评价批处理系统的重要指标。系统吞吐量是<strong>单位时间内完成的作业数</strong>，它与批处理作业的平均长度具有密切关系。</li>
<li>处理机利用率(Processor Utilization)高<br>  对于大中型多用户系统，由于CPU价格十分昂贵，所以处理机利用率成为衡量大、中型系统性能的十分重要指标，但对单用户微机或某些实时系统，该准则就不那么重要。</li>
<li>各类资源的平衡利用(Balancing Resources)<br>  在大中型系统中，有效地利用各类资源（包括CPU、外存、I&#x2F;O设备等）也是一个重要指标，对于微型机和某些实时系统，该准则也不重要。</li>
</ul>
<h3 id="调度策略"><a href="#调度策略" class="headerlink" title="调度策略"></a>调度策略</h3><ul>
<li>选择函数决定在就绪进程中选择哪一个进程分配处理机执行。可基于优先级、资源需求或进程的执行特性选择。  <ul>
<li>w&#x3D;等待的时间  </li>
<li>e&#x3D;到目前为止，花费的执行时间  </li>
<li>s&#x3D;进程所需的总服务时间，包括e</li>
</ul>
</li>
<li>决策模式说明选择函数在被执行的瞬间的处理方式  <ul>
<li>非抢占：进程一旦运行则不断执行直到终止或自己阻塞自己  </li>
<li>抢占：操作系统可打断正在执行的进程将其转移到就绪态</li>
</ul>
</li>
</ul>
<h4 id="先来先服务-First-Come-First-Served-FCFS"><a href="#先来先服务-First-Come-First-Served-FCFS" class="headerlink" title="先来先服务 (First-Come-First-Served, FCFS)"></a>先来先服务 (First-Come-First-Served, FCFS)</h4><p>当前正在运行的进程停止执行时，选择在<strong>就绪队列中存在时间最长</strong>的进程运行。</p>
<ul>
<li>非抢占模式</li>
<li>选择函数为max(w)</li>
<li>特点<ul>
<li>算法易于实现，表面上很公平</li>
<li>有利于长进程，对短进程不利，短进程可能需要等待较长时间才能运行</li>
<li>有利于受CPU限制的进程，不利于受I&#x2F;O限制的进程</li>
<li>I&#x2F;O限制的进程会经常阻塞在I&#x2F;O事件上，因此需要等待较长的时间</li>
<li>可与优先级调度算法相结合</li>
<li>缺点：平均周转时间长</li>
</ul>
</li>
</ul>
<h4 id="时间片轮转-Round-Robin-RR"><a href="#时间片轮转-Round-Robin-RR" class="headerlink" title="时间片轮转 (Round-Robin, RR)"></a>时间片轮转 (Round-Robin, RR)</h4><p>总是选择<strong>就绪队列中第一个进程</strong>，允许其占有处理机一个时间片的时间。当执行的时间片用完时，调度程序便停止该进程的执行，并将它送到就绪队列的末尾，等待分配下一时间片再执行。然后把处理机分配给就绪队列中新的队首进程，同时也让它执行一个时间片。</p>
<ul>
<li>采用基于时间片的<strong>抢占</strong>模式</li>
<li>周期性地发生时钟中断，使操作系统获得控制权</li>
<li>每次就绪进程的选择都基于FCFS策略</li>
<li>时间片的大小决定了每个进程每次所能占用处理器的时间，其值对性能有影响。<ul>
<li>如果时间片太大，大到每个进程都能在该时间片内执行完毕，则RR算法已退化为FCFS调度算法</li>
<li>如果时间片过小，在一个时间片内切换开销相对增加，一个进程要花费更多的时间片才能运行结束，一个进程在系统中的周转时间大大增长。</li>
</ul>
</li>
</ul>
<h4 id="最短进程优先-Shortest-Process-Next-，SPN"><a href="#最短进程优先-Shortest-Process-Next-，SPN" class="headerlink" title="最短进程优先(Shortest Process Next ，SPN)"></a>最短进程优先(Shortest Process Next ，SPN)</h4><p>在就绪队列中选择<strong>所需服务时间最短</strong>的进程。</p>
<ul>
<li>非抢占模式</li>
<li>选择函数为min(s)</li>
<li>有利于短进程，对长进程不利<ul>
<li>短进程将越过长进程，跳到就绪队列头被调度</li>
<li>如果不断地有短进程进入系统，长进程可能会饿死。这一算法有利于短作业，对长作业不利。</li>
</ul>
</li>
<li>需要估计每个进程的服务时间，如果估计不准确，系统可能终止该作业</li>
<li>有利于系统减少平均周转时间和平均带权周转时间</li>
</ul>
<h4 id="最短剩余时间优先-Shortest-Remaining-Time-SRT"><a href="#最短剩余时间优先-Shortest-Remaining-Time-SRT" class="headerlink" title="最短剩余时间优先(Shortest Remaining Time,SRT)"></a>最短剩余时间优先(Shortest Remaining Time,SRT)</h4><p>在就绪队列中选择运行<strong>所需剩余时间最短</strong>的进程。</p>
<ul>
<li>抢占模式</li>
<li>选择函数min(s-e) </li>
<li>需要估计服务时间</li>
<li>比SPN有更好的周转时间</li>
</ul>
<h4 id="最高响应比优先-Highest-Response-Ratio-Next，HRRN"><a href="#最高响应比优先-Highest-Response-Ratio-Next，HRRN" class="headerlink" title="最高响应比优先 (Highest Response Ratio Next，HRRN)"></a>最高响应比优先 (Highest Response Ratio Next，HRRN)</h4><p>在就绪队列中选择响应比最高的进程来调度。</p>
<ul>
<li>非抢占模式</li>
<li>选择函数max(R)&#x3D;<strong>max(1+w&#x2F;s)</strong></li>
<li>折中策略，综合考虑服务时间和等待时间</li>
</ul>
<h4 id="反馈（Feedback）"><a href="#反馈（Feedback）" class="headerlink" title="反馈（Feedback）"></a>反馈（Feedback）</h4><ul>
<li>原则：处罚运行时间较长的作业。  <ul>
<li>基于抢占原则（按时间片）并使用动态优先级机制</li>
<li>新进程进入RQ0，每当它被抢占，则降到下一个优先级队列中</li>
<li>优先级最低队列采用轮转法，其他队列采用FCFS机制</li>
</ul>
</li>
</ul>
<h4 id="例-4"><a href="#例-4" class="headerlink" title="例"></a>例</h4><p><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/a0092992-f73d-4d15-afb4-2d0f19d95a36_repeat_1700459411404__312987.png" alt="image.png"><br><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/b987e4e0-ac01-4136-9338-8ce6eb2ba03e_repeat_1700459565398__430447.png" alt="image.png"><br><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/44c412b2-ed38-4941-a7c7-526a71eee3be_repeat_1700459569009__117789.png" alt="image.png"></p>
<h1 id="IO管理和磁盘调度"><a href="#IO管理和磁盘调度" class="headerlink" title="IO管理和磁盘调度"></a>IO管理和磁盘调度</h1><h3 id="教学要求-2"><a href="#教学要求-2" class="headerlink" title="教学要求"></a>教学要求</h3><ul>
<li>了解设备的分类，熟悉设备管理的目标和功能。</li>
<li>熟悉<font color='blue'>程序I&#x2F;O方式、中断方式、DMA方式和通道方式四种I&#x2F;O的控制方式</font>。</li>
<li>熟悉<font color='blue'>I／O系统的目标—设备独立性的概念</font>；<font color='blue'>熟悉I／O软件分层结构的概念</font>。</li>
<li>熟悉<font color='blue'>缓冲的概念，熟悉单缓冲、双缓冲和多缓冲和缓冲池工作原理</font>。</li>
<li>了解磁盘结构、数据组织和磁盘的访问时间等磁盘性能，掌握<font color='orange'>磁盘调度算法</font>。</li>
<li>了解磁盘高速缓冲的原理。</li>
</ul>
<h3 id="IO设备分类"><a href="#IO设备分类" class="headerlink" title="IO设备分类"></a>IO设备分类</h3><ul>
<li>按传输速率分类<ul>
<li>低速设备</li>
<li>中速设备</li>
<li>高速设备</li>
</ul>
</li>
<li>按信息交换的单位分类<ul>
<li>块设备：以数据块为单位组织和传送数据</li>
<li>字符设备：以单个字符为单位</li>
</ul>
</li>
<li>按资源分配的角度分类<ul>
<li>独占设备</li>
<li>共享设备</li>
<li>虚拟设备</li>
</ul>
</li>
</ul>
<p>I&#x2F;O设备的差异性，使得系统难以找到一种统一且一致的方法管理I&#x2F;O设备。</p>
<h3 id="设备管理的目标和功能"><a href="#设备管理的目标和功能" class="headerlink" title="设备管理的目标和功能"></a>设备管理的目标和功能</h3><ul>
<li>目标<ul>
<li>提高设备利用率</li>
<li>为用户提供方便、统一的界面</li>
</ul>
</li>
<li>功能<ul>
<li>设备分配</li>
<li>缓冲区管理</li>
<li>实现物理IO设备的操作</li>
</ul>
</li>
</ul>
<h3 id="IO功能的组织"><a href="#IO功能的组织" class="headerlink" title="IO功能的组织"></a>IO功能的组织</h3><h4 id="控制方式"><a href="#控制方式" class="headerlink" title="控制方式"></a><font color='blue'>控制方式</font></h4><ul>
<li>程序控制I&#x2F;O (Programmed I&#x2F;O)<br>处理器给I&#x2F;O模块发送I&#x2F;O命令，进程进入忙等待，直到I&#x2F;O操作完成才可以继续执行</li>
<li>中断驱动I&#x2F;O (Interrupt-driven I&#x2F;O)<br>处理器发送I&#x2F;O命令，然后继续执行后续指令，当I&#x2F;O模块完成后，给处理器发送中断</li>
<li>直接存储器访问 (Direct Memory Access， DMA)<br>由DMA模块控制主存和I&#x2F;O模块之间的数据交换</li>
</ul>
<h4 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h4><ul>
<li>采用统一的方式处理所有的I&#x2F;O设备<br>隐藏物理I&#x2F;O设备的操作细节，而是提供了逻辑I&#x2F;O层，使用户进程和操作系统软件可以通过读、写、打开、关闭、锁定、解锁等一些通用的功能来看待所有的I&#x2F;O设备。</li>
<li>采用分层结构，它把软件组织成为一系列的层，低层参与隔离硬件特征，使其它部分软件不依赖硬件；而高层则参与向用户提供一个友好的、清晰而统一的接口。<br>I&#x2F;O软件一般共分四层：中断处理程序（调度和控制），设备驱动程序(设备I&#x2F;O)，与设备无关的操作系统软件（逻辑I&#x2F;O），以及用户级软件(指用户空间的I／O软件) 。</li>
</ul>
<h4 id="IO系统目标——设备独立性"><a href="#IO系统目标——设备独立性" class="headerlink" title="IO系统目标——设备独立性"></a><font color='blue'>IO系统目标——设备独立性</font></h4><ul>
<li>用户程序的设备独立性<br>用户程序不直接使用物理设备名（或设备的物理地址），而只使用逻辑设备名；而系统在实际执行时，将逻辑设备名转换为某个具体的物理设备名，实施I&#x2F;O操作。  </li>
<li>I&#x2F;O软件的设备独立性<br>除了直接与设备打交道的低层软件之外，其他部分的软件并不依赖于硬件。I&#x2F;O软件独立于设备，就可以提高设备管理软件的设计效率。</li>
<li>优点<ul>
<li>设备分配时的灵活性<br>当进程以逻辑设备名请求某类设备时，如果一台设备已经分配给其它进程或正在检修，此时系统可以将其它几台相同的空闲设备中的任一台分配给该进程。 </li>
<li>易于实现I&#x2F;O重定向<br>所谓I&#x2F;O重定向，指用于I&#x2F;O操作的设备可以更换，应用程序的输入、输出可以重定向，不必修改应用程序。</li>
</ul>
</li>
</ul>
<h3 id="IO缓冲"><a href="#IO缓冲" class="headerlink" title="IO缓冲"></a><font color='blue'>IO缓冲</font></h3><p>进程被阻塞，等待I&#x2F;O操作完成。速度不匹配的矛盾一直存在。<br>在I&#x2F;O操作期间，包含目标地址单元的页必须锁定在主存中，不能被换出。<br>为了解决低效的问题，往往采用事先读（输入请求发出前就开始执行输入传送）和延迟写（输出请求发出一段时间之后才开始执行输出传送）。缓冲区即用于存放这些临时数据。</p>
<h4 id="缓冲类型"><a href="#缓冲类型" class="headerlink" title="缓冲类型"></a>缓冲类型</h4><ul>
<li>硬件缓冲是指以专用的寄存器作为缓冲器。</li>
<li>软件缓冲是指在操作系统的管理下，在内存中划出若干个单元作为缓冲区。软件缓冲的好处是易于改变缓冲区的大小和数量，但占用了一部分内存空间。<br>根据缓冲区设置个数的多少，可分为<strong>单缓冲、双缓冲和多缓冲</strong>。根据缓冲区的从属关系，可以分为专用缓冲区和缓冲池。</li>
</ul>
<h5 id="单缓冲"><a href="#单缓冲" class="headerlink" title="单缓冲"></a>单缓冲</h5><p>为了提高 CPU和设备的并行操作程度，每当一个用户进程发出一个I&#x2F;O请求时，操作系统便在主存的系统区中为之分配一个缓冲区。<br>例如，CPU从磁盘上读-块数据进行计算要分三步:先从磁盘把一块数据读入到缓冲区中，然后由操作系统将缓冲区的数据传送到用户区，最后由CPU对这一块数据进行计算，这样处理一个数据时间为(T+M+C)。<br>当连续读入一组数据时，读入某数据的第一步(输入)和读入它前一个数据的最后一步(计算)是可以并行执行的，这样就提高了CPU和外设的利用率。由于对缓冲区中数据的输入和提取是串行工作的，连续处理一个数据时间&#x3D;<strong>max(C, T) +M</strong>。为使两者能并行工作，必须引入双缓冲。<br><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/dfded469-c980-4437-8f45-66eadbf1badd_repeat_1700459419751__866413.png" alt="image.png"></p>
<h5 id="双缓冲"><a href="#双缓冲" class="headerlink" title="双缓冲"></a>双缓冲</h5><p>在设备输入时，先将数据输入到缓冲区A，装满后便转向缓冲区B。此时操作系统可以从缓冲区A中提取数据传送到用户区，最后由CPU对数据进行计算。<br>这样可以实现对缓冲区中读入某数据的第一步（输入）和读入它前一个数据的后二步（传送和计算）二者的并行工作，连续处理一个数据时间&#x3D; **max(T，(M+C))**，特别是缓冲区中数据的输入和传送的速度基本相匹配时，可获得较好的效果。<br>双缓冲进一步加快了I&#x2F;O的速度，提高了设备的利用率。<br><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/169cbd2c-9c6f-405b-a3a4-6c9a80daa7b3_repeat_1700459575127__592982.png" alt="image.png"></p>
<h5 id="循环缓冲"><a href="#循环缓冲" class="headerlink" title="循环缓冲"></a>循环缓冲</h5><p>由于数据I&#x2F;O多数是间断的，可增加缓冲区的个数来改善CPU与I&#x2F;O设备间速度不匹配的矛盾。<br>将多个缓冲区组织成循环队列的形式，其中一些队列专门用于输入，另一些队列专门用于输出。<br>采用生产者&#x2F;消费者模型来解决。<br><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/eba57e27-bfb3-4cfd-bc4b-dc2afc0bb5e4_repeat_1700459424522__956275.png" alt="image.png"></p>
<h3 id="磁盘IO"><a href="#磁盘IO" class="headerlink" title="磁盘IO"></a>磁盘IO</h3><h4 id="磁盘结构"><a href="#磁盘结构" class="headerlink" title="磁盘结构"></a>磁盘结构</h4><p><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/f505e8ad-8447-47e0-b512-14749d220dac_repeat_1700459427625__651862.png" alt="image.png"></p>
<h4 id="数据组织"><a href="#数据组织" class="headerlink" title="数据组织"></a>数据组织</h4><p>磁盘设备中，一般包含一个或多个盘片，每片分两面，每面又可分成若干条<strong>磁道</strong>（即n个同心圆）。++最外边的磁道标为0道，最里面的磁道为 n-1道++。磁道的个数取决于盘的大小和存储的密度。每个磁道又被划分为若干个<strong>扇区</strong>，一般被划分成10～100个扇区。每一个扇区是磁盘存储信息和传送信息的基本单位（512字节），又称为存储块，或简称为块。<br>一个容量较大的硬盘含有若干个盘片，每一个盘片有上下两个盘面。如果硬盘中有4个盘片，则共有8个磁面。磁盘中处于相同磁道（同心圆）位置上，但在不同盘面上的磁道的集合，称为<strong>柱面</strong>。++柱面的序号与磁道的序号相同++。</p>
<h4 id="磁盘访问时间"><a href="#磁盘访问时间" class="headerlink" title="磁盘访问时间"></a>磁盘访问时间</h4><p>由于磁盘上的一个扇区要用三个参数（柱面号、磁头号和扇区号）来定位，所以对磁盘的访问时间，包括以下三部分的时间：</p>
<ul>
<li>寻道时间（ Seek time ）T<del>S</del><br>这是把磁头从当前位置移动到指定磁道上所经历的时间。该时间是启动磁盘的时间s与磁头移动n条磁道所花费的时间之和。即 T<del>S</del>＝m×n+s <ul>
<li>m是一个常数，它与磁盘驱动器的速度有关。对一般磁盘而言，m&#x3D;0.3；对高速磁盘而言，m≤0.1，磁盘启动时间约为3ms。</li>
<li>这样，对一般的硬盘，其寻道时间将随寻道距离的增大而增大。</li>
</ul>
</li>
<li>旋转延迟时间（ Rotational delay or rotational latency ）T<del>r</del><br>指定扇区移动到磁头下所经历的时间。</li>
<li>传输时间T<del>t</del><br>T<del>t</del> 是指把数据从磁盘读出，或向磁盘写入数据所经历的时间，它的大小与每次所读／写的字节数b及旋转速度r(&#x2F;秒)有关：T<del>t</del> &#x3D;b&#x2F;(r*N)(N为一条磁道上字节数)。</li>
</ul>
<p>磁盘访问时间： Ta&#x3D; TS+ Tr+ Tt&#x3D; TS + 1&#x2F;2r+ b&#x2F;rN</p>
<h4 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a><font color='orange'>磁盘调度算法</font></h4><h5 id="先来先服务FCFS"><a href="#先来先服务FCFS" class="headerlink" title="先来先服务FCFS"></a>先来先服务FCFS</h5><p>先来先服务FCFS（First Come First Served）是一种最简单的磁盘调度算法。它根据进程请求访问磁盘的先后次序进行调度。  </p>
<ul>
<li>优点是公平、简单，且每个进程的请求都能依次得到处理，不会出现某一进程的请求长期得不到满足的情况。</li>
<li>缺点是算法未对寻道进行优化，致使平均寻道时间可能较长（平均响应时间长）。<br><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/815549c8-2f58-44df-8262-8119c46e6976_repeat_1700459430637__807237.png" alt="image.png"></li>
</ul>
<h5 id="最短寻道时间优先（SSTF）"><a href="#最短寻道时间优先（SSTF）" class="headerlink" title="最短寻道时间优先（SSTF）"></a>最短寻道时间优先（SSTF）</h5><p>该算法总是满足那些<strong>与当前磁头所在的磁道距离最近</strong>的请求,也就是执行寻道时间最短的那个I&#x2F;O请求。  </p>
<ul>
<li>这种调度算法有较好的平均寻道时间。但它可能导致某些进程长时间的得不到服务（饥饿现象）。因为只要不断有新进程到达，且其所要访问的磁道与磁头当前所在磁道的距离较近，这种新进程的I&#x2F;O请求必被优先满足。</li>
<li>对中间磁道访问服务比内、外两侧磁道服务好，造成响应时间变化幅度大,在服务请求多时，内外边缘请求被无限期延迟，不可预期。<br><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/41fdb9bc-6d81-49c8-b252-7c63b86bf068_repeat_1700459434283__269597.png" alt="image.png"></li>
</ul>
<h5 id="扫描（SCAN）算法"><a href="#扫描（SCAN）算法" class="headerlink" title="扫描（SCAN）算法"></a>扫描（SCAN）算法</h5><p>为了解决SSTF算法饥饿现象，对SSTF算法略加修改后所形成了SCAN算法。  </p>
<ul>
<li>该算法不仅考虑到欲访问的磁道与当前磁道的距离，更优先考虑的是磁头的当前移动方向。即当磁头正在自里向外运动时，SCAN算法要选择的下一个访问对象是其欲访问的磁道在<strong>当前磁道之外，又是距离最近的。直至再无更外的磁道需要访问时，才将磁臂换向，自外向里运动</strong>。从而避免了饥饿现象的出现。由于这种算法中磁头移动的规律象电梯的运行，所以又称为电梯调度算法。</li>
<li>克服SSTF服务集中中间磁道和响应时间变化较大缺点，两侧磁道的访问的频率低于中间磁道。<br><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/9106b34a-182a-4e1c-9d06-a1ac1bd963a1_repeat_1700459437260__843119.png" alt="image.png"></li>
</ul>
<h5 id="循环扫描（CSCAN）"><a href="#循环扫描（CSCAN）" class="headerlink" title="循环扫描（CSCAN）"></a>循环扫描（CSCAN）</h5><p>CSCAN算法规定磁头只能<strong>单向运动</strong>（自里向外或自外向里），<strong>当磁头运动到最外面的被访问磁道时，磁头立即返回到最里面的欲访的磁道</strong>，即将最小磁道号紧接着最大磁道号构成循环，进行扫描。<br><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/6ee4a6d7-99c3-40d9-929c-4d81163d9242_repeat_1700459581502__197731.png" alt="image.png"></p>
<h5 id="算法比较"><a href="#算法比较" class="headerlink" title="算法比较"></a>算法比较</h5><p><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/c6ff42af-7a63-40c9-ab22-a6c7d24e97d2_repeat_1700459441062__990194.png" alt="image.png"></p>
<h1 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h1><h3 id="教学要求-3"><a href="#教学要求-3" class="headerlink" title="教学要求"></a>教学要求</h3><ul>
<li>掌握<font color='orange'>文件和文件系统的定义</font>，了解文件系统的类型、文件系统模型。</li>
<li>掌握<font color='orange'>文件的逻辑结构</font>，熟悉<font color='blue'>五种记录文件</font>。</li>
<li>掌握<font color='orange'>文件的物理结构及连续分配、链接分配、索引分配等外存分配方法</font>。</li>
<li>了解磁盘组织，掌握空闲表、位示图法、空闲块链接法等空闲存储空间的管理方法。</li>
</ul>
<h3 id="文件与文件系统"><a href="#文件与文件系统" class="headerlink" title="文件与文件系统"></a><font color='orange'>文件与文件系统</font></h3><h4 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h4><p>文件是存储在某种介质上的（如磁盘、磁带等）并<strong>具有文件名的一组有序信息的集合</strong>。</p>
<ul>
<li>域&#x2F;数据项（field）<br>数据项是描述一个对象的某些属性的字符集，它是数据的基本单位，一个数据项有一个值。</li>
<li>记录（record）<br>记录是一组相关数据项的集合，用于描述一个对象某方面的属性</li>
</ul>
<h4 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h4><p>文件系统是操作系统中以文件方式管理计算机软件资源的软件和被管理的文件和数据结构（如目录和索引表等）的集合。<br>从系统角度来看，文件系统是对文件存储器的存储空间进行组织、分配和回收，负责文件的存储、检索、共享和保护。<br>从用户角度来看，文件系统主要是实现“按名存取”，文件系统的用户只要知道所需文件的文件名，就可存取文件中的信息，而无需知道这些文件究竟存放在什么地方。 </p>
<h3 id="文件组织"><a href="#文件组织" class="headerlink" title="文件组织"></a><font color='orange'>文件组织</font></h3><ul>
<li>文件的逻辑组织和物理组织  <ul>
<li>逻辑组织指文件中记录的逻辑结构（用户可见结构），由用户访问记录的方式确定。</li>
<li>物理组织指文件在外存上的存储组织形式，通常取决于记录组块策略和文件分配策略。</li>
</ul>
</li>
<li>逻辑组织从结构上分成二种形式，一种是无结构的<strong>流式文件</strong>，另一种是有结构的<strong>记录式文件</strong>。流式文件是指对文件内信息不再划分单位，它是依次的一串字符流构成的文件。记录式文件是用户把文件内的信息按逻辑上独立的含义划分信息单位，每个单位称为一个逻辑记录（简称记录）。记录的长度可分为定长和不定长两类。</li>
</ul>
<h4 id="文件组织类型"><a href="#文件组织类型" class="headerlink" title="文件组织类型"></a><font color='blue'>文件组织类型</font></h4><h5 id="堆（pile）"><a href="#堆（pile）" class="headerlink" title="堆（pile）"></a>堆（pile）</h5><ul>
<li>最简单的文件组织形式。</li>
<li>数据按先来后到的次序组织，每个记录由一串数据组成，是串结构的顺序文件。</li>
<li>每个记录所包含的数据项是自我标识的，记录可以有不同的数据项。数据项的长度可以明确指定或使用界定符区分。</li>
<li>在堆文件中访问所需要的记录需穷举搜索。</li>
<li>目的是积累大量数据并保存，不适合大多数应用。</li>
</ul>
<h5 id="顺序文件-sequential-file"><a href="#顺序文件-sequential-file" class="headerlink" title="顺序文件 (sequential file)"></a>顺序文件 (sequential file)</h5><ul>
<li>最常用的文件组织形式。</li>
<li>记录采用固定格式，所有记录具有相同长度，并且由相同数目、长度固定的数据项按特定的顺序组成。</li>
<li>一般还有一个可以唯一标识记录的数据项，称为键（key），记录按键值的约定次序组织。</li>
<li>顺序文件常用于批处理应用，适用于对所有记录的处理，对于查询或更新某个记录的请求的处理性能不佳（需要遍历）。</li>
</ul>
<h5 id="索引顺序文件-indexed-sequential-file"><a href="#索引顺序文件-indexed-sequential-file" class="headerlink" title="索引顺序文件 (indexed sequential file)"></a>索引顺序文件 (indexed sequential file)</h5><ul>
<li>保留了顺序文件的关键特征：记录按照关键域的顺序组织。</li>
<li>两个新特征：<ul>
<li>支持随机访问的文件索引</li>
<li>溢出文件</li>
</ul>
</li>
<li>索引文件中建立一张索引表，为每个不同键值的记录组的第一个记录设置一个表项（关键域和指向主文件的指针），为该组的其它记录设置了溢出区域，在溢出区域内记录按顺序文件方式组织。<br>查找时先搜索索引，查找关键域值等于目标关键域值或位于目标关键域值之前且最大的索引然后在该索引的指针所指的主文件中的位置开始搜索</li>
<li>索引顺序文件既适用于交互方式应用，也适用于批处理方式应用。<br><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/07614a88-bcd2-4874-84a3-d751624697e0_repeat_1700459443994__377601.png" alt="image.png"><br><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/8e4f713f-6fa8-4e5e-a83a-297c9d039209_repeat_1700459586529__482152.png" alt="image.png"></li>
</ul>
<h5 id="索引文件-indexed-file"><a href="#索引文件-indexed-file" class="headerlink" title="索引文件 (indexed file)"></a>索引文件 (indexed file)</h5><ul>
<li>可基于多个数据项建立索引<ul>
<li>完全索引：包含主文件中每条记录的索引项</li>
<li>部分索引：包含部分记录的索引项</li>
</ul>
</li>
<li>记录可为不定长的，只通过索引访问记录，不再限制记录的放置位置</li>
<li>为了易于搜索，索引文件本身是顺序文件组织</li>
<li>当主文件中增加了一条新记录，索引文件必须全部更新</li>
<li>常用于实时处理环境中</li>
</ul>
<h5 id="直接或散列文件-direct-or-hashed-file"><a href="#直接或散列文件-direct-or-hashed-file" class="headerlink" title="直接或散列文件 (direct, or hashed, file)"></a>直接或散列文件 (direct, or hashed, file)</h5><ul>
<li>检索时给出记录编号（关键域），通过哈希函数（散列函数）计算出该记录在文件中的相对位置。</li>
<li>可以对记录在直接访问存储设备上的物理地址直接（随机）访问。</li>
<li>使用固定长度的记录格式，每次只访问一条记录。</li>
<li>常用于需要高速访问文件且每次访问一条记录的应用中。</li>
</ul>
<h3 id="记录组块"><a href="#记录组块" class="headerlink" title="记录组块"></a><font color='orange'>记录组块</font></h3><h4 id="固定组块-Fixed-blocking"><a href="#固定组块-Fixed-blocking" class="headerlink" title="固定组块 (Fixed blocking)"></a>固定组块 (Fixed blocking)</h4><ul>
<li>记录长度固定；</li>
<li>若干条完整的记录被保存在一个块中；</li>
<li>存在内部碎片。<br><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/a5fc242d-b77f-4e99-86fe-7eb68179dcec_repeat_1700459449072__192308.png" alt="image.png"></li>
</ul>
<h4 id="可变长度跨越式组块-Variable-length-spanned-blocking"><a href="#可变长度跨越式组块-Variable-length-spanned-blocking" class="headerlink" title="可变长度跨越式组块 (Variable-length spanned blocking)"></a>可变长度跨越式组块 (Variable-length spanned blocking)</h4><ul>
<li>记录长度可变</li>
<li>紧缩在块中，解决了内部碎片问题 </li>
<li>某些记录可能跨两个块，通过指针指向后继块<br><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/e2c417ad-cc00-44ac-9d5f-748199f74cac_repeat_1700459591144__240587.png" alt="image.png"></li>
</ul>
<h4 id="可变长度非跨越式组块-Variable-length-unspanned-blocking"><a href="#可变长度非跨越式组块-Variable-length-unspanned-blocking" class="headerlink" title="可变长度非跨越式组块 (Variable-length unspanned blocking)"></a>可变长度非跨越式组块 (Variable-length unspanned blocking)</h4><ul>
<li>记录长度可变</li>
<li>记录不跨块，存在内部碎片问题<br><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/56ff45ee-be55-4407-8589-c14e1a0caff6_repeat_1700459452587__791917.png" alt="image.png"></li>
</ul>
<h4 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h4><ul>
<li>固定组块是记录长度固定的顺序文件最常用的格式</li>
<li>可变长度跨越式组块存储效率高，但难于实现</li>
<li>可变长度非跨越式组块会导致空间的浪费，并且记录大小受块大小限制</li>
</ul>
<h3 id="文件分配"><a href="#文件分配" class="headerlink" title="文件分配"></a><font color='orange'>文件分配</font></h3><ul>
<li>预分配要求在发出创建文件请求时声明该文件的最大大小<ul>
<li>文件大小难以估计，通常都会多估一点，从而导致空间浪费问题</li>
</ul>
</li>
<li>动态分配只有在需要时才给文件分配空间</li>
</ul>
<h4 id="连续分配（Contiguous-allocation）"><a href="#连续分配（Contiguous-allocation）" class="headerlink" title="连续分配（Contiguous allocation）"></a>连续分配（Contiguous allocation）</h4><ul>
<li>创建文件时，给文件分配一组连续的块</li>
<li>预分配策略，分区大小可变</li>
<li>文件分配表FAT中每个文件只需要一个表项：起始块和文件长度</li>
<li>存在外部碎片，需定期执行压缩技术<br><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/dfe8ce42-2ccf-4e7e-8fa3-3702f6a1fa4c_repeat_1700459458454__214221.png" alt="image.png"></li>
</ul>
<h4 id="链式分配"><a href="#链式分配" class="headerlink" title="链式分配"></a>链式分配</h4><ul>
<li>基于单个块进行分配，链中每一块都包含指向下一块的指针</li>
<li>动态分配：按需进行块分配</li>
<li>FAT表中每个文件一个表项：起始块和文件长度</li>
<li>优点是盘存储空间利用率高，文件增删改记录方便，不存在外部碎片</li>
<li>局部性原理不再适用，可周期性地对文件进行合并<br><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/eec36d3b-1676-4be4-9e79-30d3efe8d6a4_repeat_1700459464367__923883.png" alt="image.png"><br><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/0dbaaf48-b076-499b-bd83-a3f1a87e591a_repeat_1700459461916__163047.png" alt="image.png"></li>
</ul>
<h4 id="索引分配"><a href="#索引分配" class="headerlink" title="索引分配"></a>索引分配</h4><ul>
<li>文件分配表FAT中对每个文件都包含一个一级索引</li>
<li>文件索引保存在单独块中，在FAT的表项里指向这一块的值</li>
<li>分配可基于固定大小的块，也可基于可变大小的分区</li>
<li>索引块中包括指向文件所有块的指针或指向分区起始块的指针</li>
<li>支持顺序访问文件和直接访问文件，是最普遍的一种文件分配形式<br><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/f48ce965-95b1-42be-b187-89417f80031b_repeat_1700459467753__246435_repeat_1700459469416__739465.png" alt="image.png"><br><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/f50ec86f-d7c4-4ae9-bbdb-7ebbaf64bc44_repeat_1700459597523__113748.png" alt="image.png"></li>
</ul>
<h3 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h3><h4 id="1"><a href="#1" class="headerlink" title="1"></a>1</h4><p>文件系统空间的最大容量为4GB，以磁盘块为分配单位。磁盘块大小为4KB。文件控制块FCB包含一个1KB的索引表区。<br>假设索引表区仅采用直接索引结构，索引表区存放文件占用的磁盘块号，索引表项中块号最少占多少字节？可支持的单个文件的最大长度是多少字节？  </p>
<p>答：<br>磁盘个数：4GB&#x2F;4KB&#x3D;220个，因此索引表项中块号需要20位，共占20&#x2F;8&#x3D;3B<br>索引表区大小为1KB，故包含1KB&#x2F;3B&#x3D;342个索引项<br>单个文件的最大长度是342*4KB&#x3D;1368KB</p>
<h4 id="2"><a href="#2" class="headerlink" title="2"></a>2</h4><p>请分别解释在连续分配方式、隐式链接分配方式、显式链接分配方式和索引分配方式中如何将文件的字节偏移量3500转换为物理块号和块内位移量（设盘块大小为1KB，盘块号需4个字节。）<br>提示：先将字节偏移量转换成逻辑块号和块内位移量。  </p>
<p>答：<br><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/48208609-3e5b-415d-8177-51c69f110968_repeat_1700459472479__479126_repeat_1700459474305__424436.png" alt="image.png"><br><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/9336f4a4-b3b7-47a2-8fc4-40c37c4066b3_repeat_1700459602416__758791.png" alt="image.png"></p>
<h4 id="3"><a href="#3" class="headerlink" title="3"></a>3</h4><p>存放在某个磁盘上的文件系统，采用混合索引分配方式，其FCB中共有13个地址项，第0~9个地址项为直接地址，第10个地址项为一次间接地址，第11个地址项为二次间接地址，第12个地址项三次间接地址。如果每个盘块的大小512字节，若盘块号需要用3个字节来描述，而每个盘块最多存放170个盘块地址。  </p>
<ul>
<li>该文件系统允许文件的最大长度是多少？</li>
<li>将文件的字节偏移量5000，15000，150000转换为物理块号和块内偏移量。</li>
<li>假设某个文件FCB已在内存，但其他信息均在外存，为了访问该文件中某个位置的内容，最少需要几次访问磁盘，最多需要几次访问磁盘？</li>
</ul>
<p>答：  </p>
<ol>
<li>盘块数：10+170+170×170+170×170×170&#x3D;4942080（块）<br> 4942080×512&#x3D;2471040KB  </li>
<li>5000&#x2F;512&#x3D;9……392  由于9&lt;10，可直接从FCB的第9个地址项得到物理盘块号，块内偏移量为392。<br>15000&#x2F;512&#x3D;29……152，由于10&lt;&#x3D;29&lt;10+170,而29-10&#x3D;19，故可从FCB的第10个地址项获得一次间址块的盘块号，并从一次间址块的第19项获得对应的物理盘块号，块内偏移量为152。<br>150000&#x2F;512&#x3D;292……496，10+170&lt;&#x3D;292&lt;10+170+170×170<br>292-（10+170）&#x3D;112<br>112&#x2F;170&#x3D;0……112<br>从FCB的第11个地址项，即二次间址项中得到二次间址块的地址，并从二次间址块的第0项中获得一个一次间址块的地址，再从一次间址块的第112项中获得对应的物理盘块号，块内偏移量为496。  </li>
<li>文件FCB已在内存，要访问该文件中某个位置的内容，最少需要1次访问磁盘（通过直接地址直接读文件盘块），最多需要4次访问磁盘（第一次读三次间址块，第二次读二次间址块，第三次读一次间址块，第四次读文件盘块。）</li>
</ol>
<h4 id="4"><a href="#4" class="headerlink" title="4"></a>4</h4><p>文件F由200条记录组成，记录从1开始编号。用户打开文件后，欲将内存中的一条记录插入文件F中，作为其第30条记录。请回答下列问题，并说明理由。</p>
<ul>
<li>若文件系统采用连续分配方式，每个磁盘块存放一条记录，文件F存储区域前后均有足够的空闲磁盘空间，则完成上述插入操作最少需要访问多少次磁盘块？F的文件控制块内容会发生哪些改变？</li>
<li>若文件系统采用链接分配方式，每个磁盘块存放一条记录和一个链接指针，则完成上述插入操作需要访问多少次磁盘块？</li>
</ul>
<p>答：<br>1）文件系统采用连续分配方式，插入记录需要移动其他的记录块，整个文件共有200条记录，要插入新记录作为第30条，则需要把前29条记录前移，访盘次数为29*2&#x3D;58次（一次读，一次写回），存回第30条记录，需要1次访盘，共访盘59次。<br>2）文件系统采用链接分配方式，插入记录不需要移动其他记录块，只需要通过指针找到第30条记录插入的位置，故共需访盘次数为29次，存第30条记录，需要1次访盘，再修改第29条记录的下块地址，需要1次访盘。因此，访盘总次数为29+1+1&#x3D;31次。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://blog.ripplesu.top">RippleSu</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://blog.ripplesu.top/2023/02/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/">http://blog.ripplesu.top/2023/02/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://blog.ripplesu.top" target="_blank">RippleSu's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></div><div class="post_share"><div class="social-share" data-image="http://img.ripplesu.top/random?dir=cover&amp;操作系统期末复习&amp;type=cover" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/02/20/%E7%AE%97%E6%B3%95/" title="算法"><img class="cover" src="http://oss.ripplesu.top/blog/loading.gif" data-original="http://img.ripplesu.top/random?dir=cover&amp;算法&amp;type=cover" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">算法</div></div></a></div><div class="next-post pull-right"><a href="/2023/02/07/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%A4%8D%E4%B9%A0/" title="软件工程复习"><img class="cover" src="http://oss.ripplesu.top/blog/loading.gif" data-original="http://img.ripplesu.top/random?dir=cover&amp;软件工程复习&amp;type=cover" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">软件工程复习</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/02/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1-pintos/" title="操作系统课程设计-pintos"><img class="cover" src="http://oss.ripplesu.top/blog/loading.gif" data-original="http://img.ripplesu.top/random?dir=cover&操作系统课程设计-pintos&type=cover" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-23</div><div class="title">操作系统课程设计-pintos</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div class="comment-switch"><span class="first-comment">Valine</span><span id="switch-btn"></span><span class="second-comment">Disqus</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div><div><div id="disqus_thread"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="http://121.41.55.70:9000/image-lib/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">RippleSu</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">14</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">16</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/S-Lucien" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:syp@ripplesu.top" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Welcome to my Blog!</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">操作系统概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%99%E5%AD%A6%E7%9B%AE%E7%9A%84"><span class="toc-number">1.1.</span> <span class="toc-text">教学目的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">1.2.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81"><span class="toc-number">1.3.</span> <span class="toc-text">基本特征</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%91%E5%B1%95"><span class="toc-number">1.4.</span> <span class="toc-text">发展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%B2%E8%A1%8C%E5%A4%84%E7%90%86%EF%BC%88%E6%97%A0%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%89"><span class="toc-number">1.4.1.</span> <span class="toc-text">串行处理（无操作系统）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%B9%E5%A4%84%E7%90%86"><span class="toc-number">1.4.2.</span> <span class="toc-text">批处理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E6%89%B9%E5%A4%84%E7%90%86"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">简单批处理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">多道程序设计</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%97%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.4.3.</span> <span class="toc-text">分时系统</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E6%97%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.4.4.</span> <span class="toc-text">实时系统</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B"><span class="toc-number"></span> <span class="toc-text">进程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8F%8F%E8%BF%B0%E4%B8%8E%E6%8E%A7%E5%88%B6"><span class="toc-number">1.</span> <span class="toc-text">进程描述与控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%BC%95%E5%85%A5%E7%9A%84%E5%BF%85%E8%A6%81%E6%80%A7"><span class="toc-number">1.1.</span> <span class="toc-text">进程引入的必要性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E7%89%B9%E5%BE%81"><span class="toc-number">1.2.</span> <span class="toc-text">进程的定义和特征</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-1"><span class="toc-number">1.2.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E5%BE%81"><span class="toc-number">1.2.2.</span> <span class="toc-text">特征</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97PCB%E2%80%94%E2%80%94%E8%BF%9B%E7%A8%8B%E5%AD%98%E5%9C%A8%E7%9A%84%E5%94%AF%E4%B8%80%E5%AE%9E%E4%BD%93"><span class="toc-number">1.3.</span> <span class="toc-text">进程控制块PCB——进程存在的唯一实体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E7%8A%B6%E6%80%81%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.4.</span> <span class="toc-text">五状态模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.4.1.</span> <span class="toc-text">状态转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%82%E8%B5%B7%E6%80%81"><span class="toc-number">1.4.2.</span> <span class="toc-text">挂起态</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-number">1.5.</span> <span class="toc-text">进程控制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E4%B8%AA%E9%97%AE%E9%A2%98"><span class="toc-number">1.5.1.</span> <span class="toc-text">三个问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA"><span class="toc-number">1.5.2.</span> <span class="toc-text">进程创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2"><span class="toc-number">1.5.3.</span> <span class="toc-text">进程切换</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text">线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8D%95%E4%BD%8D"><span class="toc-number">2.1.</span> <span class="toc-text">并发进程的基本单位</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.2.</span> <span class="toc-text">多线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E6%88%90"><span class="toc-number">2.3.</span> <span class="toc-text">组成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E5%85%A5%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-number">2.4.</span> <span class="toc-text">引入线程的好处</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%89%B9%E6%80%A7"><span class="toc-number">2.5.</span> <span class="toc-text">线程特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">2.6.</span> <span class="toc-text">两种实现方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E7%BA%A7%E7%BA%BF%E7%A8%8B%EF%BC%88ULTs%EF%BC%89"><span class="toc-number">2.6.1.</span> <span class="toc-text">用户级线程（ULTs）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E7%BA%A7%E7%BA%BF%E7%A8%8B%EF%BC%88KLTs%EF%BC%89"><span class="toc-number">2.6.2.</span> <span class="toc-text">内核级线程（KLTs）</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%EF%BC%9A%E4%BA%92%E6%96%A5%E4%B8%8E%E5%90%8C%E6%AD%A5"><span class="toc-number"></span> <span class="toc-text">并发：互斥与同步</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E5%88%B6%E7%BA%A6%E5%85%B3%E7%B3%BB"><span class="toc-number">0.1.</span> <span class="toc-text">并发进程间的制约关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E6%9C%AF%E8%AF%AD"><span class="toc-number">0.2.</span> <span class="toc-text">相关术语</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6"><span class="toc-number">0.3.</span> <span class="toc-text">进程同步机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E7%9A%84%E4%B8%89%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"><span class="toc-number">0.4.</span> <span class="toc-text">互斥的三种实现方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6"><span class="toc-number">0.5.</span> <span class="toc-text">信号量机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">0.5.1.</span> <span class="toc-text">信号量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%85%83%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">0.5.2.</span> <span class="toc-text">二元信号量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">0.5.3.</span> <span class="toc-text">信号量的类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5"><span class="toc-number">0.5.4.</span> <span class="toc-text">使用信号量机制实现进程互斥</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="toc-number">0.5.5.</span> <span class="toc-text">使用信号量机制实现进程同步</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E7%9A%84%E7%89%A9%E7%90%86%E6%84%8F%E4%B9%89"><span class="toc-number">0.5.5.1.</span> <span class="toc-text">同步的物理意义</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6%E6%8F%8F%E8%BF%B0%E5%89%8D%E9%A9%B1%E5%85%B3%E7%B3%BB"><span class="toc-number">0.5.6.</span> <span class="toc-text">利用信号量机制描述前驱关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%8F%E5%85%B8%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98"><span class="toc-number">0.5.7.</span> <span class="toc-text">经典进程同步问题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-number">0.5.7.1.</span> <span class="toc-text">生产者&#x2F;消费者问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%BB%E8%80%85-%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-number">0.5.7.2.</span> <span class="toc-text">读者&#x2F;写者问题</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93"><span class="toc-number">0.5.8.</span> <span class="toc-text">进程操作总结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B"><span class="toc-number">0.5.9.</span> <span class="toc-text">例</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%EF%BC%9A%E6%AD%BB%E9%94%81%E4%B8%8E%E9%A5%A5%E9%A5%BF"><span class="toc-number"></span> <span class="toc-text">并发：死锁与饥饿</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-number">0.1.</span> <span class="toc-text">死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%A7%E7%94%9F%E6%AD%BB%E9%94%81%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">0.1.1.</span> <span class="toc-text">产生死锁的原因</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E6%9D%A1%E4%BB%B6"><span class="toc-number">0.1.2.</span> <span class="toc-text">死锁的条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95"><span class="toc-number">0.1.3.</span> <span class="toc-text">死锁的解决办法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E9%A2%84%E9%98%B2"><span class="toc-number">0.1.4.</span> <span class="toc-text">死锁的预防</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E9%81%BF%E5%85%8D%EF%BC%88Avoidance%EF%BC%89"><span class="toc-number">0.1.5.</span> <span class="toc-text">死锁的避免（Avoidance）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94Dijkstra"><span class="toc-number">0.1.5.1.</span> <span class="toc-text">银行家算法——Dijkstra</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BE%8B-1"><span class="toc-number">0.1.5.2.</span> <span class="toc-text">例</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E6%A3%80%E6%B5%8B%EF%BC%88Detection%EF%BC%89%E5%92%8C%E8%A7%A3%E9%99%A4"><span class="toc-number">0.1.6.</span> <span class="toc-text">死锁的检测（Detection）和解除 </span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number"></span> <span class="toc-text">内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%99%E5%AD%A6%E8%A6%81%E6%B1%82"><span class="toc-number">0.1.</span> <span class="toc-text">教学要求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%AE%E7%9A%84%E5%92%8C%E5%8A%9F%E8%83%BD"><span class="toc-number">0.2.</span> <span class="toc-text">目的和功能</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%AE%E7%9A%84"><span class="toc-number">0.2.1.</span> <span class="toc-text">目的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD"><span class="toc-number">0.2.2.</span> <span class="toc-text">功能</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E9%87%8D%E5%AE%9A%E4%BD%8D"><span class="toc-number">0.3.</span> <span class="toc-text">地址重定位</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA"><span class="toc-number">0.4.</span> <span class="toc-text">内存分区</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BA%E5%AE%9A%E5%88%86%E5%8C%BA"><span class="toc-number">0.4.1.</span> <span class="toc-text">固定分区</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%97%AE%E9%A2%98"><span class="toc-number">0.4.1.1.</span> <span class="toc-text">问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%94%BE%E7%BD%AE%E7%AE%97%E6%B3%95"><span class="toc-number">0.4.1.2.</span> <span class="toc-text">放置算法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA"><span class="toc-number">0.4.2.</span> <span class="toc-text">动态分区</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95"><span class="toc-number">0.4.2.1.</span> <span class="toc-text">分配算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95"><span class="toc-number">0.4.2.2.</span> <span class="toc-text">回收算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%99%E4%BC%B4%E7%B3%BB%E7%BB%9F"><span class="toc-number">0.4.2.3.</span> <span class="toc-text">伙伴系统</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">0.5.</span> <span class="toc-text">分页存储管理方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B5%E8%A1%A8"><span class="toc-number">0.5.1.</span> <span class="toc-text">页表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84"><span class="toc-number">0.5.2.</span> <span class="toc-text">地址结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2"><span class="toc-number">0.5.3.</span> <span class="toc-text">地址变换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%AE%B5"><span class="toc-number">0.6.</span> <span class="toc-text">分段</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AE%B5%E8%A1%A8"><span class="toc-number">0.6.1.</span> <span class="toc-text">段表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2-1"><span class="toc-number">0.6.2.</span> <span class="toc-text">地址变换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB"><span class="toc-number">0.6.3.</span> <span class="toc-text">共享</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E9%A1%B5%E4%B8%8E%E5%88%86%E6%AE%B5%E5%AF%B9%E6%AF%94"><span class="toc-number">0.7.</span> <span class="toc-text">分页与分段对比</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98"><span class="toc-number"></span> <span class="toc-text">虚拟内存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%99%E5%AD%A6%E8%A6%81%E6%B1%82-1"><span class="toc-number">0.1.</span> <span class="toc-text">教学要求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E5%85%A5"><span class="toc-number">0.2.</span> <span class="toc-text">引入</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">0.2.1.</span> <span class="toc-text">虚拟存储的优点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80"><span class="toc-number">0.3.</span> <span class="toc-text">虚拟存储器理论基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86"><span class="toc-number">0.3.1.</span> <span class="toc-text">局部性原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AF%E7%A1%AC%E4%BB%B6%E6%94%AF%E6%92%91"><span class="toc-number">0.3.2.</span> <span class="toc-text">软硬件支撑</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E6%94%AF%E6%92%91"><span class="toc-number">0.3.2.1.</span> <span class="toc-text">硬件支撑</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E6%94%AF%E6%92%91"><span class="toc-number">0.3.2.2.</span> <span class="toc-text">软件支撑</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E5%BE%81-1"><span class="toc-number">0.3.3.</span> <span class="toc-text">特征</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E5%88%86%E9%A1%B5"><span class="toc-number">0.4.</span> <span class="toc-text">请求分页</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E6%94%AF%E6%8C%81"><span class="toc-number">0.4.1.</span> <span class="toc-text">硬件支持</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A1%B5%E8%A1%A8-1"><span class="toc-number">0.4.1.1.</span> <span class="toc-text">页表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%BA%E9%A1%B5%E4%B8%AD%E6%96%AD"><span class="toc-number">0.4.1.2.</span> <span class="toc-text">缺页中断</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E5%88%86%E9%A1%B5%E5%B8%A6%E6%9D%A5%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">0.4.2.</span> <span class="toc-text">请求分页带来的问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%AB%E8%A1%A8-Translation-Lookaside-Buffer%EF%BC%8CTLB%EF%BC%89"><span class="toc-number">0.4.3.</span> <span class="toc-text">快表(Translation Lookaside Buffer，TLB）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B-2"><span class="toc-number">0.4.4.</span> <span class="toc-text">例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AE%B5%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8"><span class="toc-number">0.5.</span> <span class="toc-text">段页式存储</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2-2"><span class="toc-number">0.5.1.</span> <span class="toc-text">地址变换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%BF%E6%8D%A2%E7%AD%96%E7%95%A5"><span class="toc-number">0.6.</span> <span class="toc-text">替换策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E6%9B%BF%E6%8D%A2%EF%BC%88OPT%EF%BC%89"><span class="toc-number">0.6.1.</span> <span class="toc-text">最佳替换（OPT）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA%EF%BC%88FIFO%EF%BC%89"><span class="toc-number">0.6.2.</span> <span class="toc-text">先进先出（FIFO）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Belady%E7%8E%B0%E8%B1%A1"><span class="toc-number">0.6.2.1.</span> <span class="toc-text">Belady现象</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E8%BF%91%E6%9C%80%E4%B9%85%E6%9C%AA%E4%BD%BF%E7%94%A8%EF%BC%88Least-Recently-Used%EF%BC%8CLRU%EF%BC%89"><span class="toc-number">0.6.3.</span> <span class="toc-text">最近最久未使用（Least Recently Used，LRU）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Clock%E7%BD%AE%E6%8D%A2"><span class="toc-number">0.6.4.</span> <span class="toc-text">Clock置换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B-3"><span class="toc-number">0.7.</span> <span class="toc-text">例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B1"><span class="toc-number">0.7.1.</span> <span class="toc-text">例1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B2"><span class="toc-number">0.7.2.</span> <span class="toc-text">例2</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%95%E5%A4%84%E7%90%86%E5%99%A8%E8%B0%83%E5%BA%A6"><span class="toc-number"></span> <span class="toc-text">单处理器调度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E5%88%86%E7%B1%BB"><span class="toc-number">0.1.</span> <span class="toc-text">调度分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E6%96%B9%E5%BC%8F%E7%9A%84%E9%80%89%E6%8B%A9%E5%87%86%E5%88%99"><span class="toc-number">0.2.</span> <span class="toc-text">调度方式的选择准则</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E7%94%A8%E6%88%B7-User-oriented-%E7%9A%84%E5%87%86%E5%88%99%E5%92%8C%E8%AF%84%E4%BB%B7"><span class="toc-number">0.2.1.</span> <span class="toc-text">面向用户(User-oriented)的准则和评价</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E7%B3%BB%E7%BB%9F-System-oriented-%E7%9A%84%E5%87%86%E5%88%99"><span class="toc-number">0.2.2.</span> <span class="toc-text">面向系统(System-oriented)的准则</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5"><span class="toc-number">0.3.</span> <span class="toc-text">调度策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1-First-Come-First-Served-FCFS"><span class="toc-number">0.3.1.</span> <span class="toc-text">先来先服务 (First-Come-First-Served, FCFS)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%AC-Round-Robin-RR"><span class="toc-number">0.3.2.</span> <span class="toc-text">时间片轮转 (Round-Robin, RR)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E7%9F%AD%E8%BF%9B%E7%A8%8B%E4%BC%98%E5%85%88-Shortest-Process-Next-%EF%BC%8CSPN"><span class="toc-number">0.3.3.</span> <span class="toc-text">最短进程优先(Shortest Process Next ，SPN)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E7%9F%AD%E5%89%A9%E4%BD%99%E6%97%B6%E9%97%B4%E4%BC%98%E5%85%88-Shortest-Remaining-Time-SRT"><span class="toc-number">0.3.4.</span> <span class="toc-text">最短剩余时间优先(Shortest Remaining Time,SRT)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E9%AB%98%E5%93%8D%E5%BA%94%E6%AF%94%E4%BC%98%E5%85%88-Highest-Response-Ratio-Next%EF%BC%8CHRRN"><span class="toc-number">0.3.5.</span> <span class="toc-text">最高响应比优先 (Highest Response Ratio Next，HRRN)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8D%E9%A6%88%EF%BC%88Feedback%EF%BC%89"><span class="toc-number">0.3.6.</span> <span class="toc-text">反馈（Feedback）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B-4"><span class="toc-number">0.3.7.</span> <span class="toc-text">例</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#IO%E7%AE%A1%E7%90%86%E5%92%8C%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6"><span class="toc-number"></span> <span class="toc-text">IO管理和磁盘调度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%99%E5%AD%A6%E8%A6%81%E6%B1%82-2"><span class="toc-number">0.1.</span> <span class="toc-text">教学要求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IO%E8%AE%BE%E5%A4%87%E5%88%86%E7%B1%BB"><span class="toc-number">0.2.</span> <span class="toc-text">IO设备分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86%E7%9A%84%E7%9B%AE%E6%A0%87%E5%92%8C%E5%8A%9F%E8%83%BD"><span class="toc-number">0.3.</span> <span class="toc-text">设备管理的目标和功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IO%E5%8A%9F%E8%83%BD%E7%9A%84%E7%BB%84%E7%BB%87"><span class="toc-number">0.4.</span> <span class="toc-text">IO功能的组织</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F"><span class="toc-number">0.4.1.</span> <span class="toc-text">控制方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84"><span class="toc-number">0.4.2.</span> <span class="toc-text">逻辑结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IO%E7%B3%BB%E7%BB%9F%E7%9B%AE%E6%A0%87%E2%80%94%E2%80%94%E8%AE%BE%E5%A4%87%E7%8B%AC%E7%AB%8B%E6%80%A7"><span class="toc-number">0.4.3.</span> <span class="toc-text">IO系统目标——设备独立性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IO%E7%BC%93%E5%86%B2"><span class="toc-number">0.5.</span> <span class="toc-text">IO缓冲</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E7%B1%BB%E5%9E%8B"><span class="toc-number">0.5.1.</span> <span class="toc-text">缓冲类型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%95%E7%BC%93%E5%86%B2"><span class="toc-number">0.5.1.1.</span> <span class="toc-text">单缓冲</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%8C%E7%BC%93%E5%86%B2"><span class="toc-number">0.5.1.2.</span> <span class="toc-text">双缓冲</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E7%BC%93%E5%86%B2"><span class="toc-number">0.5.1.3.</span> <span class="toc-text">循环缓冲</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A3%81%E7%9B%98IO"><span class="toc-number">0.6.</span> <span class="toc-text">磁盘IO</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E7%BB%93%E6%9E%84"><span class="toc-number">0.6.1.</span> <span class="toc-text">磁盘结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%84%E7%BB%87"><span class="toc-number">0.6.2.</span> <span class="toc-text">数据组织</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E8%AE%BF%E9%97%AE%E6%97%B6%E9%97%B4"><span class="toc-number">0.6.3.</span> <span class="toc-text">磁盘访问时间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">0.6.4.</span> <span class="toc-text">磁盘调度算法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1FCFS"><span class="toc-number">0.6.4.1.</span> <span class="toc-text">先来先服务FCFS</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%80%E7%9F%AD%E5%AF%BB%E9%81%93%E6%97%B6%E9%97%B4%E4%BC%98%E5%85%88%EF%BC%88SSTF%EF%BC%89"><span class="toc-number">0.6.4.2.</span> <span class="toc-text">最短寻道时间优先（SSTF）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%89%AB%E6%8F%8F%EF%BC%88SCAN%EF%BC%89%E7%AE%97%E6%B3%95"><span class="toc-number">0.6.4.3.</span> <span class="toc-text">扫描（SCAN）算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E6%89%AB%E6%8F%8F%EF%BC%88CSCAN%EF%BC%89"><span class="toc-number">0.6.4.4.</span> <span class="toc-text">循环扫描（CSCAN）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%AF%94%E8%BE%83"><span class="toc-number">0.6.4.5.</span> <span class="toc-text">算法比较</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86"><span class="toc-number"></span> <span class="toc-text">文件管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%99%E5%AD%A6%E8%A6%81%E6%B1%82-3"><span class="toc-number">0.1.</span> <span class="toc-text">教学要求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E4%B8%8E%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">0.2.</span> <span class="toc-text">文件与文件系统</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6"><span class="toc-number">0.2.1.</span> <span class="toc-text">文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">0.2.2.</span> <span class="toc-text">文件系统</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%BB%84%E7%BB%87"><span class="toc-number">0.3.</span> <span class="toc-text">文件组织</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%BB%84%E7%BB%87%E7%B1%BB%E5%9E%8B"><span class="toc-number">0.3.1.</span> <span class="toc-text">文件组织类型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A0%86%EF%BC%88pile%EF%BC%89"><span class="toc-number">0.3.1.1.</span> <span class="toc-text">堆（pile）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E6%96%87%E4%BB%B6-sequential-file"><span class="toc-number">0.3.1.2.</span> <span class="toc-text">顺序文件 (sequential file)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E9%A1%BA%E5%BA%8F%E6%96%87%E4%BB%B6-indexed-sequential-file"><span class="toc-number">0.3.1.3.</span> <span class="toc-text">索引顺序文件 (indexed sequential file)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E6%96%87%E4%BB%B6-indexed-file"><span class="toc-number">0.3.1.4.</span> <span class="toc-text">索引文件 (indexed file)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E6%88%96%E6%95%A3%E5%88%97%E6%96%87%E4%BB%B6-direct-or-hashed-file"><span class="toc-number">0.3.1.5.</span> <span class="toc-text">直接或散列文件 (direct, or hashed, file)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%B0%E5%BD%95%E7%BB%84%E5%9D%97"><span class="toc-number">0.4.</span> <span class="toc-text">记录组块</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BA%E5%AE%9A%E7%BB%84%E5%9D%97-Fixed-blocking"><span class="toc-number">0.4.1.</span> <span class="toc-text">固定组块 (Fixed blocking)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E9%95%BF%E5%BA%A6%E8%B7%A8%E8%B6%8A%E5%BC%8F%E7%BB%84%E5%9D%97-Variable-length-spanned-blocking"><span class="toc-number">0.4.2.</span> <span class="toc-text">可变长度跨越式组块 (Variable-length spanned blocking)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E9%95%BF%E5%BA%A6%E9%9D%9E%E8%B7%A8%E8%B6%8A%E5%BC%8F%E7%BB%84%E5%9D%97-Variable-length-unspanned-blocking"><span class="toc-number">0.4.3.</span> <span class="toc-text">可变长度非跨越式组块 (Variable-length unspanned blocking)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AF%94%E8%BE%83"><span class="toc-number">0.4.4.</span> <span class="toc-text">比较</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%88%86%E9%85%8D"><span class="toc-number">0.5.</span> <span class="toc-text">文件分配</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%EF%BC%88Contiguous-allocation%EF%BC%89"><span class="toc-number">0.5.1.</span> <span class="toc-text">连续分配（Contiguous allocation）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%BE%E5%BC%8F%E5%88%86%E9%85%8D"><span class="toc-number">0.5.2.</span> <span class="toc-text">链式分配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%88%86%E9%85%8D"><span class="toc-number">0.5.3.</span> <span class="toc-text">索引分配</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%80%83%E9%A2%98"><span class="toc-number">0.6.</span> <span class="toc-text">思考题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1"><span class="toc-number">0.6.1.</span> <span class="toc-text">1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2"><span class="toc-number">0.6.2.</span> <span class="toc-text">2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3"><span class="toc-number">0.6.3.</span> <span class="toc-text">3</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4"><span class="toc-number">0.6.4.</span> <span class="toc-text">4</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/11/18/GitHub%20Pages%E9%85%8D%E7%BD%AE%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D/" title="GitHub Pages配置自定义域名并利用Cloudflare CDN加速"><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="http://img.ripplesu.top/random?dir=cover&amp;GitHub Pages配置自定义域名并利用Cloudflare CDN加速&amp;type=cover" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="GitHub Pages配置自定义域名并利用Cloudflare CDN加速"/></a><div class="content"><a class="title" href="/2023/11/18/GitHub%20Pages%E9%85%8D%E7%BD%AE%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D/" title="GitHub Pages配置自定义域名并利用Cloudflare CDN加速">GitHub Pages配置自定义域名并利用Cloudflare CDN加速</a><time datetime="2023-11-18T12:44:00.000Z" title="发表于 2023-11-18 20:44:00">2023-11-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/16/%E5%B7%A5%E7%A8%8B%E7%BB%8F%E6%B5%8E%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/" title="工程经济期末复习"><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="http://img.ripplesu.top/random?dir=cover&amp;工程经济期末复习&amp;type=cover" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="工程经济期末复习"/></a><div class="content"><a class="title" href="/2023/06/16/%E5%B7%A5%E7%A8%8B%E7%BB%8F%E6%B5%8E%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/" title="工程经济期末复习">工程经济期末复习</a><time datetime="2023-06-16T06:44:08.000Z" title="发表于 2023-06-16 14:44:08">2023-06-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/22/%E5%9F%BA%E4%BA%8Ecommons-pool2%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AF%B9%E8%B1%A1%E6%B1%A0/" title="基于commons-pool2自定义对象池"><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="http://img.ripplesu.top/random?dir=cover&amp;基于commons-pool2自定义对象池&amp;type=cover" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="基于commons-pool2自定义对象池"/></a><div class="content"><a class="title" href="/2023/03/22/%E5%9F%BA%E4%BA%8Ecommons-pool2%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AF%B9%E8%B1%A1%E6%B1%A0/" title="基于commons-pool2自定义对象池">基于commons-pool2自定义对象池</a><time datetime="2023-03-22T14:29:29.000Z" title="发表于 2023-03-22 22:29:29">2023-03-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/10/Hadoop%E4%BC%AA%E5%88%86%E5%B8%83%E5%BC%8F%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/" title="Hadoop伪分布式集群搭建"><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="http://img.ripplesu.top/random?dir=cover&amp;Hadoop伪分布式集群搭建&amp;type=cover" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Hadoop伪分布式集群搭建"/></a><div class="content"><a class="title" href="/2023/03/10/Hadoop%E4%BC%AA%E5%88%86%E5%B8%83%E5%BC%8F%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/" title="Hadoop伪分布式集群搭建">Hadoop伪分布式集群搭建</a><time datetime="2023-03-10T10:41:47.000Z" title="发表于 2023-03-10 18:41:47">2023-03-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/02/27/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" title="git常用命令"><img src="http://oss.ripplesu.top/blog/loading.gif" data-original="http://img.ripplesu.top/random?dir=cover&amp;git常用命令&amp;type=cover" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="git常用命令"/></a><div class="content"><a class="title" href="/2023/02/27/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" title="git常用命令">git常用命令</a><time datetime="2023-02-27T10:03:53.000Z" title="发表于 2023-02-27 18:03:53">2023-02-27</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023 By RippleSu</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (true){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"><script>(() => {
  const initValine = () => {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '',
      appKey: '',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  const loadValine = async () => {
    if (typeof Valine === 'function') initValine()
    else {
      await getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js')
      initValine()
    }
  }

  if ('Valine' === 'Valine' || !false) {
    if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script><script>(() => {
  const disqus_config = function () {
    this.page.url = 'http://blog.ripplesu.top/2023/02/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/'
    this.page.identifier = '/2023/02/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/'
    this.page.title = '操作系统期末复习'
  }

  const disqusReset = () => {
    window.DISQUS && window.DISQUS.reset({
      reload: true,
      config: disqus_config
    })
  }

  btf.addGlobalFn('themeChange', disqusReset, 'disqus')

  const loadDisqus = () =>{
    if (window.DISQUS) disqusReset()
    else {
      const script = document.createElement('script')
      script.src = 'https://.disqus.com/embed.js'
      script.setAttribute('data-timestamp', +new Date())
      document.head.appendChild(script)
    }
  }

  const getCount = async() => {
    try {
      const eleGroup = document.querySelector('#post-meta .disqus-comment-count')
      if (!eleGroup) return
      const cleanedLinks = eleGroup.href.replace(/#post-comment$/, '')

      const res = await fetch(`https://disqus.com/api/3.0/threads/set.json?forum=&api_key=&thread:link=${cleanedLinks}`,{
        method: 'GET'
      })
      const result = await res.json()

      const count = result.response.length ? result.response[0].posts : 0
      eleGroup.textContent = count
    } catch (err) {
      console.error(err)
    }
  }

  if ('Valine' === 'Disqus' || !false) {
    if (false) btf.loadComment(document.getElementById('disqus_thread'), loadDisqus)
    else {
      loadDisqus()
      
    }
  } else {
    window.loadOtherComment = loadDisqus
  }
})()</script></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div>
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(r){r.imageLazyLoadSetting.processImages=t;var e=r.imageLazyLoadSetting.isSPA,n=r.imageLazyLoadSetting.preloadRatio||1,c=a();function a(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(){e&&(c=a());for(var t,o=0;o<c.length;o++)0<=(t=(t=c[o]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(r.innerHeight*n||document.documentElement.clientHeight*n)&&function(){var t,e,n,a,i=c[o];e=function(){c=c.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(n=new Image,a=t.getAttribute("data-original"),n.onload=function(){t.src=a,t.removeAttribute("data-original"),e&&e()},t.src!==a&&(n.src=a))}()}function i(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",i),r.addEventListener("resize",i),r.addEventListener("orientationchange",i)}(this);</script></body></html>