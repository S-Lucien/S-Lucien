<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>GitHub Pages配置自定义域名并利用Cloudflare CDN加速</title>
      <link href="/2023/11/18/GitHub%20Pages%E9%85%8D%E7%BD%AE%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D/"/>
      <url>/2023/11/18/GitHub%20Pages%E9%85%8D%E7%BD%AE%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D/</url>
      
        <content type="html"><![CDATA[<p>Hexo部署网站到Github Pages后默认访问地址是xxx.github.io，如果想要自定义为自己的域名，该怎么做呢？</p><p>前置条件：</p><ul><li>一个GitHub Pages站点。</li><li>一个自己的域名</li></ul><h3 id="DNS解析"><a href="#DNS解析" class="headerlink" title="DNS解析"></a>DNS解析</h3><p>本人域名是在阿里云购买的，以下操作都以阿里云为例。</p><p>首先添加一条记录。以本人配置的为例，主机记录<code>blog</code>代表二级域名<code>blog.ripplesu.top</code>，记录值<code>s-lucien.github.io</code>即为原先Github Pages的默认网址。</p><p><img src="http://oss.ripplesu.top/blog/Typora/image-20231119150320326.png" alt="image-20231119150320326"></p><h3 id="Github-Pages绑定域名"><a href="#Github-Pages绑定域名" class="headerlink" title="Github Pages绑定域名"></a>Github Pages绑定域名</h3><p>仓库 -&gt; Setting -&gt; Pages -&gt; 在Custom domain中填入刚才配置的域名（例如我的是<code>blog.ripplesu.top</code>）</p><p><img src="http://oss.ripplesu.top/blog/Typora/image-20231119151217002.png" alt="image-20231119151217002"></p><h3 id="Cloudflare-CDN加速"><a href="#Cloudflare-CDN加速" class="headerlink" title="Cloudflare CDN加速"></a>Cloudflare CDN加速</h3><p>在国内直接访问Github Pages速度比较慢，可以考虑用CDN加速。本人使用的是Cloudflare，提供免费版并且没有流量限制。</p><details><summary>什么是CDN？以下来自ChatGPT：</summary>    CDN 是内容分发网络（Content Delivery Network）的缩写。它是一种通过将内容分发到全球各地的服务器网络，提供高效、快速内容传输的技术架构。</br>    传统的网络架构中，当用户请求访问一个网站或应用时，请求会直接发送到网站的源服务器，然后源服务器响应请求并返回内容给用户。这种方式可能会导致延迟和网络拥塞，特别是当用户与源服务器之间的距离较远时。</br>    CDN 的作用是通过在全球各地部署分布式的边缘节点服务器，将内容缓存到这些节点上，并根据用户的地理位置选择最近的节点来响应请求。这样一来，用户可以从离他们更近的服务器获取内容，减少了网络延迟和传输时间，提高了用户体验。</br>    CDN 还可以通过负载均衡和智能路由等技术，根据网络状况和服务器负载情况，动态选择最佳的节点来响应请求。这使得网站和应用在面对高流量和突发访问压力时能够更好地处理请求，并提供稳定可靠的服务。</br>    除了加速内容传输，CDN 还可以提供其他功能，如安全性增强、防御分布式拒绝服务攻击（DDoS）等。它已广泛应用于各种网站、应用、视频流媒体和软件分发等场景，为用户提供更快速、可靠的内容访问体验。</details>    <p>详细配置可以参考：<a href="http://ask.rbluntan.cn/hu/257.html%EF%BC%8C%E8%BF%99%E9%87%8C%E5%B0%B1%E4%B8%8D%E8%B5%98%E8%BF%B0%E4%BA%86%E3%80%82">http://ask.rbluntan.cn/hu/257.html，这里就不赘述了。</a></p><p>下面给出我的网站加速前后对比：</p><p>加速前：</p><p><img src="http://oss.ripplesu.top/blog/Typora/image-20231119150732568.png" alt="image-20231119150732568"></p><p>加速后：</p><p><img src="http://oss.ripplesu.top/blog/Typora/image-20231119150810284.png" alt="image-20231119150810284"></p><p>可以看到速度提升还是很明显的。</p><h3 id="其他问题：Hexo文章推送后自定义域名失效"><a href="#其他问题：Hexo文章推送后自定义域名失效" class="headerlink" title="其他问题：Hexo文章推送后自定义域名失效"></a>其他问题：Hexo文章推送后自定义域名失效</h3><p>在Github Pages绑定域名后，根目录下会生成一个CNAME文件，内容就是你配置的域名。</p><p>后续我们更新文章使用<code>hexo d</code>推送会导致该文件清除。</p><p>解决办法只需在<code>Hexo</code>的<code>source</code>目录下新增一个CNAME文件，内容就是你之前配置的域名。</p><p><img src="http://oss.ripplesu.top/blog/Typora/image-20231119152731698.png" alt="image-20231119152731698"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>工程经济期末复习</title>
      <link href="/2023/06/16/%E5%B7%A5%E7%A8%8B%E7%BB%8F%E6%B5%8E%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"/>
      <url>/2023/06/16/%E5%B7%A5%E7%A8%8B%E7%BB%8F%E6%B5%8E%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="第一章-技术经济学"><a href="#第一章-技术经济学" class="headerlink" title="第一章 技术经济学"></a>第一章 技术经济学</h2><h3 id="技术经济分析一般过程"><a href="#技术经济分析一般过程" class="headerlink" title="技术经济分析一般过程"></a>技术经济分析一般过程</h3><p><strong>第一，确定目标功能，即明确解决的问题。</strong></p><p><strong>第二，提出备选方案。</strong></p><p>  （由工程师、产品设计人员、销售部门、财务部门、工人技师等提出）</p><p><strong>第三，方案评价。</strong></p><p>  （净现值法、内部收益率法、盈亏平衡法等）</p><p><strong>第四，选择最优方案</strong></p><p>  （技术上可行，经济效益最佳的方案）</p><h3 id="技术经济关系"><a href="#技术经济关系" class="headerlink" title="技术经济关系"></a>技术经济关系</h3><ol><li><p><strong>两者之间相互依赖、相互影响、相互制约。</strong></p></li><li><p><strong>技术进步是经济发展的重要条件和手段，对 经济发展起巨大推动作用。</strong> 案例：美国的星球大战计划</p></li><li><p><strong>反过来，技术开发是一项高投入、高风险和周 期长的活动，其产生与应用都需要经济的支持，受到经济的制约。</strong></p><pre><code>据统计：美国研制一种一类新药需要投入数亿美元花费10到20年的研发周期；美国基础研究的成功率为 5%左右，技术开发的成功率为50%左右</code></pre></li><li><p><strong>技术和经济之间是协调发展的。</strong></p></li></ol><h3 id="技术经济学研究对象"><a href="#技术经济学研究对象" class="headerlink" title="技术经济学研究对象"></a>技术经济学研究对象</h3><ul><li>研究技术方案的经济效果，寻求最佳经济效果方案。</li><li>研究技术与经济相互促进与协调发展</li><li>研究技术创新，推动技术进步，促进企业发展和国民经济增长。</li></ul><h2 id="第二章-技术创新"><a href="#第二章-技术创新" class="headerlink" title="第二章 技术创新"></a>第二章 技术创新</h2><h3 id="为什么要研究创新"><a href="#为什么要研究创新" class="headerlink" title="为什么要研究创新"></a>为什么要研究创新</h3><p>1、技术创新是经济增长的根本动力，经济的持续增长来源于技术创新的持续活跃。</p><p>2、技术创新能弥补传统方式所无法弥补的增长鸿沟。</p><pre><code>传统方式：加强营销和销售、行业的自然增长率、消减成本、提高生产效率等</code></pre><p>3、当前创新管理的现实不尽如人意。</p><h3 id="什么是创新"><a href="#什么是创新" class="headerlink" title="什么是创新"></a>什么是创新</h3><p>创新(innovation)：<strong>指企业家对生产要素的重新组合，或者是说是建立一种新的生产函数，将生产要素的“新组合”引入生产体系</strong></p><h4 id="创新与R-D"><a href="#创新与R-D" class="headerlink" title="创新与R&amp;D"></a>创新与R&amp;D</h4><p>研究与开发（R&amp;D, research and development）是在系统的基础上进行的一项创造性工作，其目的在于丰富有关人类、文化和社会的知识库，并利用这一知识进行新的发明</p><p> （1）基础研究（basic research）</p><p> （2）应用研究（applied research）</p><p> （3）实验开发（development）</p><ul><li><p>创新与R&amp;D 的区别</p><p>  创新的产出：商业化过程；product-related</p><p>  R&amp;D的产出：论文、专利、设计图纸、样品等</p></li><li><p>创新与R&amp;D的关联</p><p>  （1）R&amp;D费用已经被普遍采用为创新投入的测度指标：R&amp;D、R&amp;D&#x2F;sales</p><p>  （2）R&amp;D与创新之间的关系是非线性的</p><p>  （3）技术创新始于R＆D而终于市场实现。</p></li></ul><h3 id="如何推动创新"><a href="#如何推动创新" class="headerlink" title="如何推动创新"></a>如何推动创新</h3><h2 id="第三章-经济性评价基本要素"><a href="#第三章-经济性评价基本要素" class="headerlink" title="第三章 经济性评价基本要素"></a>第三章 经济性评价基本要素</h2><p><strong>利润</strong> <strong>&#x3D;</strong> 销售收入 - 总成本 - 税金</p><p><strong>劳动生产率</strong>&#x3D;工业生产总值 &#x2F; 劳动者人数</p><p><strong>投资利润率</strong>&#x3D;（销售收入-总成本-税金）&#x2F; 投资</p><h3 id="现金流量"><a href="#现金流量" class="headerlink" title="现金流量"></a>现金流量</h3><p><strong>现金流入（Cash In Flow , CI）。</strong>流入系统的资金称为现金流入。如：销售（经营）收入、固定资产和流动资产回收、借款等。</p><p><strong>现金流出（ Cash Out Flow , CO）。</strong>流出系统的资金称为现金流出。如：投资、经营成本、税、贷款本息偿还等。</p><p><strong>净现金流量（NCF）。</strong>现金流入与现金流出之差：NCF＝CI－CO</p><h4 id="成本"><a href="#成本" class="headerlink" title="成本"></a>成本</h4><ul><li><p><strong>机会成本</strong>——<strong>是指如果一项资源既能用于甲用途，又能用于其它用途（由于资源的稀缺性，如果用于甲用途就必须放弃其他用途），那么资源用于甲用途的机会成本，就是资源用于次好的、被放弃的其它用途本来可以得到的净收入。</strong></p><p> <strong>例如</strong>，你现在有10000元，你可以以定期形式存在银行，也可以进行短期投资（比如炒股票）。假如存在银行的利息收入为1年1000元，而炒股票的年净收入约为3000元。那么，你选择炒股票的机会成本是1000元，如果你选择存入银行的机会成本是3000元。</p></li><li><p><strong>沉没成本</strong>——<strong>指过去已经支出而现在无法得到补偿的成本。它对企业经营决策不起决定作用。</strong></p><p>某百货公司打算购买一栋销售门市部，为此他为标价100万元的门市部交了20万元优先购买权的订金，若成交，补交80万元；若不成交，订金不予返还。但后来，他发现一栋同样理想的标价75万元的门市部。问应买哪家门市部？</p></li><li><p><strong>经营成本是从投资方案本身考察的，是在一定期间（通常为一年）内由于生产和销售产品及提供劳务而实际发生的现金支出。</strong></p><p><strong>经营成本＝总成本费用—折旧费—摊销费—财务费用</strong></p></li><li><p>会计成本——是会计记录在公司帐册上的实际支出，包括生产、 销售过程中发生的原料、工资、广告、利息等支出。</p></li><li><p>固定成本——在一定产量范围内不随产量变动而变动的费用。如管理人员工资、差旅费、设备折旧费、办公费用、利息支出等。</p><p><strong>特点：</strong></p><p>   <strong>1</strong>）其总额在一定时期和一定业务量范围内不随产量的增加而变动；</p><p>   <strong>2 )</strong> 就单位产品成本而言，其中的固定成本部分与产量的增减成反比，即产量增加时，单位产品的固定成本减少。</p></li><li><p>变动成本——成本中随产量变动而变动的费用，例如直接原材料、直接人工费、直接燃料和动力费及包装费等。</p><p><strong>特点：</strong></p><p> <strong>1</strong>）其变动成本总额随产量的增加而增加。</p><p> <strong>2 )</strong> 就单位产品成本而言，变动成本部分是固定不变的。</p></li><li><p><strong>经济成本是显性成本和隐性成本之和。</strong></p><p><strong>显性成本</strong>——看得见的实际成本（诸如企业购买原材料、设备、劳动力、支付借款利息）。</p><p><strong>隐性成本</strong>——指企业自有的资源，实际上已经投入，但在形式上没有支付报酬的那部分成本。</p></li><li><p><strong>边际成本</strong>——又称增量成本，是企业每增加一个单位产品产量所产生的成本增加量。即企业每增加一单位产量所支付的追加成本。</p><p>例如，生产某种产品100个单位时，总成本为5000元，单位产品成本为50元。若生产101个时，其总成本5 040元，则所增加一个产品的成本为40元，即边际成本为40元。</p></li></ul><h4 id="现金流量图"><a href="#现金流量图" class="headerlink" title="现金流量图"></a>现金流量图</h4><p><strong>用现金流量图来表示一切经济活动：</strong></p><p><strong>（1）横坐标（轴）表示时间(年末)；</strong></p><p><strong>（2）纵坐标（轴）表示现金流量。</strong></p><p><img src="http://oss.ripplesu.top/blog/%E5%B7%A5%E7%A8%8B%E7%BB%8F%E6%B5%8E%E5%A4%8D%E4%B9%A0/image-20231120144634303.png" alt="image-20231120144634303"></p><p><img src="http://oss.ripplesu.top/blog/%E5%B7%A5%E7%A8%8B%E7%BB%8F%E6%B5%8E%E5%A4%8D%E4%B9%A0/image-20231120144652227.png" alt="image-20231120144652227"></p><h3 id="资金时间价值"><a href="#资金时间价值" class="headerlink" title="资金时间价值"></a>资金时间价值</h3><p><strong>资金时间价值——不同时间发生的等额资金在价 值上的差别称为资金的时间价值。</strong> </p><p><strong>利息（或利润）——资金在单位时间内产生的增值。利息（或利润）是衡量资金时间价值的绝对尺度。</strong></p><p><strong>利率（收益率）——利息（或利润）与本金之比，称为“利率”或收益率，它是衡量资金时间价值的相对尺度，记作</strong>i。</p><ul><li><p>单利法</p><p><img src="http://oss.ripplesu.top/blog/%E5%B7%A5%E7%A8%8B%E7%BB%8F%E6%B5%8E%E5%A4%8D%E4%B9%A0/image-20231120144659779.png" alt="image-20231120144659779"></p></li><li><p>复利法</p><p><img src="http://oss.ripplesu.top/blog/%E5%B7%A5%E7%A8%8B%E7%BB%8F%E6%B5%8E%E5%A4%8D%E4%B9%A0/image-20231120144705569.png" alt="image-20231120144705569"></p></li></ul><p><strong>计息周期 —— 一年内计算利息周期的次数，用m来表示。计息周期有年、半年、季、月、周、日等。<br>实际利率 —— 将计息周期实际发生的利率称为计息周期实际利率，用 i来表示。<br>名义利率——计息周期的实际利率乘以每年计息周期数就得到名义利率，用 r来表示。<br>实际利率 i &#x3D;(1 + r／m)<sup>m</sup>  -1</strong><br>当m &#x3D;1时，i&#x3D;r；m&gt;1时，i &gt;r；m∞时，即一年中无限多次计息，连续复利计算。这时的实际利率称连续利率。</p><p><img src="http://oss.ripplesu.top/blog/%E5%B7%A5%E7%A8%8B%E7%BB%8F%E6%B5%8E%E5%A4%8D%E4%B9%A0/image-20231120144711652.png" alt="image-20231120144711652"></p><h4 id="资金等值"><a href="#资金等值" class="headerlink" title="资金等值"></a>资金等值</h4><p><strong>资金等值</strong>——是指在考虑资金时间价值因素后，不同时点上数额不等的资金在一定利率条件下具有相等的价值。<br>影响资金等值的因素有三个：<br>     资金额大小；资金发生的时间；利率<br>将一个时点发生的资金金额换算成另一时点的等值金额，这一过程叫资金等值计算。</p><p>**贴现与贴现率——把将来某一时点处资金金额折算成现在时点的等值金额称为贴现或折现。贴现时所用的利率称贴现率或折现率，用 i 表示。<br>现值——是指资金“现在”价值，用P 表示（Present Value）。<br>终值——现值在未来某一时点的资金金额称为终值或将来值，用F表示（Final Value）。<br>等年值—— 一定时期内每期有等额收支的资金值，用A表示（Annual Value ）。 **</p><h4 id="资金等值计算公式"><a href="#资金等值计算公式" class="headerlink" title="资金等值计算公式"></a>资金等值计算公式</h4><ul><li><p>一次性支付终值公式</p><p><img src="http://oss.ripplesu.top/blog/%E5%B7%A5%E7%A8%8B%E7%BB%8F%E6%B5%8E%E5%A4%8D%E4%B9%A0/image-20231120144717998.png" alt="image-20231120144717998"></p></li><li><p>一次支付现值公式</p><p><img src="http://oss.ripplesu.top/blog/%E5%B7%A5%E7%A8%8B%E7%BB%8F%E6%B5%8E%E5%A4%8D%E4%B9%A0/image-20231120144722828.png" alt="image-20231120144722828"></p></li><li><p>等额分付终值公式</p><p><img src="http://oss.ripplesu.top/blog/%E5%B7%A5%E7%A8%8B%E7%BB%8F%E6%B5%8E%E5%A4%8D%E4%B9%A0/image-20231120144726588.png" alt="image-20231120144726588"></p><p><img src="http://oss.ripplesu.top/blog/%E5%B7%A5%E7%A8%8B%E7%BB%8F%E6%B5%8E%E5%A4%8D%E4%B9%A0/image-20231120144930689.png" alt="image-20231120144930689"></p><p><img src="http://oss.ripplesu.top/blog/%E5%B7%A5%E7%A8%8B%E7%BB%8F%E6%B5%8E%E5%A4%8D%E4%B9%A0/image-20231120144731008.png" alt="image-20231120144731008"></p></li><li><p>等额分付偿债基金公式<br>$$<br>A &#x3D; F(A／F，i ，n) \qquad A&#x3D;F\frac{i}{(1+i)^{n}-1}<br>$$<br><img src="http://oss.ripplesu.top/blog/%E5%B7%A5%E7%A8%8B%E7%BB%8F%E6%B5%8E%E5%A4%8D%E4%B9%A0/image-20231120144737819.png" alt="image-20231120144737819"></p><p>解：<font color = 'red'>A &#x3D; F(A／F，i ，n)</font>&#x3D;6×(A／F，12% ，5) &#x3D; 6 × 0.15741 &#x3D;0.9445（万元）</p><p>如果是年初存款，应多算1年利息，即0.9445&#x2F;1.12</p></li><li><p>等额分付现值公式<br>$$<br>P＝A×(P／A，i ，n)<br>$$</p><p>$$<br>F&#x3D;A\frac{(1+i)^{n}-1}{i} \quad P&#x3D;\frac{F}{(1+i)^{n}}<br>\quad P&#x3D;A\frac{(1+i)^{n}-1}{i(1+i)^{n}}<br>$$</p><p><img src="http://oss.ripplesu.top/blog/%E5%B7%A5%E7%A8%8B%E7%BB%8F%E6%B5%8E%E5%A4%8D%E4%B9%A0/image-20231120144744248.png" alt="image-20231120144744248"></p></li><li><p>资金回收公式<br>$$<br>A＝P×(A／P，i ，n) \quad A&#x3D;P\frac{i(1+i)^{n}}{(1+i)^{n}-1}<br>$$<br><img src="http://oss.ripplesu.top/blog/%E5%B7%A5%E7%A8%8B%E7%BB%8F%E6%B5%8E%E5%A4%8D%E4%B9%A0/image-20231120144747877.png" alt="image-20231120144747877"></p></li></ul><h2 id="第四章-经济性评价办法"><a href="#第四章-经济性评价办法" class="headerlink" title="第四章 经济性评价办法"></a>第四章 经济性评价办法</h2><h3 id="投资回收期法"><a href="#投资回收期法" class="headerlink" title="投资回收期法"></a>投资回收期法</h3><p><strong>投资回收期——是指投资回收的期限。也就是投资方案所产生的净现金收入回收初始全部投资所需的时间。通常用“年”表示。<br>静态投资回收期：不考虑资金时间价值因素。<br>动态投资回收期：考虑资金时间价值因素。<br>投资回收期计算——一般从工程项目开始投入之日算起，即应包括项目的建设期。</strong></p><ul><li>静态投资回收期</li></ul><p>$$<br>投资回收期T&#x3D;累计净现金流量开始出现正值的年份-1+\frac{|上年累计净现金流量|}{当年净现金流量}<br>$$</p><p><img src="http://oss.ripplesu.top/blog/%E5%B7%A5%E7%A8%8B%E7%BB%8F%E6%B5%8E%E5%A4%8D%E4%B9%A0/image-20231120144753319.png" alt="image-20231120144753319"></p><ul><li>动态投资回收期</li></ul><p>$$<br>T&#x3D;累计净现金流量折现值开始出现正值的年份-1+\frac{|上年累计净现金流量折现值|}{当年净现金流量折现值}<br>$$</p><p><img src="http://oss.ripplesu.top/blog/%E5%B7%A5%E7%A8%8B%E7%BB%8F%E6%B5%8E%E5%A4%8D%E4%B9%A0/image-20231120144756894.png" alt="image-20231120144756894"></p><p><em>折现</em>,将未来收入折算成等价的现值</p><table><thead><tr><th><strong>年份</strong></th><th><strong>0</strong></th><th><strong>1</strong></th><th><strong>2</strong></th><th><strong>3</strong></th><th><strong>4</strong></th><th><strong>5</strong></th><th><strong>6</strong></th></tr></thead><tbody><tr><td><strong>1．现金流入</strong></td><td></td><td></td><td><strong>5000</strong></td><td><strong>6000</strong></td><td><strong>8000</strong></td><td><strong>8000</strong></td><td><strong>7500</strong></td></tr><tr><td><strong>2．现金流出</strong></td><td><strong>6000</strong></td><td><strong>4000</strong></td><td><strong>2000</strong></td><td><strong>2500</strong></td><td><strong>3000</strong></td><td><strong>3500</strong></td><td><strong>3500</strong></td></tr><tr><td><strong>3．净现金流量（1-2)</strong></td><td><strong>-6000</strong></td><td><strong>-4000</strong></td><td><strong>3000</strong></td><td><strong>3500</strong></td><td><strong>5000</strong></td><td><strong>4500</strong></td><td><strong>4000</strong></td></tr><tr><td><strong>5．折现系数  (i&#x3D;10%)</strong></td><td></td><td><strong>0.909</strong></td><td><strong>0.826</strong></td><td><strong>0.751</strong></td><td><strong>0.683</strong></td><td><strong>0.62</strong></td><td><strong>0.565</strong></td></tr><tr><td><strong>6．净现金流量折现值</strong></td><td><strong>-6000</strong></td><td><strong>-3636</strong></td><td><strong>2479</strong></td><td><strong>2630</strong></td><td><strong>3415</strong></td><td><strong>2794</strong></td><td><strong>2258</strong></td></tr><tr><td><strong>7．累计净现金流量折现值</strong></td><td><strong>-6000</strong></td><td><strong>-9636</strong></td><td><strong>-7157</strong></td><td><strong>-4527</strong></td><td><strong>-1112</strong></td><td><strong>1682</strong></td><td><strong>3940</strong></td></tr></tbody></table><p>Tp &#x3D; 5 -1 + |-1112| &#x2F;  2794 &#x3D; 4.4 年</p><h3 id="现值法"><a href="#现值法" class="headerlink" title="现值法"></a>现值法</h3><ul><li>净现值（NPV）——是指项目（或方案）在寿命期内各年的净现金流量（CI－CO）t，按照一定的折现率i，折现到期初时点的现值之和，其表达式为：（CO现金流出，CI现金流入）</li></ul><p>$$<br>NPV&#x3D;\sum_{t&#x3D;0}^{n}(CI-CO)_t(1+i)^{-t}<br>$$</p><p><img src="http://oss.ripplesu.top/blog/%E5%B7%A5%E7%A8%8B%E7%BB%8F%E6%B5%8E%E5%A4%8D%E4%B9%A0/image-20231120144800542.png" alt="image-20231120144800542"><br>$$<br>NPV(10%) &#x3D; -1000 + 300(P&#x2F;A,10%,4) + 500(P&#x2F;F,10%,5)&#x3D;261.42<br>$$</p><ul><li><p>净终值</p><p>方<strong>案的净终值（NFV）——是指方案在寿命期内各年的净现金流量（CI－CO）t ，按照一定的折现率 i，折现到期末时的终值之和，其表达式为</strong><br>$$<br>NPV&#x3D;\sum_{t&#x3D;0}^{n}(CI-CO)<em>t(1+i_0)^t&#x3D;\sum</em>{t&#x3D;0}^{n}(CI-CO)_t(F&#x2F;P,i_0,t)<br>$$<br>F存入银行 &#x3D; 1000(F&#x2F;P,10%,5)&#x3D;1611</p><p>F借给朋友 &#x3D; 300(F&#x2F;A,10%,4) (F&#x2F;P,10%,1)+500 &#x3D;2032.02 </p><p>F借给朋友 - F存入银行 &#x3D; 2032.02 – 1611 &#x3D; 421.02</p><p>NFV（10%）&#x3D; -1000 (F&#x2F;P,10%,5)+300(F&#x2F;A,10%,4) (F&#x2F;P,10%,1)+500 &#x3D;421.02</p></li><li><p>净年值</p><p>方案的净年值NAV——是通过资金等值计算，将项目的净现值NPV（或净终值NFV）分摊到寿命期内各年的等额年值。与净现值是等效评价指标。其表达式为：<br>$$<br>NAV &#x3D; NPV(A&#x2F;P,i,n)&#x3D; NFV(A&#x2F;F,i,n)<br>$$</p><ul><li><p>用NPV&#x2F;NFV&#x2F;NAV评价方案的准则：<br>若NAV ≥ 0，则方案是经济合理的；<br>若NAV ＜ 0，则方案应予否定。</p><p>方案NAV＞0，意味着方案除能达到规定的基准收益率之外，还能获得超额收益；<br>方案NAV&#x3D;0，则意味着方案正好达到了规定的基准收益率水平；<br>方案NAV ＜ 0 ，意味着方案达不到规定的基准收益率水平。</p></li></ul></li><li><p>费用现值与费用年值</p><p>PC或AC最小的方案为最优方案。<br>$$<br>费用现值PC&#x3D;\sum_{t&#x3D;0}^{n}CO_t(P&#x2F;F,i,t)<br>$$</p><p>$$<br>费用年值AC&#x3D;PC(A&#x2F;P,i,n)&#x3D;\sum_{t&#x3D;0}^{n}CO_t(P&#x2F;F,i,t)(A&#x2F;P,i,n)<br>$$</p><p><img src="http://oss.ripplesu.top/blog/%E5%B7%A5%E7%A8%8B%E7%BB%8F%E6%B5%8E%E5%A4%8D%E4%B9%A0/image-20231120144806119.png" alt="image-20231120144806119"></p><p>PC(A)&#x3D;70+13（P&#x2F;A,15%,10）&#x3D;135.2<br>PC(B)&#x3D;100+10（P&#x2F;A,15%,5）+15（P&#x2F;A,15%,5） （P&#x2F;F,15%,5） &#x3D;158.5</p><p>AC(A)&#x3D;70(A&#x2F;P,15%,10)+13&#x3D;26.9<br>AC(B)&#x3D;100(A&#x2F;P,15%,10)+10(P&#x2F;A,15%,5)(A&#x2F;P,15%,10) +15(F&#x2F;A,15%,5)(A&#x2F;F,15%,10)&#x3D;31.7</p></li></ul><h3 id="内部收益率IRR"><a href="#内部收益率IRR" class="headerlink" title="内部收益率IRR"></a>内部收益率IRR</h3><p>**内部收益率（IRR）简单地说就是净现值NPV为零时的折现率。 **<br>$$<br>NPV&#x3D;\sum_{t&#x3D;0}^{n}(CI-CO)_t(1+IRR)^{-t}&#x3D;0<br>$$<br> 一般情况下，当IRR ≥ i0时，NPV（ i0 ）≥0;当IRR＜ i0时，NPV（ i0 ）＜0 </p><p>因此，对于单个方案的评价，内部收益率IRR准则与净现值NPV准则，其评价结论是一致的。</p><p><strong>由于内部收益率方程通常为高次方程，不易求解，因此一般采用“试算内插法”求IRR的近似值。</strong></p><p><img src="http://oss.ripplesu.top/blog/%E5%B7%A5%E7%A8%8B%E7%BB%8F%E6%B5%8E%E5%A4%8D%E4%B9%A0/image-20231120144810252.png" alt="image-20231120144810252"></p><p>例：</p><p><img src="http://oss.ripplesu.top/blog/%E5%B7%A5%E7%A8%8B%E7%BB%8F%E6%B5%8E%E5%A4%8D%E4%B9%A0/image-20231120144813127.png" alt="image-20231120144813127"></p><p>例： 一个项目的初始投资为10000元，以后每年均等地获得净收益2000元，项目寿命期为10年。试求内部收益率。 </p><p>NPV(10%)&#x3D; -10000+2000 (P&#x2F;A,10%,10) &#x3D;2081.03<br>NPV(15%)&#x3D; -10000+2000 (P&#x2F;A,15%,10) &#x3D; 32.64<br>NPV(20%)&#x3D; -10000+2000 (P&#x2F;A,20%,10) &#x3D; -1345.88<br>$$<br>\frac{IRR-15%}{20%-15%}&#x3D;\frac{32.64}{1345.88+32.64} \quad IRR&#x3D;15.1%<br>$$</p><h3 id="备选方案"><a href="#备选方案" class="headerlink" title="备选方案"></a>备选方案</h3><ul><li><p>年值法(NAV或者AC)</p><p>一个城市准备修建城市下水系统，有两个被选的提议。第一个寿命为20年，第二个寿命为40年，初期投资分别为1亿元和1.5亿元。两者的收益均为每年0.3亿元，基准收益率是12%，无残值。应选择哪个提议？</p><p>NAV1&#x3D;0.3-1×(A&#x2F;P,12%,20)&#x3D; 0.166亿元NAV2&#x3D;0.3-1.5(A&#x2F;P,12%,40)&#x3D; 0.1亿元<br>应选择第1方案。</p></li><li><p>最小公倍数法(NPV或者PC)</p><p>以各备选方案的寿命周期的最小公倍数作为比选的共同期限，假定各个方案均在这样一个共同的期限内反复实施，对各个方案分析期内各年的净现金流量换算到现值（即NPV法），按最小公倍数进行重复计算，直到分析期结束</p></li><li><p>研究期法(NPV或者PC)</p><p>是针对寿命期不同的互斥方案，直接选取一个适当的分析期作为各个方案共同的研究期，通过比较各个方案在该研究期内的净现值NPV（或者PC）来比选方案。<br>研究期的选择一般以各方案中寿命最短方案为比较的研究期。这种方法计算简便，而且可以避免重复性假设。</p><p>研究期法涉及寿命期结束后，方案的未使用价值的处理问题。其处理方式有三种：<br>第一种考虑方案研究期以外未使用价值；<br>第二种不考虑方案研究期以外未使用价值；<br>第三种预测方案未使用价值在研究期末的价值，并作为现金流入量计算</p></li></ul><p><img src="http://oss.ripplesu.top/blog/%E5%B7%A5%E7%A8%8B%E7%BB%8F%E6%B5%8E%E5%A4%8D%E4%B9%A0/image-20231120144816584.png" alt="image-20231120144816584"></p><ul><li><p>解：年值法</p><p>用净年值(NAV )评价两方案：<br> NAV_A  &#x3D; –10 ( A &#x2F; P,10％,6) + 3 +1.5 ( A／F,10％,6) &#x3D;  0.90 (万元)<br> NAV_B  &#x3D;– 15 ( A／P,10％,9) + 4 + 2 ( A&#x2F;F,10％,9)   &#x3D; 1.54(万元)<br> 所以， B优于A。</p></li><li><p>研究期法</p><p><img src="http://oss.ripplesu.top/blog/%E5%B7%A5%E7%A8%8B%E7%BB%8F%E6%B5%8E%E5%A4%8D%E4%B9%A0/image-20231120144939441.png" alt="image-20231120144939441"></p><ul><li><p>方法一，考虑研究期以外方案未利用价值</p><p>NPVA&#x3D; -10+3 (P&#x2F;A,10%,6) +1.5(P&#x2F;F,10%,6) &#x3D;3.9&gt;0<br>NPVB&#x3D; -15(A&#x2F;P,10%,9) (P&#x2F;A,10%,6) +4 (P&#x2F;A,10%,6) +2(A&#x2F;F,10%,9) (P&#x2F;A,10%,6) &#x3D;6.70&gt;0<br>∴ B比A好</p></li><li><p>方法二，不考虑研究期结束方案未利用价值</p><p>NPVA&#x3D; -10+3 (P&#x2F;A,10%,6) +1.5(P&#x2F;F,10%,6) &#x3D;3.9&gt;0<br>NPVB&#x3D; -15+4 (P&#x2F;A,10%,6) &#x3D;2.42&gt;0<br>A比 B好。</p></li><li><p>方法三，预计研究期结束方案未利用价值为4万元</p><p>NPVA&#x3D; -10+3 (P&#x2F;A,10%,6)+1.5(P&#x2F;F,10%,6)&#x3D;3.9&gt;0<br>NPVB&#x3D; -15+4 (P&#x2F;A,10%,6) ＋ 4(P&#x2F;F,10%,6)&#x3D;4.678&gt;0，　　<br>B 比 A好。</p></li></ul></li></ul><h3 id="不确定性评价"><a href="#不确定性评价" class="headerlink" title="不确定性评价"></a>不确定性评价</h3><p>不确定性评价——主要分析各种外部条件发生变化（如投资、产量、原料价格等发生变化）或者测算数据误差对方案经济效果的影响程度，主要考察方案本身对不确定性因素的承受能力。</p><h4 id="盈亏平衡"><a href="#盈亏平衡" class="headerlink" title="盈亏平衡"></a>盈亏平衡</h4><p><strong>盈亏平衡分析法（BEP法）——是通过分析产品产量、成本和盈利之间的关系，找出方案盈利和亏损在产量、单价、成本等方面的临界点，以判断不确定性因素对方案经济效果的影响程度，说明方案实施风险的大小。</strong></p><p><strong>盈亏平衡点（BEP）：项目的总收入和总成本支出相等时，即不亏不盈状态下的保本产量或保本销售量以及保本单价。</strong></p><p>  利润π＝单价P × 销量Q－（固定成本Cf＋变动成本 Cv × Q）<br>$$<br>Q^*&#x3D;\frac{Cf+利润π}{P*(1-税率)-Cv} \quad P^*&#x3D;C_v+\frac{Cf}{Q_0}<br>$$</p><p>$$<br>盈亏平衡生产能力利用率E&#x3D;\frac{保本销量Q^*}{预期或实际销量Q_0}<em>100%<br>\quad 经营安全率&#x3D;\frac{Q_0-Q^</em>}{Q_0}*100%<br>$$</p><p><img src="http://oss.ripplesu.top/blog/%E5%B7%A5%E7%A8%8B%E7%BB%8F%E6%B5%8E%E5%A4%8D%E4%B9%A0/image-20231120144821021.png" alt="image-20231120144821021"></p><h4 id="敏感性分析"><a href="#敏感性分析" class="headerlink" title="敏感性分析"></a>敏感性分析</h4><p>不确定性因素中对方案经济效果影响程度较大的因素，称之为敏感性因素。<br>敏感性分析法——是分析各种不确定性因素变化一定幅度时（或者变化到何种幅度），对项目方案经济效果的影响程度（或者改变对方案的选择）的一种不确定分析方法。<br>投资者必须及时把握敏感性因素，从敏感性因素发生变化的可能性，分析方案的风险大小。</p><p>分析重点：<br>          1）选择哪些不确定因素作为敏感性因素进行分析。<br>          2）确定敏感性分析的评价指标。</p><p>不确定因素：</p><p> 1）投资额，包括固定资产投资与流动资金占用；<br> 2）产品销售量；<br> 3）产品价格；<br> 4）经营成本，特别是变动成本；<br> 5）汇率、利率；<br> 6）资产残值。</p><p>步骤：</p><p>确定分析的经济效益指标。<br>评价投资项目的经济效益指标主要包括：净现值、内部收益率、投资利润率、投资回收期等。<br>选定不确定性因素，设定其变化范围。<br>计算不确定性因素变动对项目经济效益指标的影响程度，找出敏感性因素。<br>绘制敏感性分析图，求出不确定性因素变化的极限值。</p><h2 id="第六章-设备更新与租赁决策"><a href="#第六章-设备更新与租赁决策" class="headerlink" title="第六章 设备更新与租赁决策"></a>第六章 设备更新与租赁决策</h2><h3 id="设备磨损、补偿与折旧"><a href="#设备磨损、补偿与折旧" class="headerlink" title="设备磨损、补偿与折旧"></a>设备磨损、补偿与折旧</h3><p>设备磨损有<strong>有形磨损、无形磨损</strong>二种形式。</p><ol><li><p>有形磨损（又称物理磨损）<br> 第Ⅰ种有形磨损：设备使用时在<strong>力的作用</strong>下，其零部件到整个设备受到摩擦、冲击、振动或疲劳，使设备的实体遭受到损伤。通常表现为：<br>（1）零部件原始尺寸的改变，甚至其形状发生改变；<br>（2）公差配合性质的改变，以及精度的降低；<br>（3）零部件的损坏。<br> 第Ⅱ种有形磨损：设备在闲置中受到<strong>自然力</strong>的作用产生锈蚀，或是由于缺乏必要的保护、保养而自然丧失精度和工作能力，产生物质磨损。</p></li><li><p>无形磨损（又称精神磨损）<br>第Ⅰ种无形磨损：设备的技术结构和性能并没有变化，但由于设备制造厂<strong>制造工艺不断改进，劳动生产率不断提高而使得生产相同机器设备所需的社会必要劳动减少</strong>，因而使原来购买的设备价值相应贬值了。</p><p>第Ⅱ种无形磨损是由于<strong>科学技术的进步，不断创新出性能更完善、效率更高的设备</strong>，使原有设备相对陈旧落后，其经济效益相对降低而发生贬值。</p></li></ol><p>补偿方式：大修理、现代化改装和更新</p><p>大修理：是更换部分已磨损的零部件和调整设备，以恢复设备的生产功能和效率为主；<br>现代化改造：是对设备的结构作局部的改进和技术上的革新，如增添新的、必须的零部件，以增加设备的生产功能和效率为主。这两者都属于局部补偿。<br>更新：是对整个设备进行更换，属于全部补偿。</p><p>折旧：</p><p><strong>设备资产的折旧</strong>：按期或按活动量将设备磨损转成为产品的成本费用的方式。<br><strong>折旧费</strong>：按期或按活动量转为产品成本费用的设备资产的损耗价值。<br>计算设备折旧时，应考虑以下三个因素：设备资产的原值、净残值和折旧年限。</p><ol><li>设备资产的原值。一般为购置设备时一次性支付的费用，又称初始费用。</li><li>净残值。即设备的残值减去其清理费用以后的余额。</li><li>折旧年限。即按财政部规定的折旧率每年提取折旧，使设备的帐面价值为零所需要的时间。</li></ol><ul><li><p>直线折旧法</p><p>又称平均年限法，它是在设备资产估算的折旧年限里按期平均分摊资产价值的一种计算方法。其每期折旧费的表达式为<br>$$<br>D&#x3D;\frac{P-S}{N_d} \quad 每期折旧率d&#x3D;\frac{D}{P}*100%<br>$$<br>式中：D——每期折旧费，元；<br>        S——折旧期末资产净残值，元；<br>        P——资产的原值，元；<br>      ND——资产的折旧期，单位一般为年；<br> 其中   S＝ S0 － Sc<br>       式中：S0——折旧期末资产预计残值，元；<br>                   Sc——折旧期末预计清理费用，元。</p></li><li><p>年数和折旧法<br>$$<br>D_m&#x3D;\frac{2(N_D-m+1)}{N_D(N_D+1)}(P-S) \quad 折旧率d&#x3D;\frac{D_m}{P}*100%<br>$$</p></li></ul><ul><li><p>双倍余额递减法</p><p>折旧率是按<strong>直线折旧法折旧率的两倍</strong>计算的。这也是一种典型的加速折旧法。<br>年折旧率为：d &#x3D; (2&#x2F;折旧年限) x100%</p></li></ul><p>某设备的资产原值为 10 000元，估计报废时的残值为1000元，清理费用为 0 元，折旧年限为 10 年。计算其年折旧额、折旧率。</p><p><img src="http://oss.ripplesu.top/blog/%E5%B7%A5%E7%A8%8B%E7%BB%8F%E6%B5%8E%E5%A4%8D%E4%B9%A0/image-20230617221004929.png" alt="折旧对比"></p><h3 id="设备更新"><a href="#设备更新" class="headerlink" title="设备更新"></a>设备更新</h3><p>设备更新决策时，应该遵守下面两个原则：<br><strong>不考虑沉没成本</strong>。在设备更新分析中，经常会遇到沉没成本的概念。沉没成本一般不会影响方案的新选择。例如，某设备3年前的原始成本是15 000元，目前的帐面价值是5 000元，现在的净残值仅为3 000元。在进行设备更新分析时，3年前的原始成本为15 000元是过去发生的而与现在决策无关，因此是沉没成本。目前该设备的价值等于净残值3 000元。<br><strong>不要从方案直接陈述的现金流量进行比较分析，而应该立于一个客观介入的立场上比较分析</strong>。</p><ul><li><strong>设备寿命</strong><ol><li>设备的自然寿命，又称物质寿命，即设备从投入使用开始，直到因为在使用过程中发生物质磨损而不能继续使用、报废为止所经历的时间。它主要是由设备的有形磨损所决定的。</li><li>设备的技术寿命，又称有效寿命。它是指设备在市场上维持其价值的时期。具体地说，是指从设备开始使用到因技术落后而被淘汰所延续的时间。它主要是由设备的无形磨损所决定的。</li><li>设备的经济寿命。它是指设备从投入使用开始倒因继续使用不经济而被更新所经历的时间。</li></ol></li></ul><h4 id="年值法"><a href="#年值法" class="headerlink" title="年值法"></a>年值法</h4><p>年值法是指将研究期内的现金流量折算成与之等值的等额支付系列，也即将现金流量年金化。它是估算设备的经济寿命常用的方法。一般情况是要进行逐年比较的，仍然应用年值法。假设年值为AW，年利率为i，则有表达式：<br>$$<br>AW&#x3D;<a href="A/P,i,N">CF_j(P&#x2F;F,i,j)-P</a><br>$$<br>例：某专用设备其购置安装费为12万元，前3年由制造单位保修，第4年、第5年的维护费均为2万元；第5年以后每年比前一年增加2.5万元。不论哪年更新，该设备的残值均不计。假定利率为10％，该设备的经济寿命是多少？</p><p>使用 3年的平均年费用AC＝ 12（A／P， 10％，3）＝ 12 × 0．4021＝4．825（万元）<br>使用 4年的平均年费用&#x3D;［12＋ 2（ P／F， 10％，4）］（A／P， 10％，4）＝（ 12＋ 2 ×0．6830） × 0．3155＝ 4．217（万元）<br>使用 5年的平均年费用&#x3D;［12＋ 2（ P／F， 10％，4）＋ 2（ P／F， 10％，5）］×（A／P，10％，5）＝ （l＋ 2 × 0．6830＋ 2 × 0．6209） ×0．2638＝ 3．854（万元）<br>使用6年的平均年费用＝［12＋2（P／F，10％，4）＋2（P／F，10％，5）＋4．5（P／F，10％，6）］×（A／P，10％，6）＝（12＋2 × 0．6830＋2 ×0．6209＋ 4．5 × 0．5645）× 0．2296＝ 3．937（万元）<br>该设备的经济寿命为5年。</p><h4 id="平均年费用法"><a href="#平均年费用法" class="headerlink" title="平均年费用法"></a>平均年费用法</h4><p>当设备项目的现金流量以考虑费用为主时，可用平均年费用（AAC，就是AC）法。</p><p>使用期为N年设备平均年费用为<strong>AAC＝（P－S）·（A／P，i，N）＋S·i＋Y0＋Ym</strong><br>式中：Y0——平均年营运费，元；Ym——平均年维修费，元</p><p><img src="http://oss.ripplesu.top/blog/%E5%B7%A5%E7%A8%8B%E7%BB%8F%E6%B5%8E%E5%A4%8D%E4%B9%A0/image-20231120144910466.png" alt="image-20231120144910466"></p><p>设新、旧设备的平均年费用分别为AACN与AAC0，则<br> AACN＝（35 000－4 000）×（A／P，12％，10）＋4 000 ×0.12＋500＝31 000 × 0．177＋480 ＋ 500<br>　　＝6  467（元）<br>AACo＝（8000－2000）×（A／P，12％，4）＋2 000×0.12＋[3 000（P／F，12％，1）＋4 000（P／F，12％，2）＋5 000（P／F，12％，3）＋6 000（P／F，12％，4）]（A／P，12％，4） ＝ 6000  × 0.3292＋240＋（3000  × 0.892  9＋4000×0．797 2＋5 000 ×0．7118＋6 000 × 0．635 5）×0.329 2＝6 503.27（元）<br>        AACN＜AACo，所以旧设备应该更换。 </p><p>保留一年：AAC0（1）＝（8 000－6 500）（A／P，12％，l）＋6 500 ×0.12＋3 000＝5460（元）＜6467（元），应保留。<br>保留2年：AAC0（2）＝（6 500－5 000）（A／P，12％，l）＋5 000 ×0.12＋4 000＝6280（元）＜6467（元），应保留。<br>保留3年：<br>AAC0（3）＝（5 000－3 500）×（A／P，12％，l）＋3 500 × 0.12＋5 000＝7100（元）＞6467元，应更换。<br>旧设备应继续保留使用2年，于第2年年末更换。</p><h2 id="第七章-价值工程"><a href="#第七章-价值工程" class="headerlink" title="第七章 价值工程"></a>第七章 价值工程</h2><h3 id="提高价值的五种途径"><a href="#提高价值的五种途径" class="headerlink" title="提高价值的五种途径"></a>提高价值的五种途径</h3><p>成本降低，功能提高</p><p>成本不变，功能提高</p><p>功能不变，成本下降</p><p>成本略有增加，功能大幅度提高</p><p>功能略有下降，成本大幅度下降</p><h3 id="价值工程定义-价值的定义"><a href="#价值工程定义-价值的定义" class="headerlink" title="价值工程定义 价值的定义"></a>价值工程定义 价值的定义</h3><p>价值工程：<strong>以产品或作业的功能分析为核心，以提高产品或作业的价值为目的，力求以最低寿命周期成本实现产品或作业使用所要求的必要功能的一项有组织的创造性活动。</strong></p><p>价值：价值工程中所述的价值，是指对象（产品或作业）具有的必要功能与取得该功能的总成本的比值，即效用（或功能）与费用之比。</p><h2 id="公式总结"><a href="#公式总结" class="headerlink" title="公式总结"></a>公式总结</h2><p><img src="http://oss.ripplesu.top/blog/%E5%B7%A5%E7%A8%8B%E7%BB%8F%E6%B5%8E%E5%A4%8D%E4%B9%A0/image-20231120144917001.png" alt="image-20231120144917001"></p>]]></content>
      
      
      <categories>
          
          <category> 学习总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工程经济 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于commons-pool2自定义对象池</title>
      <link href="/2023/03/22/%E5%9F%BA%E4%BA%8Ecommons-pool2%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AF%B9%E8%B1%A1%E6%B1%A0/"/>
      <url>/2023/03/22/%E5%9F%BA%E4%BA%8Ecommons-pool2%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AF%B9%E8%B1%A1%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<p>大多时候，我们获取对象的方法都是直接 new 一个。但是，对于构造耗时比较久的对象，比如数据库的连接对象、Redis 的连接对象、Http 连接请求对象等等，如果每次要使用都去 new 一个是很不科学的。在设计模式中有一个专门的模式来解决这种场景下的问题，即“享元模式”。  </p><p>“享元模式”其实很好理解，也就是构造一个对象池，这个对象池中维护一定数量的对象，需要的时候就从这个对象池中获取对象，使用完后返还给对象池。这样就避免构造对象所带来的耗时，提升了系统的性能。  </p><p>设计这样的一个对象池看起来好像并不难。但是，如果考虑到系统的伸缩性、健壮性，比如在系统忙时可能需要对象池中有足够的对象可以被拿来使用，同时，在系统闲时又不需要太多的对象存放在对象池中，以免浪费内存。另外，还需要考虑对象何时构造，何时销毁，对象异常的处理等问题。  </p><p>apache 的 commons-pool2正是为了解决这些问题而生。基于它，我们只需要关注对象的生成、销毁、校验等操作就可以了。对象池的具体实现细节都交给 commons-pool2 中的具体对象池实现类来完成。  </p><h3 id="commons-pool2-核心接口"><a href="#commons-pool2-核心接口" class="headerlink" title="commons-pool2 核心接口"></a>commons-pool2 核心接口</h3><p>apache commons-pool2 包提供了一个通用的对象池技术的实现。可以很方便的基于它来实现自己的对象池，比如 DBCP 和 Jedis 他们的内部对象池的实现就是依赖于 commons-pool2 。<br>commons-pool2 由三大模块组成：ObjectPool 、PooledObject 和 PooledObjectFactory 。  </p><h4 id="ObjectPool"><a href="#ObjectPool" class="headerlink" title="ObjectPool"></a>ObjectPool</h4><p>提供所有对象的存取管理。<br>核心方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从对象池中获取对象的方法</span></span><br><span class="line">T <span class="title function_">borrowObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception, NoSuchElementException,</span><br><span class="line">        IllegalStateException;</span><br><span class="line"><span class="comment">//将对象返还给对象池</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">returnObject</span><span class="params">(T obj)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line"><span class="comment">//让对象失效</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">invalidateObject</span><span class="params">(T obj)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line"><span class="comment">//往对象池中新增一个对象</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">addObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception, IllegalStateException,</span><br><span class="line">        UnsupportedOperationException;</span><br><span class="line"><span class="comment">//获取当前闲置在对象池中的对象数量，即没有被拿走使用的对象数量</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getNumIdle</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">//获取已经在使用中的对象数量，即被使用者从对象池中拿走使用的数量</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getNumActive</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">//清空对象池中闲置的所有对象</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> <span class="keyword">throws</span> Exception, UnsupportedOperationException;</span><br><span class="line"><span class="comment">//关闭对象池</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><h4 id="PooledObjectFactory"><a href="#PooledObjectFactory" class="headerlink" title="PooledObjectFactory"></a>PooledObjectFactory</h4><p>工厂类，负责池化对象的创建，对象的初始化，对象状态的销毁和对象状态的验证。其实现要求是线程安全的。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造一个原始对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> T <span class="title function_">create</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line"><span class="comment">// 将原始对象包装为池内对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> PooledObject&lt;T&gt; <span class="title function_">wrap</span><span class="params">(T var1)</span>;</span><br><span class="line"><span class="comment">// 构造原始对象并包装为池内对象</span></span><br><span class="line"><span class="keyword">public</span> PooledObject&lt;T&gt; <span class="title function_">makeObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.wrap(<span class="built_in">this</span>.create());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 销毁对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroyObject</span><span class="params">(PooledObject&lt;T&gt; p)</span> <span class="keyword">throws</span> Exception</span><br><span class="line"><span class="comment">// 验证对象是否可用</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">validateObject</span><span class="params">(PooledObject&lt;T&gt; p)</span> </span><br><span class="line"><span class="comment">// 激活对象，使其可用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">activateObject</span><span class="params">(PooledObject&lt;T&gt; p)</span> <span class="keyword">throws</span> Exception</span><br></pre></td></tr></table></figure><h4 id="PooledObject"><a href="#PooledObject" class="headerlink" title="PooledObject"></a>PooledObject</h4><p>池化的对象，是对真正对象的一个包装，加上了对象的一些其他信息，包括对象的状态（已用、空闲），对象的创建时间等。其实现要求是线程安全的。  </p><p>通常，ObjectPool 会持有 PooledObjectFactory ，将具体的对象的创建、初始化、销毁等任务委托给 PooledObjectFactory 处理，工厂操作的对象是 PooledObject ，即具体的 Object 的包装类。因此，获取对象依赖的是 ObjectPool 而不是 PooledObjectFactory 。</p><h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><h4 id="池化对象工厂类"><a href="#池化对象工厂类" class="headerlink" title="池化对象工厂类"></a>池化对象工厂类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestObjectFactory</span> <span class="keyword">extends</span> <span class="title class_">BasePooledObjectFactory</span>&lt;TestObject&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> TestObject <span class="title function_">create</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="comment">// 构造一个初始对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TestObject</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> PooledObject&lt;TestObject&gt; <span class="title function_">wrap</span><span class="params">(TestObject testObject)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultPooledObject</span>&lt;&gt;(testObject);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroyObject</span><span class="params">(PooledObject&lt;FaceEngine&gt; p)</span>&#123;</span><br><span class="line"><span class="comment">// 自定义销毁方法</span></span><br><span class="line">        p.getObject().unInit();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="对象池"><a href="#对象池" class="headerlink" title="对象池"></a>对象池</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestObjectPool</span> <span class="keyword">extends</span> <span class="title class_">GenericObjectPool</span>&lt;TestObject&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TestObjectPool</span><span class="params">(PooledObjectFactory&lt;TestObject&gt; factory)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(factory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TestObjectPool</span><span class="params">(PooledObjectFactory&lt;TestObject&gt; factory, GenericObjectPoolConfig&lt;TestObject&gt; config)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(factory, config);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TestObjectPool</span><span class="params">(PooledObjectFactory&lt;TestObject&gt; factory, GenericObjectPoolConfig&lt;TestObject&gt; config, AbandonedConfig abandonedConfig)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(factory, config, abandonedConfig);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="配置属性"><a href="#配置属性" class="headerlink" title="配置属性"></a>配置属性</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;pool&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PoolProperties</span> &#123;</span><br><span class="line">    <span class="comment">// 最大空闲</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> maxIdle;</span><br><span class="line">    <span class="comment">// 最大总数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> maxTotal;</span><br><span class="line">    <span class="comment">// 最小空闲</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> minIdle;</span><br><span class="line">    <span class="comment">// 初始化连接数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> initialSize;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="自动配置类"><a href="#自动配置类" class="headerlink" title="自动配置类"></a>自动配置类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableConfigurationProperties(PoolProperties.class)</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PoolAutoConfiguration</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PoolProperties poolProperties;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TestObjectFactory testObjectFactory;</span><br><span class="line">    <span class="keyword">private</span> TestObjectPool pool;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PoolAutoConfiguration</span><span class="params">(PoolProperties poolProperties, TestObjectFactory testObjectFactory)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.poolProperties = poolProperties;</span><br><span class="line">        <span class="built_in">this</span>.testObjectFactory = testObjectFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ConditionalOnClass(&#123;TestObjectFactory.class&#125;)</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">protected</span> TestObjectPool <span class="title function_">testObjectPool</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//设置对象池的相关参数</span></span><br><span class="line">        GenericObjectPoolConfig&lt;TestObject&gt; poolConfig = <span class="keyword">new</span> <span class="title class_">GenericObjectPoolConfig</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 最大闲对象数</span></span><br><span class="line">        poolConfig.setMaxIdle(poolProperties.getMaxIdle());</span><br><span class="line">        <span class="comment">// 最大对象数</span></span><br><span class="line">        poolConfig.setMaxTotal(poolProperties.getMaxTotal());</span><br><span class="line">        <span class="comment">// 最小闲对象数</span></span><br><span class="line">        poolConfig.setMinIdle(poolProperties.getMinIdle());</span><br><span class="line">        <span class="comment">// 30分钟执行一次对象扫描，将无用的对象销毁，默认-1不扫描</span></span><br><span class="line">        poolConfig.setTimeBetweenEvictionRunsMillis(<span class="number">1000</span> * <span class="number">60</span> * <span class="number">30</span>);</span><br><span class="line">        <span class="comment">// 在获取对象的时候检查有效性, 默认false</span></span><br><span class="line">        poolConfig.setTestOnBorrow(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">// 在归还对象的时候检查有效性, 默认false</span></span><br><span class="line">        poolConfig.setTestOnReturn(<span class="literal">false</span>);</span><br><span class="line">        <span class="comment">// 在空闲时检查有效性, 默认false</span></span><br><span class="line">        poolConfig.setTestWhileIdle(<span class="literal">false</span>);</span><br><span class="line">        <span class="comment">// 最大等待时间， 默认的值为-1，表示无限等待。</span></span><br><span class="line">        poolConfig.setMaxWaitMillis(-<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 是否启用后进先出, 默认true</span></span><br><span class="line">        poolConfig.setLifo(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">// 连接耗尽时是否阻塞, false立即抛异常,true阻塞直到超时, 默认true</span></span><br><span class="line">        poolConfig.setBlockWhenExhausted(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">// 每次逐出检查时 逐出的最大数目 默认3</span></span><br><span class="line">        poolConfig.setNumTestsPerEvictionRun(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">//一定要关闭jmx，不然springboot启动会报已经注册了某个jmx的错误</span></span><br><span class="line">        poolConfig.setJmxEnabled(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//新建一个对象池,传入对象工厂和配置</span></span><br><span class="line">        pool = <span class="keyword">new</span> <span class="title class_">TestObjectPool</span>(testObjectFactory, poolConfig);</span><br><span class="line"></span><br><span class="line">        initPool(poolProperties.getInitialSize(), poolProperties.getMaxIdle());</span><br><span class="line">        <span class="keyword">return</span> pool;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 预先加载testObject对象到对象池中</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> initialSize 初始化连接数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> maxIdle     最大空闲连接数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initPool</span><span class="params">(<span class="type">int</span> initialSize, <span class="type">int</span> maxIdle)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (initialSize &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> Math.min(initialSize, maxIdle);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                pool.addObject();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pool != <span class="literal">null</span>) &#123;</span><br><span class="line">            pool.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">TestObjectPool testObjectPool;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">TestObject</span> <span class="variable">testObject</span>  <span class="operator">=</span> testObjectPool.borrowObject();</span><br><span class="line">    <span class="comment">// Do something</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    testObjectPool.returnObject(testObject);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 对象池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hadoop伪分布式集群搭建</title>
      <link href="/2023/03/10/Hadoop%E4%BC%AA%E5%88%86%E5%B8%83%E5%BC%8F%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/"/>
      <url>/2023/03/10/Hadoop%E4%BC%AA%E5%88%86%E5%B8%83%E5%BC%8F%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<p>操作系统：Ubuntu22.04<br>Hadoop：3.3.4<br>参考《大数据技术原理与应用》——林子雨。</p><h3 id="安装SSH和配置无密码登录"><a href="#安装SSH和配置无密码登录" class="headerlink" title="安装SSH和配置无密码登录"></a>安装SSH和配置无密码登录</h3><p>对于 Hadoop 的伪分布式和完全分布式而言，Hadoop 名称节点（NameNode）需要启动集群<br>中所有机器的 Hadoop 守护进程，这个过程可以通过 SSH 登录来实现。Hadoop 并没有提供 SSH输入密码登录的形式，因此，为了能够顺利登录每台机器，需要将所有机器配置为名称节点可以无密码登录它们。<br>为了实现 SSH 无密码登录，需要在 Ubuntu 操作系统上安装 SSH 服务端和客户端。Ubuntu<br>操作系统默认已安装了 SSH 客户端，因此这里只需要安装 SSH 服务端，命令如下：<br><code>$ sudo apt-get install openssh-server</code><br>安装以后，可以使用如下命令登录本机：<br><code>$ ssh localhost</code><br>出现提示后，输人“yes”，并输入密码，就可以登录到本机了。但是，这样登承是需要每次都输入密码的，因此，我们需要配置成 SSH 无密码登录。<br>退出刚才的 SSH 登录，然后利用 ssh-keygen 生成密钥，并将密钥加入授权，具体命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">exit</span></span><br><span class="line">$ <span class="built_in">cd</span> ~/.ssh/</span><br><span class="line">$ ssh-keygen -t rsa</span><br></pre></td></tr></table></figure><p><img src="http://oss.ripplesu.top/blog/Hadoop%E4%BC%AA%E5%88%86%E5%B8%83%E5%BC%8F%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/72873834-99e5-41fe-b1d1-a376ca64a8b0.png" alt="image.png"><br>这里都输入回车即可。然后输入命令：<br><code>$ cat ./id_rsa.pub &gt;&gt;./authorized_keys</code><br>此时再用 ssh localhost 命令，无须输入密码就可以直接登录了。</p><h3 id="安装java环境"><a href="#安装java环境" class="headerlink" title="安装java环境"></a>安装java环境</h3><p>以Hadoop3.3.4而言，需要jdk1.8以上版本。  可以到Oracle官网下载jdk1.8的安装包，也可使用apt安装。<br>以apt为例，输入如下命令搜索jdk：<code>$ apt search jdk</code><br>然后输入<code>$ apt install openjdk-8-jdk</code>安装jdk1.8。<br>接下来配置环境变量。输入<code>$ vim ~/.bashrc</code>，在文件首部加入如下语句：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/usr/lib/jvm/java-<span class="number">8</span>-openjdk-amd64</span><br><span class="line">export JRE_HOME=$&#123;JAVA_HOME&#125;/jre</span><br><span class="line">export CIASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/lib</span><br><span class="line">export PATH=$&#123;JAVA_HOME&#125;/bin:$PATH</span><br></pre></td></tr></table></figure><p>保存并退出即可。</p><h3 id="安装单机Hadoop"><a href="#安装单机Hadoop" class="headerlink" title="安装单机Hadoop"></a>安装单机Hadoop</h3><p>在采用单机模式时，Hadoop 只在一台机器上运行，存储采用本地文件系统，没有采用分布式<br>文件系统 HDFS。这里使用的 Hadoop 版本为 3.3.4，下载地址为 http:&#x2F;hadoop.apache.ong&#x2F;releases.html#Download，在页面中选择 hadoop-3.3.4.targz 进行下载即可。这里假设安装文件被保存到了Ubuntu 操作系统的“～&#x2F;Downloads”目录下，可以执行如下命令进行安装：  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo tar -zxf ~/Downloads/hadoop-3.3.4.tar.gz -C /usr/local</span><br><span class="line">$ <span class="built_in">cd</span> /usr/local/</span><br><span class="line">$ sudo <span class="built_in">mv</span> ./hadoop-3.3.4/ ./hadoop <span class="comment"># 修改目录名</span></span><br><span class="line">$ sudo <span class="built_in">chown</span> -R hadoop ./hadoop <span class="comment"># 修改文件主</span></span><br></pre></td></tr></table></figure><p>然后，可以运行如下命令查看 Hadoop 的版本信息：<br><code>$ ./bin/hadoop version</code><br>Hadoop 文档中还附带了一些例子供我们测试，现在可以运行 Grep 实例来检测一下 Hadoop<br>是否安装成功。<br>首先，在 Hadoop 安装目录下新建 input 目录，用来存放输入数据，命令如下:  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /usr/local/hadoop</span><br><span class="line">$ <span class="built_in">mkdir</span> input</span><br></pre></td></tr></table></figure><p>然后，将“&#x2F;usr&#x2F;local&#x2F;hadoop&#x2F;ete&#x2F;hadoop”目录下的配置文件复制到 input 目录，命令如下：<br><code>$ cp ./etc/hadoop/*.xml ./input</code><br>接下来，执行如下代码运行 Grep 实例：<br><code>$ ./bin/hadoop jar /usr/local/hadoop/share/hadoop/mapreduce/hadoop-mapreduce-examples-3.3.4.jar grep ./input ./output &#39;dfs[a-z.]+&#39;</code><br>最后，可以执行以下命令查看输出数据：<br><code>$ cat ./output/*</code><br>运行上面命令后，可以得到以下结果：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dfsadmin</span><br><span class="line">dfs.replication</span><br><span class="line">dfs.namenode.name.dir</span><br><span class="line">dfs.datanode.data.dir</span><br></pre></td></tr></table></figure><h3 id="Hadoop-伪分布式安装"><a href="#Hadoop-伪分布式安装" class="headerlink" title="Hadoop 伪分布式安装"></a>Hadoop 伪分布式安装</h3><p>在分布式安装时，Hadoop 存储采用分布式文件系统 HDFS，而且，HDFS 的名称节点和数据<br>节点位于集群的不同机器上。伪分布式安装是指在一台机器上模拟一个小的集群，但是集群中只<br>有一个节点。在采用伪分布式模式时，Hadoop 的存储采用分布式文件系统 HDFS，但是，HDFS<br>的名称节点和数据节点都在同一台机器上。需要说明的是，在一台机器上也是可以实现完全分布<br>式安装的（而不是伪分布式)。只要在一台机器上安装多个 Linux 虚拟机，使每个 Linux 虚拟机成为一个节点，就可以实现 Hadoop 的完全分布式安装。这里只介绍伪分布式安装。<br>当 Hadoop 应用于集群时，不论是伪分布式还是真正的分布式运行，都需要通过配置文件对各组件的协同工作进行设置。对于伪分布式配置，我们需要修改 core-site.xml 和 hdfs-site.xml 这两个文件（位于安装目录下的<code>etc/hadoop/</code>目录）。<br>修改后的 core-site.xml 文件的内容如下：  </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>hadoop.tmp.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>file:/usr/local/hadoop/tmp<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">description</span>&gt;</span>Abase for other temporary directories.<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.defaultFS<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://localhost:9000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>修改后的 hdfs-site.xml 文件的内容如下：  </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.replication<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.name.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>file:/usr/local/hadoop/tmp/dfs/name<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.datanode.data.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>file:/usr/local/hadoop/tmp/dfs/data<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对于 hds-sitce.xnl 文件，这里设置 replication 值为1，这也是 Hadoop 运行的默认最小值，它限制了 HDFS 中同一份数据的副本数量。由于这里采用伪分布式，集群中只有一个节点，因此副本数量 replication 的值也只能设置为 1。  </p><p>在配置完成后，首先需要初始化文件系统，由于 Hadeop 的很多工作是在自带的 HDFS 上完成的，因此，需要将文件系统初始化之后才能进一步执行计算任务。执行初始化的命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /usr/local/hadoop</span><br><span class="line">$ ./bin/hdfs namenode -format</span><br></pre></td></tr></table></figure><p>执行结果如下:<br><img src="http://oss.ripplesu.top/blog/Hadoop%E4%BC%AA%E5%88%86%E5%B8%83%E5%BC%8F%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/88f7f863-3fd5-4823-bc67-e78104468f75.png" alt="image.png"><br>出现<strong>successfully formatted</strong>即配置成功。  </p><p>文件系统初始化成功以后，可以用如下命令启动 HDFS：  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /ust/local/hadoop </span><br><span class="line">$ ./sbin/start-dfs.sh</span><br></pre></td></tr></table></figure><p>如遇到如下错误，可在Hadoop安装目录下的<code>etc/hadoop/hadoop-env.sh</code>中添加：<br><code>export JAVA_HOME=/usr/lib/jvm/java-8-openjdk-amd64</code><br><img src="http://oss.ripplesu.top/blog/Hadoop%E4%BC%AA%E5%88%86%E5%B8%83%E5%BC%8F%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/aee9d0ee-41ce-4ac5-b0f3-74aac4cfec57.png" alt="image.png"><br>启动之后，可以输人 jps指令查看所有的 Java 选程。如果 IIDFS 启动成功，可以得到如下类似结果：<br><img src="http://oss.ripplesu.top/blog/Hadoop%E4%BC%AA%E5%88%86%E5%B8%83%E5%BC%8F%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/b86e9970-d50c-409f-bc16-57291d5eb6ce.png" alt="image.png"></p><p>此时，可以访问 Web 页面（htp:&#x2F;localhost:9870）来查看 Hadoop 的信息。<br><img src="http://oss.ripplesu.top/blog/Hadoop%E4%BC%AA%E5%88%86%E5%B8%83%E5%BC%8F%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/f97a261f-3a0d-4df0-aab6-271d53dd7d80.png" alt="image.png">  </p><p>接下来，执行如下命令，在 HDFS 中创建 hadoop 用户的用户目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /usr/local/hadoop</span><br><span class="line">$ ./bin/hdfs dfs -<span class="built_in">mkdir</span> -p /user/hadoop</span><br></pre></td></tr></table></figure><p>然后，在 HDFS 的“&#x2F;user&#x2F;hadoop”目录下创建 input目录，命令如下：<br><code>$ ./bin/hdfs dfs -mkdir input</code><br>如遇到下述问题，可用如下命令解决：  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">groupadd supergroup</span><br><span class="line">usermod -a -G supergroup root <span class="comment"># 要加入组的用户</span></span><br></pre></td></tr></table></figure><p><img src="http://oss.ripplesu.top/blog/Hadoop%E4%BC%AA%E5%88%86%E5%B8%83%E5%BC%8F%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/1dd70553-64d8-4489-a3a4-af9296c4a64f.png" alt="image.png">  </p><p>现在，需要将“&#x2F;us&#x2F;local&#x2F;hadoop&#x2F;ete&#x2F;hadoop”目录下的本地文本文件（配置文件）“上传”到<br>分布式文件系统 HDFS 中的“&#x2F;user&#x2F;hadoop&#x2F;input”目录下。当然，这里的“上传”并不意味着数据通过网络传输。实际上，在伪分布式 Hadoop 环境下，本地的“&#x2F;usr&#x2F;localhadoop&#x2F;et&#x2F;hadoop”目录和 HDFS 中的“&#x2F;user&#x2F;hadoop&#x2F;input”目录都在同一台机器上，并不需要通过网络传输数据。可以执行如下命令实现文件“上传”：<br><code>$ ./bin/hdfs dfs -put ./etc/hadoop/*.xml input</code><br>接着，运行如下命令来执行测试样例程序 Grep：<br><code>$ ./bin/hadoop jar /usr/local/hadoop/share/hadoop/mapreduce/hadoop-mapreduce-examples-3.3.4.jar grep input output &#39;dfs[a-z.]+&#39;</code><br>如遇到错误：<code>ENOENT: No such file or directory</code>，可尝试在su模式下重试上述操作。  </p><p>在计算完成后，系统会自动在 HDFS 中生成“&#x2F;user&#x2F;hadoop&#x2F;output”目录来存储计算结果。可<br>以输人如下命令查看最终结果：<br><code>$ ./bin/hdfs dfs -cat output/*</code><br>运行上面命令后，可以得到以下结果:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dfsadmin</span><br><span class="line">dfs.replication</span><br><span class="line">dfs.namenode.name.dir</span><br><span class="line">dfs.datanode.data.dir</span><br></pre></td></tr></table></figure><p>最后需要指出的是，当需要重新运行程序时，首先应将 HDFS 中的 output目录删除，然后运行程序。删除 output 目录的命令如下：<br><code>$ ./bin/hdfs dfs -rm -r output </code><br>需要停止运行 HDFS 时，可以执行如下命令：  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /usr/local/hadoop</span><br><span class="line">$ ./sbin/stop-dfs.sh</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 实验实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hadoop </tag>
            
            <tag> 配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git常用命令</title>
      <link href="/2023/02/27/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2023/02/27/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>总结一下Git常用命令与日常使用git遇到的问题。</p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="获取-Git-仓库"><a href="#获取-Git-仓库" class="headerlink" title="获取 Git 仓库"></a>获取 Git 仓库</h3><p>有两种取得 Git 项目仓库的方法。</p><ol><li>在现有目录中初始化仓库: 进入项目目录运行 <code>git init</code> 命令,该命令将创建一个名为 <code>.git</code> 的子目录。</li><li>从一个服务器克隆一个现有的 Git 仓库: <code>git clone [url]</code> 自定义本地仓库的名字: <code>git clone [url] directoryname</code></li></ol><h3 id="记录每次更新到仓库"><a href="#记录每次更新到仓库" class="headerlink" title="记录每次更新到仓库"></a>记录每次更新到仓库</h3><ol><li><strong>检测当前文件状态</strong> : <code>git status</code></li><li><strong>提出更改（把它们添加到暂存区</strong>）：<code>git add filename</code> (针对特定文件)、<code>git add *</code>(所有文件)、<code>git add *.txt</code>（支持通配符，所有 .txt 文件）</li><li><strong>忽略文件</strong>：<code>.gitignore</code> 文件</li><li><strong>提交更新:</strong> <code>git commit -m &quot;代码提交信息&quot;</code> （每次准备提交前，先用 <code>git status</code> 看下，是不是都已暂存起来了， 然后再运行提交命令 <code>git commit</code>）</li><li><strong>跳过使用暂存区域更新的方式</strong> : <code>git commit -a -m &quot;代码提交信息&quot;</code>。 <code>git commit</code> 加上 <code>-a</code> 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 <code>git add</code> 步骤。</li><li><strong>移除文件</strong>：<code>git rm filename</code> （从暂存区域移除，然后提交。）加上-n选项则先预览此命令要删除的文件列表，而不会执行删除。</li><li><strong>对文件重命名</strong>：<code>git mv README.md README</code>(这个命令相当于<code>mv README.md README</code>、<code>git rm README.md</code>、<code>git add README</code> 这三条命令的集合)</li></ol><h3 id="推送改动到远程仓库"><a href="#推送改动到远程仓库" class="headerlink" title="推送改动到远程仓库"></a>推送改动到远程仓库</h3><ul><li><p>如果你还没有克隆现有仓库，并欲将你的仓库连接到某个远程服务器，你可以使用如下命令添加：<code>git remote add origin &lt;server&gt;</code> ,比如我们要让本地的一个仓库和 GitHub 上创建的一个仓库关联可以这样<code>git remote add origin https://github.com/Snailclimb/test.git</code></p></li><li><p>将这些改动提交到远端仓库：<code>git push origin master</code> (可以把 <em>master</em> 换成你想要推送的任何分支)</p><p>如此你就能够将你的改动推送到所添加的服务器上去了。</p></li></ul><h3 id="远程仓库的移除与重命名"><a href="#远程仓库的移除与重命名" class="headerlink" title="远程仓库的移除与重命名"></a>远程仓库的移除与重命名</h3><ul><li>将 test 重命名为 test1：<code>git remote rename test test1</code></li><li>移除远程仓库 test1:<code>git remote rm test1</code></li></ul><h3 id="查看提交历史"><a href="#查看提交历史" class="headerlink" title="查看提交历史"></a>查看提交历史</h3><p>在提交了若干更新，又或者克隆了某个项目之后，你也许想回顾下提交历史。 完成这个任务最简单而又有效的工具是 <code>git log</code> 命令。<code>git log</code> 会按提交时间列出所有的更新，最近的更新排在最上面。</p><p><strong>可以添加一些参数来查看自己希望看到的内容：</strong></p><p>只看某个人的提交记录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --author=bob</span><br></pre></td></tr></table></figure><h3 id="撤销操作"><a href="#撤销操作" class="headerlink" title="撤销操作"></a>撤销操作</h3><p>有时候我们提交完了才发现漏掉了几个文件没有添加，或者提交信息写错了。 此时，可以运行带有 <code>--amend</code> 选项的提交命令尝试重新提交：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend</span><br></pre></td></tr></table></figure><p>取消暂存的文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset filename</span><br></pre></td></tr></table></figure><p>撤消对文件的修改:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- filename</span><br></pre></td></tr></table></figure><p>假如你想丢弃你在本地的所有改动与提交，可以到服务器上获取最新的版本历史，并将你本地主分支指向它：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin</span><br><span class="line">git reset --hard origin/master</span><br></pre></td></tr></table></figure><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><p>分支是用来将特性开发绝缘开来的。在你创建仓库的时候，<em>master</em> 是“默认”的分支。在其他分支上进行开发，完成后再将它们合并到主分支上。</p><p>我们通常在开发新功能、修复一个紧急 bug 等等时候会选择创建分支。单分支开发好还是多分支开发好，还是要看具体场景来说。</p><p>创建一个名字叫做 test 的分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>切换当前分支到 test（当你切换分支的时候，Git 会重置你的工作目录，使其看起来像回到了你在那个分支上最后一次提交的样子。 Git 会自动添加、删除、修改文件以确保此时你的工作目录和这个分支最后一次提交时的样子一模一样）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>你也可以直接这样创建分支并切换过去(上面两条命令的合写)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b feature_x</span><br></pre></td></tr></table></figure><p>切换到主分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br></pre></td></tr></table></figure><p>合并分支(可能会有冲突)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>把新建的分支删掉</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d feature_x</span><br></pre></td></tr></table></figure><p>将分支推送到远端仓库（推送成功后其他人可见）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin</span><br></pre></td></tr></table></figure><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="Git冲突？"><a href="#Git冲突？" class="headerlink" title="Git冲突？"></a>Git冲突？</h3><ol><li>手动解决冲突：当 Git 发生冲突时，会提示你哪些文件发生了冲突。此时，你需要手动打开这些文件，查看冲突的部分，并决定如何解决冲突。通常，你可以选择保留自己的修改、保留别人的修改或者合并两者的修改。</li><li>使用 Git 工具解决冲突：Git 提供了一些工具来帮助你解决冲突，例如 <code>git mergetool</code> 命令。这个命令会打开一个图形化的工具，帮助你比较两个版本的文件，并进行合并。</li><li>合并提交：如果你和别人对同一个文件的不同部分进行了修改，那么你可以将你的修改和别人的修改合并到一起，然后提交一个新的版本。这样可以避免冲突。</li></ol><h3 id="gitignore全局配置"><a href="#gitignore全局配置" class="headerlink" title="gitignore全局配置"></a>gitignore全局配置</h3><ul><li>创建.gitignore_global 文件<ul><li>Win<br>在 C盘 -&gt; 用户 -&gt; 当前用户 -&gt; 创建  .gitignore_global 文件</li><li>Linux<br>在home目录创建 ~&#x2F;.gitignore_global 文件</li></ul></li><li>向.gitignore_global文件加入需要忽略的内容</li><li>执行git指令<br><code>git config --global core.excludesfile ~/.gitignore_global</code></li></ul><h3 id="不小心push了一些敏感数据"><a href="#不小心push了一些敏感数据" class="headerlink" title="不小心push了一些敏感数据"></a>不小心push了一些敏感数据</h3><h4 id="方法1：清除git仓库所有提交记录"><a href="#方法1：清除git仓库所有提交记录" class="headerlink" title="方法1：清除git仓库所有提交记录"></a>方法1：清除git仓库所有提交记录</h4><p><strong>参考：<a href="https://blog.csdn.net/icansoicrazy/article/details/128342811">https://blog.csdn.net/icansoicrazy/article/details/128342811</a></strong></p><ol><li>切换到新的分支<br><code>git checkout --orphan latest_branch</code><br>说明：git checkout –orphan 的核心用途是，以类似git init的状态创建新的非父分支，也就是创建一个无提交记录的分支。</li><li>缓存所有文件（除了.gitignore中声明排除的）<br><code>git add -A</code></li><li>提交跟踪过的文件（Commit the changes）<br><code>git commit -am &quot;commit message&quot;</code></li><li>删除master分支（Delete the branch）<br><code>git branch -D master</code></li><li>重命名当前分支为master（Rename the current branch to master）<br><code>git branch -m master</code></li><li>强制提交到远程master分支 （Finally, force update your repository）<br><code>git push -f origin master</code></li></ol><h4 id="方法2：使用bfg"><a href="#方法2：使用bfg" class="headerlink" title="方法2：使用bfg"></a>方法2：使用bfg</h4><ol><li>fork 要清除敏感信息的项目到个人仓库中，并clone仓库到本地：<br><code>$ git clone --mirror git@github.com:xxx/xxx.git</code></li><li>备份xxx.git<br>备份一份到另一个文件夹即可，主要用于操作失败后，重新push该仓库用来恢复数据。</li><li>下载bfg.jar与xxx.git同目录</li><li>准备一个文本文件，里面包含要要替换的文本<br>passwords.txt<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PASSWORD1                       # Replace literal string &#x27;PASSWORD1&#x27; with &#x27;***REMOVED***&#x27; (default)</span><br><span class="line">PASSWORD2==&gt;examplePass         # replace with &#x27;examplePass&#x27; instead</span><br><span class="line">PASSWORD3==&gt;                    # replace with the empty string</span><br><span class="line">regex:password=\w+==&gt;password=  # Replace, using a regex</span><br><span class="line">regex:\r(\n)==&gt;$1               # Replace Windows newlines with Unix newlines</span><br></pre></td></tr></table></figure>如本例中，用127.0.0.1代替敏感IP，只需在passwords.txt中添加172.1.1.1&#x3D;&#x3D;&gt;127.0.0.1。</li><li>cd xxx.git</li><li>开始替换仓库中的敏感信息<br><code>$  java -jar bfg.jar --replace-text passwords.txt --no-blob-protection xxx.git</code></li><li>删除敏感文件<br><code>$  git reflog expire --expire=now --all &amp;&amp; git gc --prune=now --aggressive</code></li><li>提交到远程仓库<br><code>$  git push</code></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈登录认证的几种方式</title>
      <link href="/2023/02/26/%E6%B5%85%E8%B0%88%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
      <url>/2023/02/26/%E6%B5%85%E8%B0%88%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>主流的登录认证的方法一般有Cookie+SessionID、Token+Redis、SSO单点登录（常用JWT）、OAuth第三方登录这几种，以下将简单介绍这几种方式。</p><h2 id="Cookie-SessionID"><a href="#Cookie-SessionID" class="headerlink" title="Cookie+SessionID"></a>Cookie+SessionID</h2><p>由于Http是无状态的，所以需要用Cookie来保存用户信息。Cookie 和 Session 都是用来跟踪浏览器用户身份的会话方式，其主要区别是Cookie存放在客户端，而Session存放在服务端。<br>基于Cookie+SessionId方案实现登录认证的主要流程如下：  </p><ol><li>用户向服务器发送用户名、密码、验证码用于登陆系统。</li><li>服务器验证通过后，服务器为用户创建一个 Session，并将 Session 信息存储起来。</li><li>服务器向用户返回一个 SessionID，写入用户的 Cookie。</li><li>当用户保持登录状态时，Cookie 将与每个后续请求一起被发送出去。</li><li>服务器可以将存储在 Cookie 上的 SessionID 与存储在内存中或者数据库中的 Session 信息进行比较，以验证用户的身份，返回给用户客户端响应信息的时候会附带用户当前的状态。<br><img src="http://oss.ripplesu.top/blog/Typora/%E6%B5%85%E8%B0%88%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/80ab5553-5b7a-4773-8a6b-2bcd918afce3_repeat_1700453389694__325339.png" alt="image.png"></li></ol><p>这种方案有如下几个问题：  </p><ul><li>跨应用的Session共享问题：可以将Session存放在Redis中，或使用Spring Session。</li><li>如果会话信息存放在Cookie中，而客户端禁用Cookie，则这种方案将失效。</li><li>无法防止CSRF(Cross Site Request Forgery， 一般被翻译为<strong>跨站请求伪造</strong>)攻击。由于当前域名下发送的任何请求都会带上Cookie，这就会有SessionId被窃取的风险，攻击者可以用你的身份发送请求。</li></ul><h2 id="Token-Redis"><a href="#Token-Redis" class="headerlink" title="Token+Redis"></a>Token+Redis</h2><p>Token是服务端生成的一串字符串，以作客户端进行请求的一个令牌。当用户第一次登录后，服务器生成一个Token并将此Token返回给客户端，以后客户端只需带上这个Token前来请求数据即可，无需再次带上用户名和密码。Token可以是SessionID，也可以携带一些其他的用户信息（最好经过加密）。SessionID一般存在Cookie里，而token一般放在浏览器的localStorage中。</p><h3 id="单token方案"><a href="#单token方案" class="headerlink" title="单token方案"></a>单token方案</h3><h4 id="流程："><a href="#流程：" class="headerlink" title="流程："></a>流程：</h4><ul><li>客户端发送登录请求</li><li>以随机生成的唯一的token作为redis的key，从数据库中取出用户数据并保存到redis，并设置一个过期时间。然后将token返回给客户端。</li><li>客户端将token保存至localStorage或sessionStorage等。后续客户端发送请求时，都将携带着token进行访问。</li><li>服务器收到请求时，查询redis中是否存在该token。若不存在，即token过期，则拦截该请求。</li></ul><h4 id="token的刷新"><a href="#token的刷新" class="headerlink" title="token的刷新"></a>token的刷新</h4><p>上述流程中，如果token的有效时间较短，则用户体验较差，可能需要频繁登录，甚至导致用户填写的表单信息丢失；而如果token有效时间太长，则redis中需要存储大量的token，可能白白耗费宝贵的内存资源。<br>一种解决办法：客户端每次携带未过期的token发送请求时，服务器就将token的有效时间刷新。<br>以下是简单的代码实现：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Mvc配置类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">RefreshTokenInterceptor</span>(stringRedisTemplate));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 拦截器，用于刷新token</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RefreshTokenInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate redisTemplate;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RefreshTokenInterceptor</span><span class="params">(StringRedisTemplate redisTemplate)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.redisTemplate = redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1.获取请求头中的token</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;token&quot;</span>);</span><br><span class="line">        <span class="comment">// 2.token不存在，则拦截</span></span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isBlank(token))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;key of token in redis&quot;</span></span><br><span class="line">        <span class="comment">// 3.刷新token</span></span><br><span class="line">        redisTemplate.expire(key, <span class="number">7200L</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述方案每次收到未过期的请求时，都需要刷新一次token，效率较低。也可以仅当token快过期时再将token刷新。下述的双token方案也许是一种更好的方案。</p><h3 id="双token方案（token续签）"><a href="#双token方案（token续签）" class="headerlink" title="双token方案（token续签）"></a>双token方案（token续签）</h3><h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><ul><li>登录成功以后，后端返回 <code>access_token</code> 和 <code>refresh_token</code>，客户端缓存此两种token;</li><li>使用 <code>access_token</code> 请求接口资源，成功则调用成功；如果token超时，客户端携带 <code>refresh_token</code> 调用token刷新接口获取新的 <code>access_token</code>;</li><li>后端接受刷新token的请求后，检查 <code>refresh_token</code> 是否过期。如果过期，拒绝刷新，并返回一个错误码。客户端收到该状态后，跳转到登录页；如果未过期，生成新的 <code>access_token</code>和<code>refresh_token</code> 返回给客户端。</li><li>客户端缓存携带新的 token ，并携带之重新调用上面的资源接口。</li><li>客户端退出登录或修改密码后，注销旧的token，使 <code>access_token</code> 和 <code>refresh_token</code> 失效，同时清空客户端的 <code>access_token</code> 和 <code>refresh_toke</code>。</li></ul><p>双 token 的优势：</p><ul><li>accessToken 的存在，保证了登录态的正常验证，因其过期时间的短暂也保证了帐号的安全性；</li><li>refreshToekn 的存在，保证了用户（即使是非活跃用户）无需在短时间内进行反复的登录操作来保证登录态的有效性，同时也保证了活跃用户的登录态可以一直存续而不需要进行重新登录。refresh token并非每次请求都传输，只有access token失效后才用refresh token换一套新的refresh token和access token，减少了暴露的风险。</li></ul><h2 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h2><p>JWT （JSON Web Token） 是目前最流行的跨域认证解决方案，特别适用于分布式站点的单点登录（SSO）场景。它是一种基于 Token 的认证授权机制。JWT 自身包含了身份验证所需要的所有信息，因此，我们的服务器不需要存储 Session 信息。这就能够减轻服务端的压力，但同时也不利于服务端管理用户状态。</p><h3 id="JWT的组成部分"><a href="#JWT的组成部分" class="headerlink" title="JWT的组成部分"></a>JWT的组成部分</h3><p>JWT 本质上就是一组字符串，通过’.’切分成三个为 Base64 编码的部分，其格式为：<br><code>header.payload.signature</code>  </p><ul><li>Header : 描述生成签名的算法以及 Token 的类型。</li><li>Payload : 用来存放实际需要传递的数据，包括注册声明、公有声明和私有声明。常见的注册声明包括jwt签发方、签发时间、过期时间等。注意：payload部分默认<strong>不加密</strong>。</li><li>Signature：服务器使用 Header 里面指定的签名算法（默认是 HMAC SHA256）对整个JWT进行签名，防止被伪造和篡改。</li></ul><h3 id="流程-1"><a href="#流程-1" class="headerlink" title="流程"></a>流程</h3><ol><li>用户向服务器发送用户名、密码以及验证码等用于登陆系统。</li><li>如果用户用户名、密码以及验证码校验正确的话，服务端会返回已经签名的 Token，也就是 JWT。</li><li>用户以后每次向后端发请求都在 Header 中带上这个 JWT（常见做法是将其放在 HTTP Header 的 Authorization 字段中：Authorization: Bearer Token）。</li><li>服务端检查 JWT 并从中获取用户相关信息。</li></ol><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><h4 id="如何防止JWT被篡改？"><a href="#如何防止JWT被篡改？" class="headerlink" title="如何防止JWT被篡改？"></a>如何防止JWT被篡改？</h4><p>只要密匙不泄露，一般无法同时篡改 Signature 、Header 、Payload。因为只要服务端拿到前端发来的JWT，会根据 Header、Payload、密钥再次生成一个 Signature，与原来JWT中的Signature作对比即可直到JWT有无被篡改。</p><h3 id="注销后JWT仍有效"><a href="#注销后JWT仍有效" class="headerlink" title="注销后JWT仍有效"></a>注销后JWT仍有效</h3><p>由于JWT是无状态的，服务端并不存储相关信息，那么直到JWT过期前，它都是有效的。<br>常用解决方案：</p><ul><li>将JWT存放在redis等内存数据库中。如果要让JWT失效只需从redis中将其删除。但这违背了JWT无状态的原则，且与仅使用token的方案没有太大区别。</li><li>黑名单机制。如果想让某个 JWT 失效的话就直接将这个 JWT 加入到 黑名单 即可。然后，每次使用 JWT 进行请求的话都会先判断这个 JWT 是否存在于黑名单中。但同样违背了无状态的原则。</li></ul><h2 id="OAuth"><a href="#OAuth" class="headerlink" title="OAuth"></a>OAuth</h2><p>OAuth（Open Authorization）是一种开放标准的授权协议，用于授权第三方应用程序访问用户在另一个服务提供商上存储的受保护资源，而无需共享用户的凭据（如用户名和密码）。</p><p>OAuth 的设计目标是允许用户授权第三方应用程序代表他们获取受保护的资源，同时保护用户的凭据不被第三方应用程序获取。它通过使用令牌（Token）来实现授权过程。</p><p>下面是 OAuth 的基本流程：</p><ol><li>第三方应用程序向服务提供商注册，并获得一个客户端标识和客户端密钥。</li><li>用户在第三方应用程序中请求访问受保护资源。</li><li>第三方应用程序将用户重定向到服务提供商的授权页面，要求用户进行身份验证和授权。</li><li>用户在服务提供商的授权页面上进行身份验证，并决定是否授权第三方应用程序访问其受保护的资源。</li><li>如果用户授权，服务提供商将生成一个访问令牌（Access Token）并返回给第三方应用程序。</li><li>第三方应用程序使用访问令牌来请求访问用户的受保护资源。</li><li>服务提供商验证访问令牌的有效性，并根据授权范围决定是否提供受保护资源。</li><li>第三方应用程序获取用户的受保护资源，并在用户的授权范围内进行操作。</li></ol><p>OAuth 的优势在于用户不需要共享他们的用户名和密码给第三方应用程序，同时可以控制第三方应用程序对其受保护资源的访问权限。它被广泛应用于各种互联网服务中，如社交媒体平台、云存储服务和API授权等场景，为用户提供了方便、安全的授权机制。</p>]]></content>
      
      
      <categories>
          
          <category> 学习总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 登录认证 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot整合SpringMail的一个demo</title>
      <link href="/2023/02/25/SpringBoot%E6%95%B4%E5%90%88SpringMail%E7%9A%84%E4%B8%80%E4%B8%AAdemo/"/>
      <url>/2023/02/25/SpringBoot%E6%95%B4%E5%90%88SpringMail%E7%9A%84%E4%B8%80%E4%B8%AAdemo/</url>
      
        <content type="html"><![CDATA[<p>使用SpringBoot整合Spring Mail实现邮件发送功能。</p><h3 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h3><h4 id="1-邮箱配置"><a href="#1-邮箱配置" class="headerlink" title="1. 邮箱配置"></a>1. 邮箱配置</h4><p>以QQ邮箱为例，启用SMTP服务：<br>在设置——账户中，开启POP3&#x2F;SMTP服务，保存好授权码。<br><img src="http://oss.ripplesu.top/blog/Typora/SpringBoot%E6%95%B4%E5%90%88SpringMail%E7%9A%84%E4%B8%80%E4%B8%AAdemo/8b599386-1936-4c10-8fa5-b15e865ee6bc_repeat_1700452521700__607495.png" alt="image.png"></p><h4 id="2-Spring-Mail配置"><a href="#2-Spring-Mail配置" class="headerlink" title="2. Spring Mail配置"></a>2. Spring Mail配置</h4><ul><li>POM中导入Spring Mail的Starter  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li>SpringBoot配置文件中配置相关参数<br>官方文档：<a href='https://docs.spring.io/spring-framework/docs/current/reference/html/integration.html#mail'>https://docs.spring.io/spring-framework/docs/current/reference/html/integration.html#mail</a>  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mail:</span></span><br><span class="line">  <span class="attr">host:</span> <span class="string">smtp.qq.com</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">465</span></span><br><span class="line">  <span class="attr">username:</span> <span class="string">xxx@qq.com</span></span><br><span class="line">  <span class="attr">password:</span> <span class="string">你的授权码</span></span><br><span class="line">  <span class="string">//</span> <span class="string">启用安全的smtp协议</span></span><br><span class="line">  <span class="attr">protocol:</span> <span class="string">smtps</span></span><br><span class="line">  <span class="string">//</span> <span class="string">SSL安全连接</span></span><br><span class="line">  <span class="attr">properties:</span></span><br><span class="line">    <span class="attr">mail:</span></span><br><span class="line">      <span class="attr">smtp:</span></span><br><span class="line">        <span class="attr">ssl:</span></span><br><span class="line">          <span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></li><li>编写Mail工具类<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MailClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(MailClient.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JavaMailSender mailSender;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.mail.username&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String from;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMail</span><span class="params">(String to, String subject, String text)</span> <span class="keyword">throws</span> MessagingException &#123;</span><br><span class="line">        <span class="type">MimeMessage</span> <span class="variable">message</span> <span class="operator">=</span> mailSender.createMimeMessage();</span><br><span class="line">        <span class="type">MimeMessageHelper</span> <span class="variable">messageHelper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MimeMessageHelper</span>(message);</span><br><span class="line">        messageHelper.setFrom(from);</span><br><span class="line"><span class="comment">// 接受者邮箱</span></span><br><span class="line">        messageHelper.setTo(to);</span><br><span class="line"><span class="comment">// 邮件主题</span></span><br><span class="line">        messageHelper.setSubject(subject);</span><br><span class="line"><span class="comment">// 邮件内容</span></span><br><span class="line">        messageHelper.setText(text);</span><br><span class="line">        mailSender.send(messageHelper.getMimeMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>测试邮件发送<br>编写测试类：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(classes = xxxApplication.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MailTest</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    MailClient mailClient;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mailClient.sendMail(<span class="string">&quot;to@qq.com&quot;</span>,<span class="string">&quot;测试&quot;</span>,<span class="string">&quot;This is a test mail&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MessagingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Mail </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统课程设计-pintos</title>
      <link href="/2023/02/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1-pintos/"/>
      <url>/2023/02/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1-pintos/</url>
      
        <content type="html"><![CDATA[<p>Pintos是一个用于80x86架构的简单操作系统框架，它以非常简单的方式实现了内核线程、加载和运行用户程序以及文件系统。本次实验将完善其线程与用户程序两个部分。</p><h2 id="1-实验准备"><a href="#1-实验准备" class="headerlink" title="1.实验准备"></a>1.实验准备</h2><h3 id="1-1安装Docker"><a href="#1-1安装Docker" class="headerlink" title="1.1安装Docker"></a>1.1安装Docker</h3><ul><li><p>安装配置Docker Desktop for Windows。</p></li><li><p>然后打开cmd执行：</p><p><code>docker run -it pkuflyingpig/pintos bash</code></p><p>这将下载并运行一个包含完整的Ubuntu18.04以及编译、运行和调试Pintos的所有工具链（包含qemu、gcc等）的镜像。</p></li></ul><h3 id="1-2下载并配置Pintos"><a href="#1-2下载并配置Pintos" class="headerlink" title="1.2下载并配置Pintos"></a>1.2下载并配置Pintos</h3><ul><li><p>进入链接<a href="https://pintos-os.org/cgi-bin/gitweb.cgi?p=pintos-anon;a=tree;h=refs/heads/master;hb=refs/heads/master">https://pintos-os.org/cgi-bin/gitweb.cgi?p=pintos-anon;a=tree;h=refs/heads/master;hb=refs/heads/master</a>  ，单击‘snapshot’下载pintos包并解压至本地。</p></li><li><p>cmd执行：</p><p><code>docker run -it --rm --name pintos --mount type=bind,source=absolute/path/to/pintos/on/your/host/machine,target=/home/PKUOS/pintos pkuflyingpig/pintos bash</code></p><p>将本地的pintos文件夹绑定到docker镜像,这样在vscode中修改代码后就可以马上运行测试。</p></li><li><p>用Vscode打开解压后的pintos文件夹，作如下修改：</p><ul><li>在pintos&#x2F;src&#x2F;utils&#x2F;pintos-gdb中GDBMACROS变量前增加‘~&#x2F;’（修改为完整路径）；</li><li>打开pintos&#x2F;src&#x2F;utils下的Makefile,将LOADLIBES变量名编辑为LDLIBS；</li><li>编辑&#x2F;utils&#x2F;pintos find_disks中的find_file函数采参数：替换kernel.bin为完整路径的（上面cmd命令中target目录pintos前的部分）kernel.bin；</li><li>编辑&#x2F;utils&#x2F;Pintos.pm（362行）：替换loader.bin为完整路径的loader.bin</li></ul></li></ul><h3 id="1-3使用Pintos"><a href="#1-3使用Pintos" class="headerlink" title="1.3使用Pintos"></a>1.3使用Pintos</h3><ul><li><p>运行docker镜像后，执行如下命令：<br>  <code>cd pintos/src/threads/</code></p><p>  <code>make</code></p><p>  <code>cd build</code></p><p>  <code>pintos --</code></p><p>  如果一切正常，则配置成功。</p></li><li><p>执行如下命令以运行pintos：  </p><p><code>pintos [--gdb] -- run mytest</code></p><p>如果使用了–gdb选项，则可以按如下步骤调试pintos：</p><ul><li><p>打开另一个cmd，输入：<br><code>docker exec -it pintos bash</code></p><p><code>cd pintos/src/threads/build</code></p><p><code>pintos-gdb kernel.o</code></p></li><li><p>在打开的gdb中输入‘debugpintos’，然后就可以自由调试pintos。</p></li></ul></li><li><p>调试完毕，则可以运行测试。<br>  例如在threads目录下执行：make check。如果一切正常，将看到测试结果。<br>  如果测试结果没有发生变化，可以先执行make clean删除原来生成的build目录，再重新运行测试。</p></li></ul><h2 id="2-Project1：Threads"><a href="#2-Project1：Threads" class="headerlink" title="2. Project1：Threads"></a>2. Project1：Threads</h2><h3 id="2-1-实验内容"><a href="#2-1-实验内容" class="headerlink" title="2.1 实验内容"></a>2.1 实验内容</h3><h4 id="2-1-1-Alarm-Clock"><a href="#2-1-1-Alarm-Clock" class="headerlink" title="2.1.1 Alarm Clock"></a>2.1.1 Alarm Clock</h4><p>重新实现在“devices&#x2F;timer.c”中定义的“timer_sleep()”。 pintos已经提供了一个可行的实现，但是它是“忙-等待”的，即循环检查当前时间并调用<code>thread_yield()</code>直到经过足够的时间。重新实现它以避免忙等待。</p><p>Function: void <strong>timer_sleep</strong> (int64_t ticks)</p><ul><li>暂停执行调用线程，直到时间提前至少x个计时器滴答为止。除非系统处于空闲状态，否则线程无需在精确的x滴答之后唤醒。他们等待正确的时间后，只需将其放在ready_list中即可。</li><li>“timer_sleep()”的参数以计时器刻度表示，而不是以毫秒或任何其他单位表示。每秒有TIMER_FREQ定时器滴答，其中TIMER_FREQ是在“devices&#x2F;timer.h”中定义的宏。默认值为100。不建议更改此值，因为任何更改都可能导致许多测试失败。</li></ul><h4 id="2-1-2-Priority-Scheduling"><a href="#2-1-2-Priority-Scheduling" class="headerlink" title="2.1.2 Priority Scheduling"></a>2.1.2 Priority Scheduling</h4><p>在Pintos中实施优先级调度。当将一个线程添加到具有比当前正在运行的线程更高的优先级的就绪列表时，当前线程应立即将处理器移交给新线程。同样，当线程正在等待锁、信号量或条件变量时，应首先唤醒优先级最高的线程。线程可以随时提高或降低其自身的优先级，但是降低其优先级以使其不再具有最高优先级时，则必须立即让出CPU。</p><p>线程优先级的范围是从PRI_MIN(0)到PRI_MAX(63)。较低的数字对应较低的优先级，因此优先级0是最低优先级，优先级63是最高优先级。 初始线程优先级作为参数传递给“ thread_create()”。如果没有理由选择其他优先级，则使用<code>PRI_DEFAULT(31)</code>。PRI_宏是在“threads&#x2F;thread.h”中定义的，不应更改其值。</p><p>优先级调度的一个问题是“优先级反转”。分别考虑高、中和低优先级线程H，M和L。如果H需要等待L（例如，等待由L持有的锁），而M在就绪列表中，则H将永远无法获得CPU，因为低优先级线程不会获得任何CPU时间。解决此问题的部分方法是，当L持有锁时，H将其优先级“捐赠”给L。L释放（这样H可以获得）锁。</p><p>实施优先级捐赠。需要考虑适用于需要优先级捐赠的所有不同情况。确保处理多个捐赠，即多个优先级捐赠给单个线程。还必须处理嵌套捐赠：如果H正在等待M持有的锁，而M正在等待L持有的锁，则M和L都应提升为H的优先级。</p><p>最后，实现以下函数，这些函数允许线程检查和修改其自身的优先级。这些功能的框架在“threads&#x2F;thread.c”中提供。</p><p>Function: void <strong>thread_set_priority</strong> (int new_priority )<br>将当前线程的优先级设置为new_priority。 如果当前线程不再具有最高优先级，则让出CPU。</p><p>Function: int <strong>thread_get_priority</strong> (void)<br>返回当前线程的优先级。 在存在优先级捐赠的情况下，返回较高（捐赠的）优先级。</p><p>无需提供任何接口即可允许线程直接修改其他线程的优先级。 </p><h4 id="2-1-3-Advanced-Scheduler"><a href="#2-1-3-Advanced-Scheduler" class="headerlink" title="2.1.3 Advanced Scheduler"></a>2.1.3 Advanced Scheduler</h4><p>实现类似于BSD调度器的多级反馈队列调度程序，以减少在系统上运行作业的平均响应时间。<br>与优先级调度程序类似，高级调度程序根据优先级选择要运行的线程。但是，高级调度程序不会进行优先级捐赠。</p><p>编写代码，以允许在Pintos启动时选择调度算法策略。默认情况下，优先级调度程序必须处于活动状态，但是我们必须能够通过“-mlfqs”内核选项选择BSD调度程序。传递此选项会将在“threads&#x2F;thread.h”中声明的“thread_mlfqs”设置为true。</p><p>启用BSD调度程序后，线程不再直接控制自己的优先级。 应该忽略对thread_create()的优先级参数以及对thread_set_priority()的任何调用，而对thread_get_priority()的调用应返回调度程序设置的线程的当前优先级。</p><p>线程优先级最初是在线程初始化时计算的。每四个时钟滴答也会重新计算一次。无论哪种情况，均由以下公式确定<br>priority &#x3D; PRI_MAX - (recent_cpu &#x2F; 4) - (nice * 2),<br>其中recent_cpu是线程最近使用的CPU时间的估计值，而nice是线程的nice值。结果应向下舍入。<br>有关高级调度器的详细实现，将在以下功能实现中说明。</p><h3 id="2-2-功能实现"><a href="#2-2-功能实现" class="headerlink" title="2.2 功能实现"></a>2.2 功能实现</h3><h4 id="2-2-1-Alarm-Clock"><a href="#2-2-1-Alarm-Clock" class="headerlink" title="2.2.1 Alarm Clock"></a>2.2.1 Alarm Clock</h4><ul><li>数据结构<ul><li><p>thread 新增全局变量<strong>sleep_list</strong>记录所有睡眠线程：</p><p><code>static struct list sleep_list;  </code></p></li><li><p>thread结构体新增成员变量<strong>sleep_ticks</strong>记录sleep时间，<strong>sleep_elem</strong>作为sleep_list的元素:</p><p><code>struct list_elem sleep_elem;</code></p><p><code>int64_t sleep_ticks;</code></p></li></ul></li></ul><p>然后在<code>thread_init</code>中加入sleep_list的初始化；在<code>thread_create</code>中将新线程的sleep_ticks初始化为0。</p><p>调用<code>timer_sleep</code>时，如果传递的参数ticks小于等于0，则调用<code>thread_yield</code>重新竞争cpu；否则调用<code>thread_sleep</code>（新增）方法置该线程的sleep_ticks为ticks，并将该线程加入sleep_list，然后阻塞该线程。</p><p>操作系统每次时钟中断（<code>timer_interrupt</code>）执行完<code>thread_tick</code>后，调用<code>thread_wake_up</code>（新增）方法。<br>该方法检查sleep_list中的每一个线程，将其sleep_ticks–，然后判断其值是否减至0。如是，则将其从sleep_list中移除，并调用<code>thread_unblock</code>唤醒该进程（该过程禁用中断）。</p><h4 id="2-2-2-Priority-Scheduling"><a href="#2-2-2-Priority-Scheduling" class="headerlink" title="2.2.2 Priority Scheduling"></a>2.2.2 Priority Scheduling</h4><h5 id="优先调度高优先级线程"><a href="#优先调度高优先级线程" class="headerlink" title="优先调度高优先级线程"></a>优先调度高优先级线程</h5><p>文档中要求，当一个优先级比当前运行线程优先级更高的线程加入就序列表（ready_list）时，当前线程应立即将处理器移交给新线程。为方便实现上述调度，这里将ready_list修改为优先级队列（头大尾小，因为在<code>next_thread_to_run</code>方法中，其调用的是<code>list_pop_front</code>方法获取ready_list的front线程，即优先级最高线程应在头部）。</p><ul><li>新增线程比较方法<code>thread_less_priority</code>，左参数线程优先级比右参数线程优先级大返回true。该方法可作为<code>list_insert_ordered</code>等方法参数中的比较函数。这样通过<code>list_insert_ordered</code>方法插入线程到ready_list时，优先级高的线程离头部近。</li><li>分别修改<code>thread_unblock</code>和<code>thread_yield</code>中插入ready_list的方法<code>list_push_back</code>为有序插入<code>list_insert_ordered</code>。</li></ul><p>当线程正在等待锁、信号量或条件变量时，首先唤醒优先级最高的线程。</p><ul><li>修改<code>sema_up</code>唤醒线程逻辑，通过<code>list_min</code>方法取出sema-&gt;waiter中优先级最高的线程（由于我的线程比较方法是左比右大返回true，这里用<code>list_min</code>而不是<code>list_max</code>），并将其唤醒。</li><li>类似的，修改<code>cond_signal</code>，以唤醒等待该条件的信号量的线程中优先级最大者。此处不再赘述。</li></ul><h5 id="实现优先级捐赠"><a href="#实现优先级捐赠" class="headerlink" title="实现优先级捐赠"></a>实现优先级捐赠</h5><p>文档中提到“优先级反转”问题可使用“优先级捐赠”来解决，并且必须实现锁的优先级捐赠。</p><p>考虑高、中和低优先级线程H，M和L。如果H需要申请某个锁，但该锁由L持有，且M在就绪列表中，则H将永远无法获得CPU，因为L不会获得任何CPU时间（只要有M存在），即L永远无法释放锁。采用优先级捐赠的方法解决上述问题：当L持有锁时，H将其优先级“捐赠”给L（即置L的优先级与H一致），这样L就能够获得CPU，也就可以释放锁。</p><p>按照本人理解，L释放锁后应该回归它原本的优先级，所以需要新增一个成员以记录线程原始的、不存在捐赠情况的优先级；文档中提到“确保处理多个捐赠，其中将多个优先级捐赠给单个线程”，那么每个线程应该要有一个占有锁的列表以方便应对多个捐赠的情况（相应的，锁也要增加一个list_elem成员）。而一个锁同时可以有多个申请者，最终捐赠的优先级应当是申请者中优先级最高者（文档中提到优先级捐赠不是累加的），因此锁中需要增加一个成员记录申请者中的最大优先级；文档中还提到了嵌套捐赠的情况，线程中可以增加一个成员记录正在等待的锁（如H等待的锁A由M占有，M等待的锁B由L占有，那么当H申请锁A时可以很方便的通过M的该成员（记录着锁B）追溯到L以进行嵌套捐赠）。</p><p>以下介绍锁的优先级捐赠的实现方法。</p><ul><li><p>数据结构：</p><p>thread结构体中增加如下成员：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> origin_priority;   <span class="comment">/* 未被捐赠时的初始priority */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list</span> <span class="title">hold_locks</span>;</span>   <span class="comment">/* 占有的锁 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lock</span> *<span class="title">waiting_lock</span>;</span>   <span class="comment">/* 正等待的锁 */</span></span><br></pre></td></tr></table></figure><p>并在init_thread中添加对上述成员的初始化：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t-&gt;origin_priority = priority;</span><br><span class="line">list_init (&amp;t-&gt;hold_locks);</span><br><span class="line">t-&gt;waiting_lock = <span class="literal">NULL</span>;  </span><br></pre></td></tr></table></figure><p>lock结构体中增加如下成员：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_elem</span> <span class="title">elem</span>;</span>      <span class="comment">/*hold_locks中的元素*/</span></span><br><span class="line"><span class="type">int</span> max_donate_priority;    <span class="comment">/*申请锁的线程中（捐赠者）优先级最大者*/</span></span><br></pre></td></tr></table></figure></li><li><p>修改<code>lock_acquire(struct lock *lock)</code>：</p><p>调用<code>lock_acquire</code>申请锁时（由于后续BSD调度不需要使用优先级捐赠，故这里thread_mlfqs需为false），如果申请的锁lock已被占有，则令当前线程的waiting_lock&#x3D;lock，然后调用<code>thread_donate_priority</code>（新增，见下）判断并处理优先级捐赠。</p><p>当执行完<code>sema_down</code>，即当前线程等待到锁，置其waiting_lock为空，更新获得锁的最大优先级（max_donate_priority）为当前线程优先级，并将其加入当前线程hold_locks列表（此处thread_mlfqs也为false）。最后将lock-&gt;holder置为当前线程。<code>sema_down</code>之后的过程不可被中断。</p><p>上面提到的<code>thread_donate_priority</code>方法判断是否存在优先级捐赠的情况：如果当前线程的优先级大于等待的锁的申请者中的最大优先级（max_donate_priority），则将其更新为当前线程优先级，并调用<code>thread_update_priority</code>（新增）更新锁的占有者的优先级（捐赠优先级）；然后从锁的占有者向上追溯，判断锁的占有者等待的锁（处理嵌套捐赠）。重复上述过程，直到没有等待的锁或当前线程的优先级不大于等待的锁的max_donate_priority（无需捐赠）。上述过程不可被中断。</p><p>其中的<code>thread_update_priority</code>将比较当前线程原始优先级（origin_priority）与其占有锁中申请者中的优先级最大者（hold_locks列表中的max_donate_priority最大者），取其较大者作为线程的实际优先级priority。</p><p>为实现上述获取hold_locks列表中的max_donate_priority最大者的功能，需新增lock的比较函数。根据比较函数的逻辑，可通过list_min或list_max方法获取最大元素。比较函数具体实现此处不再赘述。</p><p>整个lock_acquire流程如下：</p><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1-pintos/lock_acquire.png"></li><li><p>修改lock_release：</p><p>调用sema_up唤醒线程前，先调用<code>thread_remove_lock</code>将锁从hold_locks列表中删除，并调用<code>thread_update_priority</code>更新当前线程优先级（原先可能存在优先级捐赠情况，即实际优先级是其他线程捐赠的优先级）。</p></li></ul><h5 id="补充实现priority的get、set方法"><a href="#补充实现priority的get、set方法" class="headerlink" title="补充实现priority的get、set方法"></a>补充实现priority的get、set方法</h5><p>这些函数允许线程检查和修改其自身的优先级。set_priority后，如果当前线程不再具有最高优先级，则让出CPU。</p><ul><li>Function: void <strong>thread_set_priority</strong> (int new_priority )</li></ul><p>该过程不可被中断。如果不存在优先级捐赠情况，或新设置的优先级大于原来的实际优先级（可能是被捐赠的优先级），则将当前线程的实际优先级设置为new_priority。然后调用<code>thread_yield</code>重新竞争CPU。</p><ul><li><p>Function: int <strong>thread_get_priority</strong> (void)</p><p>返回当前线程的实际优先级priority。</p></li></ul><h4 id="2-2-3-Advanced-Scheduler"><a href="#2-2-3-Advanced-Scheduler" class="headerlink" title="2.2.3 Advanced Scheduler"></a>2.2.3 Advanced Scheduler</h4><p>这个部分整体上只需在正确的时间按文档要求套用公式计算对应的值即可。这里只维持一个优先级队列即ready_list。</p><p>每四个ticks使用以下公式重新计算一次所有线程优先级：</p><p><code>priority = PRI_MAX - (recent_cpu / 4) - (nice * 2)</code></p><p>每个线程有一个整数nice值，该值确定该线程与其他线程应该有多“不错”。nice为零不会影响线程优先级。正的nice会降低线程的优先级，并导致该线程放弃原本可以接收的CPU时间。nice值在-20~20之间。</p><p>recent_cpu测量线程“最近”接收到的CPU时间。在每个tick中，运行线程的recent_cpu递增1。每个线程的recent_cpu每秒一次以下述方式更新：</p><p><code>recent_cpu = (2*load_avg)/(2*load_avg + 1) * recent_cpu + nice</code>.</p><p>load_avg估计过去一分钟准备运行的平均线程数。它在引导时初始化为0，并每秒按如下公式重新计算一次：</p><p><code>load_avg = (59/60)*load_avg + (1/60)*ready_threads</code>.</p><p>其中ready_threads是在更新时正在运行或准备运行的线程数（不包括空闲线程）。  </p><p>在上面的公式中，priority，nice和ready_threads是整数，而recent_cpu和load_avg 是实数。Pintos在内核中并不支持浮点运算。因此必须使用整数来模拟实际数量的计算。</p><ul><li><p>Fixed-Point Real Arithmetic</p><p>本实验中，将带符号的32位整数的最低14位指定为小数位，这样整数x就表示实数x&#x2F;2^14。这被称为17.14定点数字表示形式，因为小数点前有17位，小数点后有14位，还有一个符号位。具体实现参考文档中给出的计算方法，以宏定义的方式实现。详情参见threads\fpra.h。</p></li></ul><p>基于上述计算方法，实现调度方法如下：</p><ul><li><p>数据结构：</p><ul><li><p>thread结构体内新增成员：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> nice; <span class="comment">/* 该值确定该线程与其他线程应该有多“不错” */</span></span><br><span class="line">fixed_point recent_cpu;  <span class="comment">/* 线程最近使用的CPU时间的估计值 */</span></span><br></pre></td></tr></table></figure><p>并在init_thread中初始化：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t-&gt;nice = <span class="number">0</span>;</span><br><span class="line">t-&gt;recent_cpu = FPRA_CONVERT_INT(<span class="number">0</span>);</span><br></pre></td></tr></table></figure></li><li><p>thread.c增加全局变量：</p><p><code>fixed_point load_avg;  /*系统平均负载*/</code></p><p>并在thread_start中初始化：</p><p><code>load_avg = FPRA_CONVERT_INT (0);</code></p></li></ul></li><li><p>修改timer_interrupt，使其完成以下功能：</p><p>对正在执行的非空闲线程的recent_cpu+1（通过新增方法<code>mlfqs_thread_recent_cpu_plus_one</code>），然后判断ticks：如果到达TIMER_FREQ（一秒）的倍数，更新一次load_avg和所有非闲线程(all_list中)的recent_cpu（通过新增方法<code>mlfqs_thread_update_per_second</code>）；如果为4的倍数，只重新计算并更新所有非闲线程优先级（通过新增方法<code>mlfqs_thread_update_priority</code>）。</p><p>上述几个方法只需用fpra.h中定义的计算方法套用文档中给出的计算公式即可。详情参见源代码。需要注意的是，当前正运行的非闲线程也应该计入ready_threads；计算完priority后需要将其调整为处于PRI_MIN至PRI_MAX的范围内。</p><p>流程如下：</p><img src="http://oss.ripplesu.top/blog/Typora/操作系统课程设计-pintos/流程图mlfqs.png"></li><li><p>最后，完善有关值的get、set方法：</p><ul><li><p><code>thread_set_nice(int nice)</code>：<br>将当前线程的nice值设置为nice，并根据新值调用<code>mlfqs_thread_update_priority</code>重新计算当前线程的优先级。然后调用<code>thread_yield</code>重新竞争CPU。</p></li><li><p><code>thread_get_nice(void)</code>:返回当前线程nice值即可。</p></li><li><p><code>thread_get_load_avg</code>:返回当前系统平均负载的100倍，四舍五入到最接近的整数：<br><code>FPRA_TO_INT_TO_NEAREST (FPRA_MULT_INT (load_avg, 100))</code></p></li><li><p><code>thread_get_recent_cpu</code>:返回当前线程的recent_cpu值的100倍，四舍五入到最接近的整数:<br><code>FPRA_TO_INT_TO_NEAREST (FPRA_MULT_INT (thread_current ()-&gt;recent_cpu, 100))</code></p></li></ul></li></ul><h3 id="2-3-测试结果"><a href="#2-3-测试结果" class="headerlink" title="2.3 测试结果"></a>2.3 测试结果</h3><ul><li>在线判题结果：<img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1-pintos/threads.png"></li></ul><h2 id="3-Project2：User-Programs"><a href="#3-Project2：User-Programs" class="headerlink" title="3. Project2：User Programs"></a>3. Project2：User Programs</h2><h3 id="3-1-实验内容"><a href="#3-1-实验内容" class="headerlink" title="3.1 实验内容"></a>3.1 实验内容</h3><h4 id="3-1-1-Process-Termination-Messages"><a href="#3-1-1-Process-Termination-Messages" class="headerlink" title="3.1.1 Process Termination Messages"></a>3.1.1 Process Termination Messages</h4><p>每当用户进程终止时，不管是因为它调用exit或任何其他原因，需打印该进程的名称和退出代码，其格式类似于由printf（“％s：exit（％d）\ n”，… ）;。 打印的名称应为传递给process_execute（）的全名，并省略命令行参数。当不是用户进程的内核线程终止时，或者在调用“halt”系统调用时，请勿打印这些消息。当进程无法加载时，此消息是可选的。</p><h4 id="3-1-2-Argument-Passing"><a href="#3-1-2-Argument-Passing" class="headerlink" title="3.1.2 Argument Passing"></a>3.1.2 Argument Passing</h4><p>当前，process_execute()不支持将参数传递给新进程。 通过扩展process_execute（）来实现此功能，以使它不仅将程序文件名作为参数，而且还将按空格分隔。第一个单词是程序名称，第二个单词是第一个参数，依此类推。也就是说，process_execute（“grep foo bar”）应该运行grep，并传递两个参数foo和bar。</p><h4 id="3-1-3-System-Calls"><a href="#3-1-3-System-Calls" class="headerlink" title="3.1.3 System Calls"></a>3.1.3 System Calls</h4><p>在“userprog&#x2F;syscall.c”中实现系统调用处理程序。它将需要检索系统调用号，然后检索系统调用参数，并执行适当的操作。</p><p>实现 halt~close 13个系统调用。列出的原型是由包含“lib&#x2F;user&#x2F;syscall.h”的用户程序看到的原型。（此头文件以及“lib&#x2F;user”中的所有其他头文件仅供用户程序使用。）每个系统调用的系统调用号在“lib&#x2F;syscall-nr.h”中定义。</p><p>要实现系统调用，需要提供在用户虚拟地址空间中读取和写入数据的方法。在获得系统调用号之前需要此功能，因为系统调用号位于用户的虚拟地址空间中的用户堆栈上。如果用户提供了无效的指针，指向内核内存的指针或部分位于这些区域之一的块，应该能够检查出并通过终止用户进程来处理这些情况。</p><p>必须同步系统调用，以便任意数量的用户进程可以进行调用。特别地，同时从多个线程调用“filesys”目录中提供的文件系统代码是不安全的。系统调用实现必须将文件系统代码视为临界区。不要忘记process_execute()也可以访问文件。</p><p>用户程序无法执行的任何操作都不会导致OS崩溃、死机、断言失败或其他故障。强调这一点很重要：测试将尝试以多种方式中断系统调用。需要考虑所有极端情况并加以处理。用户程序应该能够导致OS停止的唯一方法是调用“halt”系统调用。</p><p>如果系统调用传递了无效的参数，则可接受的选项包括返回错误值（对于那些返回值的调用），返回未定义的值或终止过程。</p><h4 id="3-1-4-Denying-Writes-to-Executables"><a href="#3-1-4-Denying-Writes-to-Executables" class="headerlink" title="3.1.4 Denying Writes to Executables"></a>3.1.4 Denying Writes to Executables</h4><p>添加代码以拒绝写入用作可执行文件的文件。如果进程尝试运行当时正在磁盘上进行更改的代码，结果将无法预测。</p><p>可以使用file_deny_write（）防止写入打开的文件。在文件上调用file_allow_write（）将重新启用它们（除非文件被另一个打开程序拒绝写入）。关闭文件也会重新启用写操作。因此，要拒绝写入进程的可执行文件，只要进程仍在运行，就必须保持打开状态。</p><h3 id="3-2-功能实现"><a href="#3-2-功能实现" class="headerlink" title="3.2 功能实现"></a>3.2 功能实现</h3><h4 id="3-2-1-Process-Termination-Messages"><a href="#3-2-1-Process-Termination-Messages" class="headerlink" title="3.2.1 Process Termination Messages"></a>3.2.1 Process Termination Messages</h4><ul><li><p>数据结构：<br>thread结构体中增加成员：</p><p><code>int exit_code; </code> &#x2F;&#x2F;退出代码</p><p>在<code>init_thread</code>中将其初始化为0：</p><p><code>t-&gt;exit_code = 0;</code></p><p>该值为0表示成功退出，非零值表示错误。</p></li></ul><p>然后在<code>thread_exit</code>方法执行完<code>process_exit</code>后，添加如下代码，按文档要求打印出进程的信息：<br><code>printf(&quot;%s: exit(%d)\n&quot;,thread_name(),thread_current()-&gt;exit_code);</code></p><p>后续测试中发现按我写的代码逻辑，无条件打印退出信息将导致测试点“exec-missing”失败。故后续将修改为子进程加载失败，在退出时不打印上述错误信息。</p><h4 id="3-2-2-Argument-Passing"><a href="#3-2-2-Argument-Passing" class="headerlink" title="3.2.2 Argument Passing"></a>3.2.2 Argument Passing</h4><h5 id="process-execute"><a href="#process-execute" class="headerlink" title="process_execute"></a>process_execute</h5><p>文档中提到，系统提供的process_execute函数不支持参数传递。它将程序文件名作为一个整体传递给thread_create作为程序名称。例如<code>process_execute（&quot;grep foo bar&quot;）</code>，它将”grep foo bar”整体作为程序的名称。而要求的实现是以”grep”作为程序名，并传递”foo bar”两个参数（程序名位于argv[0]）。</p><p>所以，修改<code>process_execute</code>以实现上述功能：</p><p>定义fn_copy、fn_copy1作为file_name的两个copy。其中fn_copy1通过strtok_r函数按空格分割为程序名与参数两部分，第一部分（程序名）存储在fn_copy1中作为参数传递给<code>thread_create</code>作为程序名称。由于<code>start_process</code>函数仍需要程序名，因此将fn_copy（file_name的完整拷贝）同样作为thread_create的参数。该参数将传递给start_process方法。</p><h5 id="start-process"><a href="#start-process" class="headerlink" title="start_process"></a>start_process</h5><p>start_process方法的任务是以文件名加载一个 ELF 格式的可执行文件（ELF是Linux、Solaris和许多其他操作系统使用的文件格式，用于目标文件、共享库和可执行文件），同时传递正确的参数。</p><p>start_process方法中同样以fn_copy作为file_name的拷贝，并执行与上述类似的分割方法。分割出的程序名存储在proc_name中作为参数传递给load方法，参数部分则存储在args中。load方法将返回加载是否成功的信息，并保存在success中。如果<code>success == true</code>，则开始解析参数，并将其放在堆栈上;如果执行失败，则置当前线程exit_code为-1，然后调用<code>thread_exit</code>。无论成功与否，最后都需要释放申请的字符串空间。</p><p>例如处理以下示例命令的参数：“&#x2F;bin&#x2F;ls -l foo bar” 其过程如下：<br>首先，将命令分解为单词：“&#x2F;bin &#x2F;ls”，“-l”，“foo”，“bar”，并将单词放在堆栈的顶部。<br>然后，按从右到左的顺序将每个字符串的地址以及一个空指针哨兵压入堆栈。这些是“argv”的元素。空指针sentinel可以确保C标准所要求的argv[argc]是空指针。该命令确保“argv[0]”位于最低虚拟地址。字对齐的访问比未对齐的访问要快，因此为了获得最佳性能，在第一次压入之前将堆栈指针向下舍入为4的倍数。<br>然后，依次将“argv”（“argv[0]”的地址）和“argc”入栈。<br>最后，推送一个伪造的“返回地址”。</p><p>详细代码以及每一步的意义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(success)&#123;</span><br><span class="line">  <span class="type">int</span> argc = <span class="number">0</span>;   <span class="comment">/* 参数个数 */</span></span><br><span class="line">  <span class="type">void</span>* argv[<span class="number">128</span>];<span class="comment">/* pintos实用程序可以传递给内核的命令行参数有128个字节的不相关限制。*/</span></span><br><span class="line">  <span class="type">char</span>* word; <span class="comment">/* 单词 */</span></span><br><span class="line">  <span class="comment">/*用户虚拟内存的范围从虚拟地址0到“PHYS_BASE”，默认为“ 0xc0000000”（3GB）。内核虚拟内存占用了其余的虚拟地址空间，从“PHYS_BASE”到最大4GB。</span></span><br><span class="line"><span class="comment">  应在用户虚拟地址空间的最顶部，即虚拟地址“PHYS_BASE”（在“threads/vaddr.h”中定义）下方的页面中开始堆栈。*/</span></span><br><span class="line">  <span class="comment">/*堆栈指针初始化为PHYS_BASE*/</span></span><br><span class="line">  if_.esp = PHYS_BASE;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 解析参数，将其放在栈顶。顺序无关紧要，因为它们将通过指针引用。*/</span></span><br><span class="line">  <span class="comment">/* char *strtok_r(char *str, const char *delim, char **saveptr);</span></span><br><span class="line"><span class="comment">    第一次调用strtok_r时，str参数必须指向待提取的字符串。</span></span><br><span class="line"><span class="comment">    连续调用时，str赋值为NULL。saveptr为上次调用后剩余的字符串。 */</span></span><br><span class="line">  <span class="keyword">for</span> (word = strtok_r (fn_copy, <span class="string">&quot; &quot;</span>, &amp;args); word != <span class="literal">NULL</span>; word = strtok_r (<span class="literal">NULL</span>, <span class="string">&quot; &quot;</span>, &amp;args)) &#123;</span><br><span class="line">    <span class="type">size_t</span> arg_len = <span class="built_in">strlen</span>(word) + <span class="number">1</span>; <span class="comment">//&#x27;\0&#x27;</span></span><br><span class="line">    if_.esp -= arg_len; <span class="comment">//地址空间从PHYS_BASE向下延伸</span></span><br><span class="line">    <span class="built_in">memcpy</span>(if_.esp, word, arg_len);<span class="comment">//将word复制到对应地址空间</span></span><br><span class="line">    argv[argc++] = if_.esp; <span class="comment">//通过指针引用参数</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 单词对齐的访问比未对齐的访问要快，因此为了获得最佳性能,在第一次压入之前将堆栈指针向下舍入为4的倍数。 */</span></span><br><span class="line">  <span class="comment">/* uintptr_t能够存储指针的无符号整数类型。这通常意味着它与指针的大小相同。*/</span></span><br><span class="line">  <span class="type">uintptr_t</span> tmp = (<span class="type">uintptr_t</span>)if_.esp; </span><br><span class="line">  <span class="keyword">if</span> (tmp % <span class="number">4</span> != <span class="number">0</span>)</span><br><span class="line">    tmp -= tmp % <span class="number">4</span>;</span><br><span class="line">  if_.esp = (<span class="type">void</span> *)tmp;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 按从右到左的顺序将每个字符串的地址以及一个空指针哨兵压入堆栈。</span></span><br><span class="line"><span class="comment">  这些是“argv”的元素。空指针sentinel(哨兵)可以确保C标准所要求的argv[argc]是空指针。</span></span><br><span class="line"><span class="comment">  该顺序确保“argv[0]”位于最低虚拟地址。*/</span></span><br><span class="line">  <span class="type">size_t</span> ptr_size = <span class="keyword">sizeof</span>(<span class="type">void</span> *); <span class="comment">//指针大小</span></span><br><span class="line">  if_.esp -= ptr_size;</span><br><span class="line">  <span class="built_in">memset</span>(if_.esp, <span class="number">0</span>, ptr_size); <span class="comment">//空指针</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = argc<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">    if_.esp -= ptr_size;</span><br><span class="line">    <span class="built_in">memcpy</span>(if_.esp, &amp;argv[i], ptr_size);<span class="comment">//依次将参数地址入栈</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 然后，依次将“argv”（“argv[0]”的地址）和“argc”入栈。*/</span></span><br><span class="line">  if_.esp -= ptr_size;</span><br><span class="line">  *(<span class="type">uintptr_t</span> *)if_.esp = ((<span class="type">uintptr_t</span>)if_.esp + ptr_size); </span><br><span class="line">  if_.esp -= ptr_size;</span><br><span class="line">  *(<span class="type">int</span> *)if_.esp = argc;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 最后，推送一个伪造的“返回地址”：</span></span><br><span class="line"><span class="comment">  尽管入口函数将永远不会返回，但其堆栈框架必须具有与其他任何结构相同的结构。 */</span></span><br><span class="line">  if_.esp -= ptr_size;</span><br><span class="line">  <span class="built_in">memset</span>(if_.esp, <span class="number">0</span>, ptr_size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* If load failed, quit. */</span></span><br><span class="line">palloc_free_page (file_name);  </span><br><span class="line">palloc_free_page (fn_copy);</span><br><span class="line"><span class="keyword">if</span> (!success) &#123;</span><br><span class="line">  thread_current()-&gt;exit_code = <span class="number">-1</span>;</span><br><span class="line">  thread_exit ();    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-3-System-Calls"><a href="#3-2-3-System-Calls" class="headerlink" title="3.2.3 System Calls"></a>3.2.3 System Calls</h4><h5 id="用户内存访问"><a href="#用户内存访问" class="headerlink" title="用户内存访问"></a>用户内存访问</h5><p>作为系统调用的一部分，内核必须经常通过用户程序提供的指针访问内存。内核必须非常小心，因为用户可能传递一个空指针，一个指向未映射虚拟内存的指针或一个指向内核虚拟地址空间的指针（在PHYS_BASE之上）。必须通过终止有问题的进程并释放其资源，拒绝所有这些类型的无效指针，而不会损害内核或其他正在运行的进程。<br>文档提供了两种设计思路，这里选择第二种（但又不完全是，此处实现可能并不完善，虽然能过测试点）。</p><p>检查用户指针的<code>check_user_ptr</code>方法实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> * </span><br><span class="line"><span class="title function_">check_user_ptr</span><span class="params">(<span class="type">void</span> *ptr)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* 判断传入的地址是否是用户可用的虚拟地址（地址是否在PHYS_BASE以下）*/</span></span><br><span class="line">  <span class="keyword">if</span> (!is_user_vaddr(ptr)) &#123;</span><br><span class="line">    kill_process();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* 判断虚拟地址及其上4字节的位置的内容是否正确，</span></span><br><span class="line"><span class="comment">    若不正确则调用kill_process()函数异常退出。否则将这个指针视作是正确的。 */</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123; </span><br><span class="line">    <span class="keyword">if</span> (get_user(ptr + i) == <span class="number">-1</span>) &#123;</span><br><span class="line">      kill_process();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法首先通过<code>is_user_vaddr</code>（定义在threads&#x2F;vaddr.h中）检查用户指针是否指向“PHYS_BASE”下方；然后通过文档中提供的<code>get_user</code>函数（从所给地址读取一个字节，如果成功则返回字节代表的值，否则返回-1）判断该地址及其上4字节（每个系统调用参数在堆栈中占用4个字节）地址是否可用。如是，则认为该指针是正确的，将其返回；否则调用<code>kill_process</code>（新增）将当前线程的exit_code置为-1，然后调用<code>thread_exit</code>终止该进程。</p><p>以下所有的系统调用获取参数时都需要通过该方法检查用户指针。</p><p>无效的用户指针将导致“页面错误”，因此需修改page_fault方法。文档中提到内核中的页面错误仅将eax设置为0xffffffff（-1）并将其以前的值复制到eip中，故修改page_fault方法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">user = (f-&gt;error_code &amp; PF_U) != <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (!user) &#123;</span><br><span class="line">  f-&gt;eip =  f-&gt;eax;</span><br><span class="line">  f-&gt;eax = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，page_fault的最后调用了<code>kill</code>方法，该方法中如果用户引发了段错误将调用<code>thread_exit</code>结束用户进程。而我在线程初始化时将exit_code初始化为0（正常退出），此处显然为异常退出，应在thread_exit前将当前线程的exit_code置为-1（否则bad开头的若干测试点无法通过，因为这些测试直接访问NULL引发了段错误）。</p><h5 id="系统调用基础结构"><a href="#系统调用基础结构" class="headerlink" title="系统调用基础结构"></a>系统调用基础结构</h5><p>本小节按照文档给出的推荐实现步骤，完成系统调用基础结构，实现halt、exit、write（部分）系统调用，使用户进程可以正常运行。</p><ul><li><p>改写syscall_handler，使其能够检索系统调用号，并根据系统调用号转移到对应的系统调用。</p><p>系统调用号在调用者的堆栈指针的32位字中，第一个参数在下一个更高地址的32位字中，依此类推。调用syscall_handler()的调用者的堆栈指针可以作为传递给它的“struct intr_frame”的“esp”成员访问。<br>先获取堆栈指针并通过<code>check_user_ptr</code>检查其合法性，然后转换为int*类型并将其解引用得到系统调用号（以下系统调用获取参数的过程与此类似）。再通过switch-case语句转移到对应的系统调用（系统调用号在“lib&#x2F;syscall-nr.h”中定义）。后续增加的系统调用只需在switch-case中增加对应的语句即可。</p></li><li><p>System Call: void halt (void)</p><p>halt系统调用很简单，只需通过调用“shutdown_power_off()”（在“threads&#x2F;init.h”中声明）终止Pintos。如下：</p></li><li><p>System Call: void exit (int status)</p><p>检查并获取参数status（系统调用号即intr_frame-&gt;esp的高32位字），将其作为当前线程的exit_code的值。然后调用thread_exit终止当前用户程序。按照惯例，状态状态为0表示成功，非零值表示错误。</p></li><li><p>System Call: int write (int fd, const void *buffer, unsigned size)</p><p>首先依次获取各个参数指针并检查其合法性，然后将其解引用。需要注意的是buf不仅要检查其指针，还需检查其字符串本体所在的地址空间。</p><p>如果文件描述符<code>fd == 1</code>，即写入标准输出，按照文档要求用<code>putbuf</code>一次性将size个字节从buffer写入打开的文件fd，并返回size。</p><p>fd不是1的情况将在后面文件系统调用部分补充。</p></li></ul><p>至此，只需将process_wait（）更改为无限循环，用户进程至少可以正常运行。后面将完善各个系统调用。</p><h5 id="exec与wait"><a href="#exec与wait" class="headerlink" title="exec与wait"></a>exec与wait</h5><p>exec系统调用的文档描述中提到“父进程在知道子进程是否成功加载其可执行文件之前不能从exec返回。您必须使用适当的同步来确保这一点”，在wait系统调用的描述中也大量提到父子进程的要求。故本小节的任务是实现父子进程，并实现与之相关的exec与wait系统调用。</p><ul><li><p>数据结构：</p><p>根据文档中描述，父进程需要知道子进程是否成功加载其可执行文件，并且在其加载完成之前不能返回。故在thread结构体中增加一个父进程指针<code>parent</code>、<code>sema_exec</code>信号量使父进程等待子进程的执行结果、<code>exec_success</code>标志子进程是否加载成功。<br>文档中又提到，“等待子进程pid并检索子进程的退出状态.如果pid仍然有效，请等待直到终止”、“进程可以生成任意数量的子代，以任何顺序等待它们”，这说明需要有一个列表记录所有子进程，并且对于每一个子进程需要有一个信号量以实现父子进程的同步、在子进程退出后父进程仍能检索子进程的相关信息。因此这里设计<code>child_info</code>结构体记录子进程需要向父进程传递的必要的信息，并在thread结构体中增加<code>children</code>列表记录其所有子进程。为方便子进程向父进程传递信息，且使得子进程退出后父进程仍能知晓子进程的相关信息，在thread结构体中增加child_info类型<code>as_child</code>成员，该成员在进程退出后不会马上销毁。</p><p>有关这些数据结构的详细使用，将在下面描述。</p><p>thread结构体中新增：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread</span> *<span class="title">parent</span>;</span>             <span class="comment">/* 父进程指针 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> <span class="title">sema_exec</span>;</span>        <span class="comment">/* 等待子进程加载其可执行文件 */</span></span><br><span class="line"><span class="type">bool</span> exec_success;                 <span class="comment">/* 加载是否成功 */</span>  </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list</span> <span class="title">children</span>;</span>              <span class="comment">/* 子进程列表 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">child_info</span> *<span class="title">as_child</span>;</span>       <span class="comment">/* 作为子进程提供给父进程的信息 */</span></span><br></pre></td></tr></table></figure><p>child_info结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">child_info</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">tid_t</span> tid;                  <span class="comment">/* 子进程tid */</span></span><br><span class="line">  <span class="type">bool</span> is_waiting;            <span class="comment">/* 父进程是否在等待该子进程 */</span></span><br><span class="line">  <span class="type">int</span> exit_code;              <span class="comment">/* 系统调用exit中的status */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> <span class="title">wait_sema</span>;</span> <span class="comment">/* 同步父子进程 */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_elem</span> <span class="title">elem</span>;</span>      <span class="comment">/* children中的list_elem */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在thread_create中初始化这些成员：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">t-&gt;as_child = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> child_info));</span><br><span class="line">t-&gt;as_child-&gt;tid = tid;</span><br><span class="line">t-&gt;as_child-&gt;is_waiting = <span class="literal">false</span>;</span><br><span class="line">t-&gt;as_child-&gt;exit_code = <span class="number">0</span>;</span><br><span class="line">sema_init(&amp;t-&gt;as_child-&gt;wait_sema, <span class="number">0</span>);</span><br><span class="line">sema_init(&amp;t-&gt;sema_exec, <span class="number">0</span>);</span><br><span class="line">t-&gt;parent = thread_current();</span><br><span class="line">list_push_back(&amp;t-&gt;parent-&gt;children, &amp;t-&gt;as_child-&gt;elem);</span><br></pre></td></tr></table></figure></li><li><p>System Call: pid_t exec (const char *cmd_line)</p><p>系统调用的任务是运行其名称在 cmd_line 中给出的可执行文件，并传递任何给定的参数，返回新进程的进程ID（pid）。 如果程序由于任何原因无法加载或运行，则必须返回pid -1，否则不应为有效pid。</p><p>用户指针的检查与参数的获取上面已经多次描述，以下不再叙述。<br>该系统调用将cmd_line中给出的可执行文件名以及参数一起传递给<code>process_execute</code>，该方法将根据加载的成功与否返回新进程的pid（pintos中为单线程，故pid也即tid）或-1，返回值写入到f-&gt;eax（函数返回值的80x86约定是将它们放在“EAX”寄存器中。 返回值的系统调用可以通过修改struct intr_frame的“eax”成员来实现）。<br><code>process_execute</code>方法的基本实现已经在3.2.2中描述。下面给出其在thread_create后增加的部分：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">tid = thread_create (fn_copy1, PRI_DEFAULT, start_process, fn_copy);</span><br><span class="line">···</span><br><span class="line">  <span class="comment">/* 由于未知原因此处sema_exec可能尚未初始化，导致assertion(is_tail) failed </span></span><br><span class="line"><span class="comment">    故这里手动判断并将其初始化 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_elem</span> *<span class="title">tail</span> =</span> list_tail(&amp;thread_current()-&gt;sema_exec.waiters);</span><br><span class="line"><span class="keyword">if</span>(tail-&gt;prev == <span class="literal">NULL</span>)</span><br><span class="line">  sema_init(&amp;thread_current()-&gt;sema_exec,<span class="number">0</span>);</span><br><span class="line">sema_down(&amp;thread_current()-&gt;sema_exec);</span><br><span class="line"><span class="keyword">if</span> (!thread_current()-&gt;exec_success) &#123;</span><br><span class="line">  <span class="keyword">return</span> TID_ERROR;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> tid;</span><br></pre></td></tr></table></figure><p>在创建子进程之后，为等待子进程加载其可执行文件的结果，这里调用<code>sema_down</code>阻塞父进程，等待子进程信号。然后父进程根据子进程修改的exec_success值返回相应的结果给exec系统调用。<br>在<code>start_process</code>中，若子进程成功加载（load返回true），将通过其父进程指针parent修改父进程的exec_success字段为true，并用<code>sema_up</code>唤醒父进程；若加载失败，则置自身的exit_code为-1，然后唤醒父进程，再调用<code>thread_exit</code>退出。</p></li><li><p>System Call: int wait (pid_t pid)</p><p>等待子进程pid并检索子进程的退出状态。文档中建议根据函数顶部的注释实现process_wait()，然后再根据process_wait()实现wait系统调用。</p><p>wait系统调用中只需检查并获取参数中的pid，将其作为参数传递给process_exit执行，执行的返回值写入到f-&gt;eax。</p><p><code>process_wait</code>方法将返回子进程的退出状态（exit_code）。<br>该方法首先根据系统调用中给出的pid(tid)检索该进程的children列表，如果找到对应pid的子进程，且<code>is_waiting == false</code>（父进程首次在pid上调用过wait），则将子进程的is_waiting字段置为true，然后调用sema_down等待该子进程终止。而如果is_waiting值为ture（文档原话：调用“wait”的进程已经在pid上调用过wait了），则根据文档要求，立即返回-1且不再等待。<br>如果检索完children列表但未找到对应pid的子进程，说明pid不是父进程的直接子级，则立即返回-1。<br>最后将pid从父进程的children列表中移除，并返回pid的exit_code给wait系统调用。</p><p>具体实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">process_wait</span> <span class="params">(<span class="type">tid_t</span> child_tid)</span> </span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">thread</span> *<span class="title">cur</span> =</span> thread_current();</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list</span> *<span class="title">children</span> =</span> &amp;cur-&gt;children;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_elem</span> *<span class="title">e</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">child_info</span> *<span class="title">child</span>;</span></span><br><span class="line">  <span class="keyword">for</span> (e = list_begin (children); e != list_end (children); e = list_next (e))</span><br><span class="line">  &#123;</span><br><span class="line">    child = list_entry(e, <span class="keyword">struct</span> child_info, elem);</span><br><span class="line">    <span class="keyword">if</span> (child-&gt;tid == child_tid) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!child-&gt;is_waiting) &#123;</span><br><span class="line">        child-&gt;is_waiting = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">/* 等待子进程终止。然后，返回子进程传递给exit的状态 */</span></span><br><span class="line">        sema_down(&amp;child-&gt;wait_sema); </span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/* 调用“wait”的进程已经在pid上调用过wait了。*/</span></span><br><span class="line">      <span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* pid不是父进程的直接子级 */</span></span><br><span class="line">  <span class="keyword">if</span> (e == list_end(children))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="comment">/* 将其从父进程的children中移除 */</span></span><br><span class="line">  list_remove(e);</span><br><span class="line">  <span class="keyword">return</span> child-&gt;exit_code;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>文档中还提到“父进程等待在父进程调用wait之前已经终止的子进程是完全合法的，但是内核仍必须允许父进程检索其子进程的退出状态，或者得知该子进程已被终止”。即如果调用wait前pid已经终止，此时再调用<code>sema_wait</code>将导致父进程忙等（终止的进程不可能再调用<code>sema_up</code>）。故子进程退出时需传递相关信息。</p><p>在thread_exit中添加如下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cur-&gt;as_child-&gt;exit_code = cur-&gt;exit_code;</span><br><span class="line">sema_up(&amp;cur-&gt;as_child-&gt;wait_sema);</span><br></pre></td></tr></table></figure><p>这样就能避免上述情况。</p></li></ul><h5 id="文件系统调用"><a href="#文件系统调用" class="headerlink" title="文件系统调用"></a>文件系统调用</h5><p>文档中提到，“您必须同步系统调用，以便任意数量的用户进程可以进行调用。特别地，同时从多个线程调用“filesys”目录中提供的文件系统代码是不安全的。您的系统调用实现必须将文件系统代码视为临界区。”</p><p>我用锁机制实现上述功能：<br>在syscall.h中加入：</p><p><code>struct lock file_lock;  /* 用于互斥访问file */</code></p><p>然后在syscall_init中完成对锁的初始化：</p><p><code>lock_init(&amp;file_lock);</code></p><p>以下系统调用对文件操作时都需要先加锁、后释放锁。</p><p>pintos在“filesys”目录下提供了一个简单但完整的文件系统，部分系统调用只需在加锁后调用对应函数即可。</p><ul><li><p>System Call: bool create (const char *file, unsigned initial_size)</p><p>创建一个名为file的新文件，其初始大小为 initial_size个字节。如果成功，则返回true，否则返回false。</p><p>filesys_create已经提供了相关的实现。该系统调用只需获取并检查参数、加锁、调用<code>filesys_create</code>并将返回值写入f-&gt;eax、释放锁即可。</p><p>如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> </span><br><span class="line"><span class="title function_">syscall_create</span><span class="params">(<span class="keyword">struct</span> intr_frame *f)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *file_name = *(<span class="type">char</span> **)check_user_ptr(f-&gt;esp + ptr_size);</span><br><span class="line">  check_user_ptr(file_name);</span><br><span class="line">  <span class="type">int</span> file_size = *(<span class="type">int</span> *)check_user_ptr(f-&gt;esp + <span class="number">2</span> * ptr_size);</span><br><span class="line"></span><br><span class="line">  lock_acquire(&amp;file_lock);  </span><br><span class="line">  f-&gt;eax = filesys_create(file_name, file_size);</span><br><span class="line">  lock_release(&amp;file_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>System Call: bool remove (const char *file)</p><p>删除名为file的文件。如果成功，则返回true，否则返回false。</p><p>具体实现同上，只需略去file_size参数、换为执行<code>filesys_remove</code>即可，此处不再赘述。</p></li><li><p>进程与文件</p><p>下面的系统调用中提到，每个进程可以打开多个文件，每个打开的文件有一个&gt;1的文件描述符，每个进程有一组独立的文件描述符。还需要根据文件描述符找到打开的文件。</p><p>为实现这些功能，增加如下数据结构与方法：</p><ul><li>数据结构：</li></ul><p><code>struct list file_list;   /* 打开文件列表 */</code></p><p><code>int next_fd;             /* 下一个打开文件的文件描述符，从2开始递增 */</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_info</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">int</span> fd;                             <span class="comment">/* 文件描述符 */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span>;</span>                     </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_elem</span> <span class="title">elem</span>;</span>              <span class="comment">/* file_list中的list_elem */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>并在<code>init_thread</code>初始化file_list、将next_fd初始化为2。</p><ul><li>方法：<br>下面的<code>find_in_file_list</code>方法根据fd在当前线程的file_list中找到对应的file_info。如果没有对应文件，则返回NULL。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> file_info *</span><br><span class="line"><span class="title function_">find_in_file_list</span><span class="params">(<span class="type">int</span> fd)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">thread</span> *<span class="title">cur</span> =</span> thread_current();</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_elem</span> *<span class="title">e</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file_info</span> *<span class="title">file</span>;</span></span><br><span class="line">  <span class="keyword">for</span> (e = list_begin (&amp;cur-&gt;file_list); e != list_end (&amp;cur-&gt;file_list); e = list_next (e))</span><br><span class="line">  &#123;</span><br><span class="line">    file = list_entry(e, <span class="keyword">struct</span> file_info, elem);</span><br><span class="line">    <span class="keyword">if</span> (file-&gt;fd == fd) &#123;</span><br><span class="line">      <span class="keyword">return</span> file;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>System Call: int open (const char *file)</p><p>打开（<code>filesys_open</code>）名为 file_name 的文件，返回文件描述符（fd写入到f-&gt;eax）。如果打开成功，则新建file_info类型变量，用malloc为其分配空间，然后令其fd的值为线程的next_fd，将其文件指针f指向打开的文件。然后将其加入当前线程的file_list。<br>如果无法打开文件，则返回-1。</p></li><li><p>System Call: int filesize (int fd)</p><p>返回以fd打开的文件的大小。</p><p>先得到参数fd，然后在当前线程的file_list中寻找文件描述符为fd的文件（通过<code>find_in_file_list</code>），若存在，filesys中已经提供了对应的实现file_length，调用之并将返回值写入f-&gt;eax即可。若不存在，则返回-1。</p></li><li><p>System Call: int read (int fd, void *buffer, unsigned size)</p><p>从打开为fd的文件中读取size个字节到buffer中。返回实际读取的字节数（文件末尾为0），如果无法读取文件（由于文件末尾以外的条件），则返回-1。</p><p>fd为0（标准输入）则使用<code>input_getc()</code>从键盘读取size个字节，然后将size返回。<br>否则，在当前线程的file_list中找到对应的文件，并用<code>file_read</code>方法读取文件，并将file_read的返回值（实际读取字节数）写到f-&gt;eax。如果找不到对应文件，则返回-1.</p></li><li><p>System Call: int write (int fd, const void *buffer, unsigned size)</p><p>write系统调用已经在3.2.3系统调用基础结构中实现了<code>fd == 1</code>的部分。这里只需将其补充完整。<br>与上面的read类似，只需要将<code>file_read</code>换成<code>file_write</code>即可。</p><p>以下是补充的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_info</span> *<span class="title">file</span> =</span> find_in_file_list(fd);</span><br><span class="line"><span class="keyword">if</span> (file)&#123;</span><br><span class="line">  lock_acquire(&amp;file_lock);  </span><br><span class="line">  f-&gt;eax = file_write(file-&gt;f, buf, size);</span><br><span class="line">  lock_release(&amp;file_lock);    </span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">  f-&gt;eax = <span class="number">0</span>; <span class="comment">//文档要求如果根本无法写入任何字节，则返回0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>System Call: void seek (int fd, unsigned position)</p><p>将打开文件fd中要读取或写入的下一个字节更改为position，以从文件开头开始的字节表示。</p><p>文档中提出这里已经在文件系统中（<code>file_seek</code>）实现，不需要额外的工作。即只需找到fd对应的file，并将其与参数中的position传递给file_seek执行。如果找不到fd则返回-1。其余与其他文件系统调用类似。</p></li><li><p>System Call: unsigned tell (int fd)</p><p>返回打开文件fd中要读取或写入的下一个字节的位置，以从文件开头开始的字节数表示。类似的，调用file_tell即可。</p></li><li><p>System Call: void close (int fd)<br>调用<code>file_close</code>关闭文件描述符fd。需要注意的是，关闭该文件后需要将其从file_list中移除，并释放其空间。其余与上相同。</p><p>另外，文档中提到“退出或终止进程会隐式关闭其所有打开的文件描述符，就像通过为每个进程调用此函数一样”。</p><p>因此，在线程退出时需要检索其file_list，关闭其打开的所有文件，并释放空间。<br>为thread_exit增加如下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 关闭所有已打开的文件 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_info</span> *<span class="title">file_opened</span>;</span></span><br><span class="line"><span class="keyword">while</span> (!list_empty(&amp;cur-&gt;file_list))</span><br><span class="line">&#123;</span><br><span class="line">  e = list_pop_front(&amp;cur-&gt;file_list);</span><br><span class="line">  file_opened = list_entry(e, <span class="keyword">struct</span> file_info, elem);</span><br><span class="line">  lock_acquire(&amp;file_lock);</span><br><span class="line">  file_close(file_opened-&gt;f);</span><br><span class="line">  lock_release(&amp;file_lock);</span><br><span class="line">  <span class="built_in">free</span>(file_opened);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-2-4-Denying-Writes-to-Executables"><a href="#3-2-4-Denying-Writes-to-Executables" class="headerlink" title="3.2.4 Denying Writes to Executables"></a>3.2.4 Denying Writes to Executables</h4><p>文档的最后要求添加代码以拒绝写入用作可执行文件的文件。并提示可以使用<code>file_deny_write（）</code>防止写入打开的文件，只要进程仍在运行，文件就必须保持打开状态。</p><p>故在thread结构体中增加成员以方便在进程退出时关闭打开的可执行文件：</p><p><code>struct file *file_executed;          /* 正在执行的文件 */</code></p><p>进程启动时将通过<code>process_execute</code>方法创建一个新线程，并在<code>start_process</code>中通过<code>load</code>加载可执行文件。<br>当加载成功后，添加如下代码以拒绝该可执行文件被修改：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line">success = load (proc_name, &amp;if_.eip, &amp;if_.esp);</span><br><span class="line"><span class="keyword">if</span>(success)&#123;</span><br><span class="line">  <span class="comment">// 这里的file_lock即上面在syscall.h中声明的锁</span></span><br><span class="line">  lock_acquire(&amp;file_lock);</span><br><span class="line">  <span class="comment">// 进程仍在运行，文件就必须保持打开状态</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span> =</span> filesys_open(proc_name);</span><br><span class="line">  <span class="comment">// 拒绝写入</span></span><br><span class="line">  file_deny_write(f);</span><br><span class="line">  lock_release(&amp;file_lock);</span><br><span class="line">  thread_current()-&gt;file_executed = f;</span><br><span class="line">  ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在进程结束时，关闭该可执行文件。这将重新启用写操作。</p><p>在<code>process_exit</code>的最后添加如下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lock_acquire(&amp;file_lock);</span><br><span class="line">file_close(cur-&gt;file_executed);</span><br><span class="line">lock_release(&amp;file_lock);</span><br></pre></td></tr></table></figure><p>至此，userprog完成。</p><h3 id="3-3测试结果"><a href="#3-3测试结果" class="headerlink" title="3.3测试结果"></a>3.3测试结果</h3><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1-pintos/userprog1.png"><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>本次实验完成了thread和userprog两部分，并且通过了全部测试点，从中我学到了很多东西。</p><p>thread实验中主要困难在于实现线程的调度。刚接触pintos让我有点无从下手，但在理解了pintos中的时钟中断处理与线程调度过程后，写起代码来也就得心应手。不过即使最后通过了所有测试点，在此过程中我仍有一些没有完全理解的地方；写报告的时候回过头来看又发现了一些不影响测试结果的错误。</p><p>例如原来在实现Alarm Clock的时候，原本只在thread结构体中增加了sleep_ticks变量，而没有sleep_list记录睡眠的线程。在调用timer_sleep时设置sleep_ticks的值并将其挂起，然后在timer_interrupt中查找all_list中的线程，使每个睡眠线程的sleep_ticks–；减至0时，将其唤醒。但是这种设计效率较低，而且不知为何导致后面一个测试点始终无法pass。<br>后来增加了sleep_list记录睡眠的线程，调用timer_sleep时将该线程放入sleep_list列表，在每个timer_interrupt时只检查sleep_list中的线程；若到达睡眠时间，则将其从sleep_list移除，并放入ready_list。从我个人理解来说，这样只减少了timer_interrupt中执行的任务量，提高了系统的效率。但修改之后，之前过不了的测试点莫名其妙也过了。这说明我的代码中可能还存在其他的错误。</p><p>再比如说，在将信号量和条件的等待队列改造为优先队列时，原本sema_down和cond_wait中通过list_insert_ordered进行有序插入，然后在唤醒线程时调用list_pop_front唤醒优先级最高的线程。理论上讲上述过程应该没有问题，但在执行过程中发现有几个测试点过不了；在pop_front前对队列执行一次排序后，对应的测试点就通过了。考虑可能是没有唤醒优先级最高的线程，但始终无法找到问题的根源。<br>最终版本中，我把insert_ordered都换回了push_back，然后在唤醒线程时调用list_min（max）找到优先级最大的线程，从而通过了上述的几个测试点。</p><p>这也让我深刻体会到，要编写一个没有漏洞的、能够实际使用的操作系统内核有多么困难。</p><p>而userprog的难点对我来说，主要在于对内核堆栈、程序加载与启动的理解。有了前面的基础，在理解了相关内容（例如指针的偏移）后编写代码也并不难，而且会发现有许多相似的工作。pintos也已经很大程度上简化了这部分的工作量，比如说每个进程只有一个线程、每个系统调用参数在堆栈中都占用4个字节、filesys中已经提供了许多功能的实现等等，文档中也给出了足够的提示。</p><p>相较于thread来说，个人认为userprog没有什么复杂的流程，但要通过所有测试点要比thread难不少，因为要考虑好父子进程的同步问题、文件的互斥问题、资源的回收、指针的检查等，稍不留神就可能导致父进程忙等、kernel panic等错误，这些错误又很难用gdb调试找到根源。</p><p>在这两个实验中，并发、互斥与同步都是重点，测试点中也有很多相关的地方。如何通过信号量、锁、条件变量来实现进程间的互斥与同步、临界区的访问等，这部分知识在课堂上也是重点内容。两个实验做下来，我认为难点不在于编写代码，而是理解操作系统底层知识、任务要求、内核代码的运行逻辑。在编写代码前，需要对pintos的同步机制、中断等有一个全面的认识。掌握了这些基本原理以后，解决实际问题时就更加得心应手。各种算法设计方案的正确与否，都能够通过测试来检验，测试中如果遇到问题，有了这些基本理论的加持，也就不会手足无措。本次课程设计很好地检验了我这部分知识的掌握情况，也锻炼了我将这部分知识投入实践的能力。</p><p>如何设计实验方案也是一个重要的内容。虽然文档中给出较为详细的任务要求，userprog中还给出了推荐的实现步骤，但最终还是要靠自己设计一个正确的实验方案与实现步骤。不合理的实现步骤可能徒增工作量甚至导致冲突。本次实验也锻炼了我这部分能力。</p>]]></content>
      
      
      <categories>
          
          <category> 实验实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>非关系式数据库期末复习</title>
      <link href="/2023/02/23/%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"/>
      <url>/2023/02/23/%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h3 id="非关系式数据库产生的原因"><a href="#非关系式数据库产生的原因" class="headerlink" title="非关系式数据库产生的原因"></a>非关系式数据库产生的原因</h3><p>关系式数据库局限性：高可用、高并发、高性能</p><h4 id="互联网环境下：数据量极大、访问量大、需求千变万化"><a href="#互联网环境下：数据量极大、访问量大、需求千变万化" class="headerlink" title="互联网环境下：数据量极大、访问量大、需求千变万化"></a>互联网环境下：数据量极大、访问量大、需求千变万化</h4><p>要求数据库系统有<strong>高可伸缩性</strong>、<strong>低成本开销</strong>、<strong>高度的灵活性</strong>和<strong>高度的可用性</strong></p><p><strong>可伸缩性</strong>是指有效应对负载变化的能力。</p><p>横向扩展：添加服务器；纵向扩展：升级服务器，配置更多的处理器、内存、网络资源。</p><h3 id="分布式数据库"><a href="#分布式数据库" class="headerlink" title="分布式数据库"></a>分布式数据库</h3><h4 id="集群架构"><a href="#集群架构" class="headerlink" title="集群架构"></a>集群架构</h4><p>集群（cluster）是互相连接的多个独立计算 机的集合，这些计算机可以是单机或多处理器系统（PC、工作站或SMP），每个结点都有自己的存储器、I&#x2F;O设备和操作系统，对用户来说是一个单一的系统，它可以提供低价高效的高性能环境和快速可靠的服务。</p><h4 id="分布式数据库管理的任务"><a href="#分布式数据库管理的任务" class="headerlink" title="分布式数据库管理的任务"></a>分布式数据库管理的任务</h4><p><strong>①</strong>持久的存储数据</p><p>为保证数据可用性，一份数据有多个副本。</p><p><strong>②</strong>维护数据一致性</p><p>用户所查询的数据与数据库中实际存储的数据的一致性， 以及不同数据副本之间的一致性。</p><p>强一致性：</p><p>任何时刻所有的用户查询到的都是最近一次成功更新的数据。这是要求</p><p>最高的标准，也是最难实现的，关系型数据库采用该标准。</p><p>弱一致性：</p><p>某个用户更新了某数据副本，但是系统不能保证后面的用户能够读取到</p><p>最新的值。</p><p><strong>最终一致性</strong>：</p><p>最终一致性是弱一致性的一种特例。某用户更新了副本的数据，如果没有其他用户更新这个副本的数据，系统最终一定能够保证后续用户能够读取到该用户写的最新值。最终一致性存在一个不一致性的窗口，也就是用户写入数据到其他用户读取所写的新值所用的时间。</p><p>a) 因果一致性</p><p>如果用户A通知用户B它已更新了一个数据项，那么用户 B的后续访问将返回更新后的值，且下一次写入将保证取代前一次写入。与用户A无因果关系的用户C的访问遵守一般的 最终一致性规则。</p><p>b) 读写一致性</p><p>当用户A自己更新一个数据项之后，它总是访问到更新过的值，绝不会看到旧值。这是因果一致性模型的一个特例。</p><p>c) 会话一致性</p><p>把访问系统的所有用户放到会话的上下文中，只要会 话还存在，系统就保证读写一致性。如果由于某些失败情 形令会话终止，就要建立新的会话，而且系统保证不会延 续到新的会话。</p><p>d) 单调读一致性</p><p>如果用户已经看到过数据对象的某个值，那么任何后续 访问都不会返回在那个值之前的值。</p><p>e) 单调写一致性</p><p>系统保证来自同一个用户的写操作按顺序执行。</p><p><strong>③</strong>保证数据可用性</p><p>数据库可用性指数据库应该随时可供使用。一般设置主服务器和备份服务器，通过两阶段提交（先写主，在写备份）策略保证数据一致性。</p><h3 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h3><p>在一个<strong>分布式系统</strong>中，一致性（Consistency） 、可用性（Availability）、分区容错性（Partition tolerance）三个基本需求最多只能同时满足两个， 不可能三者兼顾。</p><p>一致性（C） ：各服务器中的数据副本要彼此相同，当一个节点的数据更新完成后，要求其他副 本的数据与此相同。</p><p>可用性（A）：系统能够持续不断地提供相应服务，响应任意的查询请求。</p><p>分区容错性（P）： 由于网络故障，集群被切分成了若干个孤立的区域，这就是分区。分区容错性要求各分区之间虽然不能够通信，但各分区依然可以提供数据服务。一般地，分布式数据库必须尽力在网络发生故障的情况下继续工作，因此分区容错性是<strong>基本要求</strong>。</p><p>CA：SQLServer、MySql</p><p>AP：Cassandra、CouchDB、Riak</p><p>CP：Neo4j、MongoDB、Redis、HBASE、Bigtable</p><h3 id="ACID原理"><a href="#ACID原理" class="headerlink" title="ACID原理"></a>ACID原理</h3><p>ACID是指<strong>事务</strong>必须具备的四个特性:</p><p>(1)原子性(Atomicity)：每个事务是不可分割的数据库逻辑工作单位。</p><p>(2)一致性(Consistency)：事务的执行结果必须使数据库从一个一致性状态变到另一个一致性状态。</p><p>(3)隔离性(Isolation)：并发执行的各个事务之间不能相互干扰。</p><p>(4)持续性(Durability)：持续性也称为永久性，指一个事务一旦提交，它对数据库中数据的改变应该是永久性的。</p><h3 id="BASE原理"><a href="#BASE原理" class="headerlink" title="BASE原理"></a>BASE原理</h3><p>BASE原理与ACID原理不同，它满足CAP原理，通过牺牲强一致性获得可用性，通过达到<strong>最终一致性</strong>来尽量满足业务的绝大多数需求，是NoSQL的性质：</p><p>• BA：Basically Available 基本可用：如果分布式系统中的某些服务器出现了故障，其他服务器仍然可以继续提供服务。</p><p>• S：Soft state 软状态，数据库中的数据最终会被新值所覆盖。</p><p>• E：Eventually consistency 最终一致性，数据副本有可能在短时间内出现彼此不一致的现象，但最终将完成所有副本的更新，保持一致性。</p><h3 id="非关系式数据库基本特征"><a href="#非关系式数据库基本特征" class="headerlink" title="非关系式数据库基本特征"></a>非关系式数据库基本特征</h3><p>1）不需要预定义模式：每条记录都可能有不同的属性和格式，其模式在插入数据时动态定义。</p><p>2）弹性可扩展：可以动态增加或者删除集群节点，数据可自行迁移。</p><p>3）数据分区存放：将数据进行分区之后存储在多个节点上，节点间自动进行数据复制，制作多个数据副本。</p><p>4）异步复制数据：将数据先写入一个节点，再根据数据备份的数量复制数据，这样可以尽快地写入一个节点。</p><p>5）BASE：相对于事务严格的ACID特性，NoSQL数据库保证的是BASE特性。</p><p>非关系式数据库适用的范围： 1）数据模型比较简单； 2）需要灵活性更强的集群系统； 3）关注更高的性能； 4）不需要保证强一致性。</p><h2 id="键值数据库"><a href="#键值数据库" class="headerlink" title="键值数据库"></a>键值数据库</h2><h3 id="键值数据库的数据结构"><a href="#键值数据库的数据结构" class="headerlink" title="键值数据库的数据结构"></a>键值数据库的数据结构</h3><p>键值数据库根据键名（Key）来读写键值（Value），其采用的数据模型是关联数组。</p><p>关联数组（associative array）是和普通数组类似的一种数据结构，但与数组相比具有两个不同的特点：</p><p>（1） 关联数组的每个元素的数据类型可以不同，如其中的元素可以分别是整数、浮点数、字符、列表、对象等；</p><p>（2） 关联数组的下标不仅可以是整数，还可以是字符串。</p><p>也就是说，关联数组是数组概念的泛化，它以唯一的标识符作为下标的有序列表，这个下标称为键（Key），而数组元素称为值（Value）。关联数组也被称为字典、映射、哈希或者符号表等，在键值数据库中被称为键值对。</p><p>键值数据库的数据结构就是<strong>关联数组</strong>，也称为Hash表，形式上是一个键值对（Key，Value）。</p><p>– 键（Key）：用来查询值的唯一标识符。</p><p>– 值（Value）：是一个实例，与唯一的Key相关联，可以是任意的数据类型。</p><p>– 命名空间键(namespace):键值对构成的集合，也称为桶（bucket）或数据库(database)。</p><p>• 同一个命名空间中的键不允许相同，不同命名空间中的键可以相同。</p><p>– 分区：根据键名，把数据分割成不同的单元，存储在集群中的不同服务器上，实现负载均衡。</p><h3 id="键的设计与分区"><a href="#键的设计与分区" class="headerlink" title="键的设计与分区"></a>键的设计与分区</h3><p><strong>键</strong></p><p>键命名一般方法： 实体名：实体标识符：实体属性</p><p><strong>分区</strong></p><p>集群中的一组或一个服务器称为集群的分区。 目标：尽可能将键值对均衡地分配给集群中的不同分区。</p><p>一般以“键”作为分区的依据，通过所定义的Hash哈希函数直接将键值对映射到相应分区。</p><p>如果两个不同的键产生了相同的哈希值，则称为<strong>碰撞</strong>。 解决的基本方法是在对应的存储空间中另外设置一个列表，类似于一个链表。</p><p>如果某个键无法实现<strong>负载均衡</strong>，可以采取的办法： 另选合适的分区键，使得分区结果更加均衡；改变哈希分区算法。</p><p><strong>命名空间</strong></p><p>由互不相同的<strong>键值对</strong>所构成<strong>集合</strong>称为命名空间，也称为桶。同一个命名空间中的键互不相同；不同命名空间中的键可以相同。</p><p><strong>无纲要模式</strong></p><p>对于关系型数据库，一般需要先构建数据库纲要 （<strong>数据库结构</strong>），然后再添加数据。 • 在键值数据库中，则采用无纲要模型： – 不需要在添加数据之前定义所有的键，也无需 指定值的数据类型； – 可以任意的修改数据。</p><h3 id="键值数据库特点"><a href="#键值数据库特点" class="headerlink" title="键值数据库特点"></a>键值数据库特点</h3><p>数据模型简单-键值对、速度快-缓存、易缩放-动态增减结点</p><p>局限性：只能通过键来查询数据；不支持查询某个范围的值；不支持SQL式的标准查询语言。</p><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><p>String 是 Redis 最基本的数据类型，一个 key 对应一个 value，可以存储任何数据，最大能存储 512MB。数值型数据作为字符串处理。</p><p>–SET key value：设置指定 key 的值</p><p>-GET key：获取指定 key 的值。</p><p>–GETRANGE key start end:返回 key 中字符串值的子串</p><h4 id="Hash数据类型"><a href="#Hash数据类型" class="headerlink" title="Hash数据类型"></a>Hash数据类型</h4><p>哈希Hash是一个String类型的field和value的映射表，用于 存储对象,每个hash可以存储232-1键值对（40多亿）。</p><p>–HSET key field value:将哈希表 key 中的 field 的值设为 value</p><p>–HGET key field：获取指定 key 的指定字段的值。</p><p>–HMSET key field1 value1 field2 value2…：同时设置多个Hash</p><p>–HGETALL key:获得哈希表中指定key的所有字段和值。</p><h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><p>List列表是简单的字符串列表，按照插入顺序排序。</p><p>–LPUSH key value1 [value2]:将一个或多个值插入到列表 头部（左部）</p><p>–LRANGE key start stop:获取列表指定范围内的元素</p><p>–RPUSH key value1 [value2]:将一个或多个值插入到列表 尾部（右部）</p><h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><p>Set是String类型的无序集合，集合成员是唯一的，不能出现重复的数据。通过哈希表实现，每个集合可存储40 多亿个成员。</p><p>–SADD key member1 [member2]：向集合添加一个或多个成员</p><p>–SMEMBERS key:返回集合中的所有成员。</p><p>–SREM key member1 [member2]：移除集合中一个或多个成员</p><h4 id="Sorted-Set"><a href="#Sorted-Set" class="headerlink" title="Sorted Set"></a>Sorted Set</h4><p>Sorted Set有序集合和集合一样也是String类型元素的 集合，且不允许重复的成员。不同的是每个元素都会关联一个double类型的数，Redis通过这个数来为集合中的成员进行从小到大的排序。</p><p>–ZADD key score1 member1 [score2 member2]：向有序集 合添加一个或多个成员，或者更新已存在成员的数值</p><p>–ZRANGE key start stop [WITHSCORES]:通过索引区间返回有序集合指定区间内的成员</p><h4 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h4><p>Redis事务的定义方法：</p><p>–执行MULTI:开始一个事务。</p><p>–命令入队。</p><p>–执行EXEC：依次执行队列中的命令。</p><p>单个命令是原子性的，但事务不是原子性的。</p><p>批量操作在发送 EXEC 命令前被放入队列缓存；</p><p>收到 EXEC 命令后进入事务执行，事务中任意命令执行失败，其余的命令依然被执行（非原子性）；</p><p>在事务执行过程，其他客户端提交的命令请求不会插入 到事务执行命令序列中。</p><h2 id="文档数据库"><a href="#文档数据库" class="headerlink" title="文档数据库"></a>文档数据库</h2><p>文档数据库是将数据以文档的形式存储，若干个文档形成一个集合，若干个集合构成了一个独立的文档数据库。</p><p>文档是由一些键值对构成的有序集合。而键值对是由键和值组成的， 且每个键值对只能出现一次。文档通常用 JSON 格式进行编写，也可以用 XML 格式进行描述。</p><p>集合是由相似文档构成的组，同一个集合内的文档结构可以是不同的。集合没有类似SQL数据库中严格的数据库结构（称为模式或纲要），无需提前为集合中的文档定义模式，是无纲要的数据库。一般地，集合内的文档通常都与同一个主题相关。</p><p>文档数据库是存放集合的容器。</p><h3 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h3><p>1）垂直分区：对文档的键值对进行分区，不同的键值 对存储到不同的服务器上</p><p>2）水平分区 将不同的文档划分在不同的分区上，称为“分片”，这些分片会保存在不同的服务器上。</p><p>–优势：提高文档数据库的访问性能，并发度；提高文档数据库的可扩展性。</p><p>–用分片键来划分：用某个键去划分文档，如名称、 类型、日期、地域等。</p><p>–用分区算法来实现数据划分，如按照范围、标准、 哈希分区等。</p><h3 id="设计策略"><a href="#设计策略" class="headerlink" title="设计策略"></a>设计策略</h3><p>在关系数据库中，规范化的目标是减少数据冗余 和更新异常。在文档数据库中，为了提高性能，尽量少地进行连接操作，把相关的数据都放在同一份文档之内，这个过程称为去规范化。 1：n关系</p><p>– 采用嵌套的两个文档表示一对多关系中的两个实体</p><p>– 在文档中给出父节点&#x2F;子节点的引用</p><p>N:M关系</p><p>– 采用两个集合来建模，每个集合表示一种实体， 每个集合内的文档维护一份标识符列表。</p><h3 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h3><p>show dbs；db 显示当前数据库；use dbname；db.dropDatabase()</p><h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><p>1）db.createCollection(name, options)：创建集合，类似 数据库中的表。</p><p>– name: 要创建的集合名称；</p><p>– options: 可选参数, 指定有关内存大小及索引的选 项；</p><p>例如：db.createCollection(“orders”,{size:1024,capped:true,ma x:100}) &#x2F;&#x2F;指定size 1024KB，大小固定，满了就会删除旧文 档，最多存放100个文档。</p><p>2）show collections：显示当前数据库中的集合。</p><p>3）db.collection.drop()：删除集合</p><h4 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h4><p>1）db.COLLECTION_NAME**.insert(**document):向集合中添加文档，注意大小写敏感。</p><p>db.firstcollect.insert({</p><p>person_id:319,</p><p>name:”Gang zhang”,</p><p>occupation:”teacher”,</p><p>address: [</p><p>{street:”Zhaohui road”, zip: 310014},</p><p>{street:”Liuhe road”, zip:310032} ]</p><p>})</p><p>2）db.COLLECTION_NAME.insertOne():向指定集合中插入一条文档数据</p><p>– db.firstcollect.insertOne({“a”: 3})</p><p>3）db.COLLECTION_NAME.**insertMany():**向指定集合中插入多条文档数据</p><p>– db.firstcollect.insertMany([{“b”: 3}, {‘c’: 4}])</p><p>4）db.COLLECTION_NAME.<strong>find({query}, {projection})</strong>: 查询指定集合中的文档，注意大小写敏感。</p><p>–query：使用查询操作符指定查询条件，<strong>必填，但可以是空</strong>。类似于SQL中的where子句。</p><p>–projection ：可选参数，使用<strong>投影</strong>操作符指定返回的键。如果返回所有键值，省略该参数。类似于 SQL中的Select子句</p><p>db.COLLECTION_NAME.find().pretty():</p><p>–pretty()方法：可选，以格式化的方式来显示所有 文档。</p><p>–sort({key: 1&#x2F;-1}) 方法：对文档按照key排序，1为升序排列，-1降序排列。</p><p>–skip()方法 ：可选，跳过指定数量的记录，优先级 2（&gt;3）。</p><p>–limit()方法：可选，指定读取的记录条数，优先级 3。</p><p>例如：db.orders.find({},{_id:0}) db.orders.find({cust_id:“A123”})</p><p>db.orders.find({},{_id:0,cust_id:1,amount:1}).limit(2).skip(1).sort({amount:-1})</p><p><img src="http://oss.ripplesu.top/blog/Typora/%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/1ee8d632-1ad1-46f2-8f81-aaffca6d1e22.png" alt="image.png"></p><p>5）db.COLLECTION_NAME.<strong>update</strong>(<strong>&lt;query&gt;,&lt;update&gt;,</strong></p><p>{<strong>upsert</strong>:&lt;boolean&gt;,<strong>multi</strong>: &lt;boolean&gt;, <strong>writeConcern</strong>: &lt;document&gt;})</p><p>– query:更新条件，必填。</p><p>– update:更新的对象和一些更新的操作符，必填。</p><p>– 更新参数：</p><p>• upsert:如果不存在update的记录，是否插入新文档，true为插入，</p><p>默认是false，不插入。选填</p><p>·multi: 默认是false,只更新找到的第一条记录，如果这个参数为true, 就把按条件查出来多条记录全部更新。选填</p><p>db.orders.update({cust_id:”A123”},{$set:{amount:500}},true,false)</p><p>6）db.COLLECTION_NAME.save(&lt;document&gt;):插入或更新已存在的文档。</p><p>指定 _id 字段更新，否则insert</p><p>7）db.COLLECTION_NAME.remove({}) : 移除集合中的文档。</p><p>– query: 删除文档的条件，必填。</p><p>– justOne：如果设为 true 或 1，则只删除一个文档，如果不设置该参数，或使用默认值 false，则删除所有匹配条件的文档。</p><p>deleteOne（）、deleteMany（）类似。</p><h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><p>1）db.collection.createIndex({keys：value}, options})</p><p>– Key:要创建的索引字段，value值是1按升序创建索引，-1则按降序创建索引。</p><p>– Options：根据该参数创建不同类型的索引。</p><p>• 在title上按升序创建一个索引</p><p>db.col.createIndex({“title”:1})</p><p>• 在title和description多个Key上创建复合、唯一索引”cust_index”</p><p>db.col.createIndex({“title”:1,”description”:-1}, { name:”cust_index”,unique: true}) db.collection.dropIndex(“cust_index”) db.orders.getIndexes()</p><h4 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h4><p>db.COLLECTION.aggregate([{pipeline1},{pipelin e2},{pipeline3}…]): 主要用于数据的分组统计，如求平均值、求和等，类似sql语句中的 sum()、count()等。</p><p>– Pipeline操作: 管道操作的目的在于将上一个管道命令的输出作为下一个管道命令的输入。</p><p>db.orders.aggregate([{$match:{status:”A”}},{$group:{ _id:”$cust_id”,totals:{$sum:”$amount”}}}])</p><p>–先使用$match命令查询符合条件的文档，再使用$group命令根据”cust_id”分组统计。</p><h4 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h4><p>MongoDB 模糊查询使用反斜杠“&#x2F;”，并结合一些转义字符实现模糊查询，通过例子来说明具 体使用方法。</p><p>查询图书名称中包含”office”的文档，其语句为：</p><p>db.Books.find({“book_name”:<strong>&#x2F;office&#x2F;</strong>}).pretty()</p><p><img src="http://oss.ripplesu.top/blog/Typora/%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/393f21eb-cfcb-42fa-9f7c-1ab7ee12591d.png" alt="image.png"></p><h2 id="列族数据库"><a href="#列族数据库" class="headerlink" title="列族数据库"></a>列族数据库</h2><h3 id="集群机制"><a href="#集群机制" class="headerlink" title="集群机制"></a>集群机制</h3><h4 id="列族数据库特点"><a href="#列族数据库特点" class="headerlink" title="列族数据库特点"></a>列族数据库特点</h4><p>① 弹性可扩展： Cassandra高度可扩展，允许添加更 多的硬件以适应更多的客户和更多的数据。 ② 始终基于架构：Cassandra没有单点故障，它可以 连续用于不能承担故障的关键业务应用程序。 ③ 线性可扩展： Cassandra通过增加集群中的节点数 量增加吞吐量，保持一个快速的响应时间。 ④ 灵活的数据存储：Cassandra适应所有可能的数据 格式，包括：结构化，半结构化和非结构化。可 以根据需要动态地适应变化的数据结构。⑤ 便捷的数据分发：Cassandra通过在多个数据中 心之间复制数据，可以灵活地在需要时分发数据。 ⑥ 事务支持：支持最终一致性（AP）。 ⑦ 快速写入：被设计为在廉价的商品硬件上运行。 它执行快速写入，并可以存储数百TB的数据， 而不牺牲读取效率。</p><h4 id="Cassandra架构"><a href="#Cassandra架构" class="headerlink" title="Cassandra架构"></a>Cassandra架构</h4><p>Cassandra的设计目的是处理跨多个节点的大数据工作负载，而没有任何单点故障；节点之间具有对等分布式系统，并且数据分布在集群中的所有节点之间。</p><p>– Cassandra集群是一个对等的网络，所有节点都扮演相同的 角色， 每个节点是独立的，并且同时互连到其他节点。</p><p>– Cassandra集群中的每个节点都可以接受读取和写入请求， 无论数据实际位于集群中的何处。</p><p>– 当某节点关闭时，可以从网络中的其他节点提供读&#x2F;写请求。</p><p>1）Cassandra<strong>存储机制</strong>：</p><p>• <strong>提交日志</strong>（CommitLog）： Cassandra在写入数据之前，都要先写日志，用于崩溃后的恢复。</p><p>• <strong>存储表</strong>（Mem表）：是一个驻留在内存中的数据结构，当超过存储表的块大小时，批量写入到磁盘上，即SSTable上。</p><p>• <strong>磁盘文件</strong>（SSTable）： Cassandra在磁盘上存储列族数据的文件。</p><p>• <strong>布隆（Bloom）过滤器</strong>：Cassandra中使用了Bloom过滤器来检测行键所代表的数据是否存在。</p><p>2）Cassandra<strong>通信机制</strong>：</p><p>Cassandra采用<strong>Gossiper协议</strong>进行节点间通信，通过该机制可以了解集群中包含哪些节点、每个节点的状态，这使得集群中任何一个节点都可以收到其他服务器的状态信息，完成任意读取和写入操作；</p><p>此外，Cassandra采用<strong>反熵机制</strong>定期检查节点数据，保障不同副本数据之间的一致性。这里采用的检查不一致的方法是<strong>Merkle Tree</strong>（默克尔树）。</p><p>3）Cassandra<strong>数据复制</strong></p><p>• 数据复制方式：将数据分配到各个节点上，每个节点会存放部分数据的一个副本，允许数据在节点间相互复制，对用户透明。但要求同一行的所有数据必须放在集群的同一节点上。</p><p>• 数据副本因子：定义了集群中存储的副本数量，例如副本 因子是3，则存储3份数据副本。</p><p>数据复制策略：定义数据的副本如何放置到集群环上。</p><p>– <strong>SimpleStrategy</strong> ：不考虑机架的因素，存储在连续的几个节点。假如副本数为3，属于A节点的数据存储在相邻的两个节点中。</p><p>– <strong>OldNetworkTopologyStrategy</strong> :考虑机架的因素，先找一个与第一个数据副本不在同一个数据中心的节点放置第二个 副本；然后再继续找与第二个备份节点位于同一个数据中心，但是不同机架的节点进行备份；接下来所有的备份节点寻找策略就按照SimpleStrategy的备份策略继续寻找。</p><p>– <strong>NetworkTopologyStrategy</strong> ：将M个副本放置到其他的数据中心，将N-M-1的副本放置在同一数据中心的不同机架中。</p><p>4）Cassandra<strong>读写过程</strong></p><p>• 写操作：</p><p>– 节点的每个写入活动都由提交日志捕获。</p><p>– 稍后数据将被存储在内存表中。</p><p>– 每当内存表满时，数据将写入SStable数据文件。</p><p>– 所有写入都会在整个集群中自动分区和复制。</p><p>– Cassandra会定期整合SSTables，丢弃不必要的数据。</p><p>• 读操作：</p><p>– 先从内存表读取所需要的值。</p><p>– 否则从保存所需数据的SSTable中读取。</p><h3 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h3><p>·Keyspace：键空间，概念同早期版本，对应一个数据库。</p><p>• Table：表，与键族的概念相对应，且与RDBMS中的表很类似，不同的是在 Cassandra 中属于同一张表的数据在物理上是分布在不同节点上存储的，同 一张表由多个分区（Partition）组成。</p><p>• 主键：同之前的行键，是一行数据的唯一标识符；如果主键由多个键组成，则称为复合主键。</p><p>• 复合主键：复合主键各部分作用不同：</p><p>– 分区键（partition key）：复合主键的第一个或者第一组 是分区键，将根据这个column的值来分区。不同的分区 会被存储在不同的节点上，<strong>同一行数据分配到相同节点</strong>。</p><p>– 聚类键（clustering columns）：复合主键的第二个及之后 的键为聚类键，用来给数据<strong>排序</strong>，或者索引。</p><p>• <strong>只有主键中涉及的column，才可以作为查询的条件</strong>。</p><p>• 集合数据类型：Cassandra新版本通过设置集合数据 类型来灵活实现超级列：</p><p>– List数据类型：列表，存储类型相同且可以重复的值。</p><p>• [value, value,…]</p><p>– Set数据类型：集合，存储类型相同但不重复的值。</p><p>• {value, value, …}</p><p>– Map数据类型：提供了键到值的映射，每一个元素在内部 作为一列存储，可以修改，替换，删除和查询。</p><p>• {‘key1’:value1, ‘key2’:value2}</p><h3 id="操作语言"><a href="#操作语言" class="headerlink" title="操作语言"></a>操作语言</h3><h4 id="创建键空间"><a href="#创建键空间" class="headerlink" title="创建键空间"></a>创建键空间</h4><p>CREATE KEYSPACE KeySpaceName WITH replication &#x3D; {‘<strong>class</strong>‘: ‘Strategy name’, ‘<strong>replication_factor</strong>‘ : ‘No.Of replicas’}</p><h4 id="增删改-类似于SQL"><a href="#增删改-类似于SQL" class="headerlink" title="增删改 类似于SQL"></a>增删改 类似于SQL</h4><p>CREATE (TABLE | COLUMNFAMILY) ( primary key， [static] ，…… )</p><p>– 静态列：列为静态(STATIC)则能够在在一个给定<strong>分区键</strong>里的多行数据之间共享数据</p><p>例如：</p><p>CREATE TABLE users (</p><p>username text,</p><p>id timeuuid,</p><p>email text STATIC,</p><p>encrypted_password blob STATIC,</p><p>body text,</p><p>PRIMARY KEY (username, id)</p><p>);</p><p>– 将 email 和 encrypted_password 两个字段设置为 STATIC列了，则意味着同一个 username 只会有一个 email 和 encrypted_password 。</p><p>– 在插入获修改数据时，email和encrypted_password 都被设置为相同的值</p><h4 id="查"><a href="#查" class="headerlink" title="查"></a>查</h4><p>SELECT * FROM &lt;table name&gt;</p><p>WHERE &lt;condition&gt;;</p><p>• Where 条件中只支持主键列及索引列的查询。</p><p>• <strong>分区主键</strong>只能用”**&#x3D;**”比较运算符进行查询。</p><p>• 聚类主键支持&#x3D;、&gt;、 &lt;、 &gt;&#x3D;、 &lt;&#x3D;，且要<strong>依次使用</strong>。</p><p>primary key(key1, key2, key3) key1&#x3D;</p><p>• <strong>索引列</strong>只支持**&#x3D;**查询。</p><p>• 否则，需要增加<strong>allow filtering</strong>短语，表示强制查询。</p><p>·删除 DELETE [ column_name ] FROM &lt;identifier&gt; WHERE &lt;condition&gt;</p><h4 id="集合-1"><a href="#集合-1" class="headerlink" title="集合"></a>集合</h4><p><img src="http://oss.ripplesu.top/blog/Typora/%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/28a19bd6-a78d-4262-b974-fb8e1e4519fb.png" alt="image.png"></p><p><img src="http://oss.ripplesu.top/blog/Typora/%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/14e4b88e-c183-4e65-9e15-b842a712b22c.png" alt="image.png"></p><p><img src="http://oss.ripplesu.top/blog/Typora/%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/30f31845-e3e1-4641-9682-03b5528f6aa6.png" alt="image.png"></p><p><img src="http://oss.ripplesu.top/blog/Typora/%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/dd461fe5-4301-4925-ac53-beb0de97b177.png" alt="image.png"></p><p><img src="http://oss.ripplesu.top/blog/Typora/%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/73d8fafe-0b86-4c57-8c02-7f6d3876e578.png" alt="image.png"></p><p><img src="http://oss.ripplesu.top/blog/Typora/%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/21e8df2c-ddd8-4f26-95e2-63c4b64ee096.png" alt="image.png"></p><p><img src="http://oss.ripplesu.top/blog/Typora/%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/ba1ca70b-5b06-4bde-8426-3b899abb2666.png" alt="image.png"></p><h2 id="图数据库"><a href="#图数据库" class="headerlink" title="图数据库"></a>图数据库</h2><p>图数据库是一种基于图论的新型NoSQL数据库， 它的数据存储结构和数据查询方式都是以图论为基础：</p><p>· 节点：表示对象，对象可 以有属性和标签；</p><p>• 边：表示对象间的关系， 边也可以有属性和类型；</p><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><h4 id="属性图数据模型"><a href="#属性图数据模型" class="headerlink" title="属性图数据模型"></a>属性图数据模型</h4><p>图数据模型定义了图中节点以及关系的存储和实现方法。</p><p>属性图是一种常用的图数据模型，被广泛采用，如Neo4j，其主要特点如下：</p><p>– 图由节点和关系（边）组成；</p><p>– 节点有一个或多个标签；</p><p>– 节点有一组属性（键值对）；</p><p>– 关系有一个类型，可以有一组属性；</p><p>– 关系是有方向的，只有一个开始节点和一个结束节点。</p><h4 id="三元组图数据模型"><a href="#三元组图数据模型" class="headerlink" title="三元组图数据模型"></a>三元组图数据模型</h4><p>三元组模型是另外一种重要的图数据模型，包含主谓宾的数据结构，通过三元组来表达实体与实体之间的关系，或者属性与属性值之间的关系，有两种形式：</p><p>– （实体，关系，实体）</p><p>– （实体，属性，属性值）</p><h4 id="超图"><a href="#超图" class="headerlink" title="超图"></a>超图</h4><p>一条边可以关联多个节点</p><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p><strong>写语句：</strong></p><h4 id="创建节点Create语句"><a href="#创建节点Create语句" class="headerlink" title="创建节点Create语句"></a>创建节点Create语句</h4><p>节点用一对小括号<strong>（）</strong>表示，是图数据库的一个节点，节点可以有一个或多个标签，可以有一个或多个 属性。</p><p>Create (Variable:Lable1:Lable2 {Key1:Value1, Key2:Value2})</p><h4 id="创建关系Create语句"><a href="#创建关系Create语句" class="headerlink" title="创建关系Create语句"></a>创建关系Create语句</h4><p>关系用**[]<strong>表示，创建关系时要指定头节点、尾节点和</strong>类型**， 并指定关系方向</p><p>– 符号“（a）-[r:type]-&gt;（b）”，表示有方向的关系。</p><p>StartNode-[Variable:Type {Key1: Value1, Key2:Value2}] -&gt; EndNode</p><p>• 创建两个节点和一个关系</p><p>CREATE (n:Person { name: ‘Robert’, born: 1951 })</p><p>-[r:DIRECTED] -&gt; (m:Movie { title: ‘Forrest’, released: 1951 })</p><p>RETURN n,r,m</p><p>• Create语句<strong>无法创建没有方向的关系</strong></p><h4 id="MERGE语句"><a href="#MERGE语句" class="headerlink" title="MERGE语句"></a>MERGE语句</h4><p>MERGE语句的作用有两个：</p><p>– 若模式存在，则匹配指定的模式；</p><p>– 若模式不存在，则创建新的模式；</p><p>– 功能是Match子句和Create子句的组合。</p><p>当在整个模式上使用MERGE时，要么整个模式匹配到，要么整个模式被创建。MERGE不能部分应用于模式</p><p>• 检查‘michael’节点是否存在，若不存在该节点，则创建该节点并设置它的属性；若存在所匹配的节点，则不设置它的属性。</p><p>Merge (n:Person{name:’michael’}) <em>on create</em> set n.age&#x3D;20 return n</p><h4 id="SET语句"><a href="#SET语句" class="headerlink" title="SET语句"></a>SET语句</h4><p>SET语句用于更新节点的标签以及节点和关系的属性。</p><p>• 为节点新增一个属性。</p><p>MATCH (n:Person{name:’michael’}) SET <strong>n.born</strong> &#x3D; 1955 RETURN n</p><p>• 为节点新增两个标签。</p><p>MATCH (n:Person{name:’michael’}) SET <strong>n:Teacher:Man</strong> RETURN n</p><p>• 将一个节点的属性值设置为Null，此时属性被删除</p><p>MATCH (n:Person{name:’michael’}) SET n.name&#x3D;<strong>NULL</strong> RETURN n</p><p>• 匹配节点，若匹配成功，则在该节点上设置属性； 若匹配不成功，则创建新节点，不设置属性。</p><p>Merge(n:Teacher{name: ‘michael’}) <strong>on match</strong> set n.title&#x3D;’Professor’ return</p><h4 id="DELETE语句"><a href="#DELETE语句" class="headerlink" title="DELETE语句"></a>DELETE语句</h4><p>DELETE语句用于删除图元素（节点、关系或者路径）。</p><p>– 不能只删除节点，而不删除与之相连的关系，要么显式地删除对应的关系。</p><p>– <strong>DETACH</strong> DELETE语句能够删除一个节点及其所有关系。</p><h4 id="REMOVE语句"><a href="#REMOVE语句" class="headerlink" title="REMOVE语句"></a>REMOVE语句</h4><p>REMOVE语句用于移除节点的标签或者节点和关系的属性。</p><p>• 移除节点的一个属性。</p><p>MATCH (n:Person{name:’michael’}) Remove n.born RETURN n</p><p>• 移除节点的一个（或多个）标签。</p><p>Match(n:Person{name:’Cheng long’}) remove n:Person:Man return n</p><h4 id="FOREACH语句"><a href="#FOREACH语句" class="headerlink" title="FOREACH语句"></a>FOREACH语句</h4><p>FOREACH语句能够更新列表、路径等集合中的每一个元素，可执行的更新命令包括CREATE、SET、 CREATE UNIQUE、DELETE。</p><p>语法格式： <strong>FOREACH (变量 IN [列表] | 更新语句)</strong></p><p>例如：FOREACH (n IN <strong>nodes(p)</strong> | SET n.marked&#x3D;TRUE)</p><p><strong>读语句：</strong></p><h4 id="Match"><a href="#Match" class="headerlink" title="Match"></a>Match</h4><p>• 查询与给定节点<strong>有关系</strong>的节点</p><p>match (n)<strong>–</strong>(m:Movie{title:’American’}) return n,m</p><h4 id="OPTIONAL-MATCH语句"><a href="#OPTIONAL-MATCH语句" class="headerlink" title="OPTIONAL MATCH语句"></a>OPTIONAL MATCH语句</h4><p>OPTIONAL MATCH匹配模式与Match类似，不同之处在于，如果没有匹配到，OPTIONAL MATCH将用 <strong>NULL作为未匹配到部分的值</strong>。</p><h4 id="aggregation"><a href="#aggregation" class="headerlink" title="aggregation"></a>aggregation</h4><p>count、sum、avg、min、max、<strong>collect（放入一个列表）</strong></p><p><strong>通用语句：</strong></p><h4 id="Return：返回查询结果集中的内容。"><a href="#Return：返回查询结果集中的内容。" class="headerlink" title="Return：返回查询结果集中的内容。"></a>Return：返回查询结果集中的内容。</h4><h4 id="Order-by：对输出结果进行排序。"><a href="#Order-by：对输出结果进行排序。" class="headerlink" title="Order by：对输出结果进行排序。"></a>Order by：对输出结果进行排序。</h4><p>ORDER BY语句用于对输出的结果进行排序，要<strong>紧跟在RETURN或WITH的后面</strong>，它指定了输出的结果 应该如何排序，ASC升序，DESC降序。</p><h4 id="Limit：限制输出的行数。"><a href="#Limit：限制输出的行数。" class="headerlink" title="Limit：限制输出的行数。"></a>Limit：限制输出的行数。</h4><h4 id="Skip：跳过开始的一部分结果。"><a href="#Skip：跳过开始的一部分结果。" class="headerlink" title="Skip：跳过开始的一部分结果。"></a>Skip：跳过开始的一部分结果。</h4><h4 id="With：将分段的查询部分连接在一起，查询结果从一部分以管道形式传递给另外一部分作为开始点。"><a href="#With：将分段的查询部分连接在一起，查询结果从一部分以管道形式传递给另外一部分作为开始点。" class="headerlink" title="With：将分段的查询部分连接在一起，查询结果从一部分以管道形式传递给另外一部分作为开始点。"></a>With：将分段的查询部分连接在一起，查询结果从一部分以管道形式传递给另外一部分作为开始点。</h4><p>一个复杂的查询语句可能需要经多次处理。WITH语句把上一个查询语句的结果作为输入，经适当处理， 再把结果传递到后面的语句中。类似于<strong>管道</strong></p><p>MATCH (d{name:’D’})–(n1)–&gt;(n2) WITH n1, <strong>count</strong>(n2) AS num WHERE num &gt;1 RETURN n1.name,num</p><p><strong>聚合的结果必须通过with子句才能被过滤</strong>，即with子句保留n1，并新增聚合查询count(*)，通过where子句过滤。</p><p>• 按照姓名排序后，收集姓名的列表</p><p>MATCH (n) WITH n ORDER BY n.name DESC RETURN collect(n.name)</p><p>ORDER BY子句不可以跟在Match语句后面，要紧跟RETURN或者WITH的后面</p><h4 id="Unwind：将一个列表展开为一个行的序列，列表可以以参数的形式传入。"><a href="#Unwind：将一个列表展开为一个行的序列，列表可以以参数的形式传入。" class="headerlink" title="Unwind：将一个列表展开为一个行的序列，列表可以以参数的形式传入。"></a>Unwind：将一个列表展开为一个行的序列，列表可以以参数的形式传入。</h4><p><img src="http://oss.ripplesu.top/blog/Typora/%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/5815713f-66fb-4daf-9f31-36e7f04be7b0.png" alt="image.png"></p><h4 id="Union：将多个查询结果组合起来。"><a href="#Union：将多个查询结果组合起来。" class="headerlink" title="Union：将多个查询结果组合起来。"></a>Union：将多个查询结果组合起来。</h4><p>• UNION语句：将两个结果集进行合并，去掉重复的。</p><p>• UNION ALL语句：将两个结果集合并，不去掉重复的。</p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="断言函数"><a href="#断言函数" class="headerlink" title="断言函数"></a>断言函数</h4><p>断言是一个布尔函数，即对给定的输入返回true 或false，用于过滤子图。</p><p>• All：判断断言是否适用于列表中的所有元素。</p><p>• Any：判断断言是否至少适用于列表中的一个元素。</p><p>• None：断言不适用于列表中的任何元素，则返回true。</p><p>• Single：断言刚好只适用于列表中的某一个元素，则返回true 。</p><p>语法：</p><p>All&#x2F;Any&#x2F;None&#x2F;Single (variable IN list WHERE predicate)</p><p>– variable：断言变量</p><p>– list：列表表达式</p><p>– predicate：测试列表中所有元素的断言</p><p>例如：</p><p>Any(var IN nodes(p) WHERE var.eyes&#x3D;’blue’)</p><p>• Exists：数据库存在该<strong>模式</strong>或节点中存在该<strong>属性</strong>时，返回true 。</p><p>返回具有name属性，且是否已婚的信息。</p><p>MATCH (n) WHERE <strong>exists(n.name)</strong> &#x2F;&#x2F;存在指定name属性</p><p>RETURN n.name AS name, <strong>exists((n)-[:MARRIED]-&gt;())</strong> AS is_married</p><h4 id="标量函数"><a href="#标量函数" class="headerlink" title="标量函数"></a>标量函数</h4><p>• Size：返回列表中元素的个数。</p><p>返回模式表达式匹配的<strong>子图的个数</strong></p><p>MATCH(a) WHERE a.name&#x3D;’Alice’ RETURN <strong>size((a)–&gt;()–&gt;())</strong> AS num</p><p>• Length：返回路径的长度（关系的个数）。</p><p>• <strong>Type：返回关系的类型(关系的类型只有一个)。</strong></p><p>• Id：返回关系或者节点的id.</p><p>• Coalesce：返回表达式列表中第一个非空的值，若全为空， 返回null。</p><p>• Head：返回列表中的第一个元素。</p><p>• Last ：返回列表中最后一个元素。</p><p>• startNode:返回一个关系的开始节点。</p><p>• endNode：返回一个关系的结束节点。</p><p>·<strong>PROPERTIES()<strong>：返回节点或关系的</strong>属性及属性值</strong>。</p><h4 id="列表函数"><a href="#列表函数" class="headerlink" title="列表函数"></a>列表函数</h4><p>• <strong>Nodes</strong>：返回<strong>路径中的所有节点</strong>的属性和属性值。</p><p>• <strong>Relationships</strong>：返回路径中的<strong>所有关系</strong>的属性和属性值。</p><p>• <strong>Labels</strong>：返回节点的标签(标签可以有多个)。</p><p>• Keys：以字符串形式返回一个节点、关系或map的所有<strong>属性名称</strong>。</p><p>• Tail：返回除首元素之外的所有元素。</p><p>• Range：返回某个范围内的数值，值之间默认步长为1。</p><p>返回0-10之间步长为1，2-18步长为3的所有值。</p><p>RETURN range(0,10),range(2,18,3)</p><p>• Reduce：对列表中每个元素执行表达式，将表达式结果存入累加器。</p><p>将路径中每个节点的age数值加起来，返回一个单值</p><p>RETURN reduce(totalAge&#x3D;0, n IN nodes(p) | totalAge+n.age) AS reduction</p><h3 id="模式操作"><a href="#模式操作" class="headerlink" title="模式操作"></a>模式操作</h3><p><strong>模式用于描述如何查询图数据</strong>，包括节点模式、关系模式、关联节点模式、变长路径的模式、 路径变量。</p><h4 id="模式概念"><a href="#模式概念" class="headerlink" title="模式概念"></a>模式概念</h4><p>1、节点模式</p><p>节点模式使用一对小括号()表示，节点具有标签和属性，如果需要引用节点，则需要定义节点变量，常见的节点模式如下：</p><p>· ()：该模式用于描述节点，且是匿名节点；</p><p>·(n) ：该模式用于描述节点，节点变量名是 n；</p><p>· (n:label)：该模式用于描述节点，节点具有指定的标签 label，也可以指定多个标签；</p><p>··(n{name: ‘Vic’})：该模式用于描述节点，节点具有 name 属性，并且属性值是’Vic’，也可以指定多个属性；</p><p>· (n:label{name: ‘Vic’})：该模式用于描述节点，节点具有指定的标签 label 和属性 name，并且属性值是 ‘Vic’。</p><p>2、关系模式</p><p>关系模式使用一对中括号[]表示，如果需要引用关系，则需要定义关系变量，常见的关系模式如下：</p><p>· []：该模式用于描述关系，且是匿名关系；</p><p>· [r]：该模式用于描述关系，关系变量名是 r；</p><p>· [r: type]：该模式用于描述关系，type 是关系类型，每一个关系必须有且仅有一个类型；</p><p>· [r:type {name: ‘Friend’}]：该模式用于描述关系，关系的类型是 type，关系具有属性 name，并且属性值是 ‘Friend’。</p><p>3、关联节点模式</p><p>节点之间通过关系联系在一起，由于关系具有方向性，因此，–&gt;表示有向关系，–表示存在关系，但不指定方向，常见的关联节点模式如下：</p><p>· (a)-[r]-&gt;(b) ：该模式用于描述节点 a 和 b 之间存在的有向关系 r；</p><p>· (a)–&gt;(b)：该模式用于描述节点 a 和节点 b 之间存在的有向关系；</p><p>· (a)-[r]-(b)：该模式用于描述节点 a 和 b 之间存在关系 r，不指定方向。</p><p>4、路径模式</p><p>路径（Path）是节点和关系的有序组合。从一个节点通过直接关系链接到另外一个节点，这个过程叫遍历，经过的关系个数称为路径长度，也称为步长。Neo4j 支持变长路径模式，**[*N..M]表示路径长度的最小值为 N，最大值为 M**，常见的路径模式如下：</p><p>· (a)–&gt;(b)：是步长为 1 的路径，节点 a 和 b 之间存在直接关系，且方向从 a 到 b；</p><p>· (a)–&gt;()–&gt;(b)：是步长为 2 的路径，从节点 a 经过两个关系和一个节点，到达节点 b；</p><p>· (a)-[*2]-&gt;(b)：表示路径长度固定为 2，头节点是 a，尾节点是 b；</p><p>· (a)-[*3..5]-&gt;(b)：表示路径长度的最小值是 3，最大值是 5，头节点是 a，尾节点是 b；</p><p>· (a)-[*3..]-&gt;(b)：表示路径长度的最小值是 3，头节点是 a，尾节点是 b；</p><p>· (a)-[*..5]-&gt;(b)：表示路径长度的最大值是 5，头节点是 a，尾节点是 b；</p><p>· (a)-[*]-&gt;(b)：表示不限制路径长度，头节点是 a，尾节点是 b。</p><p>此外，路径可以赋给一个变量，该变量是路径变量，用于查询路径。5、路径变量</p><p>路径可以指定（assign）给一个变量，该变量是路径变量，用于引用查询路径。</p><p>• 返回‘Alice‘节点到’Daniel‘节点，且长度不超过3的路径:</p><p>MATCH <strong>p&#x3D;(a)-[*1..3]-&gt;(b)</strong>  WHERE a.name&#x3D;’Alice’ AND</p><p>b.name&#x3D;’Daniel’ RETURN p</p><h4 id="索引-1"><a href="#索引-1" class="headerlink" title="索引"></a>索引</h4><p>使用CREATE INDEX ON 可以在<strong>拥有某个标签的所有节点的某个属性</strong>上创建索引。</p><p>• 在拥有Person标签的节点name属性上创建索引</p><p>CREATE（Drop） INDEX ON :Person(name)</p><h4 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h4><p>约束 Neo4j通过使用约束来保证数据完整性。约束可应用于节点 或者关系，可以创建节点属性的唯一性约束，也可以创建节点 和关系的属性存在性约束。</p><p>在节点的 name 属性上添加唯一性约束。</p><p><strong>CREATE CONSTRAINT ON (b:Person) ASSERT b.name IS UNIQUE</strong></p><p>通过上述唯一性约束，<strong>具有 Person 标签的节点，其 name属性值是唯一的</strong>。</p><p>在关系的 day 属性上添加<strong>存在性约束</strong>。</p><p>CREATA CONSTRAINT ON <strong>()-[k: Knows]-()</strong> <em>ASSERT</em> <strong>exists</strong><em>(k.day)</em></p><p>通过上述唯一性约束，具有 <strong>Knows 类型的关系必须具有 name 属性</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> 学习总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NoSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL注入实验</title>
      <link href="/2023/02/23/SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E9%AA%8C/"/>
      <url>/2023/02/23/SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="实验任务"><a href="#实验任务" class="headerlink" title="实验任务"></a>实验任务</h2><h3 id="搭建DVWA环境"><a href="#搭建DVWA环境" class="headerlink" title="搭建DVWA环境"></a>搭建DVWA环境</h3><p>包括：</p><p>1、搭建LAMP服务；</p><p>2、部署DVWA服务；</p><p>3、访问DVWA主页。</p><h3 id="判断是否存在SQL注入漏洞"><a href="#判断是否存在SQL注入漏洞" class="headerlink" title="判断是否存在SQL注入漏洞"></a>判断是否存在SQL注入漏洞</h3><p>1、在1的环境基础上判断是否存在SQL注入漏洞。</p><p>2、使用sql注入查询数据库用户名和数据库名。</p><h3 id="获取数据库表名、列名"><a href="#获取数据库表名、列名" class="headerlink" title="获取数据库表名、列名"></a>获取数据库表名、列名</h3><p>1、在2的基础上获取数据库表名、列名。</p><p>2、使用sql注入查询dvwa数据库的所有表名。</p><h3 id="获取用户名密码，并猜测root用户"><a href="#获取用户名密码，并猜测root用户" class="headerlink" title="获取用户名密码，并猜测root用户"></a>获取用户名密码，并猜测root用户</h3><p>1、在3的基础上获取用户名密码并猜测root用户。</p><p>2、使用sql注入查询users表中管理员的密码，并将密码解密。</p><h2 id="实验原理"><a href="#实验原理" class="headerlink" title="实验原理"></a>实验原理</h2><p>前置知识：Linux基本使用。</p><h3 id="LAMP和DVWA简介"><a href="#LAMP和DVWA简介" class="headerlink" title="LAMP和DVWA简介"></a>LAMP和DVWA简介</h3><p>LAMP是指一组通常一起使用来运行动态网站或者服务器的自由软件名称首字母缩写。</p><p>L:Linux，操作系统</p><p>A:Apache网页服务器</p><p>M:MySQL，数据库管理软件</p><p>P:PHP，脚本语言</p><p>DVWA（Damn Vulnerable Web Application）是一个用来进行安全脆弱性鉴定的PHP&#x2F;MySQL Web应用，旨在为安全专业人员测试自己的专业技能和工具提供合法的环境，帮助web开发者更好的理解web应用安全防范的过程。</p><h3 id="SQL注入分类"><a href="#SQL注入分类" class="headerlink" title="SQL注入分类"></a>SQL注入分类</h3><p>SQL 注入的分类，基于从服务器接收到的响应，可以划分为：</p><p><strong>联合查询注入：</strong></p><p>前提要求：数据会进行回显，页面有显位符，在一个网站的正常页面，服务端执行SQL语句查询数据库中的数据，客户端将数据展示在页面中，这个展示数据的位置就叫显示位。</p><p>在判断注入点是否存在后，首先可以使用联合查询判断当前数据库类型、版本信息以便于进一步进行注入。</p><p>因为联合查询要求两个语句所查询的字段数与类型需要一致，因此，在进行联合查询之前首先应当判断查询语句中涉及的字段数为多少,使用order by 字段加数字的方法进行测试，order by 原本用来对查询结果进行排序，后面跟上的字段或者数字表示根据那一列来进行排序，若超出结果，则会进行报错，因此可以判断出原本查询中涉及多少个字段。</p><p><strong>基于布尔 SQL 盲注：</strong></p><p>布尔为计算机中的一种数据类型，分为true、False两种类型，盲注则是表示注入过程中数据不会回显，只能根据页面返回两种内容的的不同来判断注入语句判断的内容是否正确。在布尔盲注中通常需要使用连接符号and、or等字符来连接两个字符串。</p><p><strong>基于时间的 SQL 盲注：</strong></p><p>时间类型的盲注本质是利用插入的SQL语句执行造成时间延迟;在猜解正确或者失败时执行造成时间延迟的语句,辅助判断是否内容猜解正确。</p><p>还有基于错误的 SQL 注入、堆查询注入、基于报错的 SQL 盲注等等。</p><h3 id="注入中常用的系统函数"><a href="#注入中常用的系统函数" class="headerlink" title="注入中常用的系统函数"></a>注入中常用的系统函数</h3><p>列举 mysql 中几个常用函数（这些函数常用与 SQL 注入点的判断）。</p><p>version()——MySQL 版本</p><p>user()——数据库用户名</p><p>database()——数据库名</p><p>@@datadir——数据库路径</p><p>@@version_compile_os——操作系统版本</p><h3 id="字符串连接函数"><a href="#字符串连接函数" class="headerlink" title="字符串连接函数"></a>字符串连接函数</h3><p>字符串连接函数在构造 SQL 注入中也常使用：</p><p>concat(str1,str2,…)——没有分隔符地连接字符串；</p><p>concat_ws(separator,str1,str2,…)——含有分隔符地连接字符串；</p><p>group_concat(str1,str2,…)——连接一个组的所有字符串，并以逗号分隔每一条数据。</p><h3 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h3><p>逻辑运算符在 SQL 注入中发挥着十分重要的作用如：||、&amp;&amp;、&amp; 等，其本身含义很容易理解，这里不做过多介绍，等到后面涉及到真正的实操时再做进一步解释。</p><h2 id="实验过程与分析"><a href="#实验过程与分析" class="headerlink" title="实验过程与分析"></a>实验过程与分析</h2><h3 id="搭建DVWA环境-1"><a href="#搭建DVWA环境-1" class="headerlink" title="搭建DVWA环境"></a>搭建DVWA环境</h3><h4 id="1-安装apache2"><a href="#1-安装apache2" class="headerlink" title="1.安装apache2"></a>1.安装apache2</h4><p>打开终端，首先更新源：apt update</p><p>安装apache2：apt install apache2 -y</p><p>启动apache2：service apache2 start</p><p>浏览器访问localhost查看apache2是否正常运行：</p><p><img src="http://oss.ripplesu.top/blog/Typora/SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E9%AA%8C/b81c8833-b285-4898-ab74-d6e23e0a2779.png" alt="image.png"></p><h4 id="2-安装php"><a href="#2-安装php" class="headerlink" title="2.安装php"></a>2.安装php</h4><p>安装PHP：apt install php -y</p><p>安装常用模块：apt install php-pear php-fpm php-dev php-zip php-curl php-xmlrpc php-gd php-mysql php-mbstring php-xml libapache2-mod-php</p><p>查看PHP版本：php -v</p><p><img src="http://oss.ripplesu.top/blog/Typora/SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E9%AA%8C/b4786590-2232-4d9a-9c26-a6e8078bf7f5.png" alt="image.png"></p><p>修改apache配置文件：sudo vim &#x2F;etc&#x2F;php&#x2F;8.1&#x2F;apache2&#x2F;php.ini</p><p>#allow_url_include &#x3D; Off</p><p>allow_url_include &#x3D; On # 设置为On</p><p>vim打开后可输入‘&#x2F;allow_url_include’搜索，然后按‘a’进入插入模式将‘Off’修改为‘On’。修改完成按ESC退出插入模式，然后输入‘:wq’回车保存并退出vim。</p><h4 id="3-安装mysql"><a href="#3-安装mysql" class="headerlink" title="3.安装mysql"></a>3.安装mysql</h4><p>安装mysql：apt install mysql-server -y</p><p>启动mysql服务：service mysql start</p><p>测试数据库是否安装成功，使用root登录数据库。由于是root权限不需要密码：mysql -u root</p><p><img src="http://oss.ripplesu.top/blog/Typora/SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E9%AA%8C/4e4f57f6-c2cb-4182-a3dc-6613d999efa9.png" alt="image.png"></p><p>然后按Ctrl+Z回到终端。</p><p>mysql安全配置初始化：终端输入mysql_secure_installation</p><p>输入y为root用户添加密码插件：</p><p><img src="http://oss.ripplesu.top/blog/Typora/SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E9%AA%8C/b6870c6f-a591-47ef-a8f2-3d40d14cb3cd.png" alt="image.png"></p><p>密码强度与密码可自行设置。</p><p><img src="http://oss.ripplesu.top/blog/Typora/SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E9%AA%8C/8baf3994-b8ec-476c-b494-6946a87242ea.png" alt="image.png"></p><p>如遇到下图错误，可用root登录mysql后输入如下语句修改密码：</p><p>ALTER USER ‘root‘@’localhost’ IDENTIFIED WITH mysql_native_password by ‘mynewpassword’;</p><p><img src="http://oss.ripplesu.top/blog/Typora/SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E9%AA%8C/88adcdca-8883-4052-9344-c26d60ef343d.png" alt="image.png"></p><p>然后回到终端重新输入：mysql_secure_installation，输入刚才设置的密码</p><p><img src="http://oss.ripplesu.top/blog/Typora/SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E9%AA%8C/71b552fe-8596-4f98-b060-06b556ed3002.png" alt="image.png"></p><p>随后即可自行配置（移除匿名用户、禁止远程登录、删除test数据库、重新加载权限表）。这里全部选择y：</p><p><img src="http://oss.ripplesu.top/blog/Typora/SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E9%AA%8C/4f6cd6bf-f915-49f4-a9bf-43354633ba1b.png" alt="image.png"></p><p>最后在终端输入sudo mysql -u root -p，输入密码登录mysql，为dvwa创建数据库：create database dvwa;</p><p><img src="http://oss.ripplesu.top/blog/Typora/SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E9%AA%8C/7c611504-1baa-4cc1-8221-5c8d72af522d.png" alt="image.png"></p><h4 id="4-安装dvwa"><a href="#4-安装dvwa" class="headerlink" title="4.安装dvwa"></a>4.安装dvwa</h4><p>终端输入：cd &#x2F;var&#x2F;www&#x2F;html 回车，然后输入：</p><p>git clone <a href="https://github.com/digininja/DVWA.git">https://github.com/digininja/DVWA.git</a> 下载dvwa（如未下载git可先输入sudo apt install git下载git）。</p><p><img src="http://oss.ripplesu.top/blog/Typora/SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E9%AA%8C/a169bab5-a2b7-4ad6-8245-ac58c7ddf96a.png" alt="image.png"></p><p>修改配置文件，依次输入如下命令：</p><p>1. cd &#x2F;var&#x2F;www&#x2F;html&#x2F;DVWA&#x2F;config &#x2F;&#x2F;切换目录</p><p>2. cp config.inc.php.dist config.inc.php &#x2F;&#x2F;复制文件</p><p>3. vim config.inc.php &#x2F;&#x2F;编辑配置文件</p><p>做如下修改：</p><p>$_DVWA[ ‘db_user’ ] &#x3D; ‘root’;</p><p>$_DVWA[ ‘db_password’ ] &#x3D; ‘dvwa123456’;&#x2F;&#x2F;自行设置的密码</p><p>$_DVWA[ ‘recaptcha_public_key’ ] &#x3D; ‘6LdJJlUUAAAAAH1Q6cTpZRQ2Ah8VpyzhnffD0mBb’;</p><p>$_DVWA[ ‘recaptcha_private_key’ ] &#x3D; ‘6LdJJlUUAAAAAM2a3HrgzLczqdYp4g05EqDs-W4K’;</p><p>最终如下图所示，保存并退出：</p><p><img src="http://oss.ripplesu.top/blog/Typora/SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E9%AA%8C/67a7777b-7acc-4f36-bab8-abaae476ff88.png" alt="image.png"></p><p>给文件夹赋予权限（777代表所有权限）：在终端依次输入如下命令：</p><p>sudo chmod 777 -R &#x2F;var&#x2F;www&#x2F;html&#x2F;DVWA&#x2F;hackable&#x2F;uploads&#x2F;</p><p>sudo chmod 777 &#x2F;var&#x2F;www&#x2F;html&#x2F;DVWA&#x2F;external&#x2F;phpids&#x2F;0.6&#x2F;lib&#x2F;IDS&#x2F;tmp&#x2F;phpids_log.txt</p><p>sudo chmod 777 -R &#x2F;var&#x2F;www&#x2F;html&#x2F;DVWA&#x2F;config</p><p>访问127.0.0.1&#x2F;DVWA&#x2F;setup.php，点击Create&#x2F;Reset Database<br><img src="http://oss.ripplesu.top/blog/Typora/SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E9%AA%8C/edf0454e-de8b-423a-967d-badba1deea9a.png" alt="image.png"></p><p>成功之后会自动跳转到登录界面用户名为admin，密码为password。登陆成功页面如下：</p><p><img src="http://oss.ripplesu.top/blog/Typora/SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E9%AA%8C/89646331-b1a2-46cb-9879-96a442f05241.png" alt="image.png">  </p><p>至此，环境搭建结束。</p><h3 id="SQL注入漏洞的判断"><a href="#SQL注入漏洞的判断" class="headerlink" title="SQL注入漏洞的判断"></a>SQL注入漏洞的判断</h3><p>登录dvwa平台，用户名为”admin”，密码为”password”，并访问127.0.0.1&#x2F;DVWA&#x2F;security.php，设置安全等级为low（此安全级别完全易受攻击，根本没有安全措施）。</p><p><img src="http://oss.ripplesu.top/blog/Typora/SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E9%AA%8C/1c9baa1e-9da2-4f80-9ac2-9443bf7c97cb.png" alt="image.png"></p><p>在终端输入：</p><p>sudo cat &#x2F;var&#x2F;www&#x2F;html&#x2F;DVWA&#x2F;vulnerabilities&#x2F;sqli&#x2F;source&#x2F;low.php</p><p>以查看low级别的sql注入源码。其中最关键的为sql语句的拼接代码，$query &#x3D; “SELECT first_name, last_name FROM users WHERE user_id &#x3D; ‘$id’;”;。代码直接将输入的id拼接在sql语句后并没有对输入的id进行过滤。</p><p><img src="http://oss.ripplesu.top/blog/Typora/SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E9%AA%8C/f0dbcaf9-c56a-41d0-953a-470aef3d562f.png" alt="image.png"></p><p>点击SQL Injection，并在id处输入1。可以看到：</p><p><img src="http://oss.ripplesu.top/blog/Typora/SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E9%AA%8C/19d88b7d-b992-4a33-9893-80df87be5cdd.png" alt="image.png"></p><p>输入1’,可以看到报错。原因是1后的单引号和前面的单引号产生了闭合，导致原有后面的那个单引号变成了多余，而sql语法中引号是必须成对出现的否则就会报错。即可能存在sql注入。</p><p><img src="http://oss.ripplesu.top/blog/Typora/SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E9%AA%8C/46f1ab22-4b67-4169-b2ac-411f3df791f7.png" alt="image.png"></p><p>使用肯定为真的语句测试1’ or ‘1’ &#x3D; ‘1。输出了所有用户信息，判断肯定存在sql注入：</p><p><img src="http://oss.ripplesu.top/blog/Typora/SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E9%AA%8C/9b6c5860-8f24-4d55-aad2-66265652e5b2.png" alt="image.png"></p><p>上面提到low级别sql注入源码直接将输入的id拼接在sql语句后并没有对输入的id进行过滤，那么我们就可以构造语句将单引号进行闭合。我们在1后面加上单引号，与前面的引号构成闭合，再接着在后面插入我们自己想要查询的语句就可以查询我们想要查询的数据。上面的永真语句1’ or ‘1’ &#x3D; ‘1正是如此。</p><p>接下来判断sql注入返回的列数。下面order by x表示输出按照第x列排序，#表示注释后面的sql语句（也可在最后加上’构造单引号的闭合）。当x&#x3D;3时报错，说明sql语句只返回两列信息。</p><p><img src="http://oss.ripplesu.top/blog/Typora/SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E9%AA%8C/efa75692-87b9-4397-b5d7-3a2bbfaa3f97.png" alt="image.png"></p><p>使用联合查询方法查询MySQL 版本和操作系统版本：</p><p>1’ union select version(),@@version_compile_os#</p><p><img src="http://oss.ripplesu.top/blog/Typora/SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E9%AA%8C/6162a72d-4650-4cf4-a864-809d76aefcfb.png" alt="image.png"></p><p>至此完成sql注入的准备活动。</p><h3 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h3><h4 id="1-查询用户名与数据库名"><a href="#1-查询用户名与数据库名" class="headerlink" title="1.查询用户名与数据库名"></a>1.查询用户名与数据库名</h4><p>输入：1’ and 1&#x3D;2 union select user(),database()# （‘1&#x3D;2’为永假语句，这样就可以使前面的查询条件失效，只保留union后查询的数据。）后提交：</p><p><img src="http://oss.ripplesu.top/blog/Typora/SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E9%AA%8C/296529ad-77be-46a6-8fcc-117506023d8b.png" alt="image.png"></p><p>可见用户名为：root@localhost；数据库名：dvwa</p><h4 id="2-查询dvwa数据库的所有表名"><a href="#2-查询dvwa数据库的所有表名" class="headerlink" title="2. 查询dvwa数据库的所有表名"></a>2. 查询dvwa数据库的所有表名</h4><p>每一个mysql都存在一个系统库information_schema，里面有mysql的“骨架”即所有的数据库、数据表、相应的字段名。以下语句查询所有数据库名。得到一个dvwa数据库与1中database()获得的数据库名称相同。</p><p>1’ and 1&#x3D;2 UNION SELECT 1,database() from information_schema.schemata#</p><p><img src="http://oss.ripplesu.top/blog/Typora/SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E9%AA%8C/8cf463ed-ec5e-48b6-b389-6e0eebffe389.png" alt="image.png"></p><p>利用下面语句可以查询information_schema下所有表的名字：</p><p>1’ UNION SELECT 1,table_name from information_schema.tables where table_schema&#x3D;’information_schema’#（table_schema：数据库名）</p><p><img src="http://oss.ripplesu.top/blog/Typora/SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E9%AA%8C/68b29bb3-738d-4b92-8adc-17cb745530d4.png" alt="image.png"></p><p>下面的语句可以查询dvwa表中的所有表名：</p><p>1’ and 1&#x3D;2 UNION SELECT 1,table_name FROM information_schema.tables WHERE TABLE_SCHEMA &#x3D; ‘dvwa’#</p><p><img src="http://oss.ripplesu.top/blog/Typora/SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E9%AA%8C/8837a34a-d669-4844-badc-1c21c16aef52.png" alt="image.png"></p><p>可见dvwa数据库中含guestbook和users两个表。</p><h4 id="3-获取users表中用户名密码，并猜测root用户"><a href="#3-获取users表中用户名密码，并猜测root用户" class="headerlink" title="3. 获取users表中用户名密码，并猜测root用户"></a>3. 获取users表中用户名密码，并猜测root用户</h4><p>在2中，我们已经得到了数据库dvwa的表名guestbook和users。</p><p>可以使用联合查询的方法查询guestbook表的所有列名分别为comment_id、comment、name：</p><p>1’ UNION SELECT 1,column_name from information_schema.columns where table_schema&#x3D;’dvwa’ and table_name&#x3D;’guestbook’#</p><p><img src="http://oss.ripplesu.top/blog/Typora/SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E9%AA%8C/00cb64fa-cd73-42f8-b64c-b90b65394306.png" alt="image.png"></p><p>可以使用联合查询获取获得数据，因为列的数量大于2，所以需要使用group_concat将所有数据合并，并使用0x3a（0x3a是”:”的16进制）分割。</p><p>1’ UNION SELECT 1,group_concat(comment_id,0x3a,comment,0x3a,name) from guestbook#</p><p><img src="http://oss.ripplesu.top/blog/Typora/SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E9%AA%8C/7d1e0a5e-60b0-4e52-ab79-dffd7f1a76ea.png" alt="image.png"></p><p>以下语句可以查看users表中所有列的名字：</p><p>1’ and 1&#x3D;2 UNION SELECT 1,column_name from information_schema.columns where table_schema&#x3D;’dvwa’ and table_name&#x3D;’users’#</p><p><img src="http://oss.ripplesu.top/blog/Typora/SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E9%AA%8C/6e9c3da8-ccdb-4b7c-8b6d-a3500bbf9d1e.png" alt="image.png"></p><p>可以看到users表中有‘user’和‘password’两个列，推测其为用户名和密码。用连接查询获得这两列的数据（或使用上述的group_concat合并所有列的数据），语句如下：</p><p>1’ and 1&#x3D;2 UNION SELECT user,password from users#<br><img src="http://oss.ripplesu.top/blog/Typora/SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E9%AA%8C/53fdf1a2-8bf3-434e-956b-772c214a0b52.png" alt="image.png"></p><p>查出的数据中有用户名为admin的数据。</p><p>将密码：5f4dcc3b5aa765d61d8327deb882cf99通过在线网站解密得明文密码：password。</p><p>至此，实验结束。</p>]]></content>
      
      
      <categories>
          
          <category> 实验实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息安全 </tag>
            
            <tag> SQL注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法</title>
      <link href="/2023/02/20/%E7%AE%97%E6%B3%95/"/>
      <url>/2023/02/20/%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="LeetCode-15-三数之和"><a href="#LeetCode-15-三数之和" class="headerlink" title="LeetCode-15 三数之和"></a><a href="https://leetcode.cn/problems/3sum/">LeetCode-15 三数之和</a></h3><p>题目中要求找到所有「不重复」且和为 00 的三元组，这个「不重复」的要求使得我们无法简单地使用三重循环枚举所有的三元组。这是因为在最坏的情况下，数组中的元素全部为 00，即</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[0, 0, 0, 0, 0, ..., 0, 0, 0]</span><br></pre></td></tr></table></figure><p>任意一个三元组的和都为 0。如果我们直接使用三重循环枚举三元组，会得到 O(N^3^)个满足题目要求的三元组（其中 N 是数组的长度）时间复杂度至少为 O(N^3^)。在这之后，我们还需要使用哈希表进行去重操作，得到不包含重复三元组的最终答案，又消耗了大量的空间。这个做法的时间复杂度和空间复杂度都很高，因此我们要换一种思路来考虑这个问题。</p><p>「不重复」的本质是什么？我们保持三重循环的大框架不变，只需要保证：</p><ul><li><p>第二重循环枚举到的元素不小于当前第一重循环枚举到的元素；</p></li><li><p>第三重循环枚举到的元素不小于当前第二重循环枚举到的元素。</p></li></ul><p>也就是说，我们枚举的三元组 (a, b, c) 满足 a≤b≤c，保证了只有 (a, b, c) 这个顺序会被枚举到，而 (b, a, c)、(c, b, a) 等等这些不会，这样就减少了重复。要实现这一点，我们可以将数组中的元素从小到大进行排序，随后使用普通的三重循环就可以满足上面的要求。</p><p>同时，对于每一重循环而言，相邻两次枚举的元素不能相同，否则也会造成重复。举个例子，如果排完序的数组为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[0, 1, 2, 2, 2, 3]</span><br><span class="line"> ^  ^  ^</span><br></pre></td></tr></table></figure><p>我们使用三重循环枚举到的第一个三元组为 (0, 1, 2)，如果第三重循环继续枚举下一个元素，那么仍然是三元组 (0, 1, 2)，产生了重复。因此我们需要将第三重循环「跳到」下一个不相同的元素，即数组中的最后一个元素 3，枚举三元组 (0, 1, 3)。</p><p>下面给出了改进的方法的伪代码实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">nums.sort()</span><br><span class="line">for first = 0 .. n-1</span><br><span class="line">    // 只有和上一次枚举的元素不相同，我们才会进行枚举</span><br><span class="line">    if first == 0 or nums[first] != nums[first-1] then</span><br><span class="line">        for second = first+1 .. n-1</span><br><span class="line">            if second == first+1 or nums[second] != nums[second-1] then</span><br><span class="line">                for third = second+1 .. n-1</span><br><span class="line">                    if third == second+1 or nums[third] != nums[third-1] then</span><br><span class="line">                        // 判断是否有 a+b+c==0</span><br><span class="line">                        check(first, second, third)</span><br></pre></td></tr></table></figure><p>这种方法的时间复杂度仍然为 O(N^3^)，毕竟我们还是没有跳出三重循环的大框架。然而它是很容易继续优化的，可以发现，如果我们固定了前两重循环枚举到的元素 a 和 b，那么只有唯一的 cc 满足 a+b+c&#x3D;0a+b+c&#x3D;0。当第二重循环往后枚举一个元素 b’时，由于 b’ &gt; b，那么满足 a+b’+c’&#x3D;0的 c’一定有 c’ &lt; c，即 c’在数组中一定出现在 c 的左侧。也就是说，我们可以从小到大枚举 b，同时从大到小枚举 c，即第二重循环和第三重循环实际上是并列的关系。</p><p>有了这样的发现，我们就可以保持第二重循环不变，而将第三重循环变成一个从数组最右端开始向左移动的指针，从而得到下面的伪代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">nums.sort()</span><br><span class="line">for first = 0 .. n-1</span><br><span class="line">    if first == 0 or nums[first] != nums[first-1] then</span><br><span class="line">        // 第三重循环对应的指针</span><br><span class="line">        third = n-1</span><br><span class="line">        for second = first+1 .. n-1</span><br><span class="line">            if second == first+1 or nums[second] != nums[second-1] then</span><br><span class="line">                // 向左移动指针，直到 a+b+c 不大于 0</span><br><span class="line">                while nums[first]+nums[second]+nums[third] &gt; 0</span><br><span class="line">                    third = third-1</span><br><span class="line">                // 判断是否有 a+b+c==0</span><br><span class="line">                check(first, second, third)</span><br></pre></td></tr></table></figure><p>这个方法就是我们常说的「双指针」，当我们需要枚举数组中的两个元素时，如果我们发现随着第一个元素的递增，第二个元素是递减的，那么就可以使用双指针的方法，将枚举的时间复杂度从 O(N^2^)减少至 O(N)。为什么是 O(N) 呢？这是因为在枚举的过程每一步中，「左指针」会向右移动一个位置（也就是题目中的 b），而「右指针」会向左移动若干个位置，这个与数组的元素有关，但我们知道它一共会移动的位置数为 O(N)，均摊下来，每次也向左移动一个位置，因此时间复杂度为 O(N)。</p><p>注意到我们的伪代码中还有第一重循环，时间复杂度为 O(N)，因此枚举的总时间复杂度为 O(N^2^)。由于排序的时间复杂度为 O(NlogN)，在渐进意义下小于前者，因此算法的总时间复杂度为 O(N^2^)。</p><p>上述的伪代码中还有一些细节需要补充，例如我们需要保持左指针一直在右指针的左侧（即满足 b≤c），具体可以参考下面的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>; a &lt; n ;a++)&#123;</span><br><span class="line">    <span class="comment">// 需要和上一次枚举的数不相同</span></span><br><span class="line">            <span class="keyword">if</span>(a &gt; <span class="number">0</span> &amp;&amp; nums[a] == nums[a-<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> n - <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> -nums[a];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> a + <span class="number">1</span>; b &lt; c; b++)&#123;</span><br><span class="line"><span class="comment">// 需要和上一次枚举的数不相同</span></span><br><span class="line">                <span class="keyword">if</span> (b &gt; a + <span class="number">1</span> &amp;&amp; nums[b] == nums[b-<span class="number">1</span>])&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span>(b &lt; c &amp;&amp; nums[b] + nums[c] &gt; target)&#123;</span><br><span class="line">                    c--;</span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">// 如果指针重合，随着 b 后续的增加</span></span><br><span class="line">                <span class="comment">// 就不会有满足 a+b+c=0 并且 b&lt;c 的 c 了，可以退出循环</span></span><br><span class="line">                <span class="keyword">if</span>(b == c)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(nums[b] + nums[c] == -nums[a])&#123;</span><br><span class="line">                    result.add(Arrays.asList(nums[a], nums[b], nums[c]));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度：O(N^2)，其中 N 是数组 nums 的长度。</li><li>空间复杂度：O(logN)。我们忽略存储答案的空间，额外的排序的空间复杂度为 O(logN)。然而我们修改了输入的数组 nums，在实际情况下不一定允许，因此也可以看成使用了一个额外的数组存储了 nums 的副本并进行排序，空间复杂度为 O(N)。</li></ul><h3 id="LeetCode-19-删除链表的倒数第-N-个结点"><a href="#LeetCode-19-删除链表的倒数第-N-个结点" class="headerlink" title="LeetCode-19 删除链表的倒数第 N 个结点"></a><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">LeetCode-19 删除链表的倒数第 N 个结点</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// 双指针。l指向倒数第n个结点的前驱，r指向尾结点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">l</span> <span class="operator">=</span> head, r = head;</span><br><span class="line">        <span class="comment">// 直到r为尾结点</span></span><br><span class="line">        <span class="keyword">while</span>(r.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">// n减至0时，l与r距离正好为n</span></span><br><span class="line">            n--;</span><br><span class="line">            r = r.next;</span><br><span class="line">            <span class="comment">// 同步将l右移，以保持间距为n</span></span><br><span class="line">            <span class="keyword">if</span>(n &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                l = l.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 代表要删除的是头结点（头尾节点距离为n-1）</span></span><br><span class="line">        <span class="keyword">if</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 否则l的next即为待删除结点</span></span><br><span class="line">            l.next = l.next.next;            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LeetCode-23-合并-K-个升序链表"><a href="#LeetCode-23-合并-K-个升序链表" class="headerlink" title="LeetCode-23 合并 K 个升序链表"></a><a href="https://leetcode.cn/problems/merge-k-sorted-lists/">LeetCode-23 合并 K 个升序链表</a></h3><ul><li>前置-合并两个有序链表</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode list1, ListNode list2)</span> &#123;</span><br><span class="line">    <span class="comment">// head为哨兵</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>), p = head;</span><br><span class="line">    <span class="keyword">while</span>(list1 != <span class="literal">null</span> &amp;&amp; list2 != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(list1.val &lt; list2.val)&#123;</span><br><span class="line">            p.next = list1;</span><br><span class="line">            list1 = list1.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p.next = list2;</span><br><span class="line">            list2 = list2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果l1或l2还有元素，直接将当前队尾p的next指向之</span></span><br><span class="line">    p.next = list1 == <span class="literal">null</span> ? list2 : list1;</span><br><span class="line">    <span class="keyword">return</span> head.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>顺序合并</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">mergeKLists</span><span class="params">(ListNode[] lists)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;lists.length;i++)&#123;</span><br><span class="line">        head = mergeTwoLists(head,lists[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://oss.ripplesu.top/blog/%E7%AE%97%E6%B3%95/6214d5d0-ae6d-4074-9388-ccbf21380a58.png" alt="image.png"></p><ul><li>分治</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">mergeKLists</span><span class="params">(ListNode[] lists)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> merge(lists, <span class="number">0</span>, lists.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">merge</span><span class="params">(ListNode[] lists, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        <span class="keyword">return</span> lists[l];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l &gt; r) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> mergeTwoLists(merge(lists, l, mid), merge(lists, mid + <span class="number">1</span>, r));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://oss.ripplesu.top/blog/%E7%AE%97%E6%B3%95/b7882cfe-44cc-4d76-a6c4-bbbcf5dcb9b8.png" alt="image.png"></p><h3 id="LeetCode-46-全排列"><a href="#LeetCode-46-全排列" class="headerlink" title="LeetCode-46 全排列"></a><a href="https://leetcode.cn/problems/permutations/">LeetCode-46 全排列</a></h3><p>这个问题可以看作有 n 个排列成一行的空格，我们需要从左往右依此填入题目给定的 n 个数，每个数只能使用一次。那么很直接的可以想到一种穷举的算法，即从左往右每一个位置都依此尝试填入一个数，看能不能填完这 n 个空格，在程序中我们可以用「<strong>回溯法</strong>」来模拟这个过程。</p><p>我们定义递归函数 <code>backtrack(first,output)</code> 表示从左往右填到第 first 个位置，当前排列为 output。 那么整个递归函数分为两个情况：</p><ul><li><p>如果 first&#x3D;n ，说明我们已经填完了 n 个位置（注意下标从 0 开始），找到了一个可行的解，我们将 output 放入答案数组中，递归结束。</p></li><li><p>如果 first&lt;n，我们要考虑这第 first 个位置我们要填哪个数。根据题目要求我们肯定不能填已经填过的数，因此很容易想到的一个处理手段是我们定义一个标记数组 <code>vis</code> 来标记已经填过的数，那么在填第 first 个数的时候我们遍历题目给定的 n 个数，如果这个数没有被标记过，我们就尝试填入，并将其标记，继续尝试填下一个位置，即调用函数<code>backtrack(first+1,output)</code>。回溯的时候要撤销这一个位置填的数以及标记，并继续尝试其他没被标记过的数。<br>使用标记数组来处理填过的数是一个很直观的思路，但是可不可以去掉这个标记数组呢？毕竟标记数组也增加了我们算法的空间复杂度。<br>答案是可以的，我们可以将题目给定的 n 个数的数组 nums 划分成左右两个部分，左边的表示已经填过的数，右边表示待填的数，我们在回溯的时候只要动态维护这个数组即可。<br>具体来说，假设我们已经填到第 first 个位置，那么 nums 数组中 <code>[0,first−1]</code> 是已填过的数的集合，<code>[first,n−1]</code> 是待填的数的集合。我们肯定是尝试用 <code>[first,n−1]</code> 里的数去填第 first 个数，假设待填的数的下标为 i，那么填完以后我们将第 i 个数和第 first 个数交换，即能使得在填第 <code>first+1</code> 个数的时候 nums 数组的 <code>[0,first]</code> 部分为已填过的数，<code>[first+1,n−1]</code> 为待填的数，回溯的时候交换回来即能完成撤销操作。</p></li><li><p>官方解答（无需标记数组，不按字典序）</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; output = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            output.add(num);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        backtrack(n, output, res, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span> n, List&lt;Integer&gt; output, List&lt;List&lt;Integer&gt;&gt; res, <span class="type">int</span> first)</span> &#123;</span><br><span class="line">        <span class="comment">// 所有数都填完了</span></span><br><span class="line">        <span class="keyword">if</span> (first == n) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(output));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> first; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 动态维护数组</span></span><br><span class="line">            Collections.swap(output, first, i);</span><br><span class="line">            <span class="comment">// 继续递归填下一个数</span></span><br><span class="line">            backtrack(n, output, res, first + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 撤销操作</span></span><br><span class="line">            Collections.swap(output, first, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>标记数组</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; numsList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="comment">// 标记每一位是否已使用 </span></span><br><span class="line">    <span class="type">int</span>[] used = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    backTrace(numsList, list, n, nums, <span class="number">0</span>, used);</span><br><span class="line">    <span class="keyword">return</span> numsList;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backTrace</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; numsList,List&lt;Integer&gt; numList, <span class="type">int</span> n, <span class="type">int</span>[] nums, <span class="type">int</span> depth, <span class="type">int</span>[] used)</span>&#123;</span><br><span class="line">    <span class="comment">// 当n == 递归深度，说明已经找到一个排列</span></span><br><span class="line">    <span class="keyword">if</span>(n == depth)&#123;</span><br><span class="line">        <span class="comment">// 递归函数共享numList，因此需new一个数组放入结果集中</span></span><br><span class="line">        numsList.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(numList));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="comment">// 当前数尚未使用</span></span><br><span class="line">        <span class="keyword">if</span>(used[i] != <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">// 添加进数组中，并标记</span></span><br><span class="line">            numList.add(nums[i]);</span><br><span class="line">            used[i] = <span class="number">1</span>;</span><br><span class="line">            backTrace(numsList, numList, n, nums, depth + <span class="number">1</span>, used);</span><br><span class="line">            <span class="comment">// 回溯</span></span><br><span class="line">            used[i] = <span class="number">0</span>;</span><br><span class="line">            numList.remove(depth);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LeetCode-33-搜索旋转排序数组"><a href="#LeetCode-33-搜索旋转排序数组" class="headerlink" title="LeetCode-33 搜索旋转排序数组"></a><a href="https://leetcode.cn/problems/search-in-rotated-sorted-array/">LeetCode-33 搜索旋转排序数组</a></h3><p>我们将数组从中间分开成左右两部分的时候，一定有一部分的数组是有序的。</p><p>这启示我们可以在常规二分查找的时候查看当前 mid 为分割位置分割出来的两个部分 [l, mid] 和 [mid + 1, r] 哪个部分是有序的，并根据有序的那个部分确定我们该如何改变二分查找的上下界，因为我们能够根据有序的那部分判断出 target 在不在这个部分：</p><ul><li>如果 [l, mid - 1] 是有序数组，且 target 的大小满足 <code>[nums[l],nums[mid]]</code>，则我们应该将搜索范围缩小至 [l, mid - 1]，否则在 [mid + 1, r] 中寻找。</li><li>如果 [mid, r] 是有序数组，且 target 的大小满足 <code>[nums[mid+1],nums[r]]</code>，则我们应该将搜索范围缩小至 [mid + 1, r]，否则在 [l, mid - 1] 中寻找。</li></ul><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>] == target ? <span class="number">0</span> : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">        mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 左边是有序的</span></span><br><span class="line">        <span class="comment">// 注意等号：mid向下取整</span></span><br><span class="line">        <span class="keyword">if</span>(nums[l] &lt;= nums[mid])&#123;</span><br><span class="line">            <span class="comment">// target在左半边</span></span><br><span class="line">            <span class="keyword">if</span>(nums[l] &lt;= target &amp;&amp; nums[mid] &gt; target)&#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target &amp;&amp; nums[r] &gt;= target)&#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LeetCode-39-组合总和"><a href="#LeetCode-39-组合总和" class="headerlink" title="LeetCode-39 组合总和"></a><a href="https://leetcode.cn/problems/combination-sum/">LeetCode-39 组合总和</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> candidates.length;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 升序排序，以便剪枝</span></span><br><span class="line">    Arrays.sort(candidates);</span><br><span class="line">    backTrace(result, candidates, <span class="number">0</span>, target, n, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backTrace</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; result, <span class="type">int</span>[] candidates, <span class="type">int</span> index, <span class="type">int</span> target</span></span><br><span class="line"><span class="params">                      , <span class="type">int</span> n, List&lt;Integer&gt; list, <span class="type">int</span> sum)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index; i &lt; n; i++)&#123;</span><br><span class="line">        list.add(candidates[i]);</span><br><span class="line">        sum += candidates[i];</span><br><span class="line">        <span class="keyword">if</span>(sum &lt; target)&#123;</span><br><span class="line">            <span class="comment">// 由于同一个数可以被无限制重复选取，因此递归的index仍是i</span></span><br><span class="line">            backTrace(result, candidates, i, target, n, list, sum);                </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(sum == target)&#123;</span><br><span class="line">                result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(list));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当sum&gt;=target，则由于candidates已经按升序排序，</span></span><br><span class="line">            <span class="comment">// 则回溯后sum加上后面的数一定&gt;target，故可以剪枝</span></span><br><span class="line">            <span class="comment">// 但因为与上层函数共享list，故仍需remove</span></span><br><span class="line">            list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 回溯</span></span><br><span class="line">        list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">        sum -= candidates[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="LeetCode-49-字母异位词分组"><a href="#LeetCode-49-字母异位词分组" class="headerlink" title="LeetCode-49.字母异位词分组"></a><a href="https://leetcode.cn/problems/group-anagrams/">LeetCode-49.字母异位词分组</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">groupAnagrams</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">    Map&lt;String, List&lt;String&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, List&lt;String&gt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String str : strs) &#123;</span><br><span class="line">        <span class="comment">// 方法1：计数</span></span><br><span class="line">        <span class="comment">// 由于字母异位词的各个字母出现次数必定相等</span></span><br><span class="line">        <span class="comment">// 故可用26位长的整形数组记录每个词的字母出现次数</span></span><br><span class="line">        <span class="comment">// 并按字母顺序及出现次数拼接为map的key</span></span><br><span class="line">        <span class="comment">// int[] counts = new int[26];</span></span><br><span class="line">        <span class="comment">// int length = str.length();</span></span><br><span class="line">        <span class="comment">// for (int i = 0; i &lt; length; i++) &#123;</span></span><br><span class="line">        <span class="comment">//     counts[str.charAt(i) - &#x27;a&#x27;]++;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// // 将每个出现次数大于 0 的字母和出现次数按顺序拼接成字符串，作为哈希表的键</span></span><br><span class="line">        <span class="comment">// StringBuffer sb = new StringBuffer();</span></span><br><span class="line">        <span class="comment">// for (int i = 0; i &lt; 26; i++) &#123;</span></span><br><span class="line">        <span class="comment">//     if (counts[i] != 0) &#123;</span></span><br><span class="line">        <span class="comment">//         sb.append((char) (&#x27;a&#x27; + i));</span></span><br><span class="line">        <span class="comment">//         sb.append(counts[i]);</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// String key = sb.toString();</span></span><br><span class="line">        <span class="comment">// 方法二：排序</span></span><br><span class="line">        <span class="type">char</span>[] array = str.toCharArray();</span><br><span class="line">        Arrays.sort(array);</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(array);</span><br><span class="line">        <span class="comment">// 存在key则返回对应值，否则返回第二个参数</span></span><br><span class="line">        List&lt;String&gt; list = map.getOrDefault(key, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;());</span><br><span class="line">        list.add(str);</span><br><span class="line">        map.put(key, list);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;String&gt;&gt;(map.values());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LeetCode-55-跳跃游戏"><a href="#LeetCode-55-跳跃游戏" class="headerlink" title="LeetCode-55 跳跃游戏"></a><a href="https://leetcode.cn/problems/jump-game/?envType=featured-list&envId=2cktkvj?envType=featured-list&envId=2cktkvj">LeetCode-55 跳跃游戏</a></h3><p>刚开始很快就想到了回溯的方法，兴高采烈地写完代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canJump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> backTrace(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">backTrace</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> index, <span class="type">int</span> n)</span>&#123;</span><br><span class="line"><span class="comment">// 当前位置可以直接跳到末尾</span></span><br><span class="line">        <span class="keyword">if</span>(index + nums[index] &gt;= n)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 否则，依次尝试跳[1,nums[index]]步</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= nums[index]; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(backTrace(nums, index + i, n))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一提交…<br><img src="http://oss.ripplesu.top/blog/%E7%AE%97%E6%B3%95/ac3625b2-de3e-4e9c-94f1-2a15519742d9.png" alt="image.png"><br>一看提示，好家伙，数组长度最大为3*10^4^…<br>思索许久，也没什么好思路。不得已偷瞄了一下题解，才发现可以用贪心来做（距离上次接触贪心，已经是大半年以前上算法课的时候了)。  </p><p>我们依次遍历数组中的每一个位置，并实时维护 <strong>最远可以到达的位置</strong>。对于当前遍历到的位置 i，如果它在 <strong>最远可以到达的位置</strong> 的范围内，那么我们就可以从起点通过若干次跳跃到达该位置，因此我们可以用 i+nums[i] 更新 <strong>最远可以到达的位置</strong>。<br>在遍历的过程中，如果 <strong>最远可以到达的位置</strong> 大于等于数组中的最后一个位置，那就说明最后一个位置可达，我们就可以直接返回 <code>true</code> 作为答案。反之，如果在遍历结束后，最后一个位置仍然不可达，我们就返回 <code>false</code> 作为答案。<br>代码如下：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canJump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length, right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n &amp;&amp; i &lt;= right; i++)&#123;</span><br><span class="line">            right = Math.max(right, i + nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(right &gt;= n - <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成功通过！<br><img src="http://oss.ripplesu.top/blog/%E7%AE%97%E6%B3%95/e798982a-a697-4501-a5ef-6d52dbd8819a.png" alt="image.png"></p><h3 id="LeetCode-56-合并区间"><a href="#LeetCode-56-合并区间" class="headerlink" title="LeetCode-56 合并区间"></a><a href="https://leetcode.cn/problems/merge-intervals/?envType=featured-list&envId=2cktkvj?envType=featured-list&envId=2cktkvj">LeetCode-56 合并区间</a></h3><p>常规的排序的题目，但需要自定义排序规则。好久没写了，这里简单记录一下。<br>排序规则可以使用常规的重写Comparator的方法，也可以使用简洁的lambda表达式，不过实测执行耗时lambda要比重写Comparator的方式慢三分之一。<br>toArray方法可将list转为数组。参数数组的初始化大小list.size如果大于等于list的列表的长度，那么就默认使用当前的参数数组；如果小于list的长度就会重新创建一个数组，效率略低。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] merge(<span class="type">int</span>[][] intervals) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> intervals.length;</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> intervals;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 按左端点升序排序 </span></span><br><span class="line">        Arrays.sort(intervals, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;<span class="type">int</span>[]&gt;() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">int</span>[] interval1, <span class="type">int</span>[] interval2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> interval1[<span class="number">0</span>] - interval2[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// Arrays.sort(intervals, (v1, v2) -&gt; v1[0] - v2[0]); </span></span><br><span class="line">        List&lt;<span class="type">int</span>[]&gt; merge = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> merge.size();</span><br><span class="line">            <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> intervals[i][<span class="number">0</span>], r = intervals[i][<span class="number">1</span>];</span><br><span class="line">    <span class="comment">// merge为空则直接放入</span></span><br><span class="line">    <span class="comment">// 或如果上一数对的右端点小于当前数对的左端点，即无交集 </span></span><br><span class="line">            <span class="keyword">if</span>(size == <span class="number">0</span> || merge.get(size - <span class="number">1</span>)[<span class="number">1</span>] &lt; l)&#123;</span><br><span class="line">                merge.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;l ,r&#125;);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 上一数对右端点小于当前的左端点，由于按左端点排序</span></span><br><span class="line"><span class="comment">// 故取右端点中较大的作为新的右端点的值</span></span><br><span class="line">                merge.get(size - <span class="number">1</span>)[<span class="number">1</span>] = Math.max(merge.get(size - <span class="number">1</span>)[<span class="number">1</span>], r);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> merge.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[merge.size()][]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LeetCode-62-不同路径"><a href="#LeetCode-62-不同路径" class="headerlink" title="LeetCode-62 不同路径"></a><a href="https://leetcode.cn/problems/unique-paths/?envType=featured-list&envId=2cktkvj?envType=featured-list&envId=2cktkvj">LeetCode-62 不同路径</a></h3><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><p>最开始想到的仍然是DFS，不出意料又超时了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        Set&lt;String&gt; result = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        backTrace(m , n, <span class="number">0</span>, <span class="number">0</span>, result, <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> result.size();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backTrace</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n, <span class="type">int</span> i, <span class="type">int</span> j, Set&lt;String&gt; result, StringBuilder path)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == m - <span class="number">1</span> &amp;&amp; j == n - <span class="number">1</span>)&#123;</span><br><span class="line">            result.add(path.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i + <span class="number">1</span> &lt;= m - <span class="number">1</span>)&#123;</span><br><span class="line">            path.append(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">            backTrace(m, n, i + <span class="number">1</span>, j, result, <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(path.toString()));</span><br><span class="line">            path.deleteCharAt(path.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j + <span class="number">1</span> &lt;= n - <span class="number">1</span>)&#123;</span><br><span class="line">            path.append(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">            backTrace(m, n, i, j + <span class="number">1</span>, result, <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(path.toString()));</span><br><span class="line">            path.deleteCharAt(path.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>我们用<code>f(i,j)</code> 表示从左上角走到 <code>(i,j)</code> 的路径数量，其中 i 和 j 的范围分别是 <code>[0,m)</code> 和 <code>[0,n)</code>。<br>由于我们每一步只能从向下或者向右移动一步，因此要想走到 <code>(i,j)</code>，如果向下走一步，那么会从 <code>(i−1,j)</code> 走过来；如果向右走一步，那么会从 <code>(i,j−1)</code> 走过来。因此我们可以写出动态规划转移方程：  <code>f(i,j)=f(i−1,j)+f(i,j−1)</code><br>需要注意的是，如果 <code>i=0</code>，那么 <code>f(i−1,j)</code> 并不是一个满足要求的状态，我们需要忽略这一项；同理，如果 <code>j=0</code>，那么 <code>f(i,j−1)</code> 并不是一个满足要求的状态，我们需要忽略这一项。<br>初始条件为 <code>f(0,0)=1</code>，即从左上角走到左上角有一种方法。</p><p>最终的答案即为 <code>f(m−1,n−1)</code>。</p><h4 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h4><p>为了方便代码编写，我们可以将所有的 <code>f(0,j)</code> 以及 <code>f(i,0)</code> 都设置为边界条件，它们的值均为 1。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] f = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            f[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            f[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                f[i][j] = f[i - <span class="number">1</span>][j] + f[i][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LeetCode-64-最小路径和"><a href="#LeetCode-64-最小路径和" class="headerlink" title="LeetCode-64 最小路径和"></a><a href="https://leetcode.cn/problems/minimum-path-sum/?envType=featured-list&envId=2cktkvj?envType=featured-list&envId=2cktkvj">LeetCode-64 最小路径和</a></h3><p>又是一题动态规划的题目，吸取了上次的教训，这次没有再尝试DFS的方法。<br>由于路径的方向只能是<strong>向下或向右</strong>，因此网格的第一行的每个元素只能从左上角元素开始向右移动到达，网格的第一列的每个元素只能从左上角元素开始向下移动到达，此时的路径是唯一的，因此每个元素对应的最小路径和即为对应的路径上的数字总和。  </p><p>对于不在第一行和第一列的元素，可以从其上方相邻元素向下移动一步到达，或者从其左方相邻元素向右移动一步到达，元素对应的最小路径和等于其上方相邻元素与其左方相邻元素两者对应的最小路径和中的最小值加上当前元素的值。由于每个元素对应的最小路径和与其相邻元素对应的最小路径和有关，因此可以使用动态规划求解。  </p><p>创建二维数组 dp，与原始网格的大小相同，dp[i][j] 表示从左上角出发到 (i,j) 位置的最小路径和。显然，dp[0][0]&#x3D;grid[0][0]。对于 dp 中的其余元素，通过以下状态转移方程计算元素值。</p><p>当 <code>i&gt;0</code> 且 <code>j=0</code> 时，<code>dp[i][0]=dp[i−1][0]+grid[i][0]</code>。</p><p>当 <code>i=0</code> 且 <code>j&gt;0</code> 时，<code>dp[0][j]=dp[0][j−1]+grid[0][j]</code>。</p><p>当 <code>i&gt;0</code> 且 <code>j&gt;0</code> 时，<code>dp[i][j]=min(dp[i−1][j],dp[i][j−1])+grid[i][j]</code>。</p><p>最后得到 <code>dp[m−1][n−1]</code> 的值即为从网格左上角到网格右下角的最小路径和。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minPathSum</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> grid.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">if</span>(m == <span class="number">1</span> &amp;&amp; n == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[][] result = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">        result[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m; i++)&#123;</span><br><span class="line">            result[i][<span class="number">0</span>] = result[i - <span class="number">1</span>][<span class="number">0</span>] + grid[i][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">            result[<span class="number">0</span>][j] = result[<span class="number">0</span>][j - <span class="number">1</span>] + grid[<span class="number">0</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">                result[i][j] = Math.min(result[i - <span class="number">1</span>][j], result[i][j - <span class="number">1</span>]) + grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LeetCode-75-颜色分类"><a href="#LeetCode-75-颜色分类" class="headerlink" title="LeetCode-75 颜色分类"></a><a href="https://leetcode.cn/problems/sort-colors/?envType=featured-list&envId=2cktkvj?envType=featured-list&envId=2cktkvj">LeetCode-75 颜色分类</a></h3><p>一开始就想到了双指针的做法，但思路出现了偏差：我的想法是把2交换到数组尾部，然后让尾部指针–；把0交换到数组首部，然后让指针++。但是尝试了许久都没成功。看了下官方题解的方法三，也是这个思路。但我在细节上考虑不周。<br>以下是官方题解：<br>用指针 p0 来交换 0 ， p2 来交换 2。此时，p0 的初始值仍然为 0，而 p2 的初始值为 n−1。在遍历的过程中，我们需要找出所有的 0 交换至数组的头部，并且找出所有的 2 交换至数组的尾部。  </p><p>由于此时其中一个指针 p2 是从右向左移动的，因此当我们在从左向右遍历整个数组时，如果遍历到的位置超过了 p2，那么就可以直接停止遍历了。  </p><p>具体地，我们从左向右遍历整个数组，设当前遍历到的位置为 i，对应的元素为 nums[i]；<br>如果找到了 0，那么与前面两种方法类似，将其与 nums[p0] 进行交换，并将 p0向后移动一个位置；  </p><p>如果找到了 2，那么将其与 nums[p2] 进行交换，并将 p2向前移动一个位置。  </p><p>这样做是正确的吗？可以发现，对于第二种情况，当我们将 nums[i] 与 nums[p2] 进行交换之后，新的 nums[i] 可能仍然是 2，也可能是 0。然而此时我们已经结束了交换，开始遍历下一个元素 nums[i+1]，不会再考虑 nums[i] 了，这样我们就会得到错误的答案。<br>因此，当我们找到 2 时，我们需要不断地将其与 nums[p2] 进行交换，直到新的 nums[i] 不为 2。此时，如果 nums[i] 为 0，那么对应着第一种情况；如果 nums[i] 为 1，那么就不需要进行任何后续的操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sortColors</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p0</span> <span class="operator">=</span> <span class="number">0</span>, p2 = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= p2; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt;= p2 &amp;&amp; nums[i] == <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">                nums[i] = nums[p2];</span><br><span class="line">                nums[p2] = temp;</span><br><span class="line">                --p2;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">                nums[i] = nums[p0];</span><br><span class="line">                nums[p0] = temp;</span><br><span class="line">                ++p0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LeetCode-87-子集"><a href="#LeetCode-87-子集" class="headerlink" title="LeetCode-87 子集"></a><a href="https://leetcode.cn/problems/subsets/?envType=featured-list&envId=2cktkvj?envType=featured-list&envId=2cktkvj">LeetCode-87 子集</a></h3><p>又是回溯，感觉这块掌握的还可以了，10分钟搞定。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsets</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;());</span><br><span class="line">        backTrace(result, <span class="number">0</span>, nums.length, nums, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backTrace</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; result, <span class="type">int</span> index, <span class="type">int</span> n, <span class="type">int</span>[] nums, List&lt;Integer&gt; cur)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &gt;= n)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index; i &lt; n; i++)&#123;</span><br><span class="line">            cur.add(nums[i]);</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(cur));</span><br><span class="line">            backTrace(result, i + <span class="number">1</span>, n, nums, cur);</span><br><span class="line">            cur.remove(cur.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LeetCode-79-单词搜索"><a href="#LeetCode-79-单词搜索" class="headerlink" title="LeetCode-79 单词搜索"></a><a href="https://leetcode.cn/problems/word-search/?envType=featured-list&envId=2cktkvj?envType=featured-list&envId=2cktkvj">LeetCode-79 单词搜索</a></h3><p>原来以为是单纯的搜索，但仔细想想又是一题回溯，因为相邻字母可能不止一个与单词中下一个字母一致，这条路走不通必须回溯查看有无下一条可行路径。<br>需要注意的是，字母不能重复使用，所以必须增加一个标记数组来标志当前字母是否已经使用。  </p><p>整体思路是：找到单词中第一个字母在数组中所处的位置，然后调用search依次尝试其相邻的字母：如果与单词中下一个字母一致，则在标记数组中将该位置标记为1，然后继续搜索，直到搜索深度与单词长度一致，返回true。若其中一个返回true，则可结束搜索；否则回溯，将标记数组对应位置重置为0。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">exist</span><span class="params">(<span class="type">char</span>[][] board, String word)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> board.length, c = board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span>[][] flag = <span class="keyword">new</span> <span class="title class_">int</span>[r][c];</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; r; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; c; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == word.charAt(<span class="number">0</span>))&#123;</span><br><span class="line">                    flag[i][j] = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span>(search(board, word, flag, <span class="number">1</span>, word.length(), i, j) == <span class="literal">true</span>)&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    &#125; </span><br><span class="line">                    flag[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(<span class="type">char</span>[][] board, String word, <span class="type">int</span>[][] flag, <span class="type">int</span> depth, <span class="type">int</span> n, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(depth == n)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i - <span class="number">1</span> &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i - <span class="number">1</span>][j] == word.charAt(depth) &amp;&amp; flag[i - <span class="number">1</span>][j] != <span class="number">1</span>)&#123;</span><br><span class="line">                flag[i - <span class="number">1</span>][j] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(search(board, word, flag, depth + <span class="number">1</span>, n, i - <span class="number">1</span>, j) == <span class="literal">true</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;      </span><br><span class="line">                flag[i - <span class="number">1</span>][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j - <span class="number">1</span> &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i][j - <span class="number">1</span>] == word.charAt(depth) &amp;&amp; flag[i][j - <span class="number">1</span>] != <span class="number">1</span>)&#123;</span><br><span class="line">                flag[i][j - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(search(board, word, flag, depth + <span class="number">1</span>, n, i, j - <span class="number">1</span>) == <span class="literal">true</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;     </span><br><span class="line">                flag[i][j - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j + <span class="number">1</span> &lt; board[<span class="number">0</span>].length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i][j + <span class="number">1</span>] == word.charAt(depth) &amp;&amp; flag[i][j + <span class="number">1</span>] != <span class="number">1</span>)&#123;</span><br><span class="line">                flag[i][j + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(search(board, word, flag, depth + <span class="number">1</span>, n, i, j + <span class="number">1</span>) == <span class="literal">true</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;   </span><br><span class="line">                flag[i][j + <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i + <span class="number">1</span> &lt; board.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i + <span class="number">1</span>][j] == word.charAt(depth) &amp;&amp; flag[i + <span class="number">1</span>][j] != <span class="number">1</span>)&#123;</span><br><span class="line">                flag[i + <span class="number">1</span>][j] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(search(board, word, flag, depth + <span class="number">1</span>, n, i + <span class="number">1</span>, j) == <span class="literal">true</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125; </span><br><span class="line">                flag[i + <span class="number">1</span>][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LeetCode-146-LRU缓存"><a href="#LeetCode-146-LRU缓存" class="headerlink" title="LeetCode-146 LRU缓存"></a><a href="https://leetcode.cn/problems/lru-cache/?envType=featured-list&envId=2cktkvj?envType=featured-list&envId=2cktkvj">LeetCode-146 LRU缓存</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用LinkedList</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> <span class="keyword">extends</span> <span class="title class_">LinkedHashMap</span>&lt;Integer, Integer&gt;&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capacity;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LRUCache</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(capacity, <span class="number">0.75F</span>, <span class="literal">true</span>);</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.getOrDefault(key, -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">removeEldestEntry</span><span class="params">(Map.Entry&lt;Integer, Integer&gt; eldest)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size() &gt; capacity; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义双向链表</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">capacity</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">ListNode</span>&#123;</span><br><span class="line">        <span class="type">int</span> key;</span><br><span class="line">        <span class="type">int</span> value;</span><br><span class="line">        ListNode prev;</span><br><span class="line">        ListNode next;</span><br><span class="line">        ListNode(<span class="type">int</span> key, <span class="type">int</span> value)&#123;</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode()&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">tail</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LRUCache</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        <span class="built_in">this</span>.map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(capacity);</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.prev = head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, ListNode&gt; map;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        moveToHead(node);</span><br><span class="line">        <span class="keyword">return</span> node.value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">        <span class="keyword">if</span>(node != <span class="literal">null</span>)&#123;</span><br><span class="line">            node.value = value;</span><br><span class="line">            moveToHead(node);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">n</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(key, value);</span><br><span class="line">            map.put(key, n);</span><br><span class="line">            addToHead(n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(map.size() &gt; capacity)&#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">res</span> <span class="operator">=</span> removeTail();</span><br><span class="line">            map.remove(res.key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">removeNode</span><span class="params">(ListNode node)</span>&#123;</span><br><span class="line">        node.prev.next = node.next;</span><br><span class="line">        node.next.prev = node.prev;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addToHead</span><span class="params">(ListNode node)</span>&#123;</span><br><span class="line">        node.prev = head;</span><br><span class="line">        node.next = head.next;</span><br><span class="line">        node.next.prev = node;</span><br><span class="line">        head.next = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">moveToHead</span><span class="params">(ListNode node)</span>&#123;</span><br><span class="line">        removeNode(node);</span><br><span class="line">        addToHead(node);</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode <span class="title function_">removeTail</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">res</span> <span class="operator">=</span> tail.prev;</span><br><span class="line">        removeNode(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LeetCode-152-乘积最大子数组"><a href="#LeetCode-152-乘积最大子数组" class="headerlink" title="LeetCode-152 乘积最大子数组"></a>LeetCode-152 乘积最大子数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProduct</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxF</span> <span class="operator">=</span> nums[<span class="number">0</span>], minF = nums[<span class="number">0</span>], result = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; length; i++)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> maxF, min = minF;</span><br><span class="line">        <span class="comment">// 如果当前位置是一个正数的话，我们更希望以它前一个位置结尾的某个段的积也是个正数，并且希望它尽可能地大。考虑当前位置如果是一个负数的话，那么我们希望以它前一个位置结尾的某个段的积也是个负数，这样就可以负负得正，并且我们希望这个积尽可能「负得更多」，即尽可能小。</span></span><br><span class="line">        maxF = Math.max(max * nums[i], Math.max(nums[i], min * nums[i]));</span><br><span class="line">        minF = Math.min(min * nums[i], Math.min(nums[i], max * nums[i]));</span><br><span class="line">        result = Math.max(maxF, result);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LeetCode-200-岛屿数量"><a href="#LeetCode-200-岛屿数量" class="headerlink" title="LeetCode-200 岛屿数量"></a>LeetCode-200 岛屿数量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 深度优先搜索，时间击败了100%</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numIslands</span><span class="params">(<span class="type">char</span>[][] grid)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">width</span> <span class="operator">=</span> grid.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; width; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; length; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(grid[i][j] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                <span class="comment">// 每找到一块陆地，就进行搜索，</span></span><br><span class="line">                <span class="comment">// 搜索结束该陆地所有相连陆地都被标记为水地，故搜索次数即为岛屿数量</span></span><br><span class="line">                sum ++;</span><br><span class="line">                dfs(grid, i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[][] grid, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &gt;= grid.length || j &gt;= grid[<span class="number">0</span>].length || i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(grid[i][j] == <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(grid[i][j] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">        <span class="comment">// 如果是陆地，则标记为水地代表已搜索</span></span><br><span class="line">        grid[i][j] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="comment">// 上下左右四个方向搜索</span></span><br><span class="line">        dfs(grid, i + <span class="number">1</span>, j);</span><br><span class="line">        dfs(grid, i, j + <span class="number">1</span>);</span><br><span class="line">        dfs(grid, i - <span class="number">1</span>, j);</span><br><span class="line">        dfs(grid, i, j - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LeetCode-206-反转链表"><a href="#LeetCode-206-反转链表" class="headerlink" title="LeetCode-206 反转链表"></a><a href="https://leetcode.cn/problems/reverse-linked-list/">LeetCode-206 反转链表</a></h3><p>小小反转链表竟暗藏玄机。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public ListNode reverseList(ListNode head) &#123;</span><br><span class="line">    ListNode prev = null;</span><br><span class="line">    ListNode curr = head;</span><br><span class="line">    while (curr != null) &#123;</span><br><span class="line">        ListNode next = curr.next;</span><br><span class="line">        curr.next = prev;</span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = next;</span><br><span class="line">    &#125;</span><br><span class="line">    return prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LeetCode-208-前缀树"><a href="#LeetCode-208-前缀树" class="headerlink" title="LeetCode-208 前缀树"></a>LeetCode-208 前缀树</h3><p>Trie，又称前缀树或字典树，是一棵有根树，其每个节点包含以下字段：</p><ul><li><p>指向子节点的指针数组 children。对于本题而言，数组长度为 26，即小写英文字母的数量。此时 children[0] 对应小写字母 a，children[1]对应小写字母 b，…，children[25] 对应小写字母 z。</p></li><li><p>布尔字段 isEnd，表示该节点是否为字符串的结尾。</p></li></ul><p>插入字符串</p><p>我们从字典树的根开始，插入字符串。对于当前字符对应的子节点，有两种情况：</p><ul><li><p>子节点存在。沿着指针移动到子节点，继续处理下一个字符。</p></li><li><p>子节点不存在。创建一个新的子节点，记录在 children数组的对应位置上，然后沿着指针移动到子节点，继续搜索下一个字符。</p></li></ul><p>重复以上步骤，直到处理字符串的最后一个字符，然后将当前节点标记为字符串的结尾。</p><p>查找前缀</p><p>我们从字典树的根开始，查找前缀。对于当前字符对应的子节点，有两种情况：</p><ul><li>子节点存在。沿着指针移动到子节点，继续搜索下一个字符。</li><li>子节点不存在。说明字典树中不包含该前缀，返回空指针。</li></ul><p>重复以上步骤，直到返回空指针或搜索完前缀的最后一个字符。</p><p>若搜索到了前缀的末尾，就说明字典树中存在该前缀。此外，<strong>若前缀末尾对应节点的 isEnd 为真，则说明字典树中存在该字符串</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Trie[] children;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> isEnd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Trie</span><span class="params">()</span> &#123;</span><br><span class="line">        children = <span class="keyword">new</span> <span class="title class_">Trie</span>[<span class="number">26</span>];</span><br><span class="line">        isEnd = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="type">Trie</span> <span class="variable">node</span> <span class="operator">=</span> <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; word.length(); i++)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> word.charAt(i);</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> ch - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(node.children[index] == <span class="literal">null</span>)&#123;</span><br><span class="line">                node.children[index] = <span class="keyword">new</span> <span class="title class_">Trie</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.children[index];</span><br><span class="line">        &#125;</span><br><span class="line">        node.isEnd = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="type">Trie</span> <span class="variable">node</span> <span class="operator">=</span> searchPrefix(word);</span><br><span class="line">        <span class="keyword">return</span> node != <span class="literal">null</span> &amp;&amp; node.isEnd;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">startsWith</span><span class="params">(String prefix)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> searchPrefix(prefix) != <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Trie <span class="title function_">searchPrefix</span><span class="params">(String prefix)</span>&#123;</span><br><span class="line">        <span class="type">Trie</span> <span class="variable">node</span> <span class="operator">=</span> <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; prefix.length(); i++)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> prefix.charAt(i);</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> ch - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(node.children[index] == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.children[index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LeetCode-226-翻转二叉树"><a href="#LeetCode-226-翻转二叉树" class="headerlink" title="LeetCode-226 翻转二叉树"></a>LeetCode-226 翻转二叉树</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 依次翻转左右子树</span></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> invertTree(root.left);</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> invertTree(root.right);</span><br><span class="line">    root.left = right;</span><br><span class="line">    root.right = left;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LeetCode-236-二叉树的最近公共祖先"><a href="#LeetCode-236-二叉树的最近公共祖先" class="headerlink" title="LeetCode-236 二叉树的最近公共祖先"></a>LeetCode-236 二叉树的最近公共祖先</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    search(root, stack, p);</span><br><span class="line">    <span class="comment">// 最近公共祖先节点可以为节点本身，所以还需将结点本身入栈</span></span><br><span class="line">    stack.push(p);</span><br><span class="line">    TreeNode node;</span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">        node = stack.pop();</span><br><span class="line">        <span class="keyword">if</span>(search(node, stack, q))&#123;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将node结点的所有父节点放入栈中</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">search</span><span class="params">(TreeNode root, Stack&lt;TreeNode&gt; stack, TreeNode node)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root == node)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    stack.push(root);</span><br><span class="line">    <span class="keyword">if</span>(search(root.left, stack, node) || search(root.right, stack, node))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    stack.pop();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LeetCode-347-前K个高频元素"><a href="#LeetCode-347-前K个高频元素" class="headerlink" title="LeetCode-347 前K个高频元素"></a>LeetCode-347 前K个高频元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] topKFrequent(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    PriorityQueue&lt;<span class="type">int</span>[]&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;<span class="type">int</span>[]&gt;()&#123;</span><br><span class="line">        <span class="comment">// 小顶堆</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">int</span>[] m, <span class="type">int</span>[] n)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> m[<span class="number">1</span>] - n[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i : nums)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> map.getOrDefault(i, <span class="number">0</span>);</span><br><span class="line">        map.put(i, ++j);</span><br><span class="line">    &#125;</span><br><span class="line">    map.entrySet().stream().forEach(entry -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span>(queue.size() &lt; k)&#123;</span><br><span class="line">            queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;entry.getKey(), entry.getValue()&#125;);                </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (queue.peek()[<span class="number">1</span>] &lt; entry.getValue()) &#123;</span><br><span class="line">                queue.poll();</span><br><span class="line">                queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;entry.getKey(), entry.getValue()&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="type">int</span>[] ret = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">        ret[i] = queue.poll()[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LeetCode-240-搜索二维矩阵II"><a href="#LeetCode-240-搜索二维矩阵II" class="headerlink" title="LeetCode-240 搜索二维矩阵II"></a>LeetCode-240 搜索二维矩阵II</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">searchMatrix</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> matrix.length, col = matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">lastj</span> <span class="operator">=</span> col;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; row; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix[i][<span class="number">0</span>] &gt; target)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从右边开始搜索，因为每行、列都递增，</span></span><br><span class="line">        <span class="comment">// 如果当前搜索位置比目标元素小，下次从当前位置左下角元素开始搜索</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> lastj - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][j] == target)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][j] &lt; target)&#123;</span><br><span class="line">                lastj = j + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LeetCode-287-寻找重复数"><a href="#LeetCode-287-寻找重复数" class="headerlink" title="LeetCode-287 寻找重复数"></a>LeetCode-287 寻找重复数</h3><p>快慢指针</p><p>我们对 nums 数组建图，每个位置 i 连一条 i→nums[i] 的边。由于存在的重复的数字 target，因此 target 这个位置一定有起码两条指向它的边，因此整张图一定存在环，且我们要找到的 target 就是这个环的入口，那么整个问题就等价于 142. 环形链表 II。</p><p>假设环长为 L，从起点到环的入口的步数是 a，从环的入口继续走 b 步到达相遇位置，从相遇位置继续走 c 步回到环的入口，则有 b+c&#x3D;L，其中 L、a、b、c 都是正整数。根据上述定义，慢指针走了 a+b 步，快指针走了 2(a+b ) 步。从另一个角度考虑，在相遇位置，快指针比慢指针多走了若干圈，因此快指针走的步数还可以表示成 a+b+kL，其中 k 表示快指针在环上走的圈数。联立等式，可以得到 <code>2(a+b)=a+b+kL</code><br>解得 <code>a=kL−b</code>，整理可得<code>a = (k − 1)L + (L − b) = (k − 1)L + c</code><br>从上述等式可知，如果慢指针从起点出发，快指针从相遇位置出发，每次两个指针都移动一步，则慢指针走了 a 步之后到达环的入口，快指针在环里走了 k−1 圈之后又走了 c 步，由于从相遇位置继续走 c 步即可回到环的入口，因此快指针也到达环的入口。两个指针在环的入口相遇，相遇点就是答案。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findDuplicate</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="number">0</span>, fast = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        slow = nums[slow];</span><br><span class="line">        fast = nums[nums[fast]];</span><br><span class="line">    &#125; <span class="keyword">while</span>(slow != fast);</span><br><span class="line">    slow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(slow != fast)&#123;</span><br><span class="line">        slow = nums[slow];</span><br><span class="line">        fast = nums[fast];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LeetCode-394-字符串解码"><a href="#LeetCode-394-字符串解码" class="headerlink" title="LeetCode-394 字符串解码"></a>LeetCode-394 字符串解码</h3><p>给定一个经过编码的字符串，返回它解码后的字符串。</p><p>编码规则为: <code>k[encoded_string]</code>，表示其中方括号内部的 <code>encoded_string</code> 正好重复 <code>k</code> 次。注意 <code>k</code> 保证为正整数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">decodeString</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    Stack&lt;Integer&gt; nums = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    Stack&lt;String&gt; strs = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">        <span class="keyword">if</span>(Character.isDigit(ch))&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> ch - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">while</span>(Character.isDigit(ch = s.charAt(++i)))&#123;</span><br><span class="line">                num = num * <span class="number">10</span> + (ch - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            nums.push(num);</span><br><span class="line">            i--;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ch == <span class="string">&#x27;]&#x27;</span>)&#123;</span><br><span class="line">            String letter;</span><br><span class="line">            Stack&lt;String&gt; sub = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span>(!<span class="string">&quot;[&quot;</span>.equals((letter = strs.pop())))&#123;</span><br><span class="line">                sub.push(letter);</span><br><span class="line">            &#125;</span><br><span class="line">            Collections.reverse(sub);</span><br><span class="line">            letter = getString(sub);</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> nums.pop();</span><br><span class="line">            <span class="keyword">while</span>(num-- &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                strs.push(letter);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            strs.push(String.valueOf(ch));    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getString(strs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getString</span><span class="params">(Stack&lt;String&gt; v)</span> &#123;</span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">    <span class="keyword">for</span> (String s : v) &#123;</span><br><span class="line">        ret.append(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LeetCode-406-根据身高重建队列"><a href="#LeetCode-406-根据身高重建队列" class="headerlink" title="LeetCode-406 根据身高重建队列"></a>LeetCode-406 根据身高重建队列</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[][] reconstructQueue(<span class="type">int</span>[][] people) &#123;</span><br><span class="line">    <span class="keyword">if</span> (people == <span class="literal">null</span> || people.length == <span class="number">0</span> || people[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    Arrays.sort(people, (a, b) -&gt; (a[<span class="number">0</span>] == b[<span class="number">0</span>] ? a[<span class="number">1</span>] - b[<span class="number">1</span>] : b[<span class="number">0</span>] - a[<span class="number">0</span>]));</span><br><span class="line">    List&lt;<span class="type">int</span>[]&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 矮的对高的位置没有影响，但需要自己找位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>[] p : people) &#123;</span><br><span class="line">        queue.add(p[<span class="number">1</span>], p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> queue.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[queue.size()][]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LeetCode-437-路径总和-III"><a href="#LeetCode-437-路径总和-III" class="headerlink" title="LeetCode-437 路径总和 III"></a>LeetCode-437 路径总和 III</h3><h5 id="方法一：搜索（我的方法）"><a href="#方法一：搜索（我的方法）" class="headerlink" title="方法一：搜索（我的方法）"></a>方法一：搜索（我的方法）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pathSum</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">        res += doSearch(node, targetSum);</span><br><span class="line">        <span class="keyword">if</span>(node.left != <span class="literal">null</span>)&#123;</span><br><span class="line">            stack.push(node.left);                </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node.right != <span class="literal">null</span>)&#123;</span><br><span class="line">            stack.push(node.right);                </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">doSearch</span><span class="params">(TreeNode node, <span class="type">long</span> targetSum)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    targetSum -= node.val;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> == targetSum)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + doSearch(node.left, targetSum) + doSearch(node.right, targetSum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> doSearch(node.left, targetSum) + doSearch(node.right, targetSum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="方法二：前缀和"><a href="#方法二：前缀和" class="headerlink" title="*方法二：前缀和"></a>*方法二：前缀和</h5><p>我们仔细思考一下，解法一中应该存在许多重复计算。我们定义节点的前缀和为：由根结点到当前结点的路径上所有节点的和。我们利用先序遍历二叉树，记录下根节点 root 到当前节点 p 的路径上除当前节点以外所有节点的前缀和，在已保存的路径前缀和中查找是否存在前缀和刚好等于当前节点到根节点的前缀和 curr 减去 targetSum。</p><ul><li><p>对于空路径我们也需要保存预先处理一下，此时因为空路径不经过任何节点，因此它的前缀和为 0。</p></li><li><p>假设根节点为 root，我们当前刚好访问节点 node，则此时从根节点 root 到节点 node 的路径（无重复节点）刚好为 root→p1→p2→…→pk→node，此时我们可以已经保存了节点 p1,p2,p3,…,pk 的前缀和，并且计算出了节点 node的前缀和。</p></li><li><p>假设当前从根节点 root 到节点 node 的前缀和为 curr，则此时我们在已保存的前缀和查找是否存在前缀和刚好等于 curr−targetSum。假设从根节点 root 到节点 node 的路径中存在节点 pi 到根节点 root 的前缀和为 curr−targetSum，则节点 pi 到 node 的路径上所有节点的和一定为 targetSum。</p></li><li><p>我们利用深度搜索遍历树，当我们退出当前节点时，我们需要及时更新已经保存的前缀和。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pathSum</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">    Map&lt;Long, Integer&gt; prefix = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Long, Integer&gt;();</span><br><span class="line">    prefix.put(<span class="number">0L</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> dfs(root, prefix, <span class="number">0</span>, targetSum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(TreeNode root, Map&lt;Long, Integer&gt; prefix, <span class="type">long</span> curr, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    curr += root.val;</span><br><span class="line"></span><br><span class="line">    ret = prefix.getOrDefault(curr - targetSum, <span class="number">0</span>);</span><br><span class="line">    prefix.put(curr, prefix.getOrDefault(curr, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    ret += dfs(root.left, prefix, curr, targetSum);</span><br><span class="line">    ret += dfs(root.right, prefix, curr, targetSum);</span><br><span class="line">    prefix.put(curr, prefix.getOrDefault(curr, <span class="number">0</span>) - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">作者：力扣官方题解</span><br><span class="line">链接：https:<span class="comment">//leetcode.cn/problems/path-sum-iii/solutions/1021296/lu-jing-zong-he-iii-by-leetcode-solution-z9td/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><h3 id="LeetCode-438-找到字符串中所有字母异位词"><a href="#LeetCode-438-找到字符串中所有字母异位词" class="headerlink" title="LeetCode-438 找到字符串中所有字母异位词"></a>LeetCode-438 找到字符串中所有字母异位词</h3><ul><li>方法一（我的方法，时空双5%）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">findAnagrams</span><span class="params">(String s, String p)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">slen</span> <span class="operator">=</span> s.length(), plen = p.length();</span><br><span class="line">    <span class="keyword">if</span>(s.length() &lt; p.length())&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span>[] pc = p.toCharArray();</span><br><span class="line">    Arrays.sort(pc);</span><br><span class="line">    Set&lt;Character&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(Character ch : pc)&#123;</span><br><span class="line">        set.add(ch);</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; slen; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; slen; )&#123;</span><br><span class="line">            <span class="keyword">if</span>(set.contains(s.charAt(j)))&#123;</span><br><span class="line">                j++;</span><br><span class="line">                <span class="keyword">if</span>(j == i + plen)&#123;</span><br><span class="line">                    <span class="type">char</span>[] sc = s.substring(i, j).toCharArray();</span><br><span class="line">                    Arrays.sort(sc);</span><br><span class="line">                    <span class="keyword">if</span>(Arrays.equals(pc, sc))&#123;</span><br><span class="line">                        res.add(i);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                i = j;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>方法二：滑动窗口</p><p>方法一中其实不需要排序，只要字符串中每个字符数量相等即可</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">findAnagrams</span><span class="params">(String s, String p)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sLen</span> <span class="operator">=</span> s.length(), pLen = p.length();</span><br><span class="line">    <span class="keyword">if</span>(s.length() &lt; p.length())&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">    <span class="type">int</span>[] sCount = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="type">int</span>[] pCount = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; pLen; ++i) &#123;</span><br><span class="line">        ++sCount[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        ++pCount[p.charAt(i) - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Arrays.equals(sCount, pCount)) &#123;</span><br><span class="line">        ans.add(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; sLen - pLen; ++i) &#123;</span><br><span class="line">        --sCount[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        ++sCount[s.charAt(i + pLen) - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Arrays.equals(sCount, pCount)) &#123;</span><br><span class="line">            ans.add(i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LeetCode-560-和为k的子数组"><a href="#LeetCode-560-和为k的子数组" class="headerlink" title="LeetCode-560 和为k的子数组"></a>LeetCode-560 和为k的子数组</h3><ul><li><p>前缀和 O（N2）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">subarraySum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="comment">// 计算前缀和数组</span></span><br><span class="line">    <span class="type">int</span>[] preSum = <span class="keyword">new</span> <span class="title class_">int</span>[len + <span class="number">1</span>];</span><br><span class="line">    preSum[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        preSum[i + <span class="number">1</span>] = preSum[i] + nums[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>; left &lt; len; left++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> left; right &lt; len; right++) &#123;</span><br><span class="line">            <span class="comment">// 区间和 [left..right]，注意下标偏移</span></span><br><span class="line">            <span class="keyword">if</span> (**preSum[right + <span class="number">1</span>] - preSum[left] == k**) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>前缀和+哈希表 O（N）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">subarraySum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="comment">// 前缀和，结果</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// key为前缀和，value是key对应前缀和的出现次数</span></span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">0</span>; r &lt; nums.length; r++)&#123;</span><br><span class="line">        sum += nums[r];</span><br><span class="line">        <span class="comment">// 当前和为sum，以r结尾的子数组值为k的次数 = 前缀和为sum - k的出现次数</span></span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(sum - k))&#123;</span><br><span class="line">            res += map.get(sum - k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 前缀和为sum的出现次数+1</span></span><br><span class="line">        map.put(sum, map.getOrDefault(sum, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><h4 id="LeetCode-234-回文链表"><a href="#LeetCode-234-回文链表" class="headerlink" title="LeetCode-234 回文链表"></a>LeetCode-234 回文链表</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="comment">// 找到链表中点</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head, slow = head;</span><br><span class="line">    <span class="keyword">while</span>(fast.next != <span class="literal">null</span> &amp;&amp; fast.next.next != <span class="literal">null</span>)&#123;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 反转后半链表</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">curr</span> <span class="operator">=</span> slow.next;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span>(curr != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> curr.next;</span><br><span class="line">        curr.next = prev;</span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 逐一比对</span></span><br><span class="line">    <span class="keyword">while</span>(prev != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(head.val != prev.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        prev = prev.next;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// return前最好将后半链表反转回去</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="LeetCode-148-排序链表"><a href="#LeetCode-148-排序链表" class="headerlink" title="LeetCode-148 排序链表"></a>LeetCode-148 排序链表</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 归并排序</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">sortList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sort(head, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode <span class="title function_">sort</span><span class="params">(ListNode head, ListNode tail)</span>&#123;</span><br><span class="line">        <span class="comment">// 先通过快慢指针找出链表中点</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(head.next == tail)&#123;</span><br><span class="line">            head.next = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(fast != tail)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            <span class="keyword">if</span>(fast != tail)&#123;</span><br><span class="line">                fast = fast.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">mid</span> <span class="operator">=</span> slow;</span><br><span class="line">        <span class="comment">// 分别对两段链表排序，然后归并</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">list1</span> <span class="operator">=</span> sort(head, mid);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">list2</span> <span class="operator">=</span> sort(mid, tail);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">sorted</span> <span class="operator">=</span> merge(list1, list2);</span><br><span class="line">        <span class="keyword">return</span> sorted;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 合并两个有序链表</span></span><br><span class="line">    ListNode <span class="title function_">merge</span><span class="params">(ListNode list1, ListNode list2)</span>&#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">sentinel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> sentinel, head1 = list1, head2 = list2;</span><br><span class="line">        <span class="keyword">while</span>(head1 != <span class="literal">null</span> &amp;&amp; head2 != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(head1.val &lt; head2.val)&#123;</span><br><span class="line">                cur.next = head1;</span><br><span class="line">                head1 = head1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur.next = head2;</span><br><span class="line">                head2 = head2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(head1 != <span class="literal">null</span>)&#123;</span><br><span class="line">            cur.next = head1;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(head2 != <span class="literal">null</span>)&#123;</span><br><span class="line">            cur.next = head2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sentinel.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="动态规划-1"><a href="#动态规划-1" class="headerlink" title="动态规划"></a>动态规划</h3><h4 id="LeetCode-198-打家劫舍"><a href="#LeetCode-198-打家劫舍" class="headerlink" title="LeetCode-198 打家劫舍"></a>LeetCode-198 打家劫舍</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 暴力法，超出时间限制</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(doRub(nums, <span class="number">0</span>, <span class="number">0</span>), doRub(nums, <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">doRub</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> start, <span class="type">int</span> sum)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start &gt;= nums.length)&#123;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> Math.max(doRub(nums, start + <span class="number">2</span>, sum + nums[start]), </span><br><span class="line">                    doRub(nums, start + <span class="number">3</span>, sum + nums[start]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 动态规划 O（N）</span></span><br><span class="line"><span class="comment">// 状态转移方程：dp[i]=max(dp[i−2]+nums[i],dp[i−1])</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="keyword">if</span>(nums == <span class="literal">null</span> || length == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(length == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">first</span> <span class="operator">=</span> nums[<span class="number">0</span>], second = Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> second;</span><br><span class="line">        second = Math.max(first + nums[i], second);</span><br><span class="line">        first = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="LeetCode-337-打家劫舍-III"><a href="#LeetCode-337-打家劫舍-III" class="headerlink" title="LeetCode-337 打家劫舍 III"></a>LeetCode-337 打家劫舍 III</h4><p>一棵二叉树，树上的每个点都有对应的权值，每个点有两种状态（选中和不选中），问在不能同时选中有父子关系的点的情况下，能选中的点的最大权值和是多少。</p><p>我们可以用 f(o) 表示选择 o 节点的情况下，o 节点的子树上被选择的节点的最大权值和；g(o) 表示不选择 o 节点的情况下，o 节点的子树上被选择的节点的最大权值和；l 和 r 代表 o 的左右孩子。</p><p>当 o 被选中时，o 的左右孩子都不能被选中，故 o 被选中情况下子树上被选中点的最大权值和为 l 和 r 不被选中的最大权值和相加，即 <code>f(o)=g(l)+g(r)</code>。<br>当 o 不被选中时, o 的左右孩子可以被选中，也可以不被选中。对于 o 的某个具体的孩子 x，它对 o 的贡献是 x 被选中和不被选中情况下权值和的较大值。故 <code>g(o)=max⁡&#123;f(l),g(l)&#125;+max⁡&#123;f(r),g(r)&#125;</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] result = doRob(root);</span><br><span class="line">    <span class="keyword">return</span> Math.max(result[<span class="number">0</span>], result[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] doRob(TreeNode node) &#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] l = doRob(node.left);</span><br><span class="line">    <span class="type">int</span>[] r = doRob(node.right);</span><br><span class="line">    <span class="type">int</span> <span class="variable">select</span> <span class="operator">=</span> node.val + l[<span class="number">1</span>] + r[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">notSelect</span> <span class="operator">=</span> Math.max(l[<span class="number">0</span>], l[<span class="number">1</span>]) + Math.max(r[<span class="number">0</span>], r[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;select, notSelect&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="LeetCode-300-最长递增子序列"><a href="#LeetCode-300-最长递增子序列" class="headerlink" title="LeetCode-300 最长递增子序列"></a>LeetCode-300 最长递增子序列</h4><ul><li><p>方法一：动态规划</p><p>定义 dp[i] 为考虑前 iii 个元素，以第 i 个数字结尾的最长上升子序列的长度，注意 nums[i] 必须被选取。</p><p>我们从小到大计算 dp 数组的值，在计算 dp[i] 之前，我们已经计算出 dp[0…i−1] 的值，则状态转移方程为：</p><p><code>dp[i] = max⁡(dp[j]) + 1, 其中 0 ≤ j &lt; i 且  num[j] &lt; num[i]</code></p><p>即考虑往 dp[0…i−1] 中最长的上升子序列后面再加一个 nums[i]。由于 dp[j] 代表 nums[0…j] 中以 nums[j] 结尾的最长上升子序列，所以如果能从 dp[j] 这个状态转移过来，那么 nums[i] 必然要大于 nums[j]，才能将 nums[i] 放在 nums[j] 后面以形成更长的上升子序列。</p><p>时间复杂度：O（n2）</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">        dp[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; nums[j])&#123;</span><br><span class="line">                dp[i] = Math.max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        max = Math.max(dp[i], max);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="LeetCode-279-完全平方数"><a href="#LeetCode-279-完全平方数" class="headerlink" title="LeetCode-279 完全平方数"></a>LeetCode-279 完全平方数</h4><p>给你一个整数 <code>n</code> ，返回 <em>和为 <code>n</code> 的完全平方数的最少数量</em> 。</p><p><strong>完全平方数</strong> 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，<code>1</code>、<code>4</code>、<code>9</code> 和 <code>16</code> 都是完全平方数，而 <code>3</code> 和 <code>11</code> 不是。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numSquares</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] f = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">minn</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j * j &lt;= i; j++) &#123;</span><br><span class="line">            minn = Math.min(minn, f[i - j * j]);</span><br><span class="line">        &#125;</span><br><span class="line">        f[i] = minn + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="LeetCode-221-最大正方形"><a href="#LeetCode-221-最大正方形" class="headerlink" title="LeetCode-221 最大正方形"></a>LeetCode-221 最大正方形</h4><ul><li>方法一：暴力法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximalSquare</span><span class="params">(<span class="type">char</span>[][] matrix)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> matrix.length, col = matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; row; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; col; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][j] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">while</span>(flag)&#123;</span><br><span class="line">                    len++;</span><br><span class="line">                    <span class="keyword">if</span>(i + len &gt;= row || j + len &gt;= col)&#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> j; m &lt;= j + len; m++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(matrix[i + len][m] == <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">                            flag = <span class="literal">false</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> i; n &lt;= i + len; n++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(matrix[n][j + len] == <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">                            flag = <span class="literal">false</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                max = Math.max(len, max);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max * max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>方法二：动态规划</p><p>用 dp(i, j) 表示以 (i, j) 为右下角，且只包含 1 的正方形的边长最大值。如果我们能计算出所有 dp(i, j) 的值，那么其中的最大值即为矩阵中只包含 1 的正方形的边长最大值，其平方即为最大正方形的面积。</p><p>那么如何计算 dp 中的每个元素值呢？对于每个位置 (i, j)，检查在矩阵中该位置的值：</p><ul><li>如果该位置的值是 0，则 dp(i,j)&#x3D;0，因为当前位置不可能在由 111 组成的正方形中；</li><li>如果该位置的值是 1，则 dp(i,j)的值由其上方、左方和左上方的三个相邻位置的 dp 值决定。具体而言，当前位置的元素值等于三个相邻位置的元素中的最小值加 1，状态转移方程如下：<br><code>dp(i, j) = min(dp(i − 1, j), dp(i − 1, j − 1), dp(i, j − 1)) + 1</code></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximalSquare</span><span class="params">(<span class="type">char</span>[][] matrix)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> matrix.length, col = matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[row][col];</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; row; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; col; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][j] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span> || j == <span class="number">0</span>)&#123;</span><br><span class="line">                    dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = Math.min(Math.min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]), </span><br><span class="line">                                        dp[i - <span class="number">1</span>][j - <span class="number">1</span>]) + <span class="number">1</span>;                           </span><br><span class="line">                &#125;</span><br><span class="line">                max = Math.max(max, dp[i][j]);   </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max * max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="LeetCode-309-买卖股票的最佳时机含冷冻期"><a href="#LeetCode-309-买卖股票的最佳时机含冷冻期" class="headerlink" title="LeetCode-309 买卖股票的最佳时机含冷冻期"></a>LeetCode-309 买卖股票的最佳时机含冷冻期</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> prices.length;</span><br><span class="line">    <span class="keyword">if</span>(length &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">dp0</span> <span class="operator">=</span> -prices[<span class="number">0</span>], dp1 = <span class="number">0</span>, dp2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; length; i++)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">odp0</span> <span class="operator">=</span> dp0, odp1 = dp1, odp2 = dp2;</span><br><span class="line">        <span class="comment">// 前一天不卖或前一天买入</span></span><br><span class="line">        dp0 = Math.max(odp0, odp2 - prices[i]);</span><br><span class="line">        <span class="comment">// 前一天卖</span></span><br><span class="line">        dp1 = odp0 + prices[i];</span><br><span class="line">        <span class="comment">// 前一天没有卖且不持有股票</span></span><br><span class="line">        dp2 = Math.max(odp1, odp2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.max(dp1, dp2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="LeetCode-322-零钱兑换"><a href="#LeetCode-322-零钱兑换" class="headerlink" title="LeetCode-322 零钱兑换"></a>LeetCode-322 零钱兑换</h4><p>给你一个整数数组 <code>coins</code> ，表示不同面额的硬币；以及一个整数 <code>amount</code> ，表示总金额。</p><p>计算并返回可以凑成总金额所需的 <strong>最少的硬币个数</strong> 。如果没有任何一种硬币组合能组成总金额，返回 <code>-1</code> 。</p><p>你可以认为每种硬币的数量是无限的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">coinChange</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span> amount)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">    Arrays.fill(dp, amount + <span class="number">1</span>);</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= amount; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; coins.length; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i - coins[j] &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                dp[i] = Math.min(dp[i], dp[i - coins[j]] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[amount] &gt; amount ? -<span class="number">1</span> : dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="LeetCode-416-分隔等和子集"><a href="#LeetCode-416-分隔等和子集" class="headerlink" title="*LeetCode-416 分隔等和子集"></a>*LeetCode-416 分隔等和子集</h4><p><img src="http://oss.ripplesu.top/blog/Typora/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20231004111522094.png" alt="image-20231004111522094"></p><p>上述代码的空间复杂度是 O(n×target)。但是可以发现在计算 dp 的过程中，每一行的 dp 值都只与上一行的 dpdpdp 值有关，因此只需要一个一维数组即可将空间复杂度降到 O(target)。此时的转移方程为：</p><p><code>dp[j]=dp[j] ∣ dp[j−nums[i]]</code><br>且需要注意的是第二层的循环我们需要从大到小计算，因为如果我们从小到大更新 dp 值，那么在计算 dp[j] 值的时候，dp[j−nums[i]] 已经是被更新过的状态，不再是上一行的 dp 值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canPartition</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>, maxNum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            sum += num;</span><br><span class="line">            maxNum = Math.max(maxNum, num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> sum / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (maxNum &gt; target) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span>[] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[target + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> nums[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> target; j &gt;= num; --j) &#123;</span><br><span class="line">                dp[j] |= dp[j - num];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="LeetCode-338-比特位计数"><a href="#LeetCode-338-比特位计数" class="headerlink" title="LeetCode-338 比特位计数"></a>LeetCode-338 比特位计数</h4><p>定义正整数 x 的「最低设置位」为 x 的二进制表示中的最低的 1 所在位。例如，10 的二进制表示是 1010，其最低设置位为 2，对应的二进制表示是 10 。</p><p>令 <code>y=x &amp; (x−1)</code>，则 y 为将 x 的最低设置位从 1 变成 0 之后的数，显然<code> 0≤y&lt;x0</code>，<code>bits[x]=bits[y]+1</code>。因此对任意正整数 x，都有 <code>bits[x]=bits[x &amp; (x−1)]+1</code>。</p><p>遍历从 1 到 n 的每个正整数 i，计算 bits 的值。最终得到的数组 bits 即为答案。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] countBits(<span class="type">int</span> n) &#123;</span><br><span class="line">    <span class="type">int</span>[] bits = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        bits[i] = bits[i &amp; (i - <span class="number">1</span>)] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bits;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="LeetCode-494-目标和"><a href="#LeetCode-494-目标和" class="headerlink" title="LeetCode-494 目标和"></a>LeetCode-494 目标和</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findTargetSumWays</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i : nums)&#123;</span><br><span class="line">        sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">diff</span> <span class="operator">=</span> sum - target;</span><br><span class="line">    <span class="keyword">if</span>(diff &lt; <span class="number">0</span> || diff %<span class="number">2</span> != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">neg</span> <span class="operator">=</span> diff / <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][neg + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> nums[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= neg; j++)&#123;</span><br><span class="line">            <span class="comment">// 不选</span></span><br><span class="line">            <span class="keyword">if</span>(j &lt; num)&#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i - <span class="number">1</span>][j - num];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][neg];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 优化空间</span></span><br><span class="line"><span class="comment">// 由于 dp 的每一行的计算只和上一行有关，因此可以使用滚动数组的方式，去掉 dp 的第一个维度，将空间复杂度优化到 O(neg)。</span></span><br><span class="line"><span class="comment">// 实现时，内层循环需采用倒序遍历的方式，这种方式保证转移来的是 dp[i−1][] 中的元素值</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findTargetSumWays</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i : nums)&#123;</span><br><span class="line">        sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">diff</span> <span class="operator">=</span> sum - target;</span><br><span class="line">    <span class="keyword">if</span>(diff &lt; <span class="number">0</span> || diff %<span class="number">2</span> != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">neg</span> <span class="operator">=</span> diff / <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[neg + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> num : nums)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> neg; j &gt;= num; j--)&#123;</span><br><span class="line">            dp[j] += dp[j - num];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[neg];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="LeetCode-739-每日温度"><a href="#LeetCode-739-每日温度" class="headerlink" title="LeetCode-739 每日温度"></a>LeetCode-739 每日温度</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自己想的，可能不算动态规划</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] dailyTemperatures(<span class="type">int</span>[] temperatures) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> temperatures.length;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    dp[n - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        dp[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(temperatures[i] &lt; temperatures[i + <span class="number">1</span>])&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">do</span>&#123;</span><br><span class="line">                dp[i] += dp[j];</span><br><span class="line">                <span class="keyword">if</span>(dp[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i] = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                j += dp[j];</span><br><span class="line">            &#125;<span class="keyword">while</span>(temperatures[j] &lt;= temperatures[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h2><h3 id="LeetCode-185-部门工资前三高的所有员工"><a href="#LeetCode-185-部门工资前三高的所有员工" class="headerlink" title="LeetCode-185 部门工资前三高的所有员工"></a>LeetCode-185 部门工资前三高的所有员工</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> d.name <span class="keyword">as</span> Department, e1.name <span class="keyword">as</span> Employee, salary <span class="keyword">as</span> salary</span><br><span class="line"><span class="keyword">from</span> Employee e1 </span><br><span class="line"><span class="keyword">join</span> Department d <span class="keyword">on</span> e1.departmentId <span class="operator">=</span> d.id </span><br><span class="line">    <span class="keyword">where</span> <span class="number">3</span> <span class="operator">&gt;</span> (</span><br><span class="line">        <span class="keyword">select</span> <span class="built_in">count</span>(<span class="keyword">distinct</span>(e2.salary))</span><br><span class="line">        <span class="keyword">from</span> Employee e2</span><br><span class="line">        <span class="keyword">where</span> </span><br><span class="line">        e2.salary <span class="operator">&gt;</span> e1.salary </span><br><span class="line">        <span class="keyword">and</span> e1.departmentId <span class="operator">=</span> e2.departmentId</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><h3 id="LeetCode-196-删除重复的电子邮箱"><a href="#LeetCode-196-删除重复的电子邮箱" class="headerlink" title="LeetCode-196 删除重复的电子邮箱"></a>LeetCode-196 删除重复的电子邮箱</h3><p><strong>删除</strong> 所有重复的电子邮件，只保留一个具有最小 <code>id</code> 的唯一电子邮件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DELETE p1 FROM Person p1,</span><br><span class="line">    Person p2</span><br><span class="line">WHERE</span><br><span class="line">    p1.Email = p2.Email AND p1.Id &gt; p2.Id</span><br></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>操作系统期末复习</title>
      <link href="/2023/02/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"/>
      <url>/2023/02/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="操作系统概述"><a href="#操作系统概述" class="headerlink" title="操作系统概述"></a>操作系统概述</h2><h3 id="教学目的"><a href="#教学目的" class="headerlink" title="教学目的"></a>教学目的</h3><ul><li>熟悉<font color='blue'>操作系统作用和定义</font>，了解操作系统的历史。</li><li>熟练掌握<font color='red'>多道程序设计技术</font>的概念，掌握<font color='orange'>批处理系统、分时系统及实时系统</font>三种操作系统基本类型，了解微机操作系统、网络操作系统、分布式操作系统和嵌入式操作系统。</li><li>掌握操作系统<font color='orange'>并发性、共享性、虚拟性和异步性</font>等特征，了解现代操作系统特征，熟悉<font color='blue'>操作系统功能</font>。</li></ul><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a><font color='blue'>定义</font></h3><ul><li>从计算机系统组成观点――操作系统是系统软件  </li><li>从资源管理程序观点――操作系统是系统资源管理者  </li><li>从软件分层、扩充机器的观点――操作系统是扩充裸机的第一层系统软件  </li><li>从服务用户的观点――操作系统是用户与裸机之间接口<br>作业级接口：提供一组键盘命令<br>程序级接口：提供一组系统调用  </li><li>从进程的观点——操作系统是由若干个可以并发执行的进程和一个对进程进行控制和协调的核心（kernel）组成。</li></ul><h3 id="基本特征"><a href="#基本特征" class="headerlink" title="基本特征"></a><font color='orange'>基本特征</font></h3><ul><li>并发:是指两个或多个活动在同一给定的时间<br>间隔中进行。</li><li>共享:是指计算机系统中的资源被多个进程所<br>共用。</li><li>异步:进程以不可预知的速度向前推进</li><li>虚拟:把一个物理上的实体变为若干个逻辑上<br>的对应物。<br>最基本特征:并发、共享(两者互为存在条<br>件)</li></ul><h3 id="发展"><a href="#发展" class="headerlink" title="发展"></a>发展</h3><h4 id="串行处理（无操作系统）"><a href="#串行处理（无操作系统）" class="headerlink" title="串行处理（无操作系统）"></a>串行处理（无操作系统）</h4><p>程序员直接与硬件打交道。计算机系统串行工作。<br>缺点：人机速度矛盾、计算机资源利用率低</p><h4 id="批处理"><a href="#批处理" class="headerlink" title="批处理"></a><font color='orange'>批处理</font></h4><h5 id="简单批处理"><a href="#简单批处理" class="headerlink" title="简单批处理"></a>简单批处理</h5><p>目标：为了解决人工操作（无操作系统）严重降低了计算机资源利用率的问题，即解决CPU等待人工操作和高速CPU与低速I&#x2F;O间矛盾等问题。</p><h5 id="多道程序设计"><a href="#多道程序设计" class="headerlink" title="多道程序设计"></a><font color='red'>多道程序设计</font></h5><p>多程序设计是一种操作模式，它由一个处理器交替执行两个或多个计算机程序。<br>目标：为了进一步提高资源利用率，在硬件采用通道和中断技术支持并行操作的情况下，引入了多道程序设计技术，由此引入多道批处理系统。<br>宏观上并行执行，微观上串行，即多道程序轮流地使用部件，交替执行。  </p><ul><li>首先要考虑：周转时间和系统吞吐量</li></ul><h4 id="分时系统"><a href="#分时系统" class="headerlink" title="分时系统"></a><font color='orange'>分时系统</font></h4><p>多个用户分时共享使用同一台计算机，也就是说把计算机的系统资源（尤其是CPU时间）进行时间上分割，即将整个工作时间分成一个个的时间片，每个时间片分给一个用户使用，依次轮流使用一个时间片。  </p><ul><li>采用调进／调出的单道分时系统<br>单道分时系统内存中只驻留一道程序，其余程序都在外存上。每当内存中一个程序运行一个时间片后，便调至外存（称为调出）。</li><li>基于多道程序设计的多道分时系统<br>在<strong>内存</strong>中存放多道作业排成一个队列，依次轮流地获得一个时间片来运行。由于切换作业就在内存，不要花费大量时间用于调进调出，故多道分时系统具有较好的系统性能。</li><li>重要指标——响应时间T&#x3D;n*q<br>响应时间是分时系统的重要指标，它是用户发出终端命令到系统开始作出响应的时间间隔。<br>优点：提供人机交互<br>缺点：不能优先处理紧急事件  </li><li>首要考虑：交互性和响应时间</li></ul><h4 id="实时系统"><a href="#实时系统" class="headerlink" title="实时系统"></a><font color='orange'>实时系统</font></h4><p>目标：为了提高系统的响应时间，对随机发生的外部事件作出及时响应并对其进行处理。<br>分类：实时控制系统、实时信息处理系统<br>快速的响应时间、有限的交互能力（弱于分时）、高可靠性（高于分时），能优先处理紧急任务    </p><ul><li>首要考虑：实时性和可靠性</li></ul><h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><h2 id="进程描述与控制"><a href="#进程描述与控制" class="headerlink" title="进程描述与控制"></a>进程描述与控制</h2><ul><li>熟悉<font color='blue'>进程引入的必要性</font>；</li><li>熟练掌握<font color='red'>进程的定义和特征</font>，</li><li>熟练掌握<font color='red'>进程的三个基本状态、状态转换的条件</font>；</li><li>熟练掌握<font color='red'>进程存在的唯一实体——进程控制块</font>；</li><li>熟悉<font color='blue'>进程上下文</font>。</li></ul><h3 id="进程引入的必要性"><a href="#进程引入的必要性" class="headerlink" title="进程引入的必要性"></a><font color='blue'>进程引入的必要性</font></h3><p>为了提高资源利用率，系统采用多道程序设计，程序执行环境由顺序执行变为并发执行。<br>由于程序在<strong>并发执行时</strong>，可能会造成<strong>执行结果的不可再现</strong>，所以用“程序”这个概念已无法描述程序的并发执行，所以必须引入新的概念—进程来<strong>描述程序的并发执行</strong>，并要对进程进行必要的管理，以<strong>保证进程在并发执行时结果可再现</strong>。</p><h3 id="进程的定义和特征"><a href="#进程的定义和特征" class="headerlink" title="进程的定义和特征"></a><font color='red'>进程的定义和特征</font></h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>进程是一个正在执行的程序，它被操作系统控制和调度。<br>可并发执行的程序在一个数据集合上的运行过程。  </p><ul><li>一段可执行的程序</li><li>计算机中正在运行的程序的一个实例</li><li>可以分配给处理器并由处理器执行的一个实体</li><li>由一个顺序的执行线程、一个当前的状态以及一组相关的系统资源所描述的活动单元</li></ul><h4 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h4><ul><li>动态性：动态性是进程的<strong>最基本特征</strong>，它是程序执行过程，它是有一定的生命期。它由创建而产生、由调度而执行，因得不到资源而暂停，并由撤消而死亡。而程序是静态的，它是存放在介质上一组有序指令的集合，无运动的含义。</li><li>并发性：并发性是进程的重要特征。并发性指多个进程实体同存于内存中，能在一段时间内同时运行。</li><li>独立性：进程是一个能独立运行的基本单位，即是一个独立获得资源和独立调度的单位。</li><li>异步性：进程按各自独立的不可预知的速度向前推进，即进程按异步方式进行，正是这一特征，将导致程序执行的不可再现性，因此OS必须采用某种措施来限制各进程推进序列以保证各程序间正常协调运行。</li><li>结构特征：从结构上，进程实体由<strong>程序段、数据段和进程控制块</strong>三部分组成。</li></ul><h3 id="进程控制块PCB——进程存在的唯一实体"><a href="#进程控制块PCB——进程存在的唯一实体" class="headerlink" title="进程控制块PCB——进程存在的唯一实体"></a><font color='red'>进程控制块PCB——进程存在的唯一实体</font></h3><ul><li>包含描述进程的基本信息<ul><li>标识符（Identifier ）</li><li>进程状态（State ）</li><li>优先级（Priority ）</li><li>程序计数器（Program counter ）</li><li>内存指针（Memory pointers ）</li><li>上下文数据（Context data ）</li><li>I&#x2F;O状态信息（I&#x2F;O status information ）</li><li>统计信息（Accounting information ）</li></ul></li><li>由操作系统创建并管理</li></ul><h3 id="五状态模型"><a href="#五状态模型" class="headerlink" title="五状态模型"></a><font color='red'>五状态模型</font></h3><ul><li>运行（Running）：占有CPU</li><li>就绪（Ready ）：除了CPU，其它所需资源都已占有，一旦得到处理机即可运行，则称此进程处于就绪状态</li><li>阻塞（Blocked ）：等待某些事件</li><li>新建（New ）: 已经创建了PCB并保存在主存中，但程序代码和相关数据还没有读入主存</li><li>退出（Exit ）<br><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/66a58bdc-d059-4f78-9241-79f69d31d8b8_repeat_1700459209057__806745.png" alt="image.png"></li></ul><h4 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h4><ul><li>就绪态――＞运行态：当处理机空闲时，进程调度程序必将处理机分配给一个处于就绪态的进程，该进程便由就绪态转换为运行态。</li><li>运行态――＞阻塞态：处于运行态的进程在运行过程中需要等待某一事件发生后，才能继续运行，则该进程放弃处理机，从运行态转换为阻塞态。</li><li>阻塞态――＞就绪态：处于阻塞态的进程，若其等待的事件已经发生，进程由阻塞态转换为就绪态。</li><li>运行态――＞就绪态：处于运行状态的进程在其运行过程中，因分给它的处理机时间片已用完，而不得不让出（被抢占）处理机，于是进程由运行态转换为就绪态。</li><li>阻塞态――＞运行态和就绪态――＞阻塞态这二种状态转换不可能发生。</li></ul><h4 id="挂起态"><a href="#挂起态" class="headerlink" title="挂起态"></a>挂起态</h4><p>处理器运行的速度远远地快于I&#x2F;O设备，运行一段时间后会出现所有进程都处于阻塞态（等待I&#x2F;O操作），就绪态进程数为0，此时处理器必须等待。<br>解决：</p><ol><li>扩充内存  </li><li>将进程交换到磁盘，释放内存空间<br>当进程被交换到磁盘上，则该进程从阻塞状态转换到挂起状态。<br>进程处于挂起状态是指该进程不在主存中。</li></ol><ul><li><p>进程不能立即执行；</p></li><li><p>进程可能在等待某个事件，也可能不等待事件，即进程挂起与否与进程阻塞与否没有必然的联系。</p></li><li><p>单挂起态<br><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/5b7c3132-2b6c-42d6-afb4-99c5e032468e_repeat_1700459257035__949762.png" alt="image.png"></p></li><li><p>双挂起态<br><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/4b91da04-ceb5-4d91-b77b-a15c8dfe3205_repeat_1700459264652__015256.png" alt="image.png"><br>阻塞&#x2F;挂起（Blocked&#x2F;Suspend ）<br>就绪&#x2F;挂起（Ready&#x2F;Suspend )</p></li></ul><h3 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h3><ul><li>用户模式（目态）<ul><li>通常在该模式下执行用户程序</li><li>权限较低</li></ul></li><li>系统模式、控制模式或内核模式（管态）<ul><li>在该模式下执行操作系统内核</li><li>可执行特权指令，权限更高</li></ul></li></ul><h4 id="三个问题"><a href="#三个问题" class="headerlink" title="三个问题"></a>三个问题</h4><ul><li>为什么需要两种执行模式?<br>保护操作系统和重要数据不受用户干扰</li><li>处理器如何知道当前系统处于哪个执行模式下?<br>程序状态字（PSW）中管理程序&#x2F;用户模式位记录了当前系统所处的模式信息</li><li>模式如何切换?<br>用户调用操作系统服务（<strong>系统调用</strong>）或发生<strong>中断</strong>时，执行模式从用户模式切换到内核模式<br>当系统服务返回或中断返回到用户进程时，执行模式从内核模式切换到用户模式</li></ul><h4 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h4><ul><li>给进程分配一个唯一的进程标识号</li><li>给进程分配空间</li><li>初始化进程控制块  </li><li>将进程控制块加入到正确的队列中</li><li>创建或扩充操作系统所需的其他数据结构</li></ul><h4 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h4><ul><li>何时切换<br>中断、陷阱（进程运行错误或异常）、系统调用</li><li>进程切换与模式切换<ul><li>模式切换是系统执行模式的改变，发生模式切换可以不改变正处于运行态的进程状态 </li><li>进程切换时，操作系统必须使其运行环境发生改变</li><li>进程切换必然会存在模式切换（只有在内核模式下才能实现进程调度），但模式切换不一定会发生进程切换</li><li>进程切换比模式切换更复杂</li></ul></li></ul><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>了解线程的概念、引入线程的好处和线程的应用 。</p><h3 id="并发进程的基本单位"><a href="#并发进程的基本单位" class="headerlink" title="并发进程的基本单位"></a>并发进程的基本单位</h3><ul><li>资源拥有者<br>一个进程包括一个存放进程映像的虚拟地址空间，进程需要申请并拥有系统资源，如主存、I&#x2F;O设备、文件等。</li><li>调度或执行的基本单位<br> 一个进程沿着其执行轨迹执行，在多道情况下，其执行过程可能与其他进程的执行过程交替进行<br>这两个基本属性使进程成为并发执行的基本单位。 大多数操作系统将这两个属性<strong>独立对待</strong>。</li></ul><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p>操作系统在一个进程内支持多个线程的能力。  </p><ul><li>资源分配与保护以进程为单位</li><li>调度执行以线程为基本单位。<ul><li>线程只拥有一点在运行中必不可省的资源（程序计数器、一组寄存器和栈），但它可与同属一个进程的其它线程<strong>共享进程拥有的全部资源</strong></li><li>线程定义为进程内一个执行单元或一个可调度实体</li></ul></li></ul><h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><ul><li>执行状态 (running, ready等)</li><li>未运行时需保存线程的上下文（一个独立的程序计数器）</li><li>一个执行栈</li><li>每个线程一些局部变量的静态存储空间</li><li>和这个进程的其它线程共享对这个进程的存储器和资源的访问<br>进程内的所有线程驻留在同一块地址空间中，并且可以访问到相同的数据</li></ul><h3 id="引入线程的好处"><a href="#引入线程的好处" class="headerlink" title="引入线程的好处"></a>引入线程的好处</h3><ul><li>在一个已有进程中创建一个新线程比创建一个全新进程所需的时间更少</li><li>终止一个线程比终止一个进程花费的时间更少</li><li>在同一进程内二个线程间切换时间要比二个进程切换时间小得多</li><li>同一个进程内的所有线程共享存储器和文件，当一个线程修改了数据，其他线程都能访问到修改后的结果。因此，线程间通信不需要调用内核就可以实现。  </li><li>总结：提高并发执行的程度,减少管理的时空开销。</li></ul><h3 id="线程特性"><a href="#线程特性" class="headerlink" title="线程特性"></a>线程特性</h3><ul><li>线程与进程共享地址空间，故挂起线程将导致进程内所有线程被挂起</li><li>进程终止，所有线程随之终止</li><li>三个基本状态：运行、就绪、阻塞</li></ul><h3 id="两种实现方式"><a href="#两种实现方式" class="headerlink" title="两种实现方式"></a>两种实现方式</h3><h4 id="用户级线程（ULTs）"><a href="#用户级线程（ULTs）" class="headerlink" title="用户级线程（ULTs）"></a>用户级线程（ULTs）</h4><p>线程管理的所有工作都由应用程序来完成，内核并不知道线程的存在。</p><ul><li>优点  <ul><li><strong>不依赖于OS内核</strong>，应用进程利用线程库提供创建、同步、调度和管理线程的函数来控制用户线程，可以在任何操作系统中运行</li><li>调度由应用软件内部进行，通常采用非抢占式或更简单的规则，<strong>无需用户态&#x2F;核心态切换</strong>，所以速度特别快，用户线程调度算法可针对应用优化</li><li>同一进程内各<strong>线程的切换不需要内核参与</strong>，减少了模式切换的开销</li></ul></li><li>缺点<ul><li>当一个线程因系统调用而被阻塞时，该进程内的所有线程都被阻塞<br>——系统调用使得模式从用户模式切换到内核模式，操作系统只知道进程，故操作系统将进程置为阻塞状态，从而使得该进程内的所有线程都被阻塞</li><li>内核一次只把一个进程分配给一个处理器，因此一次进程中只有一个线程可以执行，使多线程技术不能得到应用</li></ul></li></ul><h4 id="内核级线程（KLTs）"><a href="#内核级线程（KLTs）" class="headerlink" title="内核级线程（KLTs）"></a>内核级线程（KLTs）</h4><p>有关线程管理的所有工作都由内核来完成；应用程序只调用内核级线程的API；操作系统基于线程进行调度。</p><ul><li>优点<ul><li>内核可以同时把同一个进程中的多个线程调度到多个处理器中，从而更好地利用多道程序设计技术</li><li>如果一个进程内的线程阻塞，内核可以调度同一进程内的其他线程运行，不会导致整个进程被阻塞</li><li>内核自身也可以使用多线程</li></ul></li><li>缺点<br>同一个进程内两个线程的切换需要内核模式的切换</li></ul><h1 id="并发：互斥与同步"><a href="#并发：互斥与同步" class="headerlink" title="并发：互斥与同步"></a>并发：互斥与同步</h1><ul><li>熟悉<font color='blue'>进程间制约关系</font>，掌握<font color='orange'>临界资源和临界区概念</font>，掌握<font color='orange'>进程同步和进程同步机制</font>，熟悉<font color='blue'>利用软件、硬件技术解决进程同步机制</font>。</li><li>熟练掌握<font color='red'>信号量机制(记录型信号量和wait、signal操作)的概念、定义和实质</font>，熟练掌握<font color='red'>利用信号量机制实现进程互斥和同步</font>。掌握<font color='orange'>利用信号量解决生产者-消费者等经典同步问题</font>，掌握<font color='orange'>进程同步分析方法</font>。</li></ul><h3 id="并发进程间的制约关系"><a href="#并发进程间的制约关系" class="headerlink" title="并发进程间的制约关系"></a><font color='blue'>并发进程间的制约关系</font></h3><p>在多道程序环境下，系统中各进程以不可预测的速度向前推进，进程的异步性会造成结果的不可再现性。为防止这种现象，异步的进程间推进受到两种限制：</p><ul><li>资源共享关系<br>多进程共享资源时，每次只允许一个进程使用资源，等该进程使用完毕后再将资源分配给其它进程。这种使用原则称为<strong>互斥</strong>使用。<br>进程之间竞争资源面临三个控制问题：<ul><li>互斥（mutual exclusion)指多个进程不能同时使用同一个资源；</li><li>死锁（ deadlock )指多个进程互不相让，都得不到足够的资源；</li><li>饥饿（ starvation )指一个进程一直得不到资源（其他进程可能轮流占用资源）</li></ul></li><li>相互合作关系<br>   在某些进程之间还存在合作关系，进程并发执行时推进序列受到限制，要保证其合作关系正确。进程间这种关系称为<strong>同步</strong>关系。</li></ul><h3 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h3><ul><li><font color='orange'>临界资源</font> —— 一次只允许一个进程使用的资源。</li><li><font color='orange'>临界区</font> —— 多个进程共享临界资源时必须互斥使用，将程序中使用临界资源的那一段代码称为临界区。</li><li>竞争条件 —— 多个进程或线程在读写一个共享数据时，结果依赖于它们执行的相对时间，这种情形叫竞争。</li></ul><h3 id="进程同步机制"><a href="#进程同步机制" class="headerlink" title="进程同步机制"></a><font color='orange'>进程同步机制</font></h3><p>进程在并发执行时为了保证结果的可再现性，各进程执行序列必须加以限制以保证互斥地使用临界资源，相互合作完成任务。<br><strong>多个相关进程在执行次序上的协调</strong>称为进程同步。用于保证多个进程在执行次序上的协调关系的相应机制称为进程同步机制。<br>所有的进程同步机制应遵循下述<strong>四条准则</strong>：  </p><ul><li>空闲让进<br>  当无进程进入临界区时，相应的临界资源处于空闲状态，因而允许一个请求进入临界区的进程立即进入自己的临界区。</li><li>忙则等待<br>   当已有进程进入自己的临界区时，即相应的临界资源正被访问，其它试图进入临界区的进程必须等待，以保证进程互斥地访问临界资源。    </li><li>有限等待<br>   对要求访问临界资源的进程，应保证进程能在有限时间进入临界区，以免陷入“饥饿”状态。</li><li>让权等待<br>   当进程不能进入自己的临界区时，应立即释放处理机，以免进程陷入忙等。<br>   进程同步机制在临界区前加上进入区，它负责对欲访问的临界资源状态进行检查，以决定是否允许该进程进入临界区还是等待。同时在临界区后加上退出区，它负责释放临界资源以便其它等待该临界资源的进程使用。</li></ul><h3 id="互斥的三种实现方法"><a href="#互斥的三种实现方法" class="headerlink" title="互斥的三种实现方法"></a>互斥的三种实现方法</h3><ul><li>软件方法：由进程本身负责实施互斥，不需要操作系统支持。<ul><li>增加一定的开销</li></ul></li><li>硬件方法：使用专门的机器指令来实现互斥。 <ul><li>可减少开销，但依赖于硬件，难以成为通用的解决办法</li></ul></li><li>操作系统层提供支持解决互斥 <ul><li>信号量机制、管程机制和消息传递机制</li></ul></li></ul><h3 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a><font color='red'>信号量机制</font></h3><p>Dijkstra</p><ul><li>基本原理：两个或多个进程可以通过简单的信号进行合作，一个进程可以被迫在某一个位置停止，直到它接收到一个特定的信号。</li></ul><h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><ul><li>特殊的变量，初始化为<strong>非负数</strong>，称为信号量，用于发送信号</li><li>一个进程为了通过信号量s发送信号,它需要执行原语 semSignal(s)&#x2F;V(s)。该操作使信号量值减1。如果信号量值变为负数，则执行该操作的进程被阻塞。</li><li>一个进程通过信号量s接收信号, 它需要执行原语semWait(s) &#x2F;P(s)。该操作使信号量值增1。如果值小于或等于零，表示之前有进程在等该信号，则需要在该信号量的阻塞队列中唤醒一个进程。</li><li>如果相应的信号没有接收到，该进程将被<strong>挂起</strong>，直到它所需的信号发送为止</li></ul><h4 id="二元信号量"><a href="#二元信号量" class="headerlink" title="二元信号量"></a>二元信号量</h4><p>只有0和1两个值。</p><h4 id="信号量的类型"><a href="#信号量的类型" class="headerlink" title="信号量的类型"></a>信号量的类型</h4><ul><li>互斥信号量（公用信号量）：它为一组需互斥共享临界资源的并发进程而设置，它代表永久性共享的临界资源，每个进程均可对它施加wait、signal操作，即可申请和释放该临界资源，其初始值置为1。</li><li>同步信号量（专用信号量）：它为一组需同步协作完成任务的并发进程而设置，它代表消耗性的专用资源，只有拥有该资源的进程才能对它施加wait操作（即可申请资源），而由其合作进程对它施加signal操作（即释放资源）。</li></ul><h4 id="使用信号量机制实现进程互斥"><a href="#使用信号量机制实现进程互斥" class="headerlink" title="使用信号量机制实现进程互斥"></a>使用信号量机制实现进程互斥</h4><p>为使多个进程能互斥地访问某临界资源，只需为该资源设置一个互斥信号量<strong>mutex</strong>, 其初值为1。<br>规定每个进程在<strong>进入临界区CS前</strong>必须申请资源，即对互斥信号量mutex进行<strong>semwait</strong>操作，在<strong>退出临界区CS后</strong>必须释放资源，即对互斥信号量mutex进行<strong>semsignal</strong>操作；即将各进程的临界区CS置于semwait（mutex）和semsignal(mutex)操作之间。<br><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/59fb6e49-2b14-4368-b6b7-46e7e61c2fa7_repeat_1700459269065__771836.png" alt="image.png">  </p><h4 id="使用信号量机制实现进程同步"><a href="#使用信号量机制实现进程同步" class="headerlink" title="使用信号量机制实现进程同步"></a>使用信号量机制实现进程同步</h4><p>例：进程p打印进程c计算后放入缓冲区的数据<br>两条规则：</p><ul><li>只有当C进程把数据送入Buffer后，P进程才能从Buffer中取出数据来打印，否则P进程只能等待。</li><li>只有当P进程从Buffer中取走数据后，C进程才能将新计算的数据再存入Buffer,否则C进程也只能等待。<br><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/3ee9319e-1c28-4e66-bd55-ec5d47ba7d3b_repeat_1700459272361__816461.png" alt="image.png">  </li><li>同步信号量full，它代表的消耗性的专用资源是缓冲器装满数据；  </li><li>同步信号量empty，它代表的消耗性的专用资源是缓冲器空。</li></ul><h5 id="同步的物理意义"><a href="#同步的物理意义" class="headerlink" title="同步的物理意义"></a>同步的物理意义</h5><p>先做动作的进程C在动作完成后对同步信号量施加signal操作，代表发送消息；后做动作的进程P在动作前对同步信号量施加wait操作，代表测试消息是否到达。</p><h4 id="利用信号量机制描述前驱关系"><a href="#利用信号量机制描述前驱关系" class="headerlink" title="利用信号量机制描述前驱关系"></a>利用信号量机制描述前驱关系</h4><p><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/d32274cb-d4ae-4a25-af54-517b961ed5fe_repeat_1700459282414__279457.png" alt="image.png"></p><h4 id="经典进程同步问题"><a href="#经典进程同步问题" class="headerlink" title="经典进程同步问题"></a><font color='orange'>经典进程同步问题</font></h4><h5 id="生产者-消费者问题"><a href="#生产者-消费者问题" class="headerlink" title="生产者&#x2F;消费者问题"></a>生产者&#x2F;消费者问题</h5><p>问题描述：<br>一个或多个生产者生产某种类型的数据（记录、字符），并放置在缓冲区中；<br>有一个消费者从缓冲区中取数据，每次取一项；<br>任何时候只有一个生产者或消费者可以访问缓冲区</p><ul><li><p>情况一：缓冲区无限大<br><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/16d9f92b-18f4-4caf-88c5-2deef1d1822f_repeat_1700459285427__215664.png" alt="image.png"></p></li><li><p>情况二：缓冲区有限  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">producer:  </span><br><span class="line">while (true) &#123;  </span><br><span class="line">/* produce item v */  </span><br><span class="line">while   </span><br><span class="line">((in + 1) % n == out)   </span><br><span class="line"> /* do nothing */;  </span><br><span class="line">b[in] = v;  </span><br><span class="line">in = (in + 1) % n  </span><br><span class="line">&#125;    </span><br><span class="line">consumer:  </span><br><span class="line">while (true) &#123;  </span><br><span class="line">while (in == out)  </span><br><span class="line">/* do nothing */;   </span><br><span class="line">w = b[out];  </span><br><span class="line">out = (out + 1) % n;  </span><br><span class="line">/* consume item w */  </span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><p><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/0c52cfd8-e687-4f34-8752-130291ea6235_repeat_1700459489858__243453.png" alt="image.png"></p></li></ul><h5 id="读者-写者问题"><a href="#读者-写者问题" class="headerlink" title="读者&#x2F;写者问题"></a>读者&#x2F;写者问题</h5><p>问题描述：<br>有一个许多进程共享的数据区（文件、主存空间或处理器寄存器）；有一些进程只从该数据区中读数据，称为读者；有一些进程只往该数据区中写数据，称为写者。<br>任意多的读者可以同时读数据<br>一次只有一个写者可以往数据区写数据<br>如果写者正在写数据时，禁止任何读者读数据  </p><ul><li>解决方法一：读者优先  <ul><li>写者之间必须保证互斥，因此设置wsem 信号量，其初始值为1</li><li>写者只有在没有读者读数据时才能写数据，因此写进程可能会处于“饥饿”状态</li><li>写者在写数据时，不允许读者进来，因此第一个读者进程需要在wsem 信号量上等待</li><li>当有读者在读时，其他读者都可以进入数据区访问数据，不需要等待（因此称为读者优先）</li><li>为了记录读者的个数，定义readcount 变量，初始值为0</li><li>每个读者进程都会修改readcount变量，为了确保该共享变量修改的一致性，定义x信号量，初始值为1<br><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/c8204aca-27b9-488c-83cc-8f14f8939e79_repeat_1700459292233__505324.png" alt="image.png"></li></ul></li><li>解决方法二：写者优先<ul><li>当一个写者进程想写数据时，不允许新的读者进程访问数据区（解决饥饿的问题）</li><li>信号量 rsem ：当至少有一个写者进程准备访问数据区时，禁止所有的读进程 </li><li>writecount ： 记录写进程的个数，用于控制对信号量rsem的操作</li><li>信号量y ：用于确保对writecount的更新</li><li>信号量z：为了避免rsem阻塞队列太长，除了一个读者进程阻塞在rsem队列上，其它所有的读进程都阻塞在信号量z上<br><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/ab7519bb-5dfe-48ca-98da-88133c8307d8_repeat_1700459295039__352366.png" alt="image.png"></li></ul></li></ul><h4 id="进程操作总结"><a href="#进程操作总结" class="headerlink" title="进程操作总结"></a>进程操作总结</h4><ul><li>信号量的物理含义：<br> S&gt;0表示有S个资源可用；<br>S&#x3D;0表示无资源可用；<br>S&lt;0则| S |表示S等待队列中的进程个数。<br>信号量的初值应该大于等于0<br>wait(s)（P(S)）:表示申请(等待)一个资源<br>signal(s)（V(S)）:表示释放一个资源。  </li><li>wait(P)&#x2F;signal(V)操作必须成对出现，有一个wait(P)操作就一定有一个signal(V)操作<br>当为互斥操作时，它们同处于同一进程<br>当为同步操作时，则不在同一进程中出现<br>如果wait(S1)和wait(S2)两个操作在一起，那么wait操作的顺序至关重要,一个同步wait操作与一个互斥wait操作在一起时同步wait操作在互斥wait操作前；而两个signal操作无关紧要</li></ul><h4 id="例"><a href="#例" class="headerlink" title="例"></a>例</h4><ul><li>假定系统有三个并发进程read, move和print共享缓冲器B1和B2。进程read负责从输入设备上读信息，每读出一个记录后把它存放到缓冲器B1中。进程move从缓冲器B1中取出一记录，加工后存入缓冲器B2。进程print将B2中的记录取出打印输出。缓冲器B1和B2某个时刻只能被一个进程访问。要求三个进程协调完成任务，使打印出来的与读入的记录的个数，次序完全一样。请用wait&#x2F;signal操作，写出它们的并发程序。<br><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/0e29d14b-f956-4401-9918-7a8a12536b0a_repeat_1700459297678__021441.png" alt="image.png"><br><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/b8658aa3-5de1-49e0-b97b-3a285ef94c9d_repeat_1700459496666__050823.png" alt="image.png"></li></ul><h1 id="并发：死锁与饥饿"><a href="#并发：死锁与饥饿" class="headerlink" title="并发：死锁与饥饿"></a>并发：死锁与饥饿</h1><ul><li>掌握<font color='orange'>死锁的定义和产生死锁的原因</font>，掌握<font color='orange'>死锁的四个必要条件</font>；熟悉<font color='blue'>预防死锁的方法</font>，熟练掌握<font color='red'>银行家算法及其在死锁避免中的应用</font>；掌握<font color='orange'>资源分配图的简化及其死锁定理</font>，熟悉<font color='blue'>解除死锁的方法</font>。</li></ul><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a><font color='orange'>死锁</font></h3><p>死锁是指计算机系统和进程所处的一种状态。在系统中，两个或多个进程无限期地等待永远不会发生的条件，此时称系统处于死锁状态。 </p><h4 id="产生死锁的原因"><a href="#产生死锁的原因" class="headerlink" title="产生死锁的原因"></a><font color='orange'>产生死锁的原因</font></h4><ul><li>竞争资源<br>两个进程都在等待对方释放出自己所需要的资源，但它们又都因不能获得所需的资源而不能继续推进，从而也不能释放出自己占有的资源，以致进入死锁状态。<ul><li>资源分配图<br>可用资源分配图表示系统状态。资源分配图由结点和边组成。<br>结点有两类，一类是进程结点，用圆圈表示；另一类是资源结点，用小方框表示一类资源，方框中的小圈表示资源数。<br>边也有两类，一类是分配边，它由资源结点指向进程结点，另一类是申请边，它由进程结点指向资源结点。<br><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/8fb875e7-e2d0-438c-b21d-512aa4cf9bd1_repeat_1700459303828__410008.png" alt="image.png"></li></ul></li><li>进程推进顺序不当<br>在多道程序系统中，并发执行的进程推进序列不可预测，有些推进顺序会引起进程无限期地等待永远不会发生的条件而不能向前推进，造成了死锁。</li></ul><h4 id="死锁的条件"><a href="#死锁的条件" class="headerlink" title="死锁的条件"></a><font color='orange'>死锁的条件</font></h4><ul><li>互斥(Mutual exclusion)<br>一次只有一个进程可以使用资源</li><li>占有且等待 (Hold-and-wait)<br>当一个进程在等待分配得到其他资源时，将继续占有已分配到的资源</li><li>非剥夺 (No preemption )<br>不能强行抢占进程已占有的资源</li><li>循环等待 (Circular wait)<br>存在一个封闭的进程-资源链，每个进程至少占有一个该链中下一个进程所需要的资源</li></ul><h4 id="死锁的解决办法"><a href="#死锁的解决办法" class="headerlink" title="死锁的解决办法"></a>死锁的解决办法</h4><ul><li>死锁的预防<br>静态方法：在进程执行前采取的措施，通过设置某些限制条件，去破坏产生死锁的四个必要条件之一，防止发生死锁。  </li><li>死锁的避免<br>动态的方法：在进程执行过程中采取的措施，不需事先采取限制措施破坏产生死锁的必要条件，而是在进程申请资源时用某种方法去防止系统进入不安全状态，从而避免发生死锁。  </li><li>死锁的检测（Detection）和解除<br>这种方法预先并不采用任何限制措施，允许系统在运行过程中发生死锁，但可通过系统设置的检测机构及时检测死锁的发生（定期执行死锁检测算法），如检测到死锁，则采用撤消进程等死锁解除方法使系统恢复正常工作。</li></ul><h4 id="死锁的预防"><a href="#死锁的预防" class="headerlink" title="死锁的预防"></a><font color='blue'>死锁的预防</font></h4><p>预防死锁的方法是破坏四个产生死锁的必要条件之一。</p><ul><li>破坏互斥条件<br>互斥使用是资源本身特征所决定的。使用硬软件结合可改变资源本身特性。一般不破坏互斥条件。</li><li>破坏不可抢占条件<br>可采用<strong>抢占式调度</strong>，但抢占式调度法主要用于处理机和存储器资源调度，它们的状态容易保存和恢复。此法对外部设备和私有数据不宜使用。</li><li>破坏请求和保持条件<br>系统可采用<strong>资源静态预先全分配</strong>方式来破坏请求保持条件。系统要求所有进程<strong>一次性地申请在整个运行过程中全部资源</strong>，若系统有足够资源满足给进程，则在运行前，一次性将其所需要的所有资源分配给该进程。这样该进程在整个运行期间，便不再提出资源要求，从而摒弃了请求条件。<br>优点是简单、易于实现且很安全，但其资源利用率很低，进程也延迟运行。</li><li>破坏循环等待条件<br>有序资源使用法：<br>  该方法将所有的资源<strong>按类型进行线性排队，并赋予不同的序号</strong>。所有进程对资源的请求必须<strong>严格按资源序号递增的次序</strong>提出。这样在所形成的资源分配图中不可能再出现环路，因而摒弃了“循环等待”条件，在采用这种策略时总有一个进程占据了较高序号的资源，它继续请求的资源必然是空闲的，因而进程可以一直向前推进。<br>可提高资源利用率，但在进程使用各类资源的顺序与系统规定的顺序不同时会造成资源浪费的情况。</li></ul><h4 id="死锁的避免（Avoidance）"><a href="#死锁的避免（Avoidance）" class="headerlink" title="死锁的避免（Avoidance）"></a>死锁的避免（Avoidance）</h4><p>允许进程动态地申请资源，系统在进行资源分配之前，<strong>先计算资源分配的安全性</strong>。若此次分配不会导致系统从安全状态向不安全状态转换，便可将资源分配给进程；否则不分配资源，进程必须阻塞等待。从而避免发生死锁。<br>限制：  </p><ol><li>必须事先声明每个进程请求的最大资源数</li><li>考虑的进程必须是无关的，即进程之间不存在同步关系</li><li>分配的资源数目必须是固定的</li><li>在占有资源时，进程不能退出</li></ol><ul><li>资源分配拒绝  <ul><li>系统的安全状态是指系统的一种状态，在此状态下系统能按某种顺序（例如P1、P2……Pn）来为各个进程分配其所需资源，直至最大需求，使每个进程都可顺序地一个个地完成。这个序列（P1、P2…….Pn）称为安全序列。</li><li>若系统在某个状态下<strong>不存在一个安全序列</strong>，使所有进程能运行结束，则称系统处于不安全状态。不安全状态并不是死锁状态，而是<strong>存在死锁的可能性</strong>。</li></ul></li></ul><h5 id="银行家算法——Dijkstra"><a href="#银行家算法——Dijkstra" class="headerlink" title="银行家算法——Dijkstra"></a><font color='red'>银行家算法——Dijkstra</font></h5><ul><li>数据结构<br>考虑一个具有n个进程和 m 种不同类型资源系统。  <ul><li>Resource&#x3D;R&#x3D;(R1,R2,…,Rm)：向量，表示系统中<strong>每种资源的总量</strong> </li><li>Available&#x3D;V&#x3D;(V1,V2,…,Vm)：向量，未分配给进程的每种资源的总量，即<strong>可用的资源数</strong>  </li><li>Claim&#x3D;C：矩阵，Cij表示进程i对资源j的<strong>最大需求</strong></li><li>Allocation&#x3D;A：矩阵，Aij表示当前进程i<strong>已分配到的资源</strong>j的数量  </li><li>Need&#x3D;N：矩阵，表示每个进程<strong>尚需的各类资源数</strong>，Need[i,j]&#x3D;k 表示进程i还需要j类资源k个。Need[i,j]&#x3D;Claim[i,j]-Allocation[i,j]</li></ul></li><li>算法思想<br>假设在进程并发执行时，进程i提出请求j类资源k个后，表示为Request<del>i</del>[j]&#x3D;k。系统按下述步骤进行安全检查：</li></ul><ol><li>如果alloc[i,<em>]+Request[</em>]≤claim[i,*]，则继续以下检查，否则显示需求申请超出最大需求值的错误。</li><li>如果Request[<em>]≤Available[</em>]则继续以下检查，否则显示系统无足够资源，P<del>i</del>阻塞等待。</li><li>系统假设同意进程i的请求，将系统状态修改为满足请求之后的状态，然后对此状态执行安全性算法检测，判断在此次资源分配后，系统是否处于安全状态，若安全，才正式将资源分配给进程i，以完成本次分配；否则将恢复原来的资源分配状态，让进程P<del>i</del>等待，即进程P<del>i</del>置为阻塞状态。</li></ol><h5 id="例-1"><a href="#例-1" class="headerlink" title="例"></a>例</h5><p><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/509c51e1-4df9-45c8-8840-55cfe131c21b_repeat_1700459306266__927083.png" alt="image.png"></p><ul><li>T<del>0</del>时刻是否安全？<br><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/81bf2dff-a55f-43c0-a177-334eb8ff68ad_repeat_1700459502220__462474.png" alt="image.png"></li><li>P<del>1</del>请求资源Request<del>1</del>(1,0,2)可否允许？<ul><li>Request1(1,0,2)≤Need1(1,2,2)，P1请求在最大需求范围内。</li><li>Request1(1,0,2)≤ Available(3,3,2)，可用资源可满足P1请求需要。</li><li>试探把要求的资源分配给进程P1并修改有关数据结构的数值：<br>Available &#x3D; Available(3，3，2)－Request<del>1</del>(1,0,2)&#x3D;(2,3,0)；<br>Need<del>1</del> &#x3D; Need<del>1</del>(1,2,2)－Request<del>1</del>(1,0,2)&#x3D; (0,2,0)；<br>Allocation<del>1</del> &#x3D;Allocation<del>1</del>(2,0,0)+Request<del>1</del>(1,0,2) &#x3D;(3,0,2)；<br>利用安全性算法检查试探将资源分配后状态的安全性如下：<br><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/04b518f0-9297-4c94-b7e3-60a79944b4c1_repeat_1700459311309__846656.png" alt="image.png"><br>因为先分配资源给P1进程符合按安全序列{P1、P3、P4、P2、P0}分配资源，所以试探将资源分配给进程P1后的状态是安全的，可将资源分配给进程P1。</li></ul></li><li>P<del>4</del>请求资源Request<del>4</del>(3,3,0)是否允许？<br>Request<del>4</del>(3,3,0)≤Need<del>4</del>(4,3,1)，P<del>4</del>请求在最大需求范围内。<br>Request<del>4</del>(3,3,0)≤Available(2,3,0)不成立，即可用资源暂不能满足P4请求资源需要，P<del>4</del>阻塞等待。</li></ul><h4 id="死锁的检测（Detection）和解除"><a href="#死锁的检测（Detection）和解除" class="headerlink" title="死锁的检测（Detection）和解除 "></a><font color='blue'>死锁的检测（Detection）和解除 </font></h4><p>不限制资源访问或约束进程的行为;<br>只要系统资源能满足进程的请求就立即满足;<br>操作系统定期执行一个算法（死锁检测算法），检测当前系统是否满足了循环等待的条件，即当前系统是不是出现死锁;<br>若出现死锁，则进行相应的恢复。<br><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/f04b5ba1-cb40-41d0-9741-ecaef7be0d67_repeat_1700459313750__290804.png" alt="image.png"><br><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/f4b4a089-bd49-4a1b-b82f-96c5423f6590_repeat_1700459508199__508024.png" alt="image.png"></p><h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><h3 id="教学要求"><a href="#教学要求" class="headerlink" title="教学要求"></a>教学要求</h3><ul><li>熟悉<font color='blue'>存储管理目的和功能</font>，掌握<font color='orange'>地址重定位的概念</font>。</li><li>熟悉<font color='blue'>固定分区分配、动态分区分配的实现原理</font>；掌握<font color='orange'>可变分区分配的数据结构和分配回收算法</font>，熟悉<font color='blue'>可变分区碎片和压缩技术</font>。</li><li>熟练掌握<font color='red'>分页存储管理原理</font>，熟练掌握<font color='red'>分页存储管理基本的地址变换机构</font>。</li><li>掌握<font color='orange'>分段存储管理原理和分段地址变换机构</font>，掌握<font color='orange'>分页和分段比较</font>，熟悉<font color='blue'>分页和分段的共享</font>。</li></ul><h3 id="目的和功能"><a href="#目的和功能" class="headerlink" title="目的和功能"></a><font color='blue'>目的和功能</font></h3><h4 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h4><p>程序的指令和数据只有被调入内存（RAM）里才能被CPU直接访问，程序才能够被执行。</p><h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><p>1.内存分配<br>内存分配的主要任务是：为每一道程序分配内存空间；程序撤消时，收回它占用的内存空间。分配时注意提高存储器的利用率。<br>2.地址映射<br>目标程序所访问的地址是逻辑地址集合的地址空间，而内存空间是内存中物理地址的集合，在多道程序环境下，这两者是不一致的，因此，存储管理必须提供地址映射功能，用于<strong>把程序地址空间中的逻辑地址转换为内存空间中对应的物理地址</strong>。<br>3.存储保护<br>内存保护的任务是确保每道程序都在自己的内存空间运行，互不干扰。保护系统程序区不被用户侵犯（有意或无意的），不允许用户程序读写不属于自己地址空间的数据（系统区地址空间，其他用户程序的地址空间）。<br>4.提高主存储器的利用率<br>减少不可用的存储空间（称为“碎片”、“零头”），允许多道程序动态共享主存。<br>5.内存扩充<br>内存扩充的任务是从<strong>逻辑上</strong>来扩充内存容量，使用户认为系统所拥有的内存空间远比其实际的内存空间（硬件RAM）大的多。  </p><h3 id="地址重定位"><a href="#地址重定位" class="headerlink" title="地址重定位"></a><font color='orange'>地址重定位</font></h3><p>地址重定位，也称地址映射（map），它将相对地址转换成内存中的绝对地址。按照重定位的时机，可分为静态重定位和动态重定位。  </p><ul><li>静态重定位<br>静态重定位是在程序执行之前进行重定位。它根据装配模块将要装入的内存起始地址，直接修改装配模块中的有关使用地址的指令。</li><li>动态重定位<br>动态重定位是指在程序执行过程中进行地址重定位，即在每次访问内存单元前才进行地址变换。</li></ul><h3 id="内存分区"><a href="#内存分区" class="headerlink" title="内存分区"></a><font color='blue'>内存分区</font></h3><p>内存管理最基本的操作是由处理器将程序装入主存中执行。<br>分区存储管理是能够满足多道程序运行的最简单的存储器管理方案，其基本思想是将内存划分成若干个连续的区域，称为分区。<br>每个分区只能存储一个程序，而且程序也只能在它所驻留的分区中运行。<br>分区存储管理根据分区个数及分区大小的可变性分为固定分区和动态分区两种。</p><h4 id="固定分区"><a href="#固定分区" class="headerlink" title="固定分区"></a>固定分区</h4><p>在作业装入之前，系统管理员或操作系统<strong>事先</strong>将内存划分成若干个分区。一旦划分完成，在系统运行期间不再重新划分，即分区的<strong>个数不可变</strong>，分区的<strong>大小不可变</strong>，所以，固定式分区又称为静态分区。<br>可划分为大小相等的分区 (Equal-size partitions) 和大小不等的分区(Unequal-size partitions) 任何小于或等于分区大小的进程都可以装入到任何可用的分区中。<br>如果所有的分区都满了，系统可以换出一个进程，将其所占用的分区分配给另一个进程使用。<br><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/fde5cf36-3770-4314-a1b1-d39f7e8b7c64_repeat_1700459319176__108479.png" alt="image.png"></p><h5 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h5><ul><li>程序可能太大而不能放到一个分区中，必须使用覆盖技术，使得在任何时候该程序只有一部分放到主存中。</li><li>主存的利用率不高。任何进程，即使很小，都需要<strong>占据一个完整的分区</strong>。 一个进程的大小不可能正好等于某个分区的大小，所以每个被分配的分区内总有一部分被浪费，我们把这部分被浪费的存储区称为<strong>内部碎片</strong>( fragmentation)或内零头。</li></ul><h5 id="放置算法"><a href="#放置算法" class="headerlink" title="放置算法"></a>放置算法</h5><ul><li>大小相等的分区<br>所有分区大小都相等，只要存在可用的分区，进程就可以装入</li><li>大小不等的分区<br>把每个进程指定到足够容纳它的最小分区</li></ul><h4 id="动态分区"><a href="#动态分区" class="headerlink" title="动态分区"></a><font color='orange'>动态分区</font></h4><p>动态分区是指在作业装入内存时，从可用的内存中划出一块连续的区域分配给它，且<strong>分区大小正好等于该作业的大小</strong>。<br>动态分区中分区的大小和分区的个数都是可变的，而且是根据作业的大小和多少动态地划分，因此又称可变分区。<br><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/896224c5-3f40-407c-b0aa-8d6e60596d1c_repeat_1700459322193__184774.png" alt="image.png"><br>在分配时，首先找到一个足够大的空闲分区，系统再将这个空闲分区分成两部分：一部分成为已分配的分区（大小正好等于作业要求的大小），剩余的部分仍作为空闲区。<br>回收撤除作业所占领的分区时，要检查回收的分区是否与前后空闲的分区相邻接，若是，则加以合并，使之成为一个连续的大空间。<br>随着作业的不断分配和撤除，内存中会产生越来越多的碎片（外部碎片），内存的利用率下降，因此，必须定期使用压缩技术(compaction)，移动进程，使进程所占用的空间连续，并且所有空闲空间连成一片。</p><h5 id="分配算法"><a href="#分配算法" class="headerlink" title="分配算法"></a>分配算法</h5><ul><li>最佳适应算法BF（Best Fit）：它从全部空闲区中找出能满足作业要求的、且大小最小的空闲分区，这种方法能使碎片尽量小。为适应这种算法，空闲分区表（空闲区链）中的空闲分区要<strong>按大小从小到大进行排序</strong>，自表头开始查找到第一个满足要求的自由分区分配。该算法保留大的空闲区，但造成许多小的空闲区。</li><li>首次适应算法FF（First Fit）：从空闲分区表的第一个表目起查找该表，把最先能够满足要求的空闲区分配给作业，这种方法目的在于减少查找时间。为适应这种算法，空闲分区表（空闲区链）中的空闲分区要<strong>按地址由低到高进行排序</strong>。该算法优先使用低址部分空闲区，在低址空间造成许多小的空闲区，在高地址空间保留大的空闲区。</li><li>循环首次适应算法&#x2F;邻近算法NF(Next Fit)：该算法是首次适应算法的变种，它把空闲分区表（空闲区链）中的空闲分区按<strong>地址递增</strong>构成一个循环链。在分配内存空间时，不再每次从表头（链首）开始查找，而是从<strong>上次找到的空闲区的下一个空闲区</strong>开始查找，直到找到第一个能满足要求的的空闲区为止，并从中划出一块与请求大小相等的内存空间分配给作业。该算法能使内存中的空闲区分布得比较均匀。</li><li>最坏适应法：从所有未分配的分区中挑选最大的且大于和等于作业大小的分区分给要求的作业；空闲分区按大小<strong>由大到小排序</strong>。该算法使小的空闲区减少，但造成大的空闲区不够大。</li></ul><h5 id="回收算法"><a href="#回收算法" class="headerlink" title="回收算法"></a>回收算法</h5><p>邻接则合并，否则新建条目并插入合适位置。<br>分区存储保护：选中作业运行时将其边界存入上下界寄存器，作业运行过程中超出范围则产生越界中断。</p><h5 id="伙伴系统"><a href="#伙伴系统" class="headerlink" title="伙伴系统"></a>伙伴系统</h5><p>可用于分配的整个内存空间看做一个大小为2U的块<br>如果请求分配的空间大小s满足2U-1 &lt; s &lt;&#x3D; 2U, 则分配整个空间块（2U）<br>否则，将2U 一分为二，分为两个大小相等的伙伴，大小均为2U-1<br>这个过程一直继续，直到产生大于或等于s的最小块，并分配给该请求。<br>可用二叉树来表示，树的叶节点表示内存中的当前分区。如果两个伙伴都是叶节点且都未分配，则必须将它们合成一个更大的块。<br><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/d78b2477-9d42-47ab-a9f4-a5e332155964_repeat_1700459324979__686508.png" alt="image.png"></p><h3 id="分页存储管理方式"><a href="#分页存储管理方式" class="headerlink" title="分页存储管理方式"></a><font color='red'>分页存储管理方式</font></h3><p>分页存储管理是将一个<strong>进程的地址空间</strong>划分成若干个<strong>大小相等的片</strong>，称为页面或<strong>页</strong>，相应地，将<strong>内存空间</strong>划分成<strong>与页相同大小</strong>的若干个块，称为（物理）<strong>帧</strong>（块）或页帧。在为进程分配内存时，将进程中的若干页离散地装入不相邻接的物理帧中。<br>页面的大小通常在512B到4KB之间，每块物理块可离散地分配给进程的一页，这样不断地分配，直到剩余的物理块数不能满足一个进程的要求为止。而对每个进程只有最后一页经常装不满一块，平均产生半页“页内碎片”。由此可知，分页存储管理<strong>解决了“碎片”问题，提高了存储器的利用率</strong>。</p><h4 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h4><p>系统在内存为每个进程建立了一张页面映射表，简称<strong>页表</strong>(page table)（<strong>有多少个进程就有多少个页表</strong>）。每个页在页表中占一个表项，记录该页在内存中对应的物理块号或帧号（页号可以省略，通常默认从0开始）。<br>进程在执行时，通过查找页表，就可以找到每页所对应的物理块号或帧号。<br>可见，页表的作用是实现从<strong>页号到物理块号的地址映射</strong>。 </p><h4 id="地址结构"><a href="#地址结构" class="headerlink" title="地址结构"></a>地址结构</h4><p>分页系统的地址结构如下图所示，它由两部分组成：前一部分为<strong>页号P</strong>；后一部分为<strong>页内位移量W</strong>，即页内地址，由页的大小决定。<br>图中的地址长度为16位，其中0～9位为页内地址（每页的大小为1KB），10～15位为页号，所以允许地址空间的大小最多为64个页（26）。<br><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/da703385-537b-43bb-9fcb-99f20bd5b4d7_repeat_1700459327568__540114.png" alt="image.png"></p><h4 id="地址变换"><a href="#地址变换" class="headerlink" title="地址变换"></a>地址变换</h4><p>基本任务：利用硬件实现查页表把用户程序中的逻辑地址变换成内存中的物理地址。<br>为了实现地址变换功能，在系统中设置页表寄存器，用来存放页表的始址和页表的长度。在进程未执行时，每个进程对应的页表的始址和长度存放在进程的PCB中，当该进程被调度时，就将它们装入页表寄存器。<br>在进行地址变换时，系统将逻辑地址截成页号和页内地址二部分，将页号与页表长度进行比较，如果<strong>页号大于等于</strong>页表寄存器中的<strong>页表长度</strong>，则访问越界，产生<strong>越界中断</strong>。如未出现越界，则根据页表寄存器中的页表始址和页号计算出该页在页表项中的位置，查页表得到该页的物理块号，<strong>将物理块号与逻辑地址中页内地址二者拼接成物理地址</strong>，这样便完成了从逻辑地址到物理地址的变换。<br><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/dc2f0f14-47d2-4493-97c6-dae3d0c71140_repeat_1700459329985__639592.png" alt="image.png"><br><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/5d88d5fc-2fef-4fd0-8a35-1ab4bdaf6f6a_repeat_1700459514557__570614.png" alt="image.png"></p><h3 id="分段"><a href="#分段" class="headerlink" title="分段"></a><font color='orange'>分段</font></h3><p>在分段存储管理方式中，作业的地址空间<strong>按逻辑信息完整性被划分为若干个段</strong>，每个段都有自己的名字，编译后都是从零开始编址的一段连续的地址空间，段的长度由相应逻辑信息组的长度决定，因而<strong>各段长度是不等的</strong>。每个段分配到一个连续的分区，而进程中的各个段可以离散地分配到内存中不同的分区中。<br>分段系统的地址结构由<strong>段号</strong>和<strong>段内地址</strong>两部分组成。<br><strong>取最大段的长度为段内地址位数</strong>。</p><h4 id="段表"><a href="#段表" class="headerlink" title="段表"></a>段表</h4><p>每个段在表中占有一表项，在其中记录了该段在内存中的起始地址（又称为“基址”）和段的长度。<br><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/f6d910ba-9c42-460c-aa71-17b3647b9a1e_repeat_1700459335095__308089.png" alt="image.png"></p><h4 id="地址变换-1"><a href="#地址变换-1" class="headerlink" title="地址变换"></a>地址变换</h4><p>段表寄存器，存放段表始址和段表长度。<br>逻辑地址中的段号S与段表长度TL进行比较。若 S≥TL，产生越界中断信号；<br>若未越界，则根据段表的始址和该段的段号，计算出该段对应段表项的位置，从中读出该段在内存中的起始地址，然后再检查段内地址d是否超过该段的段长SL。若超过，即d≥SL，同样发出越界中断信号；若未越界，则将该段的基址与段内地址d相加，得要访问的内存物理地址。<br><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/03f11728-90ae-4e06-ace5-bed36e8cbb71_repeat_1700459337644__615445.png" alt="image.png"></p><h4 id="共享"><a href="#共享" class="headerlink" title="共享"></a><font color='blue'>共享</font></h4><p>段是信息的逻辑单位,因此分段系统的一个突出的优点是易于实现段的共享。<br>下图为分段系统中共享 editor编辑程序的示意图。<br><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/d02af489-3904-4a07-a93f-0a4862084418_repeat_1700459340116__972054.png" alt="image.png"></p><h3 id="分页与分段对比"><a href="#分页与分段对比" class="headerlink" title="分页与分段对比"></a><font color='orange'>分页与分段对比</font></h3><p><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/c0cf0068-7958-4cb6-8e7f-9464ec9e94d6_repeat_1700459519735__882813.png" alt="image.png"><br><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/0d25a699-acfd-4c86-b886-2fb940f0a546_repeat_1700459343642__349734.png" alt="image.png"></p><h1 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h1><h3 id="教学要求-1"><a href="#教学要求-1" class="headerlink" title="教学要求"></a>教学要求</h3><ul><li>掌握<font color='orange'>虚拟存储器的理论基础和定义</font>，熟悉<font color='blue'>虚拟存储器实现方式和特征</font>。</li><li>掌握<font color='orange'>请求分页的页表机制、缺页中断机构和地址变换机构</font>，熟悉<font color='blue'>页面的分配和置换策略、页面的分配的算法</font>。</li><li>掌握<font color='orange'>请求分段的段表机制、缺段中断机构和地址变换机构</font>，熟悉<font color='blue'>分段的共享和保护</font>。</li><li>掌握<font color='orange'>段页式存储管理原理和地址变换机构</font>。</li><li>熟练掌握<font color='red'>最佳置换算法、先进先出（FIFO）置换算法、最近最久未使用置换算法LRU</font>，熟悉<font color='blue'>Clock置换算法和页面缓冲算法</font>；了解工作集概念。</li></ul><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>前面的存储器管理方式，有一个共同的特点，即要求将一个作业<strong>全部装入内存</strong>才能运行。如果有的作业很大，其所要求的内存空间超过了内存总容量，作业就不能全部被装入内存，致使该作业无法运行；有时大量作业要求运行，但由于内存容量不足以容纳所有这些作业，只能将少数作业装入内存让它们先运行，而将其它大量的作业留在外存上等待。<br>显而易见的一种解决方法，是从物理上增加内存容量，但这往往会受到机器自身的限制，而且增加了系统成本。<br>另一种方法是从<strong>逻辑上扩充内存容量</strong>，这正是虚拟存储技术所要解决的主要问题。 </p><h4 id="虚拟存储的优点"><a href="#虚拟存储的优点" class="headerlink" title="虚拟存储的优点"></a>虚拟存储的优点</h4><ul><li>内存中可以容纳更多的进程  <ul><li>每个进程只有<strong>一部分</strong>的数据块读入内存，其他数据块仍保存在磁盘上</li><li>内存可以<strong>容纳更多的进程</strong>，并发性得到更大的提高，从而也使得处理器得到了更有效的利用</li></ul></li><li>进程可以比主存的全部空间还大<ul><li>实存 (Real memory)：内存</li><li>虚存 (Virtual memory)：磁盘的存储空间</li></ul></li></ul><h3 id="虚拟存储器理论基础"><a href="#虚拟存储器理论基础" class="headerlink" title="虚拟存储器理论基础"></a><font color='orange'>虚拟存储器理论基础</font></h3><h4 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h4><p>程序在执行时将呈现出局部性规律，即在一段时间内，程序的执行仅局限于某个部分；相应地，它所访问的存储空间也局限于某个区域内。</p><ul><li>时间局部性<br>如果程序中的某条指令一旦执行，则不久的将来该指令可能再次被执行；如果某个存储单元被访问，则不久以后该存储单元可能再次被访问。产生时间局限性的典型原因是在程序中存在着大量的<strong>循环</strong>操作。</li><li>空间局部性<br>一旦程序访问了某个存储单元，则在不久的将来，其附近的存储单元也最有可能被访问。 即程序在一段时间内所访问的地址，可能集中在一定的范围内，其典型原因是程序是<strong>顺序执行</strong>的。<br>局部性原理确保了虚拟存储机制的可行性。但利用局部性原理的同时，要避免系统出现抖动现象（thrashing），即处理器大部分时间都用于交换块，而不是执行指令。</li></ul><h4 id="软硬件支撑"><a href="#软硬件支撑" class="headerlink" title="软硬件支撑"></a>软硬件支撑</h4><h5 id="硬件支撑"><a href="#硬件支撑" class="headerlink" title="硬件支撑"></a>硬件支撑</h5><ul><li>有相当容量的辅存（磁盘）以存放所有并发作业的地址空间</li><li>有一定容量的内存来存放运行作业的部分程序</li><li>有支持分页或分段的硬件<ul><li>请求分页系统和请求分段系统</li><li>动态地址转换机构</li></ul></li></ul><h5 id="软件支撑"><a href="#软件支撑" class="headerlink" title="软件支撑"></a>软件支撑</h5><ul><li>操作系统能提供页或段在主存和辅存之间有效交换的管理模块</li></ul><h4 id="特征-1"><a href="#特征-1" class="headerlink" title="特征"></a>特征</h4><ul><li>离散性<br>指在内存分配时采用离散的分配方式，它是虚拟存储器的<strong>最基本</strong>的特征。</li><li>多次性<br>指一个作业被分成多次调入内存运行，即在作业运行时没有必要将其全部装入，只须将当前要运行的那部分程序和数据装入内存即可。多次性是虚拟存储器<strong>最重要</strong>的特征。</li><li>对换性<br>指允许在作业的运行过程中在内存和外存的对换区之间换进、换出。</li><li>虚拟性<br>指能够从逻辑上扩充内存容量，使用户所看到的内存容量远大于实际内存容量。</li></ul><h3 id="请求分页"><a href="#请求分页" class="headerlink" title="请求分页"></a><font color='orange'>请求分页</font></h3><p>请求分页存储管理系统是在纯分页系统的基础上，增加了<strong>请求调页</strong>功能、<strong>页面置换</strong>功能所形成的页式虚拟存储系统，它是目前常用的一种虚拟存储器的方式。<br>它允许只装入若干页(而非全部页)的用户程序和数据，便可启动运行。以后，再通过调页功能及页面置换功能，陆续地把即将要运行的页面调入内存，同时把暂不运行的页面换出到外存上，置换时以页面为单位。  </p><h4 id="硬件支持"><a href="#硬件支持" class="headerlink" title="硬件支持"></a>硬件支持</h4><h5 id="页表-1"><a href="#页表-1" class="headerlink" title="页表"></a>页表</h5><p><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/97ca00b8-5137-4724-90a3-7497e27a315f_repeat_1700459348613__844897.png" alt="image.png"><br>其中各字段说明如下：  </p><ul><li>状态位（中断位P）：用于指示该页<strong>是否已调入内存</strong>，供程序访问时参考。</li><li>访问字段A：用于记录本页在一段时间内被访问的次数，或最近已有多长时间未被访问，提供给置换算法选择换出页面时参考。</li><li>修改位M：表示该页在调入内存后是否被修改过。由于内存中的每一页都在外存上保留一份副本，因此，若未被修改，在置换该页时就不需将该页写回到外存上，以减少系统的开销和启动磁盘的次数；若已被修改，则必须将该页重写到外存上，以保证外存中所保留的始终是最新副本。</li><li>外存(辅存)地址：用于指出该页在外存上的地址，通常是物理块号，供调入该页时使用</li></ul><h5 id="缺页中断"><a href="#缺页中断" class="headerlink" title="缺页中断"></a>缺页中断</h5><p>在请求分页系统中，每当所要访问的页面不在内存时，便要产生缺页中断，请求OS将所缺页调入内存。</p><h4 id="请求分页带来的问题"><a href="#请求分页带来的问题" class="headerlink" title="请求分页带来的问题"></a>请求分页带来的问题</h4><ul><li>每个进程都有一个页表，页表保存在哪里？<br>一个2GB (2^31^ )的进程，如果页大小为512B(2^9^) ，则需要的页表项为2^22^<br>页表占据了大量的空间，应该保存在虚存上，可使用<strong>多级页表</strong>结构</li><li>每个虚存访问会引起<strong>两次</strong>物理内存访问，导致存储器访问时间加倍<br>第一次取相应的页表项，第二次取需要数据。<br>可使用<strong>快表</strong>机制来解决</li></ul><h4 id="快表-Translation-Lookaside-Buffer，TLB）"><a href="#快表-Translation-Lookaside-Buffer，TLB）" class="headerlink" title="快表(Translation Lookaside Buffer，TLB）"></a>快表(Translation Lookaside Buffer，TLB）</h4><p>为了提高地址变换的速度，增设了一个具有按内容查找、并行查询功能的特殊的<strong>高速缓冲存储器</strong>，称为 “快表”，或称为“关联存储器(TLB, 转换后备缓冲器)”，用以存放当前访问的那些页表项，每个页表项包括<strong>页号和相应的块号</strong>（页号不能省略）。<br>引入快表之后的存储访问修改如下：  </p><ul><li>处理器首先将逻辑地址中的页号与TLB中的各页表项的页号进行比较</li><li>如果有相同的 (TLB命中)， 则直接从TLB的输出寄存器输出相应的块号</li><li>如果没有找到(TLB不命中) ，则访问内存从该进程的页表中查找</li><li>检查该页是否在内存中(检查P位) 。如果不在，则发生缺页中断</li><li>页访问之后，++同时要将该页的页表项读入TLB++</li></ul><h4 id="例-2"><a href="#例-2" class="headerlink" title="例"></a>例</h4><p><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/4c69bf10-9885-46e8-a99d-ffa1ca04f2e4_repeat_1700459351096__291351.png" alt="image.png"><br><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/43c6d03f-f094-4dfe-bde7-a157d2f1a7b1_repeat_1700459526149__252103.png" alt="image.png"></p><h3 id="段页式存储"><a href="#段页式存储" class="headerlink" title="段页式存储"></a><font color='orange'>段页式存储</font></h3><p><strong>将内存空间划分成大小相同的若干个块，将用户程序先按逻辑完整性分为若干个段</strong>，并为每个段赋予一个段名，再把<strong>每个段划分成若干个与块大小相同的页</strong>，将这些页离散装入不相邻接的块中。<br>段页式系统中的地址结构由段号、段内页号和页内地址三部分组成。<br><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/fcbba89a-5d4d-4431-b5b8-7072cd02a7fb_repeat_1700459356211__143176.png" alt="image.png"><br>在段页式系统中，为了实现从逻辑地址到物理地址的变换，系统中必需同时配置段表和页表。由于将段中的页进行离散地分配，<strong>段表中的内容不再是段的内存始址和段长，而是页表始址和页表长度</strong>。</p><h4 id="地址变换-2"><a href="#地址变换-2" class="headerlink" title="地址变换"></a>地址变换</h4><ol><li>系统将逻辑地址截成段号S、段内页号P与页内地址W，先用段号S与段长TL（存在段表寄存器中）进行比较。若 S≥TL，表示段号太大，访问越界，于是产生越界中断信号；</li><li>若S＜TL，表示未越界，于是利用段表始址（存在段表寄存器中）和段号求出该段对应的段表项在段表中的位置，从中得到该段的页表始址；</li><li>利用逻辑地址中的段内页号P来获得对应页的页表项在页表中位置，判断状态P位，若P位为0表示该页不在内存中，产生缺页中断；</li><li>若P位为1，则从中读出该页所在的物理块号b，再用块号b和页内地址W拼成物理地址。</li></ol><ul><li>段页式系统中，为了获得一条指令或数据，需要访问几次内存？<br>需访问三次内存：<br>第一次访问内存中的段表，从中取得页表始址；<br>第二次访问内存中的页表，从中取出该页所在的物理块号，并将该块号与页内地址一起形成指令或数据的物理地址；<br>第三次访问才是真正根据所得的物理地址取出指令或数据。  <ul><li>如何提高速度？<br>在地址变换机构中增设一高速缓冲寄存器（如TLB），记录最近访问过的地址信息。每次访问它时，都同时利用段号和页号去检索高速缓存。</li></ul></li></ul><h3 id="替换策略"><a href="#替换策略" class="headerlink" title="替换策略"></a><font color='red'>替换策略</font></h3><ul><li>读取一个新页时，应该替换内存中的哪一页?<br>在进程运行过程中，如果发生缺页，此时内存中又无空闲块时，为了保证进程能正常运行，就必须从内存中调出一页到磁盘。<br>页面置换算法的性能指标：<strong>缺页率（ page fault rate ）&#x3D;“缺页次数 &#x2F; 内存访问次数” (比率)</strong></li></ul><h4 id="最佳替换（OPT）"><a href="#最佳替换（OPT）" class="headerlink" title="最佳替换（OPT）"></a>最佳替换（OPT）</h4><p><strong>选择那些永不使用的，或者是在最长时间内不再被访问的页面置换出去。</strong><br>它是一种理想化的算法，性能最好，但在实际上难于实现。<br><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/0c5ad9f3-a5ee-4f99-bd74-94e826266136_repeat_1700459358690__752195.png" alt="image.png"></p><h4 id="先进先出（FIFO）"><a href="#先进先出（FIFO）" class="headerlink" title="先进先出（FIFO）"></a>先进先出（FIFO）</h4><p>总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面予以淘汰。<br>是一种最直观的算法，但性能最差，有<strong>Belady异常</strong>现象。<br><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/2519d0a1-57e7-4676-bb99-956d8043c9c7_repeat_1700459531928__256827.png" alt="image.png"></p><h5 id="Belady现象"><a href="#Belady现象" class="headerlink" title="Belady现象"></a>Belady现象</h5><p>采用FIFO算法时，如果对一个进程未分配它所要求的全部页面，有时就会出现<strong>分配的页面数增多，缺页率反而提高的异常现象</strong>。<br>对页面访问序列A B C D A B E A B C D E ，分配3块物理块时，缺页次数为9次；分配4块物理块时，缺页次数反而为10次。<br>原因在于++刚换出去的页马上又被访问到++。 </p><h4 id="最近最久未使用（Least-Recently-Used，LRU）"><a href="#最近最久未使用（Least-Recently-Used，LRU）" class="headerlink" title="最近最久未使用（Least Recently Used，LRU）"></a>最近最久未使用（Least Recently Used，LRU）</h4><p>该算法是选择<strong>最近最久未使用</strong>的页面予以淘汰，这是局部性原理的合理近似，性能<strong>接近最佳</strong>算法。<br>但由于需要记录页面使用时间的先后关系，硬件开销太大。系统在每个页面设置一个访问字段，用以记录这个页面自上次被访问以来所经历的时间T，当要淘汰一个页面时，选择T最大的页面。但在实现时需要硬件的支持（寄存器或栈）。<br><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/caf33a80-2ed6-4df7-8916-7e315fe84bc0_repeat_1700459362384__409531.png" alt="image.png"></p><h4 id="Clock置换"><a href="#Clock置换" class="headerlink" title="Clock置换"></a><font color='blue'>Clock置换</font></h4><p>Clock置换算法是一种LRU的近似算法。该算法为每个页面设置一位<strong>访问位</strong>，将内存中的所有页面都通过链接指针链成一个<strong>循环队列</strong>，并设置一个<strong>循环替换指针</strong>，指向当前被置换页所在块。<br><strong>当页第一次读入内存时，其访问位为1；当某页被访问时，其访问位置1</strong>。<br>在选择一页淘汰时，沿循环替换指针检查页面，如其<strong>访问位是“0”，就选择该页换出；若为“1”，则重新置为“0”，暂不换出该页，在循环队列中检查下一个页面，直到访问位为“0”的页面为止</strong>。<br>由于该算法只有一位访问位，只能用它表示该页是否已经使用过，而置换时是将未使用过的页面换出去，所以把该算法称为最近未用算法NRC（Not Recently Used），又称第二次机会算法。<br><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/ed68301c-5f14-443b-893b-65f520b0adc6_repeat_1700459364712__065924.png" alt="image.png"></p><h3 id="例-3"><a href="#例-3" class="headerlink" title="例"></a>例</h3><h4 id="例1"><a href="#例1" class="headerlink" title="例1"></a>例1</h4><p><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/01d20b96-e391-40e6-af4b-3de0b1477ce3_repeat_1700459368605__015389.png" alt="image.png"><br><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/22ad2d00-64e2-4318-a222-09104a57b6c0_repeat_1700459370445__892849.png" alt="image.png"><br><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/697e0f9f-80b7-449c-98f2-c6689ae1f977_repeat_1700459390247__010186.png" alt="image.png"><br><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/cd5b4d5a-fbaa-40da-a156-898c3579bcc4_repeat_1700459538857__293361.png" alt="image.png"><br><img src="http://oss.ripplesu.top/blog/Typora/7730d39f-a7da-4f6a-8719-b3014da70abb.png" alt="image.png"></p><h4 id="例2"><a href="#例2" class="headerlink" title="例2"></a>例2</h4><p><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/114fe841-c52b-42c3-a151-e06e7754517f_repeat_1700459396946__240115.png" alt="image.png"><br>驻留集：操作系统为进程分配的物理页框的集合（驻留在内存中）<br><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/4297c7c2-0ad2-4db1-a0e9-6241a7e3d4e1_repeat_1700459558415__931007.png" alt="image.png"></p><h1 id="单处理器调度"><a href="#单处理器调度" class="headerlink" title="单处理器调度"></a>单处理器调度</h1><h3 id="调度分类"><a href="#调度分类" class="headerlink" title="调度分类"></a>调度分类</h3><ul><li>长程调度<br><strong>决定哪一个程序可以进入到系统中被处理</strong>；<br>一个进程终止时可以执行该调度，选择某个程序加入到就绪队列或就绪&#x2F;挂起队列中，供短程调度或中程调度处理。</li><li>中程调度<br><strong>对换功能（内存管理）</strong>。<br>目的是为了提高主存利用率和系统吞吐量。<br>为了充分发挥内存的效能，需将那些暂时不能运行的进程从内存调到外存盘交换区去等待，而将那些在盘交换区的等待事件已经发生急需调度运行的进程从盘交换区调入内存。<br>有时内存中进程数目过多也需将处于就绪态的进程从内存调到盘交换区，当然在盘交换区等待时间过长的就绪态的进程也要调入内存。 </li><li>短程调度<br>通常称为分派程序，决定将处理器分配给哪个就绪进程。执行得最频繁，是最基本的调度，任何操作系统都有短程调度&#x2F;进程调度。<br>可由以下事件激发：  <ul><li>时钟中断</li><li>I&#x2F;O 中断</li><li>操作系统调用</li><li>信号<br><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/571f18da-1c29-451a-ad2a-f7eb43264cfa_repeat_1700459404670__341102.png" alt="image.png"></li></ul></li></ul><h3 id="调度方式的选择准则"><a href="#调度方式的选择准则" class="headerlink" title="调度方式的选择准则"></a>调度方式的选择准则</h3><h4 id="面向用户-User-oriented-的准则和评价"><a href="#面向用户-User-oriented-的准则和评价" class="headerlink" title="面向用户(User-oriented)的准则和评价"></a>面向用户(User-oriented)的准则和评价</h4><ul><li>周转时间(Turnaround Time)短<br>它是评价批处理系统的重要性能指标。作业周转时间Ti是指从<strong>作业提交给系统开始，到作业完成为止的这段时间间隔</strong>。<br><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/e4570ac3-76eb-454e-9ebc-86c38d76c78c_repeat_1700459407877__243925.png" alt="image.png"></li><li>响应时间(Response Time)快<br>响应时间是评价分时系统的性能指标。响应时间是从<strong>用户通过键盘提交一个请求开始，直至系统首次产生响应为止的时间</strong>。  </li><li>截止时间(Deadline)的保证<br>它是用来评价实时系统的重要指标，截止时间是某任务必须执行的最迟时间，或完成的最迟时间。</li><li>优先权(Enforcing Priorities)准则<br>在选择批处理、分时和实时系统的调度算法时，都可引用优先权准则，以便让那些紧急的作业（或事件），得到及时的处理。在要求较严格的场合，往往还需选择抢占调度方式，才能保证紧急作业得到及时的处理。</li></ul><h4 id="面向系统-System-oriented-的准则"><a href="#面向系统-System-oriented-的准则" class="headerlink" title="面向系统(System-oriented)的准则"></a>面向系统(System-oriented)的准则</h4><ul><li>达到系统设计目标<br>  系统的设计目标是选择算法的主要依据。例如批处理系统所追求的是充分发挥和提高计算机的效率，分时系统则侧重于保护用户的请求及时给予响应，实时系统所关心的是不要丢失实时信息并给予处理。</li><li>系统吞吐量(throughput)大<br>  这是用来评价批处理系统的重要指标。系统吞吐量是<strong>单位时间内完成的作业数</strong>，它与批处理作业的平均长度具有密切关系。</li><li>处理机利用率(Processor Utilization)高<br>  对于大中型多用户系统，由于CPU价格十分昂贵，所以处理机利用率成为衡量大、中型系统性能的十分重要指标，但对单用户微机或某些实时系统，该准则就不那么重要。</li><li>各类资源的平衡利用(Balancing Resources)<br>  在大中型系统中，有效地利用各类资源（包括CPU、外存、I&#x2F;O设备等）也是一个重要指标，对于微型机和某些实时系统，该准则也不重要。</li></ul><h3 id="调度策略"><a href="#调度策略" class="headerlink" title="调度策略"></a>调度策略</h3><ul><li>选择函数决定在就绪进程中选择哪一个进程分配处理机执行。可基于优先级、资源需求或进程的执行特性选择。  <ul><li>w&#x3D;等待的时间  </li><li>e&#x3D;到目前为止，花费的执行时间  </li><li>s&#x3D;进程所需的总服务时间，包括e</li></ul></li><li>决策模式说明选择函数在被执行的瞬间的处理方式  <ul><li>非抢占：进程一旦运行则不断执行直到终止或自己阻塞自己  </li><li>抢占：操作系统可打断正在执行的进程将其转移到就绪态</li></ul></li></ul><h4 id="先来先服务-First-Come-First-Served-FCFS"><a href="#先来先服务-First-Come-First-Served-FCFS" class="headerlink" title="先来先服务 (First-Come-First-Served, FCFS)"></a>先来先服务 (First-Come-First-Served, FCFS)</h4><p>当前正在运行的进程停止执行时，选择在<strong>就绪队列中存在时间最长</strong>的进程运行。</p><ul><li>非抢占模式</li><li>选择函数为max(w)</li><li>特点<ul><li>算法易于实现，表面上很公平</li><li>有利于长进程，对短进程不利，短进程可能需要等待较长时间才能运行</li><li>有利于受CPU限制的进程，不利于受I&#x2F;O限制的进程</li><li>I&#x2F;O限制的进程会经常阻塞在I&#x2F;O事件上，因此需要等待较长的时间</li><li>可与优先级调度算法相结合</li><li>缺点：平均周转时间长</li></ul></li></ul><h4 id="时间片轮转-Round-Robin-RR"><a href="#时间片轮转-Round-Robin-RR" class="headerlink" title="时间片轮转 (Round-Robin, RR)"></a>时间片轮转 (Round-Robin, RR)</h4><p>总是选择<strong>就绪队列中第一个进程</strong>，允许其占有处理机一个时间片的时间。当执行的时间片用完时，调度程序便停止该进程的执行，并将它送到就绪队列的末尾，等待分配下一时间片再执行。然后把处理机分配给就绪队列中新的队首进程，同时也让它执行一个时间片。</p><ul><li>采用基于时间片的<strong>抢占</strong>模式</li><li>周期性地发生时钟中断，使操作系统获得控制权</li><li>每次就绪进程的选择都基于FCFS策略</li><li>时间片的大小决定了每个进程每次所能占用处理器的时间，其值对性能有影响。<ul><li>如果时间片太大，大到每个进程都能在该时间片内执行完毕，则RR算法已退化为FCFS调度算法</li><li>如果时间片过小，在一个时间片内切换开销相对增加，一个进程要花费更多的时间片才能运行结束，一个进程在系统中的周转时间大大增长。</li></ul></li></ul><h4 id="最短进程优先-Shortest-Process-Next-，SPN"><a href="#最短进程优先-Shortest-Process-Next-，SPN" class="headerlink" title="最短进程优先(Shortest Process Next ，SPN)"></a>最短进程优先(Shortest Process Next ，SPN)</h4><p>在就绪队列中选择<strong>所需服务时间最短</strong>的进程。</p><ul><li>非抢占模式</li><li>选择函数为min(s)</li><li>有利于短进程，对长进程不利<ul><li>短进程将越过长进程，跳到就绪队列头被调度</li><li>如果不断地有短进程进入系统，长进程可能会饿死。这一算法有利于短作业，对长作业不利。</li></ul></li><li>需要估计每个进程的服务时间，如果估计不准确，系统可能终止该作业</li><li>有利于系统减少平均周转时间和平均带权周转时间</li></ul><h4 id="最短剩余时间优先-Shortest-Remaining-Time-SRT"><a href="#最短剩余时间优先-Shortest-Remaining-Time-SRT" class="headerlink" title="最短剩余时间优先(Shortest Remaining Time,SRT)"></a>最短剩余时间优先(Shortest Remaining Time,SRT)</h4><p>在就绪队列中选择运行<strong>所需剩余时间最短</strong>的进程。</p><ul><li>抢占模式</li><li>选择函数min(s-e) </li><li>需要估计服务时间</li><li>比SPN有更好的周转时间</li></ul><h4 id="最高响应比优先-Highest-Response-Ratio-Next，HRRN"><a href="#最高响应比优先-Highest-Response-Ratio-Next，HRRN" class="headerlink" title="最高响应比优先 (Highest Response Ratio Next，HRRN)"></a>最高响应比优先 (Highest Response Ratio Next，HRRN)</h4><p>在就绪队列中选择响应比最高的进程来调度。</p><ul><li>非抢占模式</li><li>选择函数max(R)&#x3D;<strong>max(1+w&#x2F;s)</strong></li><li>折中策略，综合考虑服务时间和等待时间</li></ul><h4 id="反馈（Feedback）"><a href="#反馈（Feedback）" class="headerlink" title="反馈（Feedback）"></a>反馈（Feedback）</h4><ul><li>原则：处罚运行时间较长的作业。  <ul><li>基于抢占原则（按时间片）并使用动态优先级机制</li><li>新进程进入RQ0，每当它被抢占，则降到下一个优先级队列中</li><li>优先级最低队列采用轮转法，其他队列采用FCFS机制</li></ul></li></ul><h4 id="例-4"><a href="#例-4" class="headerlink" title="例"></a>例</h4><p><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/a0092992-f73d-4d15-afb4-2d0f19d95a36_repeat_1700459411404__312987.png" alt="image.png"><br><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/b987e4e0-ac01-4136-9338-8ce6eb2ba03e_repeat_1700459565398__430447.png" alt="image.png"><br><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/44c412b2-ed38-4941-a7c7-526a71eee3be_repeat_1700459569009__117789.png" alt="image.png"></p><h1 id="IO管理和磁盘调度"><a href="#IO管理和磁盘调度" class="headerlink" title="IO管理和磁盘调度"></a>IO管理和磁盘调度</h1><h3 id="教学要求-2"><a href="#教学要求-2" class="headerlink" title="教学要求"></a>教学要求</h3><ul><li>了解设备的分类，熟悉设备管理的目标和功能。</li><li>熟悉<font color='blue'>程序I&#x2F;O方式、中断方式、DMA方式和通道方式四种I&#x2F;O的控制方式</font>。</li><li>熟悉<font color='blue'>I／O系统的目标—设备独立性的概念</font>；<font color='blue'>熟悉I／O软件分层结构的概念</font>。</li><li>熟悉<font color='blue'>缓冲的概念，熟悉单缓冲、双缓冲和多缓冲和缓冲池工作原理</font>。</li><li>了解磁盘结构、数据组织和磁盘的访问时间等磁盘性能，掌握<font color='orange'>磁盘调度算法</font>。</li><li>了解磁盘高速缓冲的原理。</li></ul><h3 id="IO设备分类"><a href="#IO设备分类" class="headerlink" title="IO设备分类"></a>IO设备分类</h3><ul><li>按传输速率分类<ul><li>低速设备</li><li>中速设备</li><li>高速设备</li></ul></li><li>按信息交换的单位分类<ul><li>块设备：以数据块为单位组织和传送数据</li><li>字符设备：以单个字符为单位</li></ul></li><li>按资源分配的角度分类<ul><li>独占设备</li><li>共享设备</li><li>虚拟设备</li></ul></li></ul><p>I&#x2F;O设备的差异性，使得系统难以找到一种统一且一致的方法管理I&#x2F;O设备。</p><h3 id="设备管理的目标和功能"><a href="#设备管理的目标和功能" class="headerlink" title="设备管理的目标和功能"></a>设备管理的目标和功能</h3><ul><li>目标<ul><li>提高设备利用率</li><li>为用户提供方便、统一的界面</li></ul></li><li>功能<ul><li>设备分配</li><li>缓冲区管理</li><li>实现物理IO设备的操作</li></ul></li></ul><h3 id="IO功能的组织"><a href="#IO功能的组织" class="headerlink" title="IO功能的组织"></a>IO功能的组织</h3><h4 id="控制方式"><a href="#控制方式" class="headerlink" title="控制方式"></a><font color='blue'>控制方式</font></h4><ul><li>程序控制I&#x2F;O (Programmed I&#x2F;O)<br>处理器给I&#x2F;O模块发送I&#x2F;O命令，进程进入忙等待，直到I&#x2F;O操作完成才可以继续执行</li><li>中断驱动I&#x2F;O (Interrupt-driven I&#x2F;O)<br>处理器发送I&#x2F;O命令，然后继续执行后续指令，当I&#x2F;O模块完成后，给处理器发送中断</li><li>直接存储器访问 (Direct Memory Access， DMA)<br>由DMA模块控制主存和I&#x2F;O模块之间的数据交换</li></ul><h4 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h4><ul><li>采用统一的方式处理所有的I&#x2F;O设备<br>隐藏物理I&#x2F;O设备的操作细节，而是提供了逻辑I&#x2F;O层，使用户进程和操作系统软件可以通过读、写、打开、关闭、锁定、解锁等一些通用的功能来看待所有的I&#x2F;O设备。</li><li>采用分层结构，它把软件组织成为一系列的层，低层参与隔离硬件特征，使其它部分软件不依赖硬件；而高层则参与向用户提供一个友好的、清晰而统一的接口。<br>I&#x2F;O软件一般共分四层：中断处理程序（调度和控制），设备驱动程序(设备I&#x2F;O)，与设备无关的操作系统软件（逻辑I&#x2F;O），以及用户级软件(指用户空间的I／O软件) 。</li></ul><h4 id="IO系统目标——设备独立性"><a href="#IO系统目标——设备独立性" class="headerlink" title="IO系统目标——设备独立性"></a><font color='blue'>IO系统目标——设备独立性</font></h4><ul><li>用户程序的设备独立性<br>用户程序不直接使用物理设备名（或设备的物理地址），而只使用逻辑设备名；而系统在实际执行时，将逻辑设备名转换为某个具体的物理设备名，实施I&#x2F;O操作。  </li><li>I&#x2F;O软件的设备独立性<br>除了直接与设备打交道的低层软件之外，其他部分的软件并不依赖于硬件。I&#x2F;O软件独立于设备，就可以提高设备管理软件的设计效率。</li><li>优点<ul><li>设备分配时的灵活性<br>当进程以逻辑设备名请求某类设备时，如果一台设备已经分配给其它进程或正在检修，此时系统可以将其它几台相同的空闲设备中的任一台分配给该进程。 </li><li>易于实现I&#x2F;O重定向<br>所谓I&#x2F;O重定向，指用于I&#x2F;O操作的设备可以更换，应用程序的输入、输出可以重定向，不必修改应用程序。</li></ul></li></ul><h3 id="IO缓冲"><a href="#IO缓冲" class="headerlink" title="IO缓冲"></a><font color='blue'>IO缓冲</font></h3><p>进程被阻塞，等待I&#x2F;O操作完成。速度不匹配的矛盾一直存在。<br>在I&#x2F;O操作期间，包含目标地址单元的页必须锁定在主存中，不能被换出。<br>为了解决低效的问题，往往采用事先读（输入请求发出前就开始执行输入传送）和延迟写（输出请求发出一段时间之后才开始执行输出传送）。缓冲区即用于存放这些临时数据。</p><h4 id="缓冲类型"><a href="#缓冲类型" class="headerlink" title="缓冲类型"></a>缓冲类型</h4><ul><li>硬件缓冲是指以专用的寄存器作为缓冲器。</li><li>软件缓冲是指在操作系统的管理下，在内存中划出若干个单元作为缓冲区。软件缓冲的好处是易于改变缓冲区的大小和数量，但占用了一部分内存空间。<br>根据缓冲区设置个数的多少，可分为<strong>单缓冲、双缓冲和多缓冲</strong>。根据缓冲区的从属关系，可以分为专用缓冲区和缓冲池。</li></ul><h5 id="单缓冲"><a href="#单缓冲" class="headerlink" title="单缓冲"></a>单缓冲</h5><p>为了提高 CPU和设备的并行操作程度，每当一个用户进程发出一个I&#x2F;O请求时，操作系统便在主存的系统区中为之分配一个缓冲区。<br>例如，CPU从磁盘上读-块数据进行计算要分三步:先从磁盘把一块数据读入到缓冲区中，然后由操作系统将缓冲区的数据传送到用户区，最后由CPU对这一块数据进行计算，这样处理一个数据时间为(T+M+C)。<br>当连续读入一组数据时，读入某数据的第一步(输入)和读入它前一个数据的最后一步(计算)是可以并行执行的，这样就提高了CPU和外设的利用率。由于对缓冲区中数据的输入和提取是串行工作的，连续处理一个数据时间&#x3D;<strong>max(C, T) +M</strong>。为使两者能并行工作，必须引入双缓冲。<br><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/dfded469-c980-4437-8f45-66eadbf1badd_repeat_1700459419751__866413.png" alt="image.png"></p><h5 id="双缓冲"><a href="#双缓冲" class="headerlink" title="双缓冲"></a>双缓冲</h5><p>在设备输入时，先将数据输入到缓冲区A，装满后便转向缓冲区B。此时操作系统可以从缓冲区A中提取数据传送到用户区，最后由CPU对数据进行计算。<br>这样可以实现对缓冲区中读入某数据的第一步（输入）和读入它前一个数据的后二步（传送和计算）二者的并行工作，连续处理一个数据时间&#x3D; **max(T，(M+C))**，特别是缓冲区中数据的输入和传送的速度基本相匹配时，可获得较好的效果。<br>双缓冲进一步加快了I&#x2F;O的速度，提高了设备的利用率。<br><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/169cbd2c-9c6f-405b-a3a4-6c9a80daa7b3_repeat_1700459575127__592982.png" alt="image.png"></p><h5 id="循环缓冲"><a href="#循环缓冲" class="headerlink" title="循环缓冲"></a>循环缓冲</h5><p>由于数据I&#x2F;O多数是间断的，可增加缓冲区的个数来改善CPU与I&#x2F;O设备间速度不匹配的矛盾。<br>将多个缓冲区组织成循环队列的形式，其中一些队列专门用于输入，另一些队列专门用于输出。<br>采用生产者&#x2F;消费者模型来解决。<br><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/eba57e27-bfb3-4cfd-bc4b-dc2afc0bb5e4_repeat_1700459424522__956275.png" alt="image.png"></p><h3 id="磁盘IO"><a href="#磁盘IO" class="headerlink" title="磁盘IO"></a>磁盘IO</h3><h4 id="磁盘结构"><a href="#磁盘结构" class="headerlink" title="磁盘结构"></a>磁盘结构</h4><p><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/f505e8ad-8447-47e0-b512-14749d220dac_repeat_1700459427625__651862.png" alt="image.png"></p><h4 id="数据组织"><a href="#数据组织" class="headerlink" title="数据组织"></a>数据组织</h4><p>磁盘设备中，一般包含一个或多个盘片，每片分两面，每面又可分成若干条<strong>磁道</strong>（即n个同心圆）。++最外边的磁道标为0道，最里面的磁道为 n-1道++。磁道的个数取决于盘的大小和存储的密度。每个磁道又被划分为若干个<strong>扇区</strong>，一般被划分成10～100个扇区。每一个扇区是磁盘存储信息和传送信息的基本单位（512字节），又称为存储块，或简称为块。<br>一个容量较大的硬盘含有若干个盘片，每一个盘片有上下两个盘面。如果硬盘中有4个盘片，则共有8个磁面。磁盘中处于相同磁道（同心圆）位置上，但在不同盘面上的磁道的集合，称为<strong>柱面</strong>。++柱面的序号与磁道的序号相同++。</p><h4 id="磁盘访问时间"><a href="#磁盘访问时间" class="headerlink" title="磁盘访问时间"></a>磁盘访问时间</h4><p>由于磁盘上的一个扇区要用三个参数（柱面号、磁头号和扇区号）来定位，所以对磁盘的访问时间，包括以下三部分的时间：</p><ul><li>寻道时间（ Seek time ）T<del>S</del><br>这是把磁头从当前位置移动到指定磁道上所经历的时间。该时间是启动磁盘的时间s与磁头移动n条磁道所花费的时间之和。即 T<del>S</del>＝m×n+s <ul><li>m是一个常数，它与磁盘驱动器的速度有关。对一般磁盘而言，m&#x3D;0.3；对高速磁盘而言，m≤0.1，磁盘启动时间约为3ms。</li><li>这样，对一般的硬盘，其寻道时间将随寻道距离的增大而增大。</li></ul></li><li>旋转延迟时间（ Rotational delay or rotational latency ）T<del>r</del><br>指定扇区移动到磁头下所经历的时间。</li><li>传输时间T<del>t</del><br>T<del>t</del> 是指把数据从磁盘读出，或向磁盘写入数据所经历的时间，它的大小与每次所读／写的字节数b及旋转速度r(&#x2F;秒)有关：T<del>t</del> &#x3D;b&#x2F;(r*N)(N为一条磁道上字节数)。</li></ul><p>磁盘访问时间： Ta&#x3D; TS+ Tr+ Tt&#x3D; TS + 1&#x2F;2r+ b&#x2F;rN</p><h4 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a><font color='orange'>磁盘调度算法</font></h4><h5 id="先来先服务FCFS"><a href="#先来先服务FCFS" class="headerlink" title="先来先服务FCFS"></a>先来先服务FCFS</h5><p>先来先服务FCFS（First Come First Served）是一种最简单的磁盘调度算法。它根据进程请求访问磁盘的先后次序进行调度。  </p><ul><li>优点是公平、简单，且每个进程的请求都能依次得到处理，不会出现某一进程的请求长期得不到满足的情况。</li><li>缺点是算法未对寻道进行优化，致使平均寻道时间可能较长（平均响应时间长）。<br><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/815549c8-2f58-44df-8262-8119c46e6976_repeat_1700459430637__807237.png" alt="image.png"></li></ul><h5 id="最短寻道时间优先（SSTF）"><a href="#最短寻道时间优先（SSTF）" class="headerlink" title="最短寻道时间优先（SSTF）"></a>最短寻道时间优先（SSTF）</h5><p>该算法总是满足那些<strong>与当前磁头所在的磁道距离最近</strong>的请求,也就是执行寻道时间最短的那个I&#x2F;O请求。  </p><ul><li>这种调度算法有较好的平均寻道时间。但它可能导致某些进程长时间的得不到服务（饥饿现象）。因为只要不断有新进程到达，且其所要访问的磁道与磁头当前所在磁道的距离较近，这种新进程的I&#x2F;O请求必被优先满足。</li><li>对中间磁道访问服务比内、外两侧磁道服务好，造成响应时间变化幅度大,在服务请求多时，内外边缘请求被无限期延迟，不可预期。<br><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/41fdb9bc-6d81-49c8-b252-7c63b86bf068_repeat_1700459434283__269597.png" alt="image.png"></li></ul><h5 id="扫描（SCAN）算法"><a href="#扫描（SCAN）算法" class="headerlink" title="扫描（SCAN）算法"></a>扫描（SCAN）算法</h5><p>为了解决SSTF算法饥饿现象，对SSTF算法略加修改后所形成了SCAN算法。  </p><ul><li>该算法不仅考虑到欲访问的磁道与当前磁道的距离，更优先考虑的是磁头的当前移动方向。即当磁头正在自里向外运动时，SCAN算法要选择的下一个访问对象是其欲访问的磁道在<strong>当前磁道之外，又是距离最近的。直至再无更外的磁道需要访问时，才将磁臂换向，自外向里运动</strong>。从而避免了饥饿现象的出现。由于这种算法中磁头移动的规律象电梯的运行，所以又称为电梯调度算法。</li><li>克服SSTF服务集中中间磁道和响应时间变化较大缺点，两侧磁道的访问的频率低于中间磁道。<br><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/9106b34a-182a-4e1c-9d06-a1ac1bd963a1_repeat_1700459437260__843119.png" alt="image.png"></li></ul><h5 id="循环扫描（CSCAN）"><a href="#循环扫描（CSCAN）" class="headerlink" title="循环扫描（CSCAN）"></a>循环扫描（CSCAN）</h5><p>CSCAN算法规定磁头只能<strong>单向运动</strong>（自里向外或自外向里），<strong>当磁头运动到最外面的被访问磁道时，磁头立即返回到最里面的欲访的磁道</strong>，即将最小磁道号紧接着最大磁道号构成循环，进行扫描。<br><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/6ee4a6d7-99c3-40d9-929c-4d81163d9242_repeat_1700459581502__197731.png" alt="image.png"></p><h5 id="算法比较"><a href="#算法比较" class="headerlink" title="算法比较"></a>算法比较</h5><p><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/c6ff42af-7a63-40c9-ab22-a6c7d24e97d2_repeat_1700459441062__990194.png" alt="image.png"></p><h1 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h1><h3 id="教学要求-3"><a href="#教学要求-3" class="headerlink" title="教学要求"></a>教学要求</h3><ul><li>掌握<font color='orange'>文件和文件系统的定义</font>，了解文件系统的类型、文件系统模型。</li><li>掌握<font color='orange'>文件的逻辑结构</font>，熟悉<font color='blue'>五种记录文件</font>。</li><li>掌握<font color='orange'>文件的物理结构及连续分配、链接分配、索引分配等外存分配方法</font>。</li><li>了解磁盘组织，掌握空闲表、位示图法、空闲块链接法等空闲存储空间的管理方法。</li></ul><h3 id="文件与文件系统"><a href="#文件与文件系统" class="headerlink" title="文件与文件系统"></a><font color='orange'>文件与文件系统</font></h3><h4 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h4><p>文件是存储在某种介质上的（如磁盘、磁带等）并<strong>具有文件名的一组有序信息的集合</strong>。</p><ul><li>域&#x2F;数据项（field）<br>数据项是描述一个对象的某些属性的字符集，它是数据的基本单位，一个数据项有一个值。</li><li>记录（record）<br>记录是一组相关数据项的集合，用于描述一个对象某方面的属性</li></ul><h4 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h4><p>文件系统是操作系统中以文件方式管理计算机软件资源的软件和被管理的文件和数据结构（如目录和索引表等）的集合。<br>从系统角度来看，文件系统是对文件存储器的存储空间进行组织、分配和回收，负责文件的存储、检索、共享和保护。<br>从用户角度来看，文件系统主要是实现“按名存取”，文件系统的用户只要知道所需文件的文件名，就可存取文件中的信息，而无需知道这些文件究竟存放在什么地方。 </p><h3 id="文件组织"><a href="#文件组织" class="headerlink" title="文件组织"></a><font color='orange'>文件组织</font></h3><ul><li>文件的逻辑组织和物理组织  <ul><li>逻辑组织指文件中记录的逻辑结构（用户可见结构），由用户访问记录的方式确定。</li><li>物理组织指文件在外存上的存储组织形式，通常取决于记录组块策略和文件分配策略。</li></ul></li><li>逻辑组织从结构上分成二种形式，一种是无结构的<strong>流式文件</strong>，另一种是有结构的<strong>记录式文件</strong>。流式文件是指对文件内信息不再划分单位，它是依次的一串字符流构成的文件。记录式文件是用户把文件内的信息按逻辑上独立的含义划分信息单位，每个单位称为一个逻辑记录（简称记录）。记录的长度可分为定长和不定长两类。</li></ul><h4 id="文件组织类型"><a href="#文件组织类型" class="headerlink" title="文件组织类型"></a><font color='blue'>文件组织类型</font></h4><h5 id="堆（pile）"><a href="#堆（pile）" class="headerlink" title="堆（pile）"></a>堆（pile）</h5><ul><li>最简单的文件组织形式。</li><li>数据按先来后到的次序组织，每个记录由一串数据组成，是串结构的顺序文件。</li><li>每个记录所包含的数据项是自我标识的，记录可以有不同的数据项。数据项的长度可以明确指定或使用界定符区分。</li><li>在堆文件中访问所需要的记录需穷举搜索。</li><li>目的是积累大量数据并保存，不适合大多数应用。</li></ul><h5 id="顺序文件-sequential-file"><a href="#顺序文件-sequential-file" class="headerlink" title="顺序文件 (sequential file)"></a>顺序文件 (sequential file)</h5><ul><li>最常用的文件组织形式。</li><li>记录采用固定格式，所有记录具有相同长度，并且由相同数目、长度固定的数据项按特定的顺序组成。</li><li>一般还有一个可以唯一标识记录的数据项，称为键（key），记录按键值的约定次序组织。</li><li>顺序文件常用于批处理应用，适用于对所有记录的处理，对于查询或更新某个记录的请求的处理性能不佳（需要遍历）。</li></ul><h5 id="索引顺序文件-indexed-sequential-file"><a href="#索引顺序文件-indexed-sequential-file" class="headerlink" title="索引顺序文件 (indexed sequential file)"></a>索引顺序文件 (indexed sequential file)</h5><ul><li>保留了顺序文件的关键特征：记录按照关键域的顺序组织。</li><li>两个新特征：<ul><li>支持随机访问的文件索引</li><li>溢出文件</li></ul></li><li>索引文件中建立一张索引表，为每个不同键值的记录组的第一个记录设置一个表项（关键域和指向主文件的指针），为该组的其它记录设置了溢出区域，在溢出区域内记录按顺序文件方式组织。<br>查找时先搜索索引，查找关键域值等于目标关键域值或位于目标关键域值之前且最大的索引然后在该索引的指针所指的主文件中的位置开始搜索</li><li>索引顺序文件既适用于交互方式应用，也适用于批处理方式应用。<br><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/07614a88-bcd2-4874-84a3-d751624697e0_repeat_1700459443994__377601.png" alt="image.png"><br><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/8e4f713f-6fa8-4e5e-a83a-297c9d039209_repeat_1700459586529__482152.png" alt="image.png"></li></ul><h5 id="索引文件-indexed-file"><a href="#索引文件-indexed-file" class="headerlink" title="索引文件 (indexed file)"></a>索引文件 (indexed file)</h5><ul><li>可基于多个数据项建立索引<ul><li>完全索引：包含主文件中每条记录的索引项</li><li>部分索引：包含部分记录的索引项</li></ul></li><li>记录可为不定长的，只通过索引访问记录，不再限制记录的放置位置</li><li>为了易于搜索，索引文件本身是顺序文件组织</li><li>当主文件中增加了一条新记录，索引文件必须全部更新</li><li>常用于实时处理环境中</li></ul><h5 id="直接或散列文件-direct-or-hashed-file"><a href="#直接或散列文件-direct-or-hashed-file" class="headerlink" title="直接或散列文件 (direct, or hashed, file)"></a>直接或散列文件 (direct, or hashed, file)</h5><ul><li>检索时给出记录编号（关键域），通过哈希函数（散列函数）计算出该记录在文件中的相对位置。</li><li>可以对记录在直接访问存储设备上的物理地址直接（随机）访问。</li><li>使用固定长度的记录格式，每次只访问一条记录。</li><li>常用于需要高速访问文件且每次访问一条记录的应用中。</li></ul><h3 id="记录组块"><a href="#记录组块" class="headerlink" title="记录组块"></a><font color='orange'>记录组块</font></h3><h4 id="固定组块-Fixed-blocking"><a href="#固定组块-Fixed-blocking" class="headerlink" title="固定组块 (Fixed blocking)"></a>固定组块 (Fixed blocking)</h4><ul><li>记录长度固定；</li><li>若干条完整的记录被保存在一个块中；</li><li>存在内部碎片。<br><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/a5fc242d-b77f-4e99-86fe-7eb68179dcec_repeat_1700459449072__192308.png" alt="image.png"></li></ul><h4 id="可变长度跨越式组块-Variable-length-spanned-blocking"><a href="#可变长度跨越式组块-Variable-length-spanned-blocking" class="headerlink" title="可变长度跨越式组块 (Variable-length spanned blocking)"></a>可变长度跨越式组块 (Variable-length spanned blocking)</h4><ul><li>记录长度可变</li><li>紧缩在块中，解决了内部碎片问题 </li><li>某些记录可能跨两个块，通过指针指向后继块<br><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/e2c417ad-cc00-44ac-9d5f-748199f74cac_repeat_1700459591144__240587.png" alt="image.png"></li></ul><h4 id="可变长度非跨越式组块-Variable-length-unspanned-blocking"><a href="#可变长度非跨越式组块-Variable-length-unspanned-blocking" class="headerlink" title="可变长度非跨越式组块 (Variable-length unspanned blocking)"></a>可变长度非跨越式组块 (Variable-length unspanned blocking)</h4><ul><li>记录长度可变</li><li>记录不跨块，存在内部碎片问题<br><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/56ff45ee-be55-4407-8589-c14e1a0caff6_repeat_1700459452587__791917.png" alt="image.png"></li></ul><h4 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h4><ul><li>固定组块是记录长度固定的顺序文件最常用的格式</li><li>可变长度跨越式组块存储效率高，但难于实现</li><li>可变长度非跨越式组块会导致空间的浪费，并且记录大小受块大小限制</li></ul><h3 id="文件分配"><a href="#文件分配" class="headerlink" title="文件分配"></a><font color='orange'>文件分配</font></h3><ul><li>预分配要求在发出创建文件请求时声明该文件的最大大小<ul><li>文件大小难以估计，通常都会多估一点，从而导致空间浪费问题</li></ul></li><li>动态分配只有在需要时才给文件分配空间</li></ul><h4 id="连续分配（Contiguous-allocation）"><a href="#连续分配（Contiguous-allocation）" class="headerlink" title="连续分配（Contiguous allocation）"></a>连续分配（Contiguous allocation）</h4><ul><li>创建文件时，给文件分配一组连续的块</li><li>预分配策略，分区大小可变</li><li>文件分配表FAT中每个文件只需要一个表项：起始块和文件长度</li><li>存在外部碎片，需定期执行压缩技术<br><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/dfe8ce42-2ccf-4e7e-8fa3-3702f6a1fa4c_repeat_1700459458454__214221.png" alt="image.png"></li></ul><h4 id="链式分配"><a href="#链式分配" class="headerlink" title="链式分配"></a>链式分配</h4><ul><li>基于单个块进行分配，链中每一块都包含指向下一块的指针</li><li>动态分配：按需进行块分配</li><li>FAT表中每个文件一个表项：起始块和文件长度</li><li>优点是盘存储空间利用率高，文件增删改记录方便，不存在外部碎片</li><li>局部性原理不再适用，可周期性地对文件进行合并<br><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/eec36d3b-1676-4be4-9e79-30d3efe8d6a4_repeat_1700459464367__923883.png" alt="image.png"><br><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/0dbaaf48-b076-499b-bd83-a3f1a87e591a_repeat_1700459461916__163047.png" alt="image.png"></li></ul><h4 id="索引分配"><a href="#索引分配" class="headerlink" title="索引分配"></a>索引分配</h4><ul><li>文件分配表FAT中对每个文件都包含一个一级索引</li><li>文件索引保存在单独块中，在FAT的表项里指向这一块的值</li><li>分配可基于固定大小的块，也可基于可变大小的分区</li><li>索引块中包括指向文件所有块的指针或指向分区起始块的指针</li><li>支持顺序访问文件和直接访问文件，是最普遍的一种文件分配形式<br><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/f48ce965-95b1-42be-b187-89417f80031b_repeat_1700459467753__246435_repeat_1700459469416__739465.png" alt="image.png"><br><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/f50ec86f-d7c4-4ae9-bbdb-7ebbaf64bc44_repeat_1700459597523__113748.png" alt="image.png"></li></ul><h3 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h3><h4 id="1"><a href="#1" class="headerlink" title="1"></a>1</h4><p>文件系统空间的最大容量为4GB，以磁盘块为分配单位。磁盘块大小为4KB。文件控制块FCB包含一个1KB的索引表区。<br>假设索引表区仅采用直接索引结构，索引表区存放文件占用的磁盘块号，索引表项中块号最少占多少字节？可支持的单个文件的最大长度是多少字节？  </p><p>答：<br>磁盘个数：4GB&#x2F;4KB&#x3D;220个，因此索引表项中块号需要20位，共占20&#x2F;8&#x3D;3B<br>索引表区大小为1KB，故包含1KB&#x2F;3B&#x3D;342个索引项<br>单个文件的最大长度是342*4KB&#x3D;1368KB</p><h4 id="2"><a href="#2" class="headerlink" title="2"></a>2</h4><p>请分别解释在连续分配方式、隐式链接分配方式、显式链接分配方式和索引分配方式中如何将文件的字节偏移量3500转换为物理块号和块内位移量（设盘块大小为1KB，盘块号需4个字节。）<br>提示：先将字节偏移量转换成逻辑块号和块内位移量。  </p><p>答：<br><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/48208609-3e5b-415d-8177-51c69f110968_repeat_1700459472479__479126_repeat_1700459474305__424436.png" alt="image.png"><br><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/9336f4a4-b3b7-47a2-8fc4-40c37c4066b3_repeat_1700459602416__758791.png" alt="image.png"></p><h4 id="3"><a href="#3" class="headerlink" title="3"></a>3</h4><p>存放在某个磁盘上的文件系统，采用混合索引分配方式，其FCB中共有13个地址项，第0~9个地址项为直接地址，第10个地址项为一次间接地址，第11个地址项为二次间接地址，第12个地址项三次间接地址。如果每个盘块的大小512字节，若盘块号需要用3个字节来描述，而每个盘块最多存放170个盘块地址。  </p><ul><li>该文件系统允许文件的最大长度是多少？</li><li>将文件的字节偏移量5000，15000，150000转换为物理块号和块内偏移量。</li><li>假设某个文件FCB已在内存，但其他信息均在外存，为了访问该文件中某个位置的内容，最少需要几次访问磁盘，最多需要几次访问磁盘？</li></ul><p>答：  </p><ol><li>盘块数：10+170+170×170+170×170×170&#x3D;4942080（块）<br> 4942080×512&#x3D;2471040KB  </li><li>5000&#x2F;512&#x3D;9……392  由于9&lt;10，可直接从FCB的第9个地址项得到物理盘块号，块内偏移量为392。<br>15000&#x2F;512&#x3D;29……152，由于10&lt;&#x3D;29&lt;10+170,而29-10&#x3D;19，故可从FCB的第10个地址项获得一次间址块的盘块号，并从一次间址块的第19项获得对应的物理盘块号，块内偏移量为152。<br>150000&#x2F;512&#x3D;292……496，10+170&lt;&#x3D;292&lt;10+170+170×170<br>292-（10+170）&#x3D;112<br>112&#x2F;170&#x3D;0……112<br>从FCB的第11个地址项，即二次间址项中得到二次间址块的地址，并从二次间址块的第0项中获得一个一次间址块的地址，再从一次间址块的第112项中获得对应的物理盘块号，块内偏移量为496。  </li><li>文件FCB已在内存，要访问该文件中某个位置的内容，最少需要1次访问磁盘（通过直接地址直接读文件盘块），最多需要4次访问磁盘（第一次读三次间址块，第二次读二次间址块，第三次读一次间址块，第四次读文件盘块。）</li></ol><h4 id="4"><a href="#4" class="headerlink" title="4"></a>4</h4><p>文件F由200条记录组成，记录从1开始编号。用户打开文件后，欲将内存中的一条记录插入文件F中，作为其第30条记录。请回答下列问题，并说明理由。</p><ul><li>若文件系统采用连续分配方式，每个磁盘块存放一条记录，文件F存储区域前后均有足够的空闲磁盘空间，则完成上述插入操作最少需要访问多少次磁盘块？F的文件控制块内容会发生哪些改变？</li><li>若文件系统采用链接分配方式，每个磁盘块存放一条记录和一个链接指针，则完成上述插入操作需要访问多少次磁盘块？</li></ul><p>答：<br>1）文件系统采用连续分配方式，插入记录需要移动其他的记录块，整个文件共有200条记录，要插入新记录作为第30条，则需要把前29条记录前移，访盘次数为29*2&#x3D;58次（一次读，一次写回），存回第30条记录，需要1次访盘，共访盘59次。<br>2）文件系统采用链接分配方式，插入记录不需要移动其他记录块，只需要通过指针找到第30条记录插入的位置，故共需访盘次数为29次，存第30条记录，需要1次访盘，再修改第29条记录的下块地址，需要1次访盘。因此，访盘总次数为29+1+1&#x3D;31次。</p>]]></content>
      
      
      <categories>
          
          <category> 学习总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件工程复习</title>
      <link href="/2023/02/07/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%A4%8D%E4%B9%A0/"/>
      <url>/2023/02/07/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="软件工程概述"><a href="#软件工程概述" class="headerlink" title="软件工程概述"></a>软件工程概述</h2><p>软件：程序+数据+文档<br>软件特点：</p><ul><li>软件本身的复杂性</li><li>软件成本高昂</li><li>软件开发未摆脱手工开发的方式</li><li>软件维护与硬件有本质差别，维护难度高</li><li>软件是逻辑实体，无磨损性</li></ul><h3 id="软件危机"><a href="#软件危机" class="headerlink" title="软件危机"></a>软件危机</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>软件危机是指在计算机软件<strong>开发</strong>和<strong>维护</strong>过程中所遇到的一系列严重问题。<br>概括来说主要包括<strong>两方面</strong>：</p><ul><li>如何开发软件，以满足对软件日益增长的需求；</li><li>如何维护数量不断膨胀的已有软件。</li></ul><h4 id="典型表现"><a href="#典型表现" class="headerlink" title="典型表现"></a>典型表现</h4><ul><li>对软件开发成本和进度估计不准</li><li>用户对已完成的软件不满意</li><li>软件质量靠不住</li><li>软件没有适当的文档资料</li><li>软件成本在计算机系统总成本中所占的比例逐年上升</li><li>软件开发生产率提高的速度比不上计算机应用普及的趋势（供不应求）</li></ul><h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><h5 id="主观原因"><a href="#主观原因" class="headerlink" title="主观原因"></a>主观原因</h5><ul><li>忽视需求分析</li><li>轻视软件维护</li><li>没有认识到程序只是软件的一部分（程序、文档、数据）</li><li>没有认识到软件开发只是漫长软件生命周期中的一个比较次要的阶段（工作量占比较小）</li><li>越到后期引入变动付出的代价越高昂</li></ul><h5 id="客观原因"><a href="#客观原因" class="headerlink" title="客观原因"></a>客观原因</h5><ul><li>软件是逻辑实体，缺乏可见性，管理和控制困难</li><li>软件不会磨损，维护意味着修改原来设计，维护困难</li><li>软件规模庞大，程序复杂性随规模增加指数上升</li></ul><h4 id="消除软件危机的途径"><a href="#消除软件危机的途径" class="headerlink" title="消除软件危机的途径"></a>消除软件危机的途径</h4><ul><li>对计算机软件应该有正确的认识</li><li>吸取借鉴人类长期从事各种工程项目积累的原理、概念、技术和方法</li><li>积极开发和使用计算机辅助开发工具</li><li>探索更有效的管理措施对开发过程进行控制和管理</li></ul><h3 id="软件工程"><a href="#软件工程" class="headerlink" title="软件工程"></a>软件工程</h3><p>采用<strong>工程</strong>的概念、原理、技术和方法来开发与维护软件，把经过时间考验证明正确的<strong>管理技术</strong>和当前能够得到的最好的<strong>技术方法</strong>结合起来，<strong>经济</strong>的开发出<strong>高质量</strong>的软件并<strong>维护</strong>它。</p><h4 id="本质特征"><a href="#本质特征" class="headerlink" title="本质特征"></a>本质特征</h4><ul><li>关注大型程序的构造</li><li>中心课题是控制复杂性</li><li>软件经常变化</li><li>开发效率非常重要</li><li>开发人员和谐合作是关键</li><li>软件需要有效支持用户</li><li>软件开发者替代其他领域人员创造产品</li></ul><h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h4><ul><li>用分阶段的生命周期计划严格管理</li><li>坚持进行阶段评审</li><li>实行严格的产品控制</li><li>采用现代化程序设计技术</li><li>结果应能清楚地审查</li><li>开发小组的人员应少而精</li><li>承认不断改进软件工程实践的必要性</li></ul><h4 id="软件工程方法学（了解）"><a href="#软件工程方法学（了解）" class="headerlink" title="软件工程方法学（了解）"></a>软件工程方法学（了解）</h4><p>软件生命周期全过程使用的<strong>一整套技术方法的集合</strong>成为方法学，也称泛型。<br>三要素：<strong>方法</strong>、<strong>工具</strong>和<strong>过程</strong>。</p><h5 id="传统方法学"><a href="#传统方法学" class="headerlink" title="传统方法学"></a>传统方法学</h5><ul><li>结构化技术完成软件开发各项任务</li><li>把软件生命周期全过程依次划分为若干阶段</li><li>每个阶段开始和结束有严格标准</li><li>每个阶段结束后严格审查</li></ul><h5 id="面向对象方法学"><a href="#面向对象方法学" class="headerlink" title="面向对象方法学"></a>面向对象方法学</h5><ul><li>把对象作为融合了数据及在数据上的操作行为的统一的软件构件</li><li>把所有对象划分为类</li><li>按照父类与子类关系，把若干类组成层次结构的系统</li><li>对象间仅通过发送消息互相联系</li></ul><h5 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h5><ul><li>传统方法学强调自顶向下完成软件开发的各阶段任务</li><li>面向对象方法学开发软件的过程是一个主动多次反复迭代的演化过程。面向对象方法在概念和表示方法上的一致性，保证了在各项开发活动间的平滑过渡。</li></ul><h3 id="软件生命周期"><a href="#软件生命周期" class="headerlink" title="软件生命周期"></a>软件生命周期</h3><ul><li>软件定义<ul><li>问题定义：弄清用户要解决的问题</li><li>可行性研究：上阶段确定问题是否可行</li><li>需求分析：为解决这个问题，系统需要具备什么功能</li></ul></li><li>软件开发<ul><li>总体设计：设计软件结构，确定程序由哪些模块组成以及模块间的关系</li><li>详细设计：针对每个模块，设计详细规格说明，确定算法和数据结构</li><li>编码和单元测试：将详细设计内容用语言实现，并测试每个模块</li><li>综合测试：通过各种类型测试使软件达到预定要求</li></ul></li><li>软件维护<ul><li>运行维护：使软件在整个声明周期内保证满足用户需求</li></ul></li></ul><h3 id="软件过程"><a href="#软件过程" class="headerlink" title="软件过程"></a>软件过程</h3><p>为了获得高质量软件所需要完成的一系列任务框架。通常同软件生命周期模型描述。</p><h4 id="瀑布模型"><a href="#瀑布模型" class="headerlink" title="瀑布模型"></a>瀑布模型</h4><p>将软件生命周期的各项活动规定为依照<strong>固定顺序</strong>连接的若干阶段工作。</p><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ul><li>阶段间顺序性和依赖性</li><li>推迟 实现 的观点</li><li>质量保证<ul><li>每个阶段必须完成规定的文档</li><li>每个阶段结束前完成文档审查，及早改正错误</li></ul></li></ul><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ul><li>强迫开发人员使用规范的方法，严格规定了每个阶段必须提交的文档</li><li>要求每个阶段交出的产品都必须经过仔细验证。</li></ul><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ul><li>不支持产品演化，灵活性低，难以维护；</li><li>软件开发初期难以做出全面完整的需求分析；</li><li>需求确定后无法及时验证需求是否正确、完整。</li></ul><h4 id="快速原型模型"><a href="#快速原型模型" class="headerlink" title="快速原型模型"></a>快速原型模型</h4><p>快速建立可运行的程序，完成的功能往往是最终产品的一个子集。</p><h5 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h5><ul><li>开发的软件通常满足用户需求</li><li>软件开发基本是线性过程</li></ul><h5 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h5><ul><li>准确原型设计困难</li><li>原型理解可能不同</li><li>不利于开发人员创新</li></ul><h4 id="增量模型"><a href="#增量模型" class="headerlink" title="增量模型"></a>增量模型</h4><p>先完成一个系统子集的开发，再按同样的开发步骤增加功能（系统子集），直至满足所有需求。</p><h5 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h5><ul><li>短时间内可提交完成部分功能</li><li>逐渐增加产品功能，用户适应产品快</li></ul><h5 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h5><ul><li>增量构建划分以及集成困难</li><li>容易退化成边做边改模型</li></ul><h4 id="螺旋模型"><a href="#螺旋模型" class="headerlink" title="螺旋模型"></a>螺旋模型</h4><p>在每个阶段之前都增加了风险分析过程的快速原型模型。</p><h5 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h5><ul><li>利于把软件质量作为软件开发目标</li><li>减少测试</li><li>维护和开发不分开</li></ul><h5 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h5><ul><li>风险估计困难</li></ul><h4 id="喷泉模型"><a href="#喷泉模型" class="headerlink" title="喷泉模型"></a>喷泉模型</h4><p><strong>面向对象</strong>的软件过程模型，体现<strong>迭代</strong>和<strong>无缝</strong>的特性</p><h4 id="Rational统一过程"><a href="#Rational统一过程" class="headerlink" title="Rational统一过程"></a>Rational统一过程</h4><h5 id="最佳实践——6条最有效的软件开发经验："><a href="#最佳实践——6条最有效的软件开发经验：" class="headerlink" title="最佳实践——6条最有效的软件开发经验："></a>最佳实践——6条最有效的软件开发经验：</h5><ul><li>迭代式开发<ul><li>每次迭代容许需求变化，可加深对问题的理解</li><li>用户可以不断介入反馈意见；开发人员因可交付版本而提高士气</li></ul></li><li>管理需求<ul><li>提取、组织系统功能性需求并文档化</li><li>用例分析</li></ul></li><li>采用基于构建的体系结构<br>功能清晰地模块或子系统。软件重用。</li><li>可视化建模<br>提高管理软件复杂性的能力</li><li>验证软件质量<br>贯穿开发过程、全体成员参与</li><li>控制软件变更<br>控制、跟踪、监控修改</li></ul><h5 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h5><p><img src="http://oss.ripplesu.top/blog/Typora/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/be9ec2cd-afed-4aa9-84b0-1bd2ad7367dc_repeat_1700460086950__125805.png" alt="image.png"></p><h4 id="敏捷过程"><a href="#敏捷过程" class="headerlink" title="敏捷过程"></a>敏捷过程</h4><p>较好的适应商业竞争环境下对小型项目提出的有限资源和有限开发时间的约束。<br>敏捷开发宣言：</p><ul><li>个体和交互胜过过程和工具</li><li>可以工作的软件胜过面面俱到的文档</li><li>客户合作胜过合同谈判</li><li>响应变化胜过遵循计划</li></ul><h4 id="极限编程"><a href="#极限编程" class="headerlink" title="极限编程"></a>极限编程</h4><p>广泛应用于需求模糊且经常改变的场合</p><ol><li>客户作为开发团队成员</li><li>使用用户素材</li><li>短周期交付</li><li>验收测试</li><li>结对编程 —— 一人编码，一人测试</li><li>测试驱动开发 —— 编码前设计好测试方案</li><li>集体所有 —— 每个成员对全部代码质量负责</li><li>持续集成</li><li>可持续开发速度</li><li>开放工作空间</li><li>及时调整计划</li><li>简单设计</li><li>隐喻——描述系统如何运作、如何加入新功能</li></ol><ul><li>开发过程<br><img src="http://oss.ripplesu.top/blog/Typora/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/a1d1bce4-e502-4bad-adb4-eb76c69eef67.png" alt="image.png"></li></ul><p><img src="http://oss.ripplesu.top/blog/Typora/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/962cca81-4be2-4c10-a155-594d5a51adcf.png" alt="image.png"></p><h2 id="可行性研究"><a href="#可行性研究" class="headerlink" title="可行性研究"></a>可行性研究</h2><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>用最小的代价在最小的时间确定问题是否能解决</p><h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><ul><li>对以后的行动方针提出建议</li><li>分析候选解法的利弊以确定目标是否现实、是否值得</li><li>每种可行解都仔细研究：技术、经济、操作。</li></ul><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol><li>复查系统规模和目标</li><li>研究目前正在使用的系统</li><li>导出新系统的高层逻辑模型</li><li>进一步定义问题</li><li>导出和评价供选择的解法</li><li>推荐行动方针</li><li>草拟开发计划</li><li>书写文档提交审查</li></ol><h3 id="系统流程图"><a href="#系统流程图" class="headerlink" title="系统流程图"></a>系统流程图</h3><p>概括描绘物理系统的传统工具</p><h3 id="数据流图（DFD）-——-重点"><a href="#数据流图（DFD）-——-重点" class="headerlink" title="数据流图（DFD） —— 重点"></a>数据流图（DFD） —— 重点</h3><h4 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h4><ul><li>星号（*）—— 与</li><li>加号（+）—— 或</li><li>⊕ —— 从中选一个<br><img src="http://oss.ripplesu.top/blog/Typora/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/2f3df47d-ecab-4336-8e92-0c7ab131e76e.png" alt="image.png"></li></ul><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p><img src="http://oss.ripplesu.top/blog/Typora/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/f5a9c22b-0a58-4141-9ce2-c6861787f546.png" alt="image.png"><br>1个输入对应一个输出</p><ul><li>命名<ul><li>反应整个数据流或处理</li><li>处理为及物动词（只有一个）+宾语</li></ul></li></ul><h4 id="例"><a href="#例" class="headerlink" title="例"></a>例</h4><ol><li><img src="http://oss.ripplesu.top/blog/Typora/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/eea90903-da70-4ca8-b503-21a82c80f6de.png" alt="image.png"></li><li><img src="http://oss.ripplesu.top/blog/Typora/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/13edb30d-e095-4fe8-ab83-404f183f429a.png" alt="image.png"></li></ol><h3 id="数据字典-——-重点"><a href="#数据字典-——-重点" class="headerlink" title="数据字典 —— 重点"></a>数据字典 —— 重点</h3><p>关于数据的信息集合，即对数据流图中包含的所有元素的定义和集合。</p><ul><li>内容：数据流、数据流分量、数据存储、处理</li></ul><h4 id="符号表示"><a href="#符号表示" class="headerlink" title="符号表示"></a>符号表示</h4><p><img src="http://oss.ripplesu.top/blog/Typora/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/d2c609b8-1582-48bf-8c3d-78d8bc91cb57.png" alt="image.png"></p><h4 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h4><p>软件分析和设计的过程中给人提供关于数据的描述信息。</p><ul><li>分析阶段的工具（最重要）</li><li>估计改变一个数据的影响</li><li>数据库开发的第一步</li></ul><h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><p><img src="http://oss.ripplesu.top/blog/Typora/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/f3428064-4d43-4725-b6ab-dbdcc8cbddff.png" alt="image.png"><br><img src="http://oss.ripplesu.top/blog/Typora/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/89284122-d83a-468a-a568-2391f1fdee23.png" alt="image.png"></p><ul><li>数据字典卡片<br><img src="http://oss.ripplesu.top/blog/Typora/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/ea13cc44-38b1-4068-900e-bb01a1388eb2.png" alt="image.png"></li></ul><h3 id="成本分析-了解"><a href="#成本分析-了解" class="headerlink" title="成本分析 了解"></a>成本分析 了解</h3><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><ul><li>代码行技术<br>软件成本&#x3D;每行代码平均成本*代码行数</li><li>任务分解<br>任务成本&#x3D;人力*人平均工资</li></ul><h4 id="影响经济效益因素"><a href="#影响经济效益因素" class="headerlink" title="影响经济效益因素"></a>影响经济效益因素</h4><ul><li>货币时间价值 F&#x3D;P（1+i）</li><li>投资回收期</li><li>纯收入</li><li>投资回收率</li></ul><h2 id="需求分析-重点"><a href="#需求分析-重点" class="headerlink" title="需求分析 重点"></a>需求分析 重点</h2><h3 id="任务-1"><a href="#任务-1" class="headerlink" title="任务"></a>任务</h3><ul><li>确定对系统的综合要求<ul><li>功能需求</li><li>性能需求</li><li>可靠性和可用性需求</li><li>出错处理</li><li>接口需求</li><li>约束</li><li>逆向需求 不应该做什么</li><li>将来可能提出的要求</li></ul></li><li>分析系统的数据要求</li><li>导出系统的逻辑模型</li><li>修正系统开发计划</li></ul><h3 id="与用户沟通获取需求方法"><a href="#与用户沟通获取需求方法" class="headerlink" title="与用户沟通获取需求方法"></a>与用户沟通获取需求方法</h3><ul><li>访谈</li><li>面向数据流自顶向下求精</li><li>简易的应用规格说明技术</li><li>快速建立软件原型</li></ul><h3 id="分析建模与规格说明"><a href="#分析建模与规格说明" class="headerlink" title="分析建模与规格说明"></a>分析建模与规格说明</h3><h4 id="分析建模"><a href="#分析建模" class="headerlink" title="分析建模"></a>分析建模</h4><p>模型：为了理解事物而对事物做出的抽象</p><h5 id="分类-——-重点"><a href="#分类-——-重点" class="headerlink" title="分类 —— 重点"></a>分类 —— 重点</h5><ul><li><strong>数据模型</strong>（<strong>实体联系图</strong>）：描绘数据对象及数据对象之间的关系</li><li><strong>功能模型</strong>（<strong>数据流图</strong>）：描绘数据在系统中流动时被处理的逻辑过程，指明系统应具有的变换数据的功能</li><li><strong>行为模型</strong>（<strong>状态转换图</strong>）：描绘系统的各种行为模式在不同状态间转换的方式</li></ul><h4 id="软件需求规格说明"><a href="#软件需求规格说明" class="headerlink" title="软件需求规格说明"></a>软件需求规格说明</h4><p>需求分析阶段得出的最主要文档。用自然语言描述综合要求（8个）</p><h4 id="实体联系图"><a href="#实体联系图" class="headerlink" title="实体联系图"></a>实体联系图</h4><p><img src="http://oss.ripplesu.top/blog/Typora/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/64f9d941-3ea4-4c1c-ab6d-9c5b2da31283.png" alt="image.png"></p><h4 id="状态转换图"><a href="#状态转换图" class="headerlink" title="状态转换图"></a>状态转换图</h4><p><img src="http://oss.ripplesu.top/blog/Typora/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/248c1ed3-8309-40d5-aa99-48e4dda7a309.png" alt="image.png"></p><h3 id="验证软件需求"><a href="#验证软件需求" class="headerlink" title="验证软件需求"></a>验证软件需求</h3><h4 id="从哪些方面验证需求正确性"><a href="#从哪些方面验证需求正确性" class="headerlink" title="从哪些方面验证需求正确性"></a>从哪些方面验证需求正确性</h4><ul><li>一致性：所有需求必须是一致的，任何一条需求不能和其他需求互相矛盾</li><li>完整性：规格说明书应包括用户需要的每一个功能或性能</li><li>现实性：需求应能用现有的硬件和软件技术实现</li><li>有效性：验证需求是正确有效的，能解决用户面对的问题</li></ul><h2 id="总体设计"><a href="#总体设计" class="headerlink" title="总体设计"></a>总体设计</h2><ul><li>确定系统中每个程序由哪些模块组成以及这些模块间的关系</li><li>划分出物理元素，包括程序、文件、数据库、文档等</li></ul><h3 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h3><h4 id="系统设计阶段"><a href="#系统设计阶段" class="headerlink" title="系统设计阶段"></a>系统设计阶段</h4><ul><li>设想供选择的方案</li><li>选取合理的方案</li><li>推荐最佳方案</li></ul><h4 id="结构设计阶段"><a href="#结构设计阶段" class="headerlink" title="结构设计阶段"></a>结构设计阶段</h4><ul><li>功能分解 —— 数据流图细化</li><li>设计软件结构 —— 层次图或结构图</li><li>设计数据库</li><li>制定测试计划</li><li>书写文档</li><li>审查和复审</li></ul><h3 id="设计原理"><a href="#设计原理" class="headerlink" title="设计原理"></a>设计原理</h3><h4 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h4><p>模块：构成程序的基本构件<br>模块化：把程序划分成独立命名且可独立访问的模块，每个模块完成一个子功能，模块集成构成整体，可以完成指定功能<br><img src="http://oss.ripplesu.top/blog/Typora/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/64c75e2e-82d2-473b-9910-06e5912039f4.png" alt="image.png"></p><h4 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h4><p>抽出事物的本质特性而暂时不考虑他们的细节</p><h4 id="逐步求精"><a href="#逐步求精" class="headerlink" title="逐步求精"></a>逐步求精</h4><p>集中精力解决主要问题，逐步揭露出底层细节</p><h4 id="信息隐藏与局部化"><a href="#信息隐藏与局部化" class="headerlink" title="信息隐藏与局部化"></a>信息隐藏与局部化</h4><ul><li>信息隐藏：模块内包含的信息对于不需要这些信息的模块来说不可访问</li><li>局部化：关系密切的软件元素物理地放得彼此靠近，有助于实现信息隐藏</li></ul><h4 id="模块独立"><a href="#模块独立" class="headerlink" title="模块独立"></a>模块独立</h4><p>模块独立性：模块化、抽象、信息隐藏和局部化的直接结果</p><h5 id="耦合"><a href="#耦合" class="headerlink" title="耦合"></a>耦合</h5><p>软件结构内<strong>不同模块</strong>之间互联程序的度量。取决于模块接口的复杂程度、通过接口的数据等。<br>耦合度越高，独立性越弱</p><ul><li>分类 —— 从弱到强<ul><li>完全独立（不可能）</li><li>数据耦合（通过参数交换信息，交换的信息只是数据。至少必须存在）</li><li>控制耦合（通过参数交换信息，交换的信息包含控制信息）</li><li>特征耦合（被调用模块只需要参数中的一部分）</li><li>共用耦合（多个模块共用数据）</li><li>内容耦合（访问模块内部数据、不通过正常入口转移到另一个模块内部、模块间代码重叠、模块有多个入口）</li></ul></li></ul><h5 id="内聚"><a href="#内聚" class="headerlink" title="内聚"></a>内聚</h5><p>度量模块内部各个元素彼此结合的紧密程度，信息隐藏和局部化概念的自然扩展</p><ul><li>内聚与耦合<ul><li>二者密切相关，高内聚往往低耦合</li><li>内聚更重要</li></ul></li></ul><p>从低到高：</p><ul><li>低内聚<ul><li>偶然内聚：一组语句多次出现，抽出成模块</li><li>逻辑内聚：一个模块完成的任务在逻辑上相同</li><li>时间内聚：模块内功能必须在同一段时间执行</li></ul></li><li>中内聚<ul><li>过程内聚：模块内处理元素相关，且必须以某一次序执行（程序流程图为工具）</li><li>通信内聚：模块内所有元素使用同一个输入产生或产生同一个输出</li></ul></li><li>高内聚<ul><li>顺序内聚：模块内的处理元素同某一功能密切相关，且必须按顺序执行（数据流图）</li><li>功能内聚：所有处理元素属于同一整体，完成一个单一的功能</li></ul></li></ul><h3 id="启发规则"><a href="#启发规则" class="headerlink" title="启发规则"></a>启发规则</h3><ul><li>改进软件结构提高模块独立性</li><li>模块规模应该适中</li><li>深度、宽度、扇入和扇出应该适当<ul><li>深度：软件结构中控制的层数</li><li>宽度：软件结构内同一层次上的模块总数的最大值</li><li>扇出：一个模块直接调用的模块数目（好的设计平均3<del>4,上限5</del>9）</li><li>扇入：有多少模块调用它（高扇入有一定好处，但不应违反模块独立。顶层扇出高，底层扇入高）</li></ul></li><li>模块作用域应该在控制域之内<ul><li>作用域：受该模块内一个判定影响的所有模块的集合</li><li>控制域：模块本身以及所有直接或间接从属于它的模块的集合</li></ul></li><li>力争降低模块接口的复杂程度</li><li>设计单入口单出口的模块</li><li>模块功能应该可以预测（相同输入产生相同输出）</li></ul><h3 id="描绘软件结构的图形工具"><a href="#描绘软件结构的图形工具" class="headerlink" title="描绘软件结构的图形工具"></a>描绘软件结构的图形工具</h3><h4 id="层次图"><a href="#层次图" class="headerlink" title="层次图"></a>层次图</h4><p><img src="http://oss.ripplesu.top/blog/Typora/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/a012a2c0-c017-478e-99f4-e50438254f5c.png" alt="image.png"></p><h4 id="HIPO图"><a href="#HIPO图" class="headerlink" title="HIPO图"></a>HIPO图</h4><p>除顶层外，每个模块加编号的层次图</p><h4 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h4><p><img src="http://oss.ripplesu.top/blog/Typora/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/b69ed8a7-8dc0-4923-be96-466c25bfa738.png" alt="image.png"><br><img src="http://oss.ripplesu.top/blog/Typora/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/fff038ba-0fa3-4481-8a60-aeafaf9c5a73.png" alt="image.png"></p><h3 id="面向数据流设计方法-重点"><a href="#面向数据流设计方法-重点" class="headerlink" title="面向数据流设计方法  重点"></a>面向数据流设计方法  重点</h3><p>定义：把信息流映射成软件结构，信息流的类型决定了映射方法</p><p>目标：给出设计软件结构的一个系统化的途径</p><h4 id="信息流的类型"><a href="#信息流的类型" class="headerlink" title="信息流的类型"></a>信息流的类型</h4><p><img src="http://oss.ripplesu.top/blog/Typora/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/558c8361-227b-4890-aa18-191e6f2fea6c.png" alt="image.png"><br><img src="http://oss.ripplesu.top/blog/Typora/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/692e0c9c-92fd-457c-920d-9d35e072b47b.png" alt="image.png"></p><h4 id="变换分析"><a href="#变换分析" class="headerlink" title="变换分析"></a>变换分析</h4><p>例：<br><img src="http://oss.ripplesu.top/blog/Typora/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/27f4febc-af6e-4e5d-aa75-2aa1a115f79d.png" alt="image.png"><br>设计步骤：</p><ul><li>复查基本系统模型<br>确保输入数据与输出数据符合实际</li><li>复查并精化数据流图<br>确保数据流图给出了目标系统的正确逻辑模型<br><img src="http://oss.ripplesu.top/blog/Typora/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/83b2757a-0c8d-4cb4-a20e-b19a13c665b4.png" alt="image.png"></li><li>确定数据流图具有变换特性还是事务特性<br>根据数据流图占优势的属性确定数据流图的总特征。<br>上图具有变换流的总特征。</li><li>确定输入流和输出流的边界，孤立变换中心</li><li>第一级分解<br><img src="http://oss.ripplesu.top/blog/Typora/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/504524bf-5fb4-47db-a61f-eed2c7beb5a6.png" alt="image.png"><br><img src="http://oss.ripplesu.top/blog/Typora/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/9d5193a2-b725-4867-bd55-01c3a108a6fc.png" alt="image.png"></li><li>第二级分解<br>把数据流图中的每个处理映射为软件结构中一个模块<br><img src="http://oss.ripplesu.top/blog/Typora/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/b0f3731d-e61a-433e-8738-fdb10b7fb31d.png" alt="image.png"></li><li>使用设计度量和启发规则进一步精化<br><img src="http://oss.ripplesu.top/blog/Typora/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/08824c17-5b95-4bfd-9e93-357dfb2b36cf.png" alt="image.png"></li></ul><h4 id="事务分析"><a href="#事务分析" class="headerlink" title="事务分析"></a>事务分析</h4><p>在数据流具有明显的事务特点时，即有一个明显的事务中心时，采用事务分析方法为宜。否则最好采用变换分析。</p><p><img src="http://oss.ripplesu.top/blog/Typora/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/03fcdbc9-6d02-4b92-9d8b-9357b0daa14a.png" alt="image.png"><br>事务流映射成的软件结构包括-个接收分支和一个发送分支。发送分支的结构包含一个调度模块，它控制下层的所有活动模块。映射接收分支结构的方法是从事务中心边界开始，把沿接收流通路的处理映射成模块。数据流图中的每个活动流通路都应该映射成与它的流特征相对应的结构。</p><h2 id="详细设计"><a href="#详细设计" class="headerlink" title="详细设计"></a>详细设计</h2><ul><li>目标<ul><li>详细设计阶段的根本目标是确定应该怎样具体地实现所要求的系统，即经过这个阶段的设计工作，应该得出<strong>对目标系统的精确描述</strong>，从而在编码阶段可以把这个描述直接翻译成用某种程序设计语言书写的程序。</li><li>详细设计的目标不仅仅是逻辑上正确地实现每个模块的功能，更重要的是设计出的处理过程应该尽可能<strong>简明易懂</strong>。</li></ul></li><li>工作任务<br>详细设计阶段的任务是要设计出<strong>程序的“蓝图”</strong>，以后程序员将根据这个“蓝图”写出实际的程序代码。</li><li>关键技术<br>详细设计的结果基本上<strong>决定</strong>了最终的程序<strong>代码的质量</strong>。<strong>结构程序设计</strong>技术是实现详细设计目标的<strong>关键技术</strong>,也是详细设计的<strong>逻辑基础</strong>。</li></ul><h3 id="结构程序设计"><a href="#结构程序设计" class="headerlink" title="结构程序设计"></a>结构程序设计</h3><ul><li>经典的结构程序设计<br>只允许使用顺序、IF-THEN-ELSE型分支和DO-WHILE型循环这三种基本控制结构。</li><li>扩展的结构程序设计<br>除了基本控制结构之外，还允许使用DO-CASE型多分支结构和DO-UNTIL型循环结构。</li><li>修正的结构程序设计<br>除了扩展的结构程序设计之外，再允许使用LEAVE (或BREAK)结构。</li></ul><p>如果一个程序的代码块仅仅通过顺序、选择和循环这三种基本控制结构进行连接，并且每个代码块只有一个入口和一个出口，则称这个程序是结构化的。</p><h3 id="人机界面设计"><a href="#人机界面设计" class="headerlink" title="人机界面设计"></a>人机界面设计</h3><p>接口设计的一个重要组成部分。</p><h4 id="设计问题"><a href="#设计问题" class="headerlink" title="设计问题"></a>设计问题</h4><ul><li>系统响应时间<br>两个重要属性：长度和易变性</li><li>用户帮助设施</li><li>出错信息处理</li><li>命令交互</li></ul><h4 id="设计指南"><a href="#设计指南" class="headerlink" title="设计指南"></a>设计指南</h4><ul><li>一般交互指南</li><li>信息显示指南</li><li>数据输入指南</li></ul><h3 id="过程设计工具"><a href="#过程设计工具" class="headerlink" title="过程设计工具"></a>过程设计工具</h3><h4 id="程序流程图"><a href="#程序流程图" class="headerlink" title="程序流程图"></a>程序流程图</h4><p>也称程序框图，历史最悠久、使用最广泛也最混乱<br><img src="http://oss.ripplesu.top/blog/Typora/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/e29bd03c-c0db-4b39-a29d-fef1baaa16ee.png" alt="image.png"><br>缺点：<br>(1) 程序流程图本质上不是逐步求精的好工具，它诱使程序员过早地考虑程序的<strong>控制流程</strong>，而不去考虑程序的<strong>全局结构</strong>。<br>(2)程序流程图中用箭头代表控制流，因此程序员不受任何约束，可以完全不顾结构程序设计的精神，随意转移控制。<br>(3)程序流程图不易表示数据结构。</p><h4 id="盒图-N-S图"><a href="#盒图-N-S图" class="headerlink" title="盒图 N-S图"></a>盒图 N-S图</h4><p>不允许违背结构程序设计精神。<br><img src="http://oss.ripplesu.top/blog/Typora/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/650ca2ee-5110-4304-bdec-1e5d3309c738.png" alt="image.png"></p><h4 id="PAD图"><a href="#PAD图" class="headerlink" title="PAD图"></a>PAD图</h4><p>设计出来的必然是结构化程序。结构清晰，容易转换为高级语言源程序。<br><img src="http://oss.ripplesu.top/blog/Typora/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/c5bb760d-9377-4ba0-a4f4-b139e9b0c00e.png" alt="image.png"></p><h4 id="判定表"><a href="#判定表" class="headerlink" title="判定表"></a>判定表</h4><ul><li><p>适用性：<br>算法中包含多重嵌套的条件选择时，判定表能够清晰地表示复杂的条件组合与应做的动作之间的对应关系。</p></li><li><p>组成<br>一张判定表由四部分组成:<br>a.左上部列出所有条件;<br>b.左下部是所有可能做的动作;<br>c.右上部是表示各种条件组合的一个矩阵;<br>d.右下部是和每种条件组合相对应的动作。<br>注意:判定表右半部的每一列实质上是一条规则，规定了与特定的条件组合相对应的动作。</p></li><li><p>例<br>假设某航空公司规定，乘客可以免费托运重量不超过30kg的行李。当行李重量超过30kg时，对头等舱的国内乘客超重部分每公斤收费4元，对其他舱的国内乘客超重部分每公斤收费6元，对外国乘客超重部分每公斤收费比国内乘客多一倍，对残疾乘客超重部分每公斤收费比正常乘客少一半。<br><img src="http://oss.ripplesu.top/blog/Typora/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/86f928ca-5fd1-46e7-b584-f7a819e51f00.png" alt="image.png"></p></li></ul><h4 id="判定树"><a href="#判定树" class="headerlink" title="判定树"></a>判定树</h4><p><img src="http://oss.ripplesu.top/blog/Typora/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/79800b5f-85d2-43e1-b841-4f4f01521954.png" alt="image.png"></p><h4 id="过程设计语言（PDL）-重点"><a href="#过程设计语言（PDL）-重点" class="headerlink" title="过程设计语言（PDL） 重点"></a>过程设计语言（PDL） 重点</h4><ul><li>定义<br>过程设计语言(PDL)， 即伪码，它是用正文形式表示数据和处理过程的设计工具。PDL具有严格的关键字外部语法，用于定义控制结构和数据结构。PDL表示实际操作和条件的内部语法通常又是灵活自由的，可以适应各种工程项目的需要。</li><li>特点<br>a. 关键字的固定语法，它提供了结构化控制结构、数据说明和模块化的特点。<br>b. 自然语言的自由语法，它描述处理特点。<br>c. 数据说明的手段。应该既包括简单的数据结构，又包括复杂的数据结构表或层次的。<br>d. 模块定义和调用的技术，应该提供各种接口描述模式。</li><li>优点<br>a. 可作为注释直接插在源程序中。有助于保持文档和程序的一致性， 提高文档的质量。<br>b. 可以使用普通的正文编辑程序或文字处理系统，很方便地完成PDL的书写和编辑工作。<br>c. 已经有自动处理PDL的程序存在，且可以自动由PDL生成程序代码。</li><li>缺点<br>不如图形工具形象直观，描述复杂的条件组合与动作间的对应关系时，较复杂，不如判定表清晰简单。</li></ul><h4 id="程序复杂度定量度量"><a href="#程序复杂度定量度量" class="headerlink" title="程序复杂度定量度量"></a>程序复杂度定量度量</h4><p>McCabe方法</p><h5 id="流图"><a href="#流图" class="headerlink" title="流图"></a>流图</h5><p>流图实质上是“退化了的”程序流程图，它仅仅仅描绘程序的控制流程，完全不表现对数据具体操作以及分支或循环的具体条件，流图通常被用来突出表示程序的控制流。</p><ul><li>流程图映射为流图<br><img src="http://oss.ripplesu.top/blog/Typora/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/3e487469-1e3c-44a5-ad46-aac75ca99708.png" alt="image.png"></li><li>PDL翻译为流图<br><img src="http://oss.ripplesu.top/blog/Typora/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/2c26de89-0daf-4f01-82ea-d2e16e5c4fa2.png" alt="image.png"></li></ul><h5 id="计算方法"><a href="#计算方法" class="headerlink" title="计算方法"></a>计算方法</h5><p>环形复杂度定量度量程序的逻辑复杂度，可以用下述3种方法中的任何一种来计算环形复杂度:<br>a. 流图中线性无关的区域数等于环形复杂度。<br>b. 流图G的环形复杂度V (G) &#x3D;E-N+2，其中，E是流图中边的条数，N是结点数。.<br>c. 流图G的环形复杂度V (G) &#x3D;P+1, 其中，P是流图中判定结点的数目。<br>V (G)&lt;10为宜。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><h4 id="语言选择"><a href="#语言选择" class="headerlink" title="语言选择"></a>语言选择</h4><p>减少编程难度、减少程序测试量、容易维护的实现基础。</p><h4 id="编码风格"><a href="#编码风格" class="headerlink" title="编码风格"></a>编码风格</h4><ul><li>程序内部文档</li><li>数据说明</li><li>语句构造</li><li>输入输出</li><li>效率：处理机时间和存储器容量</li></ul><h4 id="代码重构"><a href="#代码重构" class="headerlink" title="代码重构"></a>代码重构</h4><p>代码重构通常是指在++不改变代码对外表现++的情况下，修改代码的内部功能特征，从而改善软件质量，使程序的设计模式和架构更趋合理，更容易被理解，提高软件的可扩展性和可维护性。</p><p>代码重构可以持续纠正和改进软件设计、使代码更被其他人所理解、帮助发现隐藏的代码缺陷、有助于提高开发效率。</p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><h4 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h4><ul><li>测试是为了发现程序中的错误而执行程序的过程。</li><li>好的测试方案是极可能发现迄今为止尚未发现的错误的测试方案。</li><li>成功的测试是发现了至今为止尚未发现的错误的测试</li></ul><h4 id="测试准则"><a href="#测试准则" class="headerlink" title="测试准则"></a>测试准则</h4><ul><li>所有测试都应该能追溯到用户需求；</li><li>应该远在测试开始之前就制定出测试计划；</li><li>把Pareto原理应用到软件测试中；（ 80&#x2F;20 法则、关键少数法则、八二法则。测试发现的错误中的80%很可能是由程序中20%的模块造成的。）</li><li>应该从“小规模”测试开始，并逐步进行“大规模”测试；</li><li>穷举测试是不可能的；</li><li>为了达到最佳的测试效果，应该由独立的第三方从事测试工作。</li></ul><h4 id="测试步骤"><a href="#测试步骤" class="headerlink" title="测试步骤"></a>测试步骤</h4><ul><li>单元测试（模块测试）<br>把每个模块作为一个单独的实体来测试，通常比较容易发现<strong>编码和详细设计</strong>的错误。</li><li>子系统测试<br>经过单元测试的模块放在一起形成一个子系统来测试。模块相互间的协调和通信是这个测试过程中的主要问题，因此，这个步骤着重测试<strong>模块的接口</strong>。</li><li>系统测试<br>在这个测试步骤中发现的往往是<strong>软件设计</strong>中的错误，也可能发现需求说明中的错误。<br>子系统测试和系统测试通常称为集成测试。</li><li>验收测试<br>验收测试把软件系统作为单一的实体进行测试，测试内容与系统测试基本类似，但是它是在<strong>用户</strong>积极参与下进行的，而且可能主要使用<strong>实际数据</strong>(系统将来要处理的信息)进行测试。<br> 验收测试的目的是验证系统确实能够满足用户的需要，在这个测试步骤中发现的往往是<strong>系统需求说明书</strong>中的错误。验收测试也称为<strong>确认测试</strong>。</li><li>平行运行<br>同时运行新开发出来的系统和将被它取代的旧系统，以便比较新旧两个系统的处理结果。</li></ul><h4 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h4><ul><li>测试依据：详细设计文档</li><li>测试技术：白盒测试</li><li>着重点</li></ul><ol><li>模块接口</li><li>局部数据结构</li><li>重要的执行通路</li><li>出错处理通路</li><li>边界条件</li></ol><ul><li>代码审查</br><br>由审查小组正式对源程序进行人工测试。它是一种非常有效的程序验证技术，对于典型的程序来说，可以查出30%～70%的逻辑设计错误和编码错误。</br><br>优点：一次审查会上可以发现许多错误；用计算机测试的方法发现错误之后，通常需要先改正这个错误才能继续测试，即：采用代码审查的方法可以减少系统验证的总工作量。 </li><li>计算机测试</li></ul><h4 id="集成测试"><a href="#集成测试" class="headerlink" title="集成测试"></a>集成测试</h4><ul><li>目标：发现与接口有关的问题</li><li>实施者：独立测试机构或第三方</li></ul><h5 id="非渐增测试"><a href="#非渐增测试" class="headerlink" title="非渐增测试"></a>非渐增测试</h5><p>先分别测试每个模块，再把所有模块按设计要求放在一起结合成所要的程序，这种方法称为非渐增式测试方法。</p><h5 id="渐增测试"><a href="#渐增测试" class="headerlink" title="渐增测试"></a>渐增测试</h5><p>把下一个要测试的模块同已经测试好的那些模块结合起来进行测试，测试完以后再把下一个应该测试的模块结合进来测试。这种每次增加一个模块的方法称为渐增式测试。</p><ul><li>自顶向下集成：<br>从主控制模块开始，沿着程序的控制层次向下移动，逐渐把各个模块结合起来。</li><li>自底向上集成：<br>从“原子”模块(即在软件结构最低层的模块)开始组装和测试。</li><li>比较</br><br>自顶向下测试方法的主要<strong>优点</strong>是不需要测试驱动程序，能够在测试阶段的早期实现并验证系统的主要功能，而且能在早期发现上层模块的接口错误。<br>自顶向下测试方法的主要<strong>缺点</strong>是需要存根程序，可能遇到与此相联系的测试困难，低层关键模块中的错误发现较晚，而且用这种方法在早期不能充分展开人力。<br>自底向上测试方法的优缺点与上述自顶向下测试方法的优缺点刚好相反。</li></ul><h5 id="持续集成"><a href="#持续集成" class="headerlink" title="持续集成"></a>持续集成</h5><p>持续集成（Continuous Integration，简称CI）要求开发过程中，编程人员不断地将修改或新增的代码提交到一个统一的代码版本控制库中，并通过回归测试来检验这些代码是否正确。<br>持续集成一般分为<strong>代码提交、自动化创建、自动化测试</strong>三个主要环节。<br>与敏捷开发方法密切相关。</p><h5 id="回归测试"><a href="#回归测试" class="headerlink" title="回归测试"></a>回归测试</h5><p>在集成测试过程中，每当一个新模块结合进来时，程序就发生了变化。回归测试是指重新执行已经做过的测试的某个子集，以保证上述这些变化没有带来非预期的副作用。</p><h4 id="确认测试"><a href="#确认测试" class="headerlink" title="确认测试"></a>确认测试</h4><p>确认测试也称为<strong>验收测试</strong>，它的目标是<strong>验证软件的有效性</strong>。<br>通常，验证指的是保证软件正确地实现了某个特定要求的一系列活动；确认指的是为了保证软件确实满足了用户需求而进行的一系列活动。<br>软件有效性的一个简单定义是：如果软件的功能和性能如同用户所合理期待的那样，软件就是有效的。</p><ul><li>软件配置复查<br>保证软件配置的所有成分都齐全，质量符合要求，文档与程序完全一致，具有完成软件维护所必须的细节，而且已经编好目录。</li><li>Alpha测试<br>用户在开发者的场所，在开发者指导下进行</li><li>Beta测试<br>用户在用户场所进行，遇到问题报告给开发者，开发者修改。</li></ul><h4 id="白盒测试"><a href="#白盒测试" class="headerlink" title="白盒测试"></a>白盒测试</h4><p>白盒测试（又称<strong>结构测试</strong>）是把程序看成装在一个透明的白盒子里，测试者++完全知道程序的结构和处理算法++。这种方法按照程序内部的逻辑测试程序，检测程序中的主要执行通路是否都能按预定要求正确工作。<br>测试用例:测试输入数据和预期的输出结果。<br>测试方案:测试目的、测试用例的集合。</p><ul><li>语句覆盖:被测试程序中的每条语句至少执行一次。</li><li>判定覆盖:使得被测程序中每个判定表达式至少获得一次“真”值和“假”值</li><li>条件覆盖:使得判定表达式中每个条件的各种可能的值至少出现一次。</li><li>判定&#x2F;条件覆盖:使得判定表达式中的每个条件的所有可能取值至少出现一次,并使每个判定表达式所有可能的结果也至少出现一次。</li><li>条件组合覆盖:设计足够多的测试用例，使得每个判定表达式中条件的各种可能的值的组合都至少出现一次。</li><li>路径覆盖:覆盖被测程序中所有可能的路径。</li></ul><h4 id="黑盒测试"><a href="#黑盒测试" class="headerlink" title="黑盒测试"></a>黑盒测试</h4><p>黑盒测试（又称<strong>功能测试</strong>）把程序看作一个黑盒子，++完全不考虑程序的内部结构和处理过程++。黑盒测试是在程序接口进行的测试，只检查程序功能是否能按照规格说明书的规定正常使用，程序是否能适当地接收输入数据并产生正确的输出信息，程序运行过程中能否保持外部信息（例如数据库或文件）的完整性。</p><ul><li>等价类划分</br><br>(1)把程序的输入数据集合按输入条件划分为若干个等价类，每一个等价类相对于输入条件表示为一组有效或无效的输入。<br>(2)为每一等价类设计一个测试用例。</li><li>边界值分析法</br><br>输入等价类和输出等价类的边界就是应该着重测试的程序边界情况。选取的测试数据应该++刚好等于、刚好小于、刚好大于++边界值。</li><li>错误推测</br><br>错误推测法在很大程度上靠直觉和经验进行。它的基本想法是列举出程序中可能有的错误和容易发生错误的特殊情况，并且根据它们选择测试方案。</li></ul><h4 id="测试驱动开发"><a href="#测试驱动开发" class="headerlink" title="测试驱动开发"></a>测试驱动开发</h4><p>测试驱动开发（Test Driven Development，简称TDD）是++敏捷开发++中的一项核心实践和技术。<br>测试驱动开发的基本思想就是在开发功能代码之前，<strong>先编写测试</strong>代码，然后<strong>只编写使测试通过的功能代码</strong>，从而以测试来驱动整个开发过程的进行。<br>这有助于编写简洁可用和高质量的代码，有很高的灵活性和健壮性，能快速响应变化，并加速开发过程。<br>这种开发方式与传统开发方式刚好相反。</p><h4 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h4><p>调试（也称为纠错）作为成功测试的后果出现，即调试是在测试发现错误之后排除错误的过程。</p><h5 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h5><ul><li>蛮干法<br>最低效，到处打印</li><li>回溯法</li><li>原因排除法<ul><li>对分查找法：注入变量正确值</li><li>归纳法：把和错误有关的数据组织起来进行分析，然后导出对错误原因的一个或多个假设，并利用已有的数据来证明或排除这些假设</li><li>演绎法：设想出所有可能的出错原因，然后试图用测试来排除每一个假设的原因</li></ul></li></ul><h2 id="维护"><a href="#维护" class="headerlink" title="维护"></a>维护</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>所谓软件维护就是在软件已经交付使用之后，为了改正错误或满足新的需要而修改软件的过程，是软件生命周期的最后一个阶段，基本任务是保证软件在一个相当长的时期内可以正常运行。</p><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul><li>改正性维护：诊断和改正错误</li><li>适应性维护：为了和变化了的环境适当地配合而进行的修改软件的活动</li><li>完善性维护：为了满足用户提出的增加新功能或修改已有功能的要求和一般性的改进要求。占大部分。</li><li>预防性维护：改进未来的可维护性与可靠性</li></ul><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ul><li>结构化维护与非结构化维护差别巨大<br>非结构化维护:惟一成分是程序代码，那么维护活动从艰苦地评价程序代码开始。<br>结构化维护:有完整的软件配置存在，那么维护工作从评价设计文档开始。</li><li>维护的代价高昂<br>1990年占总预算的70%以上<br>生产率大幅下降</li><li>维护的问题很多<br>理解别人写的程序通常非常困难；<br>维护的软件往往没有合格的文档，或者文档资料显著不足；<br>要求对软件进行维护时，不能指望由开发人员给我们仔细说明软件；<br>绝大多数软件在设计时没有考虑将来的修改；<br>软件维护不是一项吸引人的工作。</li></ul><h4 id="软件维护过程"><a href="#软件维护过程" class="headerlink" title="软件维护过程"></a>软件维护过程</h4><ul><li>维护组织</li><li>维护报告</li><li>维护的事件流</li><li>保存维护记录</li><li>评价维护活动</li></ul><h4 id="软件的可维护性"><a href="#软件的可维护性" class="headerlink" title="软件的可维护性"></a>软件的可维护性</h4><p>维护人员理解、改正、改动、或改进软件的难易程度。<br>提高可维护性是支配软件工程方法学所有步骤的<strong>关键目标</strong>。</p><h5 id="决定软件可维护性的因素"><a href="#决定软件可维护性的因素" class="headerlink" title="决定软件可维护性的因素"></a>决定软件可维护性的因素</h5><ul><li>可理解性：读者理解软件的难易程度</li><li>可测试性：论证程序正确性的容易程度</li><li>可修改性：程序容易修改的程度</li><li>可移植性：把程序从一种计算环境转移到另一种计算环境的难易程度</li><li>可重用性：同一个软件不做修改或稍加改动，就可以在不同环境中多次重复使用</li></ul><h4 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h4><p>影响软件可维护性的<strong>决定因素</strong>。<br>分为用户文档和系统文档两类。</p><h4 id="可维护性复审"><a href="#可维护性复审" class="headerlink" title="可维护性复审"></a>可维护性复审</h4><p>完成了每项维护工作之后，都应该对软件维护本身进行仔细认真的复审。<br>在测试结束时进行最正式的可维护性复审，这个复审称为配置复审。</p><h4 id="软件再工程"><a href="#软件再工程" class="headerlink" title="软件再工程"></a>软件再工程</h4><ul><li>库存目录分析：分析可能成为预防性维护的对象</li><li>文档重构</li><li>逆向工程：分析程序以便在比源代码更高的抽象层次上创建出程序的某种表示的过程</li><li>代码重构：代码重构是最常见的再工程活动。可以重构编码方式难以理解、测试、维护的代码。</li><li>数据重构：数据重构发生在相当低的抽象层次上，它是一种全范围的再工程活动——对数据的修改必然会导致体系结构或代码层的改变。</li><li>正向工程：利用现代软件工程概念、原理、技术和方法，重新开发现有的某个应用系统</li></ul><h2 id="面向对象方法学-1"><a href="#面向对象方法学-1" class="headerlink" title="面向对象方法学"></a>面向对象方法学</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>按人类习惯的思维方法，以现实世界中客观存在的对象为中心来思考和认识问题。<br>采用的思想方法与原则:抽象、分类、继承、聚合、封装等。<br>要点:</p><ul><li>对象<br>任何客观的事物或实体都是对象。对象组成客观世界，复杂的对象可以由简单的对象组成。</li><li>类<br>具有相同数据和操作的对象可以归并为一个类( class)，对象是对象类的一个实例。</li><li>继承性<br>类可以派生出子类，子类继承父类的全部特性( 数据和操作)，又可以有自己的新特性。子类与父类形成类的层次结构。</li><li>封装性<br>对象之间只能通过消息传递相互联系。</li></ul><p>面向对象&#x3D;对象+类+继承+通信</p><h4 id="优点-4"><a href="#优点-4" class="headerlink" title="优点"></a>优点</h4><ul><li>与人类的思维习惯一致</li><li>稳定性好</li><li>可重用性好</li><li>较易开发大型软件产品</li><li>可维护性好</li></ul><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>在应用领域中有意义的、与所要解决的问题有关系的任何事物都可以作为对象，包括具体的物理实体的抽象、人为的概念、任何有明确边界和意义的东西。<br>对象既有静态的属性，又有动态的行为。<br>对象的两个基本要素：<br>属性:用来描述对象静态特征的一个数据项;<br>服务:用来描述对象动态特征(行为)的一个操作序列。<br>对象的属性和所有操作封装在一起，构成一个统一体。属性一般只能通过执行对象的操作来改变。</p><h4 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h4><ol><li>以数据为中心</li><li>对象是主动的</li><li>实现了数据封装</li><li>本质上具有并行性</li><li>模块独立性好</li></ol><h3 id="面向对象建模-重点"><a href="#面向对象建模-重点" class="headerlink" title="面向对象建模 重点"></a>面向对象建模 重点</h3><p>模型是一组图示符号和组织这些符号的规则，利用它们来定义和描述问题域中的术语和概念。</p><ul><li>对象模型(object model):定义实体，描述系统数据，定义“对谁做”</li><li>动态模型(dynamic model) :描述系统控制结构,规定”何时做”</li><li>功能模型(functional model) :描述系统功能,指明系统应”做什么”</li></ul><h3 id="对象模型"><a href="#对象模型" class="headerlink" title="对象模型"></a>对象模型</h3><p>UML中，对象模型通常由“<strong>类图</strong>”组成。<br>类和类之间的联系称为”关系”。通常分为<strong>关联、范化、依赖和细化</strong>四种。</p><ul><li><p>关联:两个类之间存在某种语义上的联系<br><img src="http://oss.ripplesu.top/blog/Typora/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/0cb9d0b3-64c7-421c-9d90-6d73f9d21a57.png" alt="image.png"><br><img src="http://oss.ripplesu.top/blog/Typora/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/3d9c0697-1a7a-4c9b-b5ee-08b67af9aa05.png" alt="image.png"><br><img src="http://oss.ripplesu.top/blog/Typora/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/405f77db-d041-47b4-b9ad-edb32a0f20ca.png" alt="image.png"></p></li><li><p>聚集<br>聚集(聚合)是关联的特例。表示类与类之间的关系是<strong>整体与部分</strong>的关系。在陈述需求时使用的“包含”、“组成”、“分为…部分”等字句，往往意味着存在聚集关系。</p><ul><li>共享聚集：紧挨整体类的地方画<strong>空心菱形</strong><br><img src="http://oss.ripplesu.top/blog/Typora/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/090203ba-3669-4bc9-b57d-1acb40347f0f.png" alt="image.png"></li><li>组合聚集：<strong>实心菱形</strong><br>如果部分类完全隶属于整体类，部分与整体共存，整体不存在了部分也会随之消失，则该聚集称为组合聚集(组成)。<br><img src="http://oss.ripplesu.top/blog/Typora/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/eee6b831-23f4-4a7d-abee-732eaebd00f5.png" alt="image.png"></li></ul></li><li><p>泛化<br>UML中的泛化关系就是继承关系。在UML中，用<strong>一端为空心三角形的连线</strong>表示泛化关系，三角形的顶角紧挨着通用元素。</p><ul><li>普通泛化<br><img src="http://oss.ripplesu.top/blog/Typora/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/b874b62f-7196-4caf-bb4d-5fba015a5152.png" alt="image.png"></li><li>受限泛化：给泛化附加约束条件（多重、不相交、完全、不完全）</li></ul></li><li><p>依赖和细化</p><ul><li>依赖：带箭头的虚线，指向独立的类</li><li>细化：带箭头的空心三角形虚线</li></ul></li></ul><h3 id="动态模型"><a href="#动态模型" class="headerlink" title="动态模型"></a>动态模型</h3><p>用UML提供的<strong>状态图</strong>来描绘对象的状态、触发状态转换的事件以及对象的行为。每个类的动态行为用一张状态图来描绘，各个类的状态图通过共享事件合并起来，从而构成系统的动态模型，即动态模型是基于事件共享而互相关联的一组状态图的集合。</p><h3 id="功能模型"><a href="#功能模型" class="headerlink" title="功能模型"></a>功能模型</h3><p>功能模型表示变化的系统的功能性质，它指明了系统应该做什么，因此更直接地反映了用户对目标系统的需求。<br>用数据流图和<strong>用例图</strong>来描述。</p><h4 id="用例模型"><a href="#用例模型" class="headerlink" title="用例模型"></a>用例模型</h4><p>用例模型描述的是外部行为者所理解的系统功能。</p><ul><li>系统<ul><li>系统被看作是一个提供用例的黑盒子，内部如何工作、用例如何实现，这些对于建立用例模型来说都是不重要的。</li><li>系统用<strong>方框</strong>表示，其边线表示系统的边界，用于划定系统的功能范围，定义了系统所具有的功能。描述该系统功能的用例置于方框内，代表外部实体的行为者置于方框外。</li></ul></li><li>用例<ul><li>一个用例是可以被行为者感受到的、系统的一个完整的功能。在UML中把用例定义成系统完成的一系列动作。</li><li>在UML中，<strong>椭圆</strong>代表用例。用例通过关联与行为者连接，关联指出一个用例与哪些行为者交互，这种交互是<strong>双向</strong>的。</li><li>特征</li></ul></li></ul><ol><li>用例代表某些用户可见的功能，实现一个<strong>具体的用户目标</strong>。</li><li>用例总是被行为者启动的，并向行为者提供可识别的值。</li><li>用例必须是完整的。</br><br>注意:用例是一个<strong>类</strong>，它代表一类功能而不是使用该功能的某个具体实例。用例的实例是系统的一种实际使用方法，通常把用例的实例称为脚本。脚本是系统的一次具体执行过程。</li></ol><ul><li>行为者<ul><li>行为者是指与系统交互的人或其他系统，它代表<strong>外部实体</strong>。使用用例并且与系统交互的任何++人或物++都是行为者。行为者代表一种角色，而不是某个具体的人或物。</li><li>在UML中，线条人代表行为者。在用例图中用直线连接行为者和用例，表示两者之间交换信息，称为通信联系。行为者触发用例，并与用例交换信息。单个行为者可与多个用例联系，一个用例也可与多个行为者联系。</li></ul></li><li>用例间关系<br>用例间主要有使用和扩展两种关系，他们是泛化的不同形式。<ul><li>泛化：继承</li><li>扩展：向一个用例中添加一些动作后构成另一个用例，后者继承前者。当一个用例有多个子流程时(可选系统行为)，可以用扩展关系对其进行扩展。</li><li>使用（包含）：一个用例使用另一个用例。包含用例是基本用例自身行为的一部分；包含用例本身不完整（不能完成一个具体的功能）；不能依赖于包含它的用例。</li></ul></li></ul><p><img src="http://oss.ripplesu.top/blog/Typora/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/0257153d-ae6f-4362-967d-53e3602b2f29.png" alt="image.png"></p><h4 id="用例建模"><a href="#用例建模" class="headerlink" title="用例建模"></a>用例建模</h4><ul><li>寻找行为者<br>为获取用例首先要找出系统的行为者,可以通过请系统的用户回答一些问题的办法来发现行为者。下述问题有助于发现行为者。<ul><li>谁将使用系统的主要功能(主行为者)?</li><li>谁需要借助系统的支持来完成日常工作?</li><li>谁来维护和管理系统(副行为者)?</li><li>系统控制哪些硬件设备?</li><li>系统需要与哪些其他系统交互?</li><li>哪些人或系统对本系统产生的结果(值)感兴趣?</li></ul></li><li>寻找用例<br>一旦找到了行为者,就可以通过请每个行为者回答下述问题来获取用例。<ul><li>行为者需要系统提供哪些功能?行为者自身需要做什么?</li><li>行为者是否需要读取.创建、删除、修改或存储系统中的某类信息?</li><li>系统中发生的事件需要通知行为者吗?行为者需要通知系统某些事情吗?从功<br>能观点看,这些事件能做什么?</li><li>行为者的日常工作是否因为系统的新功能而被简化或提高了效率?</li></ul></li></ul><h4 id="三种模型比较"><a href="#三种模型比较" class="headerlink" title="三种模型比较"></a>三种模型比较</h4><ul><li>三种模型<br>(1) 三种模型相互补充、相互配合，使得人们对系统的认识更加全面。<br>(2) <strong>对象模型</strong>是++最基本最重要的++，它为其他两种模型奠定了基础。</li><li>关系<br>(1) 针对每个类建立的动态模型，描述了类实例的生命周期或运行周期。<br>(2) 状态转换驱使行为发生，这些行为在数据流图中被映射成处理，在用例图中被映射成用例，它们同时与类图中的服务相对应。<br>(3) 功能模型中的处理对应于对象模型中的类所提供的服务。<br>(4) 数据流图中的数据存储，以及数据的源点&#x2F;终点，通常是对象模型中的对象。<br>(5) 数据流图中的数据流，往往是对象模型中对象的属性值，也可能是整个对象。<br>(6) 用例图中的行为者，可能是对象模型中的对象。<br>(7) 功能模型中的处理可能产生动态模型中的事件。<br>(8) 对象模型描述了数据流图中的数据流、数据存储以及数据源点&#x2F;终点的结构。</li></ul><h2 id="软件项目管理"><a href="#软件项目管理" class="headerlink" title="软件项目管理"></a>软件项目管理</h2><p>通过计划、组织和控制等一系列活动，合理地配置和使用各种资源，以达到既定目标。</p><h3 id="估算软件规模"><a href="#估算软件规模" class="headerlink" title="估算软件规模"></a>估算软件规模</h3><ul><li>代码行技术<br>优点：容易计算<br>缺点：源代码只是软件配置的一部分；不适用非过程语言</li><li>功能点技术<br>功能点技术依据对软件信息域特性和软件复杂性的评估结果，估算软件规模。用功能点(FP) 为单位度量软件规模。是为了克服代码行技术的缺点，提出来的新技术。</li></ul><h3 id="工作量估算"><a href="#工作量估算" class="headerlink" title="工作量估算"></a>工作量估算</h3><p>工作量估算模型:</p><ul><li>静态单变量模型(基本的COCOMO模型)</li><li>静态多变量模型( COCOMO2模型)</li><li>动态多变量模型(putnam模型)</li></ul><h3 id="进度计划-较重点"><a href="#进度计划-较重点" class="headerlink" title="进度计划 较重点"></a>进度计划 较重点</h3><h4 id="甘特图"><a href="#甘特图" class="headerlink" title="甘特图"></a>甘特图</h4><p><img src="http://oss.ripplesu.top/blog/Typora/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/7a28c0b5-2b5b-433d-a045-64ce5b4a4252.png" alt="image.png"></p><h4 id="工程网络"><a href="#工程网络" class="headerlink" title="工程网络"></a>工程网络</h4><p><img src="http://oss.ripplesu.top/blog/Typora/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/8ab5bd79-33bf-446b-bb6d-369cc1ba86d2.png" alt="image.png"><br><img src="http://oss.ripplesu.top/blog/Typora/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/2a9703c8-aa7d-455d-9137-4ff2f3253673.png" alt="image.png"><br>机动时间：（LET）<del>结束</del>-（EET)<del>开始</del>-持续时间</p><h3 id="人员组织-重点"><a href="#人员组织-重点" class="headerlink" title="人员组织 重点"></a>人员组织 重点</h3><p>必要性：</p><ol><li>项目成功的关键合理的组织人员，使他们有效地分工协作共同完成开发工作。</li><li>项目组组织得越好，其生产率越高，而且产品质量也越好。</li><li>项目组具有了凝聚力，成功的可能性就大大增加了。</li></ol><h4 id="民主制程序员组"><a href="#民主制程序员组" class="headerlink" title="民主制程序员组"></a>民主制程序员组</h4><p>民主制程序员组中小组成员完全平等，享有充分民主，通过协商做出技术决策。即小组成员之间的通信是平行的，如果小组内有n个成员，则可能的通信信道共有n (n-1) 12条。</p><ul><li>要求<ul><li>小组成员不能太多（2~8名）</li><li>有一名名义组长，但他和组员完成同样任务</li></ul></li><li>优点<ul><li>组员们对发现程序错误持积极的态度，有助于更快速地发现错误，提高代码质量。</li><li>组员们享有充分民主，小组凝聚力高、学术空气浓厚，有利于攻克技术难关。</li></ul></li><li>缺点<br>没有明确的权威指导开发过程，组员间将缺乏必要的协调，最终可能导致工程失败。</li><li>适用性<br>所要开发的软件的<strong>技术难度较高</strong>时，采用民主制程序员组是适宜的。</li></ul><h4 id="主程序员组"><a href="#主程序员组" class="headerlink" title="主程序员组"></a>主程序员组</h4><p>主程序员组用经验多、技术好、能力强的程序员作为主程序员，同时，利用人和计算机在事务性工作方面给主程序员提供充分支持，而且所有通信都通过一两个人进行。<br><img src="http://oss.ripplesu.top/blog/Typora/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/635f2349-4dc0-495d-a9bc-55bcc2701b70.png" alt="image.png"></p><h5 id="核心人员及其分工"><a href="#核心人员及其分工" class="headerlink" title="核心人员及其分工"></a>核心人员及其分工</h5><ul><li>主程序员<br>既是成功的管理人员又是经验丰富、技术好、能力强的高级程序员，负责++体系结构设计和关键部分的详细设计++，并且负责指导其他程序员完成详细设计和编码工作。</li><li>后备程序员<br>技术熟练而且富于经验，协助主程序员工作并且在必要时接替主程序员的工作。具体工作是++设计测试方案、分析测试结果++及独立于设计过程的其他工作。</li><li>编程秘书<br>负责完成与项目有关的全部++事务性工作++。<br>注意:现在无须由编程秘书统一做代码的输入、编辑、编译、链接和调试等工作。</li></ul><h5 id="特点-优点"><a href="#特点-优点" class="headerlink" title="特点(优点)"></a>特点(优点)</h5><ul><li>专业化:该组每名成员仅完成他们擅长的工作。</li><li>层次性:主程序员指挥组员工作，并对项目全面负责</li></ul><h5 id="缺点-4"><a href="#缺点-4" class="headerlink" title="缺点"></a>缺点</h5><p>符合主程序员、后备程序员、编辑秘书标准的人才在现实社会中并不容易雇佣到。</p><h5 id="适用性"><a href="#适用性" class="headerlink" title="适用性"></a>适用性</h5><p>采用主程序员组这种组织方式的程序一般具有以下几方面的特点:</p><ul><li>软件开发人员多数比较<strong>缺乏经验</strong>。</li><li>程序设计过程中有<strong>许多事务性的工作</strong>。</li><li>多渠道通信很费时间，将降低程序员的生产率。</li></ul><h4 id="现代程序员组"><a href="#现代程序员组" class="headerlink" title="现代程序员组"></a>现代程序员组</h4><ul><li>主程序员由两个人共同担任<ul><li>技术负责人<br>负责小组的技术活动，参与全部代码审查工作，并且对代码的各方面质量负责。</li><li>行政负责人<br>负责非技术性事务的管理决策。不参与代码审查，其职责是对程序员的业绩进行评价。<br><img src="http://oss.ripplesu.top/blog/Typora/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/3fa319c7-382d-4210-89a1-2d3f03d0621e.png" alt="image.png"></li></ul></li><li>制定针对公共职责范围内的事务的处理方案</li><li>实行分组策略</li><li>分散决定<br>在合适的地方采用分散做决定的方法，这样做有利于形成畅通的通信渠道，以便充分发挥每个程序员的积极性和主动性，集思广益攻克技术难关。<br><img src="http://oss.ripplesu.top/blog/Typora/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/29f15c3d-2f70-4275-91fc-abac17876090.png" alt="image.png"></li></ul><h3 id="软件质量"><a href="#软件质量" class="headerlink" title="软件质量"></a>软件质量</h3><p>软件质量就是软件与明确地和隐含的定义的需求相一致的程度。</p><h4 id="保证措施"><a href="#保证措施" class="headerlink" title="保证措施"></a>保证措施</h4><ul><li>基于非执行的测试(复审或评审):主要用来保证在编码前各阶段产生的文档的质量。</li><li>基于执行的测试(软件测试):在程序编写完后进行，保证软件质量的最后一道防线。</li><li>程序正确性证明:使用数学方法严格验证程序是否与对它的说明完全一致。</li></ul><h3 id="软件配置管理"><a href="#软件配置管理" class="headerlink" title="软件配置管理"></a>软件配置管理</h3><p>软件配置管理是在软件生命期内管理变化的一组活动，用来标识、控制、报告变化,确保适当的实现了变化。<br>基线:通过了正式复审的软件配置项，可以作为进一步开发的基础，只有通过正式的变化控制过程才能改变它。<br>软件配置管理5项任务:标识软件配置对象、版本控制、变化控制、配置审计和状态报告。</p><h3 id="能力成熟度模型（CMM）"><a href="#能力成熟度模型（CMM）" class="headerlink" title="能力成熟度模型（CMM）"></a>能力成熟度模型（CMM）</h3><p>能力成熟度模型是用于评价软件机构的软件过程能力成熟度模型，用于帮助软件开发机构建立一个有规模的，成熟的软件过程。<br>五个等级从低到高:<br>初始级（1级）、可重复级、已定义级、已管理级、优化级（5级）。</p><h2 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h2><h3 id="用例图"><a href="#用例图" class="headerlink" title="用例图"></a>用例图</h3><p><img src="http://oss.ripplesu.top/blog/Typora/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/233f9531-923f-47e2-bc1a-a32e57b9d2bb.png" alt="image.png"></p><h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><p><img src="http://oss.ripplesu.top/blog/Typora/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/d9a1b808-1d09-4880-a845-1483026970f2.png" alt="image.png"><br><img src="http://oss.ripplesu.top/blog/Typora/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/970daaa4-22c9-46bb-8b92-25d41e5c8282.png" alt="image.png"><br><img src="http://oss.ripplesu.top/blog/Typora/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/1b5662fc-6e29-4970-a6b2-f603656a72fb.png" alt="image.png"></p><h3 id="顺序图"><a href="#顺序图" class="headerlink" title="顺序图"></a>顺序图</h3><p><img src="http://oss.ripplesu.top/blog/Typora/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/66ab24d5-d353-4b07-becb-07c853d78b3e.png" alt="image.png"></p><h3 id="协作图"><a href="#协作图" class="headerlink" title="协作图"></a>协作图</h3><p><img src="http://oss.ripplesu.top/blog/Typora/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/e8121b7c-e7fe-4d48-82ca-db40129aa441.png" alt="image.png"></p><h3 id="状态图"><a href="#状态图" class="headerlink" title="状态图"></a>状态图</h3><p><img src="http://oss.ripplesu.top/blog/Typora/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/a95cdc26-949d-49fc-ba8c-bcede8733228.png" alt="image.png"></p><h3 id="活动图"><a href="#活动图" class="headerlink" title="活动图"></a>活动图</h3><p><img src="http://oss.ripplesu.top/blog/Typora/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/71cf4dc7-e1be-43bb-9c1d-bab9f1c0b50e.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 学习总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web前端开发大作业-仿Bilibili</title>
      <link href="/2022/06/05/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%A4%A7%E4%BD%9C%E4%B8%9A-%E4%BB%BFBilibili/"/>
      <url>/2022/06/05/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%A4%A7%E4%BD%9C%E4%B8%9A-%E4%BB%BFBilibili/</url>
      
        <content type="html"><![CDATA[<p>网站基于Html5、CSS3和原生JavaScript实现，参照Bilibili的设计，并包含各种常用元素、样式、交互功能，内容丰富，可供前端入门人员参照学习。</p><p><a href="https://github.com/S-Lucien/imitate-Bilibili/">Github</a></p><h3 id="点击体验"><a href="#点击体验" class="headerlink" title="点击体验"></a><a href="https://bilibili.ripplesu.top/">点击体验</a></h3><h2 id="网站项目说明"><a href="#网站项目说明" class="headerlink" title="网站项目说明"></a>网站项目说明</h2><p>网站基于Html5、CSS3和原生JavaScript实现，参照Bilibili的设计，并包含各种常用元素、样式、交互功能，内容丰富，可供前端入门人员参照学习。</p><p>网站整体结构如下：</p><p><img src="http://oss.ripplesu.top/blog/Typora/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%A4%A7%E4%BD%9C%E4%B8%9A-%E4%BB%BFBilibili/bba3c39fe49af6250cd8a1930cadd4f1_repeat_1700451584402__930069.png"></p><h2 id="网站各项目详细说明"><a href="#网站各项目详细说明" class="headerlink" title="网站各项目详细说明"></a>网站各项目详细说明</h2><h3 id="网站内容完整性"><a href="#网站内容完整性" class="headerlink" title="网站内容完整性"></a>网站内容完整性</h3><h4 id="1-1网页完整性"><a href="#1-1网页完整性" class="headerlink" title="1.1网页完整性"></a>1.1网页完整性</h4><p>登录页面：</p><p><img src="http://oss.ripplesu.top/blog/Typora/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%A4%A7%E4%BD%9C%E4%B8%9A-%E4%BB%BFBilibili/9f8bde50ecfb37b36f94a1ca6f722f4c_repeat_1700451620475__421375.png"></p><p>联系页面：</p><p><img src="http://oss.ripplesu.top/blog/Typora/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%A4%A7%E4%BD%9C%E4%B8%9A-%E4%BB%BFBilibili/7d2cf85da3d26f3cb1f9ebecf275e249_repeat_1700451625107__253038.png"></p><p>主页面：</p><p><img src="http://oss.ripplesu.top/blog/Typora/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%A4%A7%E4%BD%9C%E4%B8%9A-%E4%BB%BFBilibili/c4ac424428dfa4c6bc46ded48062978b_repeat_1700451690639__449217.png"></p><p>分类展示页面-番剧：</p><p><img src="http://oss.ripplesu.top/blog/Typora/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%A4%A7%E4%BD%9C%E4%B8%9A-%E4%BB%BFBilibili/4279258fa29aafe9d582b1845f3bfb32_repeat_1700451700036__290303.png"></p><p>分类展示页面-游戏中心：</p><p><img src="http://oss.ripplesu.top/blog/Typora/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%A4%A7%E4%BD%9C%E4%B8%9A-%E4%BB%BFBilibili/3d6359a1d82bd1568f2e6e51fd038ea5_repeat_1700451732804__941288.png"></p><p>视频详情页：</p><p><img src="http://oss.ripplesu.top/blog/Typora/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%A4%A7%E4%BD%9C%E4%B8%9A-%E4%BB%BFBilibili/41f9868da9d41f4ca2ed1bd1c5bd3b92_repeat_1700451702838__893012.png"></p><h4 id="主页完整性"><a href="#主页完整性" class="headerlink" title="主页完整性"></a>主页完整性</h4><p>页眉区：</p><p><img src="http://oss.ripplesu.top/blog/Typora/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%A4%A7%E4%BD%9C%E4%B8%9A-%E4%BB%BFBilibili/7d5ed2ff21ad63d683a7f66564cd00a8_repeat_1700451642815__461312.png"></p><p>Banner广告区：</p><p><img src="http://oss.ripplesu.top/blog/Typora/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%A4%A7%E4%BD%9C%E4%B8%9A-%E4%BB%BFBilibili/689d1d2695ac02a5cedffafaafee3f02_repeat_1700451636485__360631.jpeg"></p><p>正文区：</p><p><img src="http://oss.ripplesu.top/blog/Typora/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%A4%A7%E4%BD%9C%E4%B8%9A-%E4%BB%BFBilibili/3e113b0504100a1bd5c40602b9f635fe_repeat_1700451649374__063897.png"></p><p>副栏区：</p><p><img src="http://oss.ripplesu.top/blog/Typora/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%A4%A7%E4%BD%9C%E4%B8%9A-%E4%BB%BFBilibili/6c6393167b8565e22b9520da868cf9aa_repeat_1700451646113__628977.png"></p><p>页脚区：</p><p><img src="http://oss.ripplesu.top/blog/Typora/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%A4%A7%E4%BD%9C%E4%B8%9A-%E4%BB%BFBilibili/foot_repeat_1700451647615__232188.png"></p><h4 id="网页元素多样性"><a href="#网页元素多样性" class="headerlink" title="网页元素多样性"></a>网页元素多样性</h4><p>列表（ul）：</p><p><img src="http://oss.ripplesu.top/blog/Typora/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%A4%A7%E4%BD%9C%E4%B8%9A-%E4%BB%BFBilibili/81875643b7e7ce7bc8e31646af2d8063_repeat_1700451647737__337786.png"></p><p>图文混排：</p><p><img src="http://oss.ripplesu.top/blog/Typora/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%A4%A7%E4%BD%9C%E4%B8%9A-%E4%BB%BFBilibili/0056f155b3627c5553f83ee80f00ada8_repeat_1700451712716__668055.png"></p><p>视频：</p><p><img src="http://oss.ripplesu.top/blog/Typora/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%A4%A7%E4%BD%9C%E4%B8%9A-%E4%BB%BFBilibili/9ee41b829f5f4633891ad3d4c2b60f08_repeat_1700451653694__511317.png"></p><p>Canvas：</p><p><img src="http://oss.ripplesu.top/blog/Typora/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%A4%A7%E4%BD%9C%E4%B8%9A-%E4%BB%BFBilibili/57c611fef491a2d5ab5b441f03ca5704_repeat_1700451652710__794414.png"></p><h3 id="网站样式设计说明"><a href="#网站样式设计说明" class="headerlink" title="网站样式设计说明"></a>网站样式设计说明</h3><h4 id="2-1整体设计"><a href="#2-1整体设计" class="headerlink" title="2.1整体设计"></a>2.1整体设计</h4><p>Dilidili整体以白色为主色调，纯净、简约兼容性好，有效突出网站内容。各个分页面布局与边距等设计不尽相同，以下一一介绍。</p><p>主页：</p><p>主页整体分为三个部分：header、main和footer。</p><p>Header部分包括导航栏、banner以及channel三个部分。导航栏整体采用flex布局，左边导航链接部分为横向排列的ul列表，紧接着是搜索框，最右边的用户部分采用绝对位置布局。背景为banner。Channel部分也采用flex布局，外边距与内边距为55px左右，使channel部分整体位于中央，排列紧凑。</p><p>Main部分宽1400px，左右内边距56px，包含推荐区、推广区、直播区、番剧区、漫画区、游戏区六大模块。这六个模块均采用grid布局，模块间存在56px的下内边距。具体行列数各分区略有不同。以下以推荐区与直播区为例介绍。</p><p>推荐区分为2行5列共10个小网格，其中左边为切换广告，占2行2列4个网格；右边为6个推荐视频，每个视频占1个小网格。直播区整体采用网格布局，分为左右两部分共5列，其中左侧推荐直播占4列，右边排行榜部分占1列。推荐直播内部又分为2行4列共8个小网格，每个推荐主播占1个网格。小网格间上下边距为6px，左右边距为12px。排行榜部分分为上下两块，上方为标题即“排行榜”，下方采用纵向列表布局。列表详细内容在元素样式中说明。其他模块布局与直播区类似，此处不再赘述。</p><p>Footer部分较为简单，主要由文字构成，包含联系我们等链接以及版权说明等，文字局中布局。左右外边距为15px，上下内边距为30px。</p><p>分页面-番剧：</p><p>除导航栏外，页面整体分为上下两块，采用流式布局。上方为banner区，采用justify-content属性将其居中，宽度为整个页面的75%。下方内容区同样采用flex布局，上边距20px与banner区隔开，宽度与其保持一致。内容区又分为左右两部分，均采用float：left布局。</p><p>分页面-游戏中心：</p><p>页面同样分为上下两块，上方banner区采用默认布局（div block），宽度100%，高度为固定值，无左右边距，详细内容将在后面介绍。下方同样为block布局，宽度为固定值1160px，左右外边距为auto，使其自动居于中央。</p><p>视频详情页：</p><p>页面分为左右两块，用一个流式布局的div包含，并设置justify-content属性为center使左右两部分相中靠拢，从而无需设置左右边距。左边为视频区域，右边为up主信息与推荐视频，整体都采用默认的block布局，从上而下排列。</p><p>联系我们页面：</p><p>该页面较为简单，仅包含导航栏、一张背景图片与信息表单，表单使用绝对位置居于页面中央，表单内每行均为block布局，整体文字靠左排列。</p><p>收藏页面：</p><p>整体分为上下两块，采用flex布局并设置justify-content属性使页面元素居中。上方图片区域采用grid布局，2行2列共4个小网格，每张图片占一个网格。下方分页切换控件采用绝对位置布局，使其位于图片下方、居中排列。</p><h4 id="2-2-元素样式设计"><a href="#2-2-元素样式设计" class="headerlink" title="2.2 元素样式设计"></a>2.2 元素样式设计</h4><p>导航链接样式设计：</p><p>导航栏分为左边分类页面导航链接、中间搜索框和右边用户区三个部分，各个部分均为绝对位置布局，不含背景图片高度60px，浮动于页面最上方。</p><p>左边的分类链接区为横向排列的ul列表，采用flex布局，列表元素间左内边距10px。当鼠标悬停在“番剧”和“直播”两个链接上时将出现下拉框。下拉框宽500px，高300px，采用flex布局，分为左右两块，中间用浅灰色线隔开。左边宽350px，内边距20px，采用grid布局，共2列2行，每张图片及其标题占1个网格；右边为列表，包含若干项。</p><p>中间搜索框宽446px，高36px，背景为白色，紧接着是浅灰色的搜索button。右边用户区由登录、注册和投稿三个链接构成，内部采用flex布局；登录后则变为用户头像、收藏和投稿三个部分。其中投稿页面尚未实装。</p><p>当滚轮位于最上方时，导航栏内文字颜色为白色，背景为透明，与背景图融为一体。滚轮向下移动离开页面最上方时，导航栏内文字颜色变为黑色，背景颜色变为浅灰色，浮于页面最上层。如下图所示：</p><p><img src="http://oss.ripplesu.top/blog/Typora/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%A4%A7%E4%BD%9C%E4%B8%9A-%E4%BB%BFBilibili/e922333501d428e11f83a4a7dc1962dc_repeat_1700451717132__140672.png"></p><p><img src="http://oss.ripplesu.top/blog/Typora/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%A4%A7%E4%BD%9C%E4%B8%9A-%E4%BB%BFBilibili/f4ca83d85a2e94542df2c731c98f9c50_repeat_1700451655048__297786.png"></p><p>图 22.1 导航栏样式</p><p>广告样式设计：</p><p>Dilidili共有三种广告样式，此处只介绍第二种。效果如下图所示：</p><p><img src="http://oss.ripplesu.top/blog/Typora/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%A4%A7%E4%BD%9C%E4%B8%9A-%E4%BB%BFBilibili/c3af6848c2a01dae97ff996a59387df0_repeat_1700451657204__233038.png"></p><p>整个banner区域采用flex布局，并设置justify-content属性为center，使其居中。Banner宽度为75%，内部使用dl列表，并设置position属性为relative。列表内含dt和dd两部分。</p><p>dt部分即为右下角的切换控件，内含4个anchor元素，每个anchor元素由一张小封面构成，宽64px，高48px，右边距5px，边框2px 白色。当鼠标悬停在小封面上方时，其边框颜色变为红色，且自动切换为对应的图片。</p><p>dd部分由图片及其左下角的介绍构成。图片铺满整个banner区域，位于底层。左下角介绍部分文字为白色，字体大小18px，为避免图片颜色干扰，对文字的背景设置了由黑到白的渐变色，并设置了背景虚化。</p><p>图文混排样式设计：</p><p>以如下样式为例介绍：</p><p><img src="http://oss.ripplesu.top/blog/Typora/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%A4%A7%E4%BD%9C%E4%B8%9A-%E4%BB%BFBilibili/4ccf4c040e29b58d6426bda57b634402_repeat_1700451660137__357274.png"></p><p>区域顶部为高1px的灰色分割线，下方内容区与其间距为16px。内容区分为左右两部分。左边为宽高固定的图片，图片包含于anchor中。为anchor设置向左浮动（float：left）属性，使文字可以居于图片右方。右边文字自上而下分为5个小块。除了简介部分为detail外，其他均包含于div中。各个部分的文字在颜色、大小、字宽、行高、内外边距等方面各有差异，详情不再赘述。</p><h3 id="网站交互功能"><a href="#网站交互功能" class="headerlink" title="网站交互功能"></a>网站交互功能</h3><h4 id="3-1-数据验证"><a href="#3-1-数据验证" class="headerlink" title="3.1 数据验证"></a>3.1 数据验证</h4><p>登录页使用JavaScript对输入的密码进行验证，密码为‘123456’时即可登陆成功。</p><p>联系我们页面主要通过input标签的pattern属性对姓名和手机号码进行校验。</p><p>其中姓名校验方式如下，其含义为2~4个中文字符：</p><p>pattern&#x3D;”^[\u4e00-\u9fa5][\u4e00-\u9fa5]{0,2}[\u4e00-\u9fa5]$“</p><p>手机号校验方式如下，根据各个运营商的号码区段进行校验，最长11位：</p><p>pattern&#x3D;”^(13[0-9]|14[01456879]|15[0-35-9]|16[2567]|17[0-8]|18[0-9]|19[0-35-9])\d{8}$“ maxlength&#x3D;“11”</p><h4 id="3-2-用户状态"><a href="#3-2-用户状态" class="headerlink" title="3.2 用户状态"></a>3.2 用户状态</h4><p>登录后，导航栏右边用户区发生变化，显示用户的用户名、头像、收藏页链接。如下图所示：</p><p><img src="http://oss.ripplesu.top/blog/Typora/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%A4%A7%E4%BD%9C%E4%B8%9A-%E4%BB%BFBilibili/15f3651cc1c76375874228a9730a2c25_repeat_1700451662413__867613.png"> –&gt; <img src="http://oss.ripplesu.top/blog/Typora/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%A4%A7%E4%BD%9C%E4%B8%9A-%E4%BB%BFBilibili/ff1476899f4cd976d7d02494737a66c9_repeat_1700451665964__027617.png"></p><p>登陆成功时，通过js将用户名存入sessionStorage中，跳转到各个页面时，从sessionStorage中读出用户名并将其作为文本替换原来的‘登录’；将‘注册’元素隐藏并显示‘收藏’。</p><h4 id="3-3-图片切换"><a href="#3-3-图片切换" class="headerlink" title="3.3 图片切换"></a>3.3 图片切换</h4><p>本网站中共有三种图片切换效果，此处介绍较为简单的两种，分别位于主页和番剧页面。</p><p>广告主体由一个img元素和一个span元素组成，分别用于显示图片及其标题。另外在右下方设置四个控件，用于图片切换。</p><p>首先定义iCount标记当前图片id，定义自动切换函数carousel，通过getElementById获取存放图片的img元素和存放标题的span元素，并将其内图片和标题设置为下一张图片，然后使iCount++。如果iCount&gt;图片数就将其置为1，循环播放图片。通过setInterval函数设置自动切换时间为2s。</p><p>然后定义change函数，其功能是根据用户指定的控件切换图片，并更改控件的样式以突出当前播放图片的位置。为每一个空间添加onclick或onmouseover事件，事件内调用change函数，并将iCount修改为对应值。</p><h4 id="3-4-图形绘制"><a href="#3-4-图形绘制" class="headerlink" title="3.4 图形绘制"></a>3.4 图形绘制</h4><p>利用canvas实现视频截图功能。首先需要为canvas设置width和height属性指定画布的大小。然后为截图按钮添加单击事件：单击后，首先获取视频元素和canvas元素，通过canvas.getContext（‘2d’）函数获取canvas对象，然后用其内置的drawImage函数指定图片来源，并指定绘制图片的位置和宽高，就可以将图片绘制在canvas元素内。</p><h4 id="3-5-浮动"><a href="#3-5-浮动" class="headerlink" title="3.5 浮动"></a>3.5 浮动</h4><p>为导航栏设置浮动效果。首先需将导航栏设置为fixed布局。然后通过window.onscroll方法为滚动条添加事件：通过id获取导航栏元素。当滚动条移动时，通过document.documentElement.scrollTop方法获取滚动条与页面顶端的距离，当滚动条不处于页面顶端时，将导航栏背景颜色设置为浅灰色，并将导航栏内所有字体颜色修改为黑色，避免文字溶于背景。当滚轮回到页面顶端时，再将导航栏背景修改为transparent，其内所有文字颜色修改回白色。</p><h4 id="3-6-拖放"><a href="#3-6-拖放" class="headerlink" title="3.6 拖放"></a>3.6 拖放</h4><p>首先为3.4中的canvas元素添加dragstart监听事件，拖放开始时通过事件的dataTransfer对象的setData方法将canvas中数据以‘text&#x2F;html’形式存入。</p><p>然后为导航栏中的‘收藏’元素添加drop监听事件：通过dataTransfer的getData方法获取存入的数据，并将数据以JSON对象的形式存入localStorage中，以便后续收藏页面加载数据。详情将在后面介绍。</p><p>此外还需将要拖放的元素的dragable属性设置为true，通过preventDefault方法取消默认的ondragover和ondrop方法。</p><h4 id="3-7分页导航"><a href="#3-7分页导航" class="headerlink" title="3.7分页导航"></a>3.7分页导航</h4><p>主要实现收藏页面的分页功能。3.6中提到将截图拖放至‘收藏’处即可将截图存入localStorage，此处将所有图片从localStorage中读出，然后按4张图片一页设置若干分页，并按照页面数添加上一页、下一页以及对应若干个分页按钮。定义page变量标记当前分页号。然后使用getElementByName方法获取所有分页按钮（按钮具有相同的名字，其在数组的下标值即为分页号），然后通过IIFE（Immediately Invoked Function Expression，此处用于解决循环内添加事件不能正常执行的问题）为所有按钮添加单击事件：改变按钮边框以突出当前分页号，并通过Switch方法更换分页。更换方法为：将当前分页的display属性设置为none，将其隐藏，然后显示要切换的分页。</p><p>显示效果如下：</p><p><img src="http://oss.ripplesu.top/blog/Typora/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%A4%A7%E4%BD%9C%E4%B8%9A-%E4%BB%BFBilibili/c781243849dd8e7e821ab2ba257c7322_repeat_1700451719513__680381.png"></p><h3 id="特色"><a href="#特色" class="headerlink" title="特色"></a>特色</h3><h4 id="4-1-设计亮点"><a href="#4-1-设计亮点" class="headerlink" title="4.1 设计亮点"></a>4.1 设计亮点</h4><p>广告切换效果：</p><p>游戏中心页面广告设计如下图所示：</p><p><img src="http://oss.ripplesu.top/blog/Typora/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%A4%A7%E4%BD%9C%E4%B8%9A-%E4%BB%BFBilibili/5a5b31bdcdc1d0357ab8ba1157478763_repeat_1700451670474__526856.jpeg"></p><p>广告由三张图片构成，为每张图片设置不同的z-index值，并分别调整顶层于底层图片的box-shadow与brightness值，然后利用translateX调整三张图片在X轴的偏移量使看起来其层次分明。</p><p>自顶向下图片的z-index值分别为989、979、969，当图片切换时，三张图片逆时针转动，顶层图片宽高、亮度变为原来的75%，z-index值变为979，通过调整translateX值使其向左移动，并设置transition属性为0.3s，即在0.3s时间完成切换，从而表现出动态的切换效果。</p><h4 id="4-2技术亮点"><a href="#4-2技术亮点" class="headerlink" title="4.2技术亮点"></a>4.2技术亮点</h4><p>伸缩盒子：效果如下：</p><p><img src="http://oss.ripplesu.top/blog/Typora/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%A4%A7%E4%BD%9C%E4%B8%9A-%E4%BB%BFBilibili/55b79a510e2f8964f6919183a89f905c_repeat_1700451673163__032968.jpeg"><img src="http://oss.ripplesu.top/blog/Typora/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%A4%A7%E4%BD%9C%E4%B8%9A-%E4%BB%BFBilibili/203bc285b15996a20433a01e122deea3_repeat_1700451675227__737427.png"></p><p>当鼠标悬停在区域上时，内部的简介‘弹出’，并设置其边框的阴影效果，表现出伸缩的效果。具体实现为：初始时将简介部分高度设置为0，整个标签设置上边距16px；当鼠标悬停时，将简介部分高度设置为16px，并将上边距调整为0、设置阴影效果，使得交互效果更加明显。</p><p>简易评论区：</p><p>效果如下：</p><p><img src="http://oss.ripplesu.top/blog/Typora/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%A4%A7%E4%BD%9C%E4%B8%9A-%E4%BB%BFBilibili/e7fdbcbbbf2ec583f2d663ef31133931_repeat_1700451677669__295069.png"></p><p>为‘发布’按钮添加单击事件：判断输入框内是否为空，如果为空则用focus方法使输入框成为焦点；否则调用loadStorage方法，将评论内容及评论时间以JSON格式存入localStorage。该方法在页面加载完毕或点击发布后，从localStorage中读出所有评论，然后封装在div元素中，通过innerHtml方法将所有评论加载到评论区。</p><p>截图收藏：</p><p>前置的截图、拖放、分页功能已经在上面阐述过，此处不再赘述。另外要提的一点是，在canvas拖放到收藏位置时，使用canvas的toDataUrl方法将图片以url形式封装于img标签中，然后与收藏时间一起添加进localStorage的pictures中。这里主要介绍收藏页图片的加载与删除。</p><p>定义count变量标记分页数，然后从localStorage中将所有存入的图片读出，按照4张图片一个分页的方式动态设置分页与分页导航按钮（页面主体为网格布局，2行2列），并为每张图片设置一个删除按钮。然后通过getElementByName方法获取按钮数组，并为所有分页导航按钮与删除按钮添加单击事件。当点击删除后，由于删除按钮在数组中的index与图片的index对应，单击后调用splice方法将图片从图片数组中删除，并更新到localStorage中。然后调用reload方法刷新页面，即可实现删除功能。</p><p>页面效果如下，详情可打开页面体验：</p><p><img src="http://oss.ripplesu.top/blog/Typora/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%A4%A7%E4%BD%9C%E4%B8%9A-%E4%BB%BFBilibili/8ab2e2f1f274dfeffbb9ea0af5efe74d_repeat_1700451680969__216565.png"></p>]]></content>
      
      
      <categories>
          
          <category> 个人项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Html </tag>
            
            <tag> CSS </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
