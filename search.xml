<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>用MyFlash恢复误删的MySQL数据</title>
      <link href="/2024/01/05/%E7%94%A8MyFlash%E6%81%A2%E5%A4%8D%E8%AF%AF%E5%88%A0%E7%9A%84MySQL%E6%95%B0%E6%8D%AE/"/>
      <url>/2024/01/05/%E7%94%A8MyFlash%E6%81%A2%E5%A4%8D%E8%AF%AF%E5%88%A0%E7%9A%84MySQL%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<p>近日在用Sharding-JDBC实现分表后，迁移数据时不小心误删了数据，倒腾许久才把数据恢复回来。在此记录以便不时之需。</p><h3 id="MyFlash简介"><a href="#MyFlash简介" class="headerlink" title="MyFlash简介"></a>MyFlash简介</h3><p>MyFlash是由美团点评公司技术工程部开发维护的一个回滚DML操作的工具。该工具通过解析v4版本的binlog，完成回滚操作。相对已有的回滚工具，其增加了更多的过滤选项，让回滚更加容易。</p><p><a href="https://github.com/Meituan-Dianping/MyFlash">GitHub链接</a></p><blockquote><p>注：该项目已经4年没有更新，官方称仅支持MySQL5.6与5.7，但本人在MySQL8下仍可使用。</p></blockquote><h4 id="下载与安装"><a href="#下载与安装" class="headerlink" title="下载与安装"></a>下载与安装</h4><p>git clone或Github上直接下载zip。</p><p>如果下载的是zip包，他会有一个编译好的程序为<code>解压路径/binary/flashback</code>，也可以再次编译，进入解压后的目录，编译并安装：</p><ol><li><p>首先要安装编译所必须的依赖包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y gcc pkg-config glib2 libgnomeui-devel</span><br></pre></td></tr></table></figure></li><li><p>将压缩包上传到服务器后使用unzip命令解压。</p></li><li><p>进入解压后的目录，编译并安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -w  pkg-config --cflags --libs glib-2.0` source/binlogParseGlib.c  -o binary/flashback</span><br></pre></td></tr></table></figure></li><li><p>装完之后是没有环境变量的，只能使用绝对路径调用工具，使用<code>--help</code>可以查看命令的使用方式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/path/MyFlash-master/binary/flashback --help</span><br></pre></td></tr></table></figure><p>参考如下：</p><table><thead><tr><th>参数</th><th>释义</th></tr></thead><tbody><tr><td>–databaseNames</td><td>需要闪回的数据库名称，如果有多个数据库，用逗号”，”隔开。</td></tr><tr><td>–tableNames</td><td>要闪回的表名称，如果有多个表，用逗号”,”隔开。</td></tr><tr><td>–start-position</td><td>闪回的起始位置，如不指定，从文件开始处回滚。</td></tr><tr><td>–stop-position</td><td>闪回的终止位置，如不指定，回滚到文件结尾。</td></tr><tr><td>–start-datetime</td><td>闪回的开始时间。</td></tr><tr><td>–stop-datetime</td><td>闪回的终止时间。</td></tr><tr><td>–sqlTypes</td><td>指定需要回滚的sql类型，支持INSERT、UPDATE、DELETE，多个类型使用逗号”,”分开。</td></tr><tr><td>–maxSplitSize</td><td>对文件进行固定尺寸的切割，以防止单次应用binlog尺寸较大，对线上造成压力。</td></tr><tr><td>–binlogFileNames</td><td>指定需要回滚的binlog文件，美团文档说目前只支持单个binlog文件，经测试已经支持多个binlog文件同时闪回。</td></tr><tr><td>–outBinlogFileNameBase</td><td>指定输出的binlog文件前缀，如不指定，则默认为binlog_output_base.flashback。</td></tr><tr><td>logLevel</td><td>仅供开发者使用，默认级别为error级别。在生产环境中不要修改这个级别，否则输出过多。</td></tr><tr><td>include-gtids</td><td>指定需要回滚的gtid,支持gtid的单个和范围两种形式。</td></tr><tr><td>exclude-gtids</td><td>指定不需要回滚的gtid，用法同include-gtids。</td></tr></tbody></table></li></ol><h3 id="恢复数据"><a href="#恢复数据" class="headerlink" title="恢复数据"></a>恢复数据</h3><p>以下仅适用于用<code>delete</code>命令删除的数据。</p><h4 id="1-查找当前操作的binlog状态"><a href="#1-查找当前操作的binlog状态" class="headerlink" title="1.查找当前操作的binlog状态"></a>1.查找当前操作的binlog状态</h4><p>在myql命令行或者链接工具中，命令查看binlog当前的位置状态和文件信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show master status;</span><br></pre></td></tr></table></figure><p><img src="http://oss.ripplesu.top/blog/%E7%AE%97%E6%B3%95/image-20240105163750465.png" alt="image-20240105163750465"></p><h4 id="2-查找删除数据的起始位置等关键信息"><a href="#2-查找删除数据的起始位置等关键信息" class="headerlink" title="2.查找删除数据的起始位置等关键信息"></a>2.查找删除数据的起始位置等关键信息</h4><p>可以在命令行或Navicat等连接工具中进行查询，使用命令查询后，找到删除命令的起始位置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show binlog events in &#x27;mysql-bin.000005&#x27;;</span><br></pre></td></tr></table></figure><p>以下在Navicat中查询：</p><p><img src="http://oss.ripplesu.top/blog/%E7%AE%97%E6%B3%95/image-20240105164043128.png" alt="删除起始位置"></p><p><img src="http://oss.ripplesu.top/blog/%E7%AE%97%E6%B3%95/image-20240105164132658.png" alt="删除结束位置"></p><h4 id="3-用myflash生成回滚语句"><a href="#3-用myflash生成回滚语句" class="headerlink" title="3.用myflash生成回滚语句"></a>3.用myflash生成回滚语句</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/path-of-myflash/MyFlash-master/binary/flashback --databaseNames=&quot;databaseName&quot; --tableNames=&quot;tableName&quot; --start-position=53423(上图中开始位置) --stop-position=13051857（）上图中结束位置 --sqlTypes=&quot;DELETE&quot; --binlogFileNames=/var/lib/mysql/mysql-bin.000005（binlog文件路径） --outBinlogFileNameBase=/home/MyFlash-master/rollback.sql（输出回滚语句路径）</span><br></pre></td></tr></table></figure><h4 id="4-导入回滚数据"><a href="#4-导入回滚数据" class="headerlink" title="4.导入回滚数据"></a>4.导入回滚数据</h4><p>可以先查看生成的语句：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog -vv --base64-output=decode-rows /home/MyFlash-master/rollback.sql.flashback</span><br></pre></td></tr></table></figure><p>确认后即可导入数据库：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog --skip-gtids /home/MyFlash-master/rollback.sql.flashback | mysql -uroot -ppassword</span><br></pre></td></tr></table></figure><blockquote><p>官方注：在开启gtid的MySQL server上，应用flashback报错，错误为：ERROR 1782 (HY000) at line 16: @@SESSION.GTID_NEXT cannot be set to ANONYMOUS when @@GLOBAL.GTID_MODE &#x3D; ON. ?</p><p>答：在导入时加入–skip-gtids mysqlbinlog –skip-gtids | mysql -uxxx -pxxx</p></blockquote><p>导入完成就能看到删掉的数据又回来了。  </p><p>最后提醒：物理删数据前千万小心！非必要尽量用逻辑删除。</p>]]></content>
      
      
      <categories>
          
          <category> 技术实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> MyFlash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL用Sharding-JDBC实现读写分离与简单分表</title>
      <link href="/2024/01/04/Sharding-JDBC%E5%AE%9E%E7%8E%B0%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E4%B8%8E%E7%AE%80%E5%8D%95%E5%88%86%E8%A1%A8/"/>
      <url>/2024/01/04/Sharding-JDBC%E5%AE%9E%E7%8E%B0%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E4%B8%8E%E7%AE%80%E5%8D%95%E5%88%86%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>ShardingSphere是一套开源的分布式数据库中间件解决方案组成的生态圈，它主要由Sharding-JDBC、Sharding-Proxy等相互独立的产品组成。他们均提供标准化的数据分片、分布式事务和数据库治理功能，可适用于如Java同构、异构语言、容器、云原生等各种多样化的应用场景。</p><p>Sharding-JDBC<br>定位为轻量级Java框架，在Java的JDBC层提供的额外服务。它使用客户端直连数据库，以jar包形式提供服务，无需额外部署和依赖，可理解为增强版的JDBC驱动，完全兼容JDBC和各种ORM框架。  </p><p>适用于任何基于Java的ORM框架，如：JPA, Hibernate, Mybatis, Spring JDBC Template或直接使用JDBC。基于任何第三方的数据库连接池，如：DBCP, C3P0, BoneCP, Druid, HikariCP等。  </p><p>支持任意实现JDBC规范的数据库。目前支持MySQL，Oracle，SQLServer和PostgreSQL。<br><a href="https://shardingsphere.apache.org/document/5.1.1/cn/user-manual/">官方文档</a></p><h5 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h5><ul><li><p>mysql的主从复制环境</p><ol><li><p>配置主服务器（Master）：</p><ul><li><p>打开主服务器的配置文件（通常是 <code>my.cnf</code> 或 <code>my.ini</code>）。</p></li><li><p>在文件中找到<code>[mysqld]</code>部分，并添加以下配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">server-id = 1</span><br><span class="line">log-bin = mysql-bin</span><br><span class="line">binlog-format = ROW</span><br></pre></td></tr></table></figure><ul><li><code>server-id</code>：给主服务器分配一个唯一的标识符。每个服务器都必须有不同的 ID。</li><li><code>log-bin</code>：启用二进制日志，用于记录主服务器上的所有更改。</li><li><code>binlog-format</code>：设置二进制日志的格式。<code>ROW</code> 格式通常是推荐的选择，因为它可以提供更准确的复制。MySQL8以后默认为ROW，因此无需配置</li></ul></li></ul></li><li><p>重启主服务器：</p><ul><li>保存并关闭主服务器的配置文件。</li><li>重启主服务器，使配置更改生效。</li></ul></li><li><p>配置从服务器（Slave）：</p><ul><li><p>打开从服务器的配置文件。</p></li><li><p>在文件中找到<code>[mysqld]</code>部分，并添加以下配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">server-id = 2</span><br><span class="line">relay-log = mysql-relay-bin</span><br><span class="line">log-slave-updates = 1</span><br><span class="line">read-only = 1</span><br></pre></td></tr></table></figure><ul><li><code>server-id</code>：给从服务器分配一个唯一的标识符。每个服务器都必须有不同的 ID。</li><li><code>relay-log</code>：设置从服务器上的中继日志文件的名称。</li><li><code>log-slave-updates</code>：启用从服务器记录自己的二进制日志，以便其他从服务器可以复制它。</li><li><code>read-only</code>：将从服务器设置为只读模式，以防止在从服务器上进行写操作。</li></ul></li></ul></li><li><p>重启从服务器：</p><ul><li>保存并关闭从服务器的配置文件。</li><li>重启从服务器，使配置更改生效。</li></ul></li><li><p>在主服务器上创建用于复制的用户：</p><ul><li><p>在主服务器上登录 MySQL。</p></li><li><p>创建一个用于复制的用户，并为其授予复制相关的权限。例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;replication_user&#x27;</span>@<span class="string">&#x27;slave_ip&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;password&#x27;</span>;</span><br><span class="line"><span class="keyword">GRANT</span> REPLICATION SLAVE <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;replication_user&#x27;</span>@<span class="string">&#x27;slave_ip&#x27;</span>;</span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure><ul><li><code>&#39;replication_user&#39;@&#39;slave_ip&#39;</code>：替换为实际的从服务器 IP 地址和用户名。</li><li><code>&#39;password&#39;</code>：替换为实际的密码。</li></ul></li></ul></li><li><p>在从服务器上配置复制：</p><ul><li><p>在从服务器上登录 MySQL。</p></li><li><p>运行以下命令配置复制：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CHANGE MASTER <span class="keyword">TO</span></span><br><span class="line">  MASTER_HOST <span class="operator">=</span> <span class="string">&#x27;master_ip&#x27;</span>,</span><br><span class="line">  MASTER_USER <span class="operator">=</span> <span class="string">&#x27;replication_user&#x27;</span>,</span><br><span class="line">  MASTER_PASSWORD <span class="operator">=</span> <span class="string">&#x27;password&#x27;</span>,</span><br><span class="line">  MASTER_LOG_FILE <span class="operator">=</span> <span class="string">&#x27;mysql-bin.XXXXXX&#x27;</span>,</span><br><span class="line">  MASTER_LOG_POS <span class="operator">=</span> XXXXXX;</span><br></pre></td></tr></table></figure><ul><li><code>&#39;master_ip&#39;</code>：替换为实际的主服务器 IP 地址。</li><li><code>&#39;replication_user&#39;</code> 和 <code>&#39;password&#39;</code>：替换为在主服务器上创建的复制用户的凭据。</li><li><code>&#39;mysql-bin.XXXXXX&#39;</code> 和 <code>XXXXXX</code>：替换为主服务器上当前二进制日志文件的名称和位置，可以使用 <code>SHOW MASTER STATUS;</code> 命令在主服务器上获取。</li></ul></li></ul></li><li><p>启动复制：</p><ul><li><p>在从服务器上运行以下命令启动复制：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> SLAVE;</span><br></pre></td></tr></table></figure></li><li><p>可以使用 <code>SHOW SLAVE STATUS</code> 命令检查复制状态，并确保 <code>Slave_IO_Running</code> 和 <code>Slave_SQL_Running</code> 的值都为 <code>Yes</code>。</p></li></ul></li></ol></li><li><p>导入maven坐标</p><blockquote><p>注：Sharding-JDBC4.x版本</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shardingsphere<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sharding-jdbc-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在配置文件（application.yml）中配置读写分离规则</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">shardingsphere:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="comment"># 名称可以自定义</span></span><br><span class="line">    <span class="attr">names:</span> <span class="string">master,</span> <span class="string">slave</span></span><br><span class="line">    <span class="attr">master:</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">com.zaxxer.hikari.HikariDataSource</span></span><br><span class="line">      <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">      <span class="attr">jdbc-url:</span> <span class="string">jdbc:mysql://master:3306/databaseName</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">password:</span> </span><br><span class="line">    <span class="attr">slave:</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">com.zaxxer.hikari.HikariDataSource</span></span><br><span class="line">      <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">      <span class="attr">jdbc-url:</span> <span class="string">jdbc:mysql://slave:3306/databaseName</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">password:</span> </span><br><span class="line">  <span class="attr">masterslave:</span></span><br><span class="line">    <span class="attr">load-balance-algorithm-type:</span> <span class="string">round_robin</span> <span class="comment"># 轮询</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">dataSource</span></span><br><span class="line">    <span class="attr">master-data-source-name:</span> <span class="string">master</span></span><br><span class="line">    <span class="attr">slave-data-source-names:</span> <span class="string">slave</span></span><br><span class="line">  <span class="attr">props:</span></span><br><span class="line">    <span class="attr">sql:</span></span><br><span class="line">      <span class="attr">show:</span> <span class="literal">true</span> <span class="comment">#开启SQL显示，默认false</span></span><br></pre></td></tr></table></figure><blockquote><p>注：为了保证主从库间的事务一致性，避免跨服务的分布式事务，ShardingSphere-JDBC的主从模型中，事务中的数据读写均用主库。</p><p>即： 不添加@Transactional：insert对主库操作，select对从库操作<br>            添加@Transactional：则insert和select均对主库操作</p><p><a href="https://shardingsphere.apache.org/document/5.1.1/cn/features/readwrite-splitting/use-norms/">见：文档</a></p></blockquote></li></ul><h5 id="数据分片"><a href="#数据分片" class="headerlink" title="数据分片"></a>数据分片</h5><p>Maven依赖：</p><blockquote><p>注意：数据库连接池由默认的<code>com.zaxxer.hikari.HikariDataSource</code>换成<code>com.alibaba.druid.pool.Druid</code>后，启动报错：找不到Mapper的bean对象  </p><p>官方FAQ：为什么配置了某个数据连接池的spring-boot-starter（比如druid）和sharding-jdbc-spring-boot-starter时，系统启动会报错？</p><ul><li>因为数据连接池的starter（比如druid）可能会先加载并且其创建一个默认数据源，这将会使得sharding-jdbc创建数据源时发生冲突。<br>解决办法为，去掉数据连接池的starter即可（保留主类依赖），sharing-jdbc自己会创建数据连接池。</li></ul></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.14<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shardingsphere<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shardingsphere-jdbc-core-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置参考（v5.1.1）：</p><blockquote><p>注意：不同版本配置区别较大，详情参照官方文档配置。</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">shardingsphere:</span></span><br><span class="line">    <span class="attr">mode:</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">Memory</span></span><br><span class="line">    <span class="attr">datasource:</span></span><br><span class="line">      <span class="attr">names:</span> <span class="string">master,</span> <span class="string">slave</span></span><br><span class="line">      <span class="attr">master:</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">        <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">        <span class="attr">url:</span> <span class="string">jdbc:mysql://master:3306/database</span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">        <span class="attr">password:</span> </span><br><span class="line">        <span class="attr">idle-timeout:</span> <span class="number">600000</span>  <span class="comment">#10 min</span></span><br><span class="line">        <span class="attr">max-lifetime:</span> <span class="number">1800000</span> <span class="comment">#30 min</span></span><br><span class="line">        <span class="comment"># 从机数据源</span></span><br><span class="line">      <span class="attr">slave:</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">        <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">        <span class="attr">url:</span> <span class="string">jdbc:mysql://slave:3306/database</span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">        <span class="attr">password:</span> </span><br><span class="line">        <span class="attr">idle-timeout:</span> <span class="number">600000</span>  <span class="comment">#10 min</span></span><br><span class="line">        <span class="attr">max-lifetime:</span> <span class="number">1800000</span> <span class="comment">#30 min</span></span><br><span class="line">    <span class="attr">rules:</span></span><br><span class="line">      <span class="attr">readwrite-splitting:</span></span><br><span class="line">        <span class="attr">data-sources:</span></span><br><span class="line">          <span class="attr">ds_ms:</span></span><br><span class="line">            <span class="attr">props:</span></span><br><span class="line">              <span class="attr">read-data-source-names:</span> <span class="string">slave</span></span><br><span class="line">              <span class="attr">write-data-source-name:</span> <span class="string">master</span></span><br><span class="line">            <span class="attr">type:</span> <span class="string">Static</span></span><br><span class="line">            <span class="attr">load-balancer-name:</span> <span class="string">roundRobin</span></span><br><span class="line">        <span class="attr">load-balancers:</span></span><br><span class="line">          <span class="attr">roundRobin:</span></span><br><span class="line">            <span class="attr">type:</span> <span class="string">round_robin</span></span><br><span class="line">      <span class="comment"># 数据分片</span></span><br><span class="line">      <span class="attr">sharding:</span></span><br><span class="line">        <span class="attr">tables:</span></span><br><span class="line">          <span class="attr">t_like:</span></span><br><span class="line">            <span class="attr">actual-data-nodes:</span> <span class="string">ds_ms.t_like_$-&gt;&#123;1..2&#125;</span></span><br><span class="line">            <span class="attr">key-generate-strategy:</span></span><br><span class="line">              <span class="attr">column:</span> <span class="string">id</span></span><br><span class="line">              <span class="attr">key-generator-name:</span> <span class="string">snowflake</span></span><br><span class="line">            <span class="attr">table-strategy:</span></span><br><span class="line">              <span class="attr">standard:</span></span><br><span class="line">                <span class="attr">sharding-column:</span> <span class="string">user_id</span></span><br><span class="line">                <span class="attr">sharding-algorithm-name:</span> <span class="string">like-inline</span></span><br><span class="line">        <span class="attr">key-generators:</span></span><br><span class="line">          <span class="attr">snowflake:</span></span><br><span class="line">            <span class="attr">type:</span> <span class="string">SNOWFLAKE</span></span><br><span class="line">        <span class="attr">sharding-algorithms:</span></span><br><span class="line">          <span class="comment"># 注意：名字不能带下划线</span></span><br><span class="line">          <span class="attr">like-inline:</span></span><br><span class="line">            <span class="attr">type:</span> <span class="string">INLINE</span></span><br><span class="line">            <span class="attr">props:</span></span><br><span class="line">              <span class="attr">algorithm-expression:</span> <span class="string">t_like_$-&gt;&#123;user_id</span> <span class="string">%</span> <span class="number">2</span> <span class="string">+</span> <span class="number">1</span><span class="string">&#125;</span></span><br><span class="line">    <span class="attr">props:</span></span><br><span class="line">      <span class="attr">sql:</span></span><br><span class="line">        <span class="attr">show:</span> <span class="literal">true</span> <span class="comment">#开启SQL显示，默认false</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sharding-JDBC </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试总结</title>
      <link href="/2023/12/06/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2023/12/06/%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h2><ul><li><p>Java特点：</p><ul><li>面向对象</li><li>跨平台（Write once，run anywhere）：在程序运行前，Java源代码（.java）需要经过编译器编译成字节码（.class）。在程序运行时，JVM负责将字节码翻译成特定平台下的机器码并运行，也就是说，只要在不同的平台上安装对应的JVM，就可以运行字节码文件。</li><li>编译与解释并存</li></ul></li><li><p>JVM、JDK、JRE</p><ul><li>Java 虚拟机（JVM）是运行 Java 字节码的虚拟机，负责将字节码翻译成特定平台下的机器码并运行。平台相关，针对不同系统有特定实现（Windows，Linux，macOS）</li><li>JRE（Java Runtime Environment） 是 Java 运行时环境，它包含运行已编译 Java 程序所需的所有内容，主要包括 Java 虚拟机（JVM）、Java 基础类库（Class Library）。</li><li>JDK（Java Development Kit），它是功能齐全的 Java SDK（软件开发工具包），是提供给开发者使用的，能够创建和编译 Java 程序。他包含了 JRE，同时还包含了编译 java 源码的编译器 javac 以及一些其他工具比如 javadoc（文档注释工具）、jdb（调试器）等等。</li></ul></li><li><p>基本数据类型</p><p><img src="https://s2.loli.net/2023/05/14/c4yYReJ1ijFkErd.png" alt="image-20230514151139442"></p><ul><li><p>char能不能存中文？</p><p>UTF-8 中文3字节，所以不能；Unicode中文2字节</p></li></ul></li><li><p>基本类型和引用类型区别</p><ol><li>基本数据类型是直接将值存储在栈(stack)中的，而引用数据类型在栈中存储的是一个地址，这个地址指向堆(heap)中的实际数据。</li><li>基本数据类型有8种：byte、short、int、long、float、double、char、boolean，而引用数据类型有类(class)、接口(interface)、数组(array)、枚举(enum)等。</li><li>基本数据类型的默认值是0或false，而引用数据类型的默认值是null。</li><li><em>java是值传递；</em>值传递是指在调用方法时将实际参数拷贝一份传递到方法中，这样在方法中如果对参数进行修改，将不会影响到实际参数；当传的是基本类型时，传的是值的拷贝，对拷贝变量的修改不影响原变量；当传的是引用类型时，传的是<strong>引用地址的拷贝</strong>，但是拷贝的地址和真实地址指向的都是同一个真实数据，因此可以修改原变量中的值。</li></ol></li><li><p>为什么要有包装类型</p><p>Java中一切皆对象，但八种基本数据类型不具有对象的性质，在某些场合不能使用基本类型，比如集合中存放的都是Object。为了解决这些问题，就需要为每个基本数据类型都定义一个对应的引用类型，也就是包装类。</p></li><li><p>自动拆箱装箱</p><p>java帮助我们自动完成基本数据类型与对应包装类型的转换，也就是说可以把一个基本类型的数据直接赋值给对应的包装类型，可以把一个包装类型的对象直接赋值给对应的基本类型。</p><p>优点：简化了基本类型变量和包装类对象之间的转换过程。</p><p>缺点：频繁拆装箱影响性能；包装类的值可能是null，拆箱导致NullPointerException</p><p>原理：包装类的valueOf进行装箱，xxxValue进行拆箱</p><ul><li><code>Integer i = 10</code> 等价于 <code>Integer i = Integer.valueOf(10)</code></li><li><code>int n = i</code> 等价于 <code>int n = i.intValue()</code></li></ul><p><strong>int和Integer比较，Integer自动拆箱</strong></p><blockquote><p>parseInt返回的是int基础类型，valueOf返回的是Integer包装类型</p></blockquote></li><li><p>包装类型的缓存机制</p><p>Java 基本数据类型的包装类型的大部分都用到了缓存机制来提升性能。Byte,Short,Integer,Long 这 4 种包装类默认创建了数值 [-128，127] 的相应类型的缓存数据，Character 创建了数值在 [0,127] 范围的缓存数据，Boolean 直接返回 True or False。  </p><p>范围内的值会<strong>复用缓存中的对象</strong>，因此包装类需要用equals比较而不能用&#x3D;&#x3D;。</p></li><li><p>修饰符</p><p><img src="https://s2.loli.net/2023/07/11/a2fDtpAxnvXBFRY.png" alt="Java修饰符"></p></li><li><p>重载和重写</p><ul><li><p>重载指同一个类内（或父子类间，子类可以重载父类非私有方法）<strong>同名不同参数</strong>的方法，与返回值与修饰符无关。</p></li><li><p>重写指子类覆盖从父类继承来的方法。子类重写的方法必须和父类被重写的方法具有<strong>相同的方法名称和参数列表</strong>。</p><ul><li><p>子类方法抛出的<strong>异常不能大于</strong>（不能是该异常父类）父类被重写方法的异常。</p></li><li><p>子类重写的方法的<strong>返回值类型不能大于</strong>父类被重写的方法的返回值类型。</p><ul><li>父类重写的方法的返回值类型是基本数据类型，子类被重写的方法的返回值类型必须是<strong>相同的基本数据类型</strong>。</li></ul></li><li><p>子类重写的方法使用的<strong>访问权限不能小于</strong>父类被重写的方法的访问权限。</p><ul><li>子类不能重写父类中声明为 private 权限的方法。</li></ul></li><li><p>构造方法不能重写：构造方法无法被继承</p></li></ul></li></ul></li><li><p>接口和抽象类的区别</p><ul><li>一个类可以实现多个接口，但只能继承一个抽象类。</li><li>接口主要定义了规范，对类的行为进行约束；抽象类用于继承以实现代码复用。</li><li>接口中的所有成员变量 为<code>public static final</code>， 不能被修改且必须有初始值。抽象类可以有普通成员变量。</li><li>java8前接口只能定义抽象方法，抽象类既可以定义抽象方法，也可以实现方法。（java8接口新增default方法和static方法）（默认都是public修饰。在以往开发中,接口只要增加了方法，所有实现类必须实现该方法，否则编译不通过。而default修饰的接口方法，实现类可以不做任何实现，默认调用接口的default方法。）</li><li>接口不含构造器。抽象类里可以包含构造器。</li><li>共同点：都不能被实例化；都可以有抽象方法，且子类必须实现抽象方法。</li><li><em>接口嵌套在类中时，可以定义为private</em>，private接口只能在当前类中使用；同理抽象类也可以。</li></ul></li><li><p>浅拷贝、深拷贝、引用拷贝</p><p><img src="https://s2.loli.net/2023/05/15/jc58xepytqurDd3.png" alt="image-20230515170320389"></p><p>浅拷贝：在堆上创建一个新的对象，如果原对象内部的属性有引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。</p></li><li><p>强软弱虚引用</p></li></ul><h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><ul><li><p>Object类常用方法</p><ul><li>Class&lt;?&gt; getClass()：返回该对象的运行时类。</li><li>boolean equals(Object obj)：判断指定对象与该对象是否相等。</li><li>int hashCode()：返回该对象的hashCode值，HashMap等哈希表中会用到。在默认情况下，Object类的hashCode()方法根据该对象的地址来计算。但很多类都重写了Object类的hashCode()方法，不再根据地址来计算其hashCode()方法值。</li><li>String toString()：返回该对象的字符串表示，当程序使用System.out.println()方法输出一个对象，或者把某个对象和字符串进行连接运算时，系统会自动调用该对象的toString()方法返回该对象的字符串表示。Object类的toString()方法返回 运行时类名@十六进制hashCode值 格式的字符串，但很多类都重写了Object类的toString()方法，用于返回可以表述该对象信息的字符串。</li></ul><p>另外，Object类还提供了wait()、notify()、notifyAll()这几个方法，通过这几个方法可以控制线程的暂停和运行。Object类还提供了一个clone()方法，可以得到一个当前对象的副本，默认为浅拷贝。还有finalize方法，finalize方法的调用存在不确定性，也就是说，程序无法确定finalize方法何时会被调用。当一个对象没有引用的时候，对象的垃圾回收器会调用finalize方法。</p></li><li><p>notify和notifyAll</p><p>notify()和notifyAll()方法都必须在同步代码块中调用，并且必须包含在synchronized块中，且必须是该对象的监视器对象才能够调用。而且只有在获取了锁之后才能调用，否则会抛出IllegalMonitorStateException异常。</p><p>notify()方法只会唤醒等待队列中的<strong>一个</strong>线程，并使其与其他线程竞争获取锁，这可能会导致某些线程无法被唤醒或者一直处于等待状态。</p><p>notifyAll()方法则会唤醒等待队列中的<strong>所有</strong>线程，并使它们竞争获取锁，这样可以使所有线程都有机会获取锁并进入运行状态，从而避免了一些线程一直处于等待状态。</p></li><li><p>&#x3D;&#x3D;和equals</p><p>&#x3D;&#x3D;运算符：</p><ul><li>作用于基本数据类型时，是比较两个数值是否相等；</li><li>作用于引用数据类型时，是比较两个对象的内存地址是否相同，即判断它们是否为同一个对象；</li></ul><p>equals()方法：</p><ul><li>没有重写时，Object默认以 &#x3D;&#x3D; 来实现，即比较两个对象的内存地址是否相同；</li><li>进行重写后，一般会按照对象的内容来进行比较，若两个对象内容相同则认为对象相等，否则认为对象不等。</li></ul></li><li><p>为什么重写 equals() 时必须重写 hashCode() 方法</p><ul><li><strong>如果两个对象相等，则它们必须有相同的哈希码</strong>。</li><li><strong>如果两个对象有相同的哈希码，则它们未必相等</strong>。</li></ul><p>hashcode与equals都是用来比较对象是否相等。hashcode帮助我们在散列表中快速找到元素的位置、判断元素是否相等。</p><p>以<code>HashMap</code>为例，执行put时，先通过 key 的 <code>hashcode</code> 经过hash方法处理过后得到 hash 值，然后通过 <code>(数组长度 - 1) &amp; hash</code> 判断当前元素存放的位置，如果对应位置为空，则直接放入；存在元素的话，就先判断该元素与要存入的元素的 hash 值是否相等，再用’&#x3D;&#x3D;’或equals()判断key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</p><p><strong>如果重写 <code>equals()</code> 时没有重写 <code>hashCode()</code> 方法的话，就可能会导致 <code>equals</code> 方法判断是相等的两个key，<code>hashCode</code> 值却不相等。HashMap在判断key是否相等时是先用hash值（int）进行比较，hash值不等就判断两个key不等。而hash值是通过hashcode计算得到的。所以在使用<code>HashMap</code>时就可能出现key相同但散列位置不同，也就是出现重复的key</strong>。</p><p>以<code>HashSet</code>为例，当你把对象加入 <code>HashSet</code> 时，<code>HashSet</code> 会先计算对象的 <code>hashCode</code> 值来判断对象加入的位置，同时也会与其他已经加入的对象的 <code>hashCode</code> 值作比较，如果没有相符的 <code>hashCode</code>，<code>HashSet</code> 会假设对象没有重复出现。但是如果发现有相同 <code>hashCode</code> 值的对象，这时会调用 <code>equals()</code> 方法来检查 <code>hashCode</code> 相等的对象是否真的相同。如果两者相同，<code>HashSet</code> 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置（在 JDK1.8 中，<code>HashSet</code>的<code>add()</code>方法只是简单的调用了<code>HashMap</code>的<code>put()</code>方法，并且判断了一下返回值以确保是否有重复元素。）。这样我们就大大减少了 <code>equals</code> 的次数，相应就大大提高了执行速度。</p></li></ul><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><ul><li><p>String常用方法</p><ul><li>char charAt(int index)：返回指定索引处的字符；</li><li>String substring(int beginIndex, int endIndex)：从此字符串中截取出一部分子字符串；</li><li>String[] split(String regex)：以指定的规则将此字符串分割成数组；</li><li>String trim()：删除字符串前导和后置的空格；</li><li>int indexOf(String str)：返回子串在此字符串首次出现的索引；</li><li>toLowerCase、toUpperCase</li></ul></li><li><p>String为什么不可变（immutable）</p><ul><li>保存字符串的数组被 <code>final</code> 修饰，初始化后就不可变</li><li><code>final</code>可以保证整个数组的引用地址不可变，但数组内的元素是可变的。而数组同时也用private修饰，并且String类没有修改数组的方法。</li><li><code>String</code> 类被 <code>final</code> 修饰导致其不能被继承，进而避免了子类破坏 <code>String</code> 不可变。</li></ul><p>不可变的好处：</p><p>\1. 字符串不可变性：由于String类是final的，因此它的值不能被修改，这就保证了字符串的不可变性。这是Java中的一项重要特性，因为它可以使得字符串常量池更有效率地管理和重用字符串对象。</p><p>\2. 安全性：由于字符串是不可变的，因此可以避免由于在多个线程中修改字符串而导致的同步问题。这意味着在并发环境中使用字符串时不需要额外的同步措施，从而提高了应用程序的安全性。</p><p>\3. 优化性能：由于字符串是不可变的，因此它们可以被缓存和重用（相同对象只需要拷贝地址。如果是可变的，修改一个对象将影响所有对象），这可以显著提高Java应用程序的性能。例如，Java的字符串常量池会缓存相同的字符串对象，从而避免了创建大量重复的字符串对象。</p><p>\4. 没有子类：由于String类是final的，因此不能被其他类继承，这可以防止其他类覆盖String类的方法并引入潜在的问题。这可以提高代码的稳定性和可靠性。</p></li><li><p>String、StringBuilder、StringBuffer</p><ul><li>首先String不可变，另外两个可变。Java9之前（9之后为byte[]）都用字符数组存放字符串，但String中用private final修饰，且没有提供修改字符串的方法。<code>StringBuilder</code> 与 <code>StringBuffer</code> 都继承自 <code>AbstractStringBuilder</code> 类，在 <code>AbstractStringBuilder</code> 中也是使用字符数组保存字符串，不过没有使用 <code>final</code> 和 <code>private</code> 关键字修饰，并且 <code>AbstractStringBuilder</code> 类还提供了很多修改字符串的方法比如 <code>append</code> 、<code>insert</code>等方法。</li><li>从线程安全角度讲，<code>String</code> 中的字符数组是不可变的，因此是线程安全。StringBuffer线程安全（通过synchronize），StringBuilder不是，因此性能略高。</li></ul></li><li><p>字符串拼接</p><ul><li>运算符：如果拼接的都是字符串直接量，则适合使用 + 运算符实现拼接；<ul><li>如果拼接的都是字符串直接量，则在编译时编译器会将其直接优化为一个完整的字符串（常量折叠），所以效率非常的高。</li><li>如果拼接的字符串中包含变量，则在编译时编译器采用StringBuilder对其进行优化，即自动创建StringBuilder实例并调用其append()方法，将这些字符串拼接在一起，效率也很高。但如果这个拼接操作是在循环中进行的，那么每次循环编译器都会创建一个StringBuilder实例，再去拼接字符串，相当于执行了 new StringBuilder().append(str)，所以此时效率很低。</li></ul></li><li>StringBuilder：如果拼接的字符串中包含变量，并不要求线程安全，则适合使用StringBuilder；+ </li><li>StringBuffer：如果拼接的字符串中包含变量，并且要求线程安全，则适合使用StringBuffer；</li><li>String类的concat方法：如果只是对两个字符串进行拼接，并且包含变量，则适合使用concat方法；<ul><li>先创建一个足以容纳待拼接的两个字符串的字节数组，然后先后将两个字符串拼到这个数组里，最后将此数组转换为字符串。</li></ul></li></ul></li><li><p>字符串反转？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;str&quot;</span>);</span><br><span class="line">sb.reverse();</span><br></pre></td></tr></table></figure></li><li><p>String s1 &#x3D; new String(“abc”);这句话创建了几个字符串对象？</p><ul><li><p>如果字符串常量池中不存在字符串对象“abc”，那么会在堆中创建 2 个字符串对象“abc”，其中一个放入常量池，另一个是常量池中那个的引用。</p></li><li><p>如果字符串常量池中已存在字符串对象“abc”，就复用常量池中已有的”abc”，将其引用赋值给变量s1。</p></li></ul></li><li><p>String s&#x3D;”a”+”b”+”c”+”d”;创建了几个对象？</p><p>一个。编译期常量折叠优化。</p></li><li><p>String的equals方法是怎么比的？</p><ol><li>先用双等号比较，如果内存地址相等即返回true</li><li>比较两个字符串长度，长度不等，返回false</li><li>如果长度相等，依次比较字符串中的每个字符是否相等</li></ol></li></ul><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><ul><li><p>介绍一下异常</p><p>异常包括Error和Exception，他们都继承自Throwable（类）。</p><p>Error是错误，常见error包括StackOverflow、OutOfMemory等，这种错误将导致程序终止，通常程序无法处理这些错误，因此不建议使用catch块来捕获Error对象（可以捕获），也无须在其throws子句中声明该方法可能抛出Error及其任何子类。</p><p>Exception是程序可以处理的异常，它分为Checked异常和Unchecked异常两大类。RuntimeException类及其子类都是Unchecked异常，常见的包括空指针异常、算术异常、数组越界异常等等，这类异常不处理也可以通过编译。而Checked异常都可以被处理，如果程序没有显式处理Checked异常，该程序在编译时就会发生错误，无法通过编译。这类异常主要包括IOException、SQLException、ClassNotFoundException等。</p></li><li><p>finally</p><ul><li>不管try块中的代码是否出现异常，也不管哪一个catch块被执行，甚至在try块或catch块中执行了return语句，finally块总会被执行。除非在finally执行前使用 System.exit(); 来退出虚拟机，或finally执行前线程就终止了。</li><li>一旦在finally块中使用了return、throw语句，将会导致try块、catch块中的return、throw语句失效。</li><li>假如try中有异常抛出，则会去执行catch块，再去执行finally块；假如没有catch 块，可以直接执行finally 块，方法就以抛出异常的方式结束，而finally 后的内容也不会被执行，所以catch 和 finally 不能同时省略。</li></ul></li></ul><h3 id="static-final"><a href="#static-final" class="headerlink" title="static&#x2F;final"></a>static&#x2F;final</h3><p>以static修饰的成员就是类成员，它属于整个类，而不属于单个实例对象；类成员不能访问实例成员；static修饰的类可以被继承。</p><ul><li>静态方法为什么不能调用非静态成员</li></ul><p>​静态方法是属于类的，在<strong>类加载</strong>的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，需要通过类的实例对象去访问。在类的非静态成员不存在的时候静态方法就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。</p><ul><li><p>静态内部类</p><p>如果使用static来修饰一个内部类，则这个内部类就属于外部类本身，而不属于外部类的某个对象。外部类的上一级程序单元是包，所以不可使用static修饰。</p><p>静态内部类的创建不依赖于外部类的实例，因此它<strong>可以像普通类一样被创建和使用</strong></p><p>静态内部类的优点是：</p><ol><li>它可以隐藏实现细节，仅在外部类内部使用，提高代码的封装性；</li><li>它可以作为外部类的静态成员，对外部类的成员进行封装，提高代码的可读性和可维护性；</li><li>它可以在不创建外部类实例的情况下创建内部类实例，减少对象的创建和内存开销；</li></ol><p>静态内部类需满足如下规则：</p><ol><li><p>静态内部类可以包含静态成员，也可以包含非静态成员；</p></li><li><p>静态内部类不能访问外部类的实例成员，只能访问它的静态成员；</p></li><li><p>外部类的所有方法、初始化块都能访问其内部定义的静态内部类；</p></li><li><p>在外部类的外部，也可以实例化静态内部类，语法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">外部类.内部类 变量名 = <span class="keyword">new</span> 外部类.内部类构造方法();</span><br></pre></td></tr></table></figure></li></ol></li><li><p>静态初始化块</p><p>静态初始化块也被称为<strong>类初始化块</strong>，也属于类的静态成员，同样需要遵循静态成员不能访问非静态成员的规则，因此静态初始化块不能访问非静态成员，包括不能访问实例变量和实例方法</p><p>与普通初始化块类似的是，系统在类初始化阶段执行静态初始化块时，不仅会执行本类的静态初始化块，而且还会一直上溯到 java.lang.Object 类(如果它包含静态初始化块)，先执行 java .lang.Object类的静态初始化块(如果有)，然后执行其父类的静态初始化块……最后才执行该类的静态初始化块，经过这个过程，才完成了该类的初始化过程。</p></li><li><p>Java程序初始化顺序：</p><ol><li>父类的静态代码块</li><li>子类的静态代码块</li><li>父类的普通代码块</li><li>父类的构造方法</li><li>子类的普通代码块</li><li>子类的构造方法</li></ol></li><li><p>static和final</p><p>static关键字可以修饰<strong>成员</strong>变量、成员方法、初始化块、内部类，被static修饰的成员是类的成员，它属于类、不属于单个对象。以下是static修饰这4种成员时表现出的特征：</p><ul><li><p>类变量：被static修饰的成员变量叫类变量（静态变量）。类变量属于类，它随类的信息存储在方法区，并不随对象存储在堆中，类变量可以通过类名来访问，也可以通过对象名来访问，但建议通过类名访问它。</p></li><li><p>类方法：被static修饰的成员方法叫类方法（静态方法）。类方法属于类，可以通过类名访问，也可以通过对象名访问，建议通过类名访问它。</p><blockquote><p>问题：静态方法中的++i有线程安全问题吗</p><p>访问静态方法不会自动加锁，所以仍会有线程安全问题。</p></blockquote></li><li><p>静态块：被static修饰的初始化块叫静态初始化块。静态块属于类，它在类加载的时候被隐式调用一次，之后便不会被调用了。</p></li><li><p>静态内部类：被static修饰的内部类叫静态内部类。静态内部类可以包含静态成员，也可以包含非静态成员。静态内部类不能访问外部类的实例成员，只能访问外部类的静态成员。外部类的所有方法、初始化块都能访问其内部定义的静态内部类。</p><p>注：内部类是懒加载，即使用时才加载</p></li></ul><p>final关键字可以修饰类、方法、变量（成员、局部），以下是final修饰这3种目标时表现出的特征：</p><ul><li><p>final类：final关键字修饰的类不可以被继承。</p></li><li><p>final方法：final关键字修饰的方法不可以被重写。</p></li><li><p>final变量：final关键字修饰的变量，一旦获得了初始值，就不可以被修改。</p></li><li><p>变量分为成员变量、局部变量。</p><p>final修饰成员变量：</p><ul><li>类变量：可以在声明变量时指定初始值，也可以在静态初始化块中指定初始值；</li><li>实例变量：可以在<strong>声明</strong>变量时指定初始值，也可以在<strong>初始化块</strong>或<strong>构造方法</strong>中指定初始值；</li></ul><p>final修饰局部变量：</p><ul><li>可以在声明变量时指定初始值，也可以在后面的代码中指定初始值。</li></ul><p><em>注意：被 final 修饰的任何形式的变量，一旦获得了初始值，就不可以被修改！</em></p></li></ul></li></ul><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><ul><li><p>说说对泛型的理解</p><p>就是指在类定义时不指定类中的属性或方法参数的具体类型，而是在实例化时再进行类型的定义。</p><p>java引入泛型前，当需要从集合中获取元素时，只知道它是Object，而不知道具体的类型，因此取出元素后通常需要进行强制类型转换；但在转换时很可能发生ClassCastException，因为集合中可能放入了其他类型的元素。</p><p>引入泛型后，集合内只能存对应类型的对象，取出元素时就不需要手动进行类型转换。也可以避免把其他类型放入集合导致强制类型转换时引发ClassCastException。</p></li><li><p>泛型（类型）擦除</p><p>Java的泛型其实是伪泛型，在编译的阶段，会进行泛型擦除。简单来说，就是编译时，就将其替换成具体的类型。替换的规则是，替换为声明该泛型形参时指定的第一个上限类型，没有指定就设置成Object。</p><p>Java的泛型使用”擦除”实现，是为了兼容老版本的Java编译器和虚拟机，因为泛型的实现需要改变Java的类文件格式。</p></li><li><p>java泛型<code>&lt;T&gt;</code>和<code>&lt;?&gt;</code>区别</p><p>在Java中，泛型是一种参数化类型的机制，用于在编译时提供类型安全和代码复用。泛型有两种常见的使用方式：使用尖括号和类型参数（如<code>&lt;T&gt;</code>）定义泛型类型，或者使用通配符（如<code>&lt;?&gt;</code>）表示未知类型。</p><ol><li><code>&lt;T&gt;</code> 泛型类型参数：<ul><li><code>&lt;T&gt;</code> 是一种泛型类型参数的定义方式，<code>T</code> 是一个占位符，表示可以在使用泛型时指定的具体类型。</li><li>使用 <code>&lt;T&gt;</code> 可以创建泛型类、泛型方法或泛型接口，以便在实例化或调用时指定具体的类型。</li><li>例如，<code>List&lt;T&gt;</code> 表示一个可以存储任意类型的列表，<code>T</code> 在实例化时可以被具体的类型替代，如 <code>List&lt;Integer&gt;</code> 或 <code>List&lt;String&gt;</code>。</li></ul></li><li><code>&lt;?&gt;</code> 通配符：<ul><li><code>&lt;?&gt;</code> 是一种通配符类型，表示未知类型，常用于泛型方法的参数、泛型类的成员变量或通配符限定。</li><li><code>&lt;?&gt;</code> 表示可以接受任意类型的参数，但在方法内部无法对其进行修改或获取具体类型信息。</li><li>例如，<code>List&lt;?&gt;</code> 表示一个未知类型的列表，可以接受任何类型的元素。</li></ul></li></ol><p>区别：</p><ul><li><code>&lt;T&gt;</code> 是一个具体的类型参数，可以在实例化或调用时指定具体的类型，提供了更严格的类型检查和更灵活的代码复用。</li><li><code>&lt;?&gt;</code> 是一个通配符，表示未知类型，可以接受任意类型的参数，但在方法内部无法对其进行修改或获取具体类型信息，提供了更大的灵活性和泛化能力。</li></ul><p>需要注意的是，<code>&lt;T&gt;</code> 和 <code>&lt;?&gt;</code> 可以在不同的上下文中使用，并且还有其他通配符的形式，如<code>&lt;? extends T&gt;</code> 和 <code>&lt;? super T&gt;</code>，用于更精确地限定泛型类型的范围。具体使用哪种形式取决于你的需求和上下文。</p></li></ul><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p>反射就是在运行时可以获取任意一个类的信息，创建类的实例、访问类的方法、访问实例对象的属性等等。</p><ul><li><p>优点：</p><ul><li><p>运行期判断类型，动态加载类，提高代码灵活度。</p></li><li><p>提高代码复用率，比如动态代理就是用了反射实现</p></li><li><p>可以在运行时获取任意一个类的方法，属性，并且还能通过反射动态调用</p></li></ul></li><li><p>缺点：</p><ul><li><p><strong>性能开销</strong>：相比于直接调用方法或访问字段，使用反射机制进行方法调用和字段访问通常会导致性能开销增加。这是因为反射需要在运行时进行动态查找和解析，而不是直接通过编译时的静态绑定进行优化。因此，使用反射可能会导致程序的执行速度变慢。</p></li><li><p><strong>安全性问题</strong>：反射机制可以绕过访问控制符（例如 private、protected），并访问和修改对象的私有成员。这可能会破坏封装性和安全性，导致不可预料的行为。如果不小心使用反射机制，可能会引入安全漏洞。</p></li></ul></li></ul><ul><li><strong>代码可读性降低</strong>：反射机制可以使代码更加复杂和难以理解。由于反射是在运行时进行动态操作，代码的逻辑和结构可能变得更加难以捉摸。这会增加代码维护的难度，并且可能导致代码的可读性降低。<ul><li><strong>编译时检查的缺失</strong>：使用反射时，一些编译时的错误只能在运行时才能被发现。例如，如果在反射调用方法时传递了错误的参数类型，只有在运行时才会抛出异常。这使得调试和排查问题变得更加困难。</li></ul></li></ul><ul><li><p>应用场景：</p><ul><li>使用JDBC时，如果要创建数据库的连接，则需要先通过反射机制（Class.forName()）加载数据库的驱动程序；</li><li>多数框架都支持注解&#x2F;XML配置，从配置中解析出来的类是字符串，需要利用反射机制实例化；</li><li>面向切面编程（AOP）的实现方案，是在程序运行时创建目标对象的代理类，这必须由反射机制来实现。</li></ul></li><li><p>Field 类：提供有关类的属性信息，以及对它的动态访问权限。它是一个封装反射类的属性的类。</p><p>Constructor 类：提供有关类的构造方法的信息，以及对它的动态访问权限。它是一个封装反射类的构造方法的类。 </p><p>Method 类：提供关于类的方法的信息，包括抽象方法。它是用来封装反射类方法的一个类。</p><p>Class 类：表示正在运行的 Java 应用程序中的类的实例。</p><p>Object 类：Object 是所有 Java 类的父类。所有对象都默认实现了 Object 类的方法。</p></li><li><p>调用步骤</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.反射得到类对象</span></span><br><span class="line">Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="comment">// 2.得到方法</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clazz.getDeclaredMethod(<span class="string">&quot;method&quot;</span>);</span><br><span class="line"><span class="comment">// 设置私有方法可访问</span></span><br><span class="line">method.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="comment">// 执行私有方法</span></span><br><span class="line">method.invoke(clazz.getDeclaredConstructor().newInstance());</span><br><span class="line"><span class="comment">// 执行静态方法</span></span><br><span class="line">staticMethod.invoke(clazz);</span><br><span class="line"><span class="comment">// 得到属性</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="comment">// 设置私有属性可访问</span></span><br><span class="line">field.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="comment">// 得到属性值</span></span><br><span class="line"><span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> (<span class="type">int</span>) field.get(clazz.getDeclaredConstructor().newInstance());</span><br></pre></td></tr></table></figure></li></ul><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><ul><li>序列化机制可以将对象转换成字节流，这些字节流可以保存在磁盘上，也可以在网络中传输，并允许程序将这些字节流再次恢复成原来的对象。作用：保证对象的完整性和可传递性，可以跨平台、跨语言传递对象。</li><li>若对象要支持序列化机制，则它的类需要实现Serializable接口，该接口是一个标记接口，它没有提供任何方法，只是标明该类是可以序列化的，Java的很多类已经实现了Serializable接口，如包装类、String、Date等。</li><li>若要实现序列化，则需要使用对象流ObjectInputStream和ObjectOutputStream。其中，在序列化时需要调用ObjectOutputStream对象的writeObject()方法，以输出对象序列。在反序列化时需要调用ObjectInputStream对象的readObject()方法，将对象序列恢复为对象。</li><li>被transient修饰的数据不能进行序列化</li><li><code>static</code> 变量因为不属于任何对象(Object)，所以无论有没有 <code>transient</code> 关键字修饰，均不会被序列化。</li><li><code>serialVersionUID</code> 起版本控制的作用。反序列化时，会检查 <code>serialVersionUID</code> 是否和当前类的 <code>serialVersionUID</code> 一致。如果 <code>serialVersionUID</code> 不一致则会抛出 <code>InvalidClassException</code> 异常。</li><li>其他序列化工具？<ul><li>JSON：简单直观，可读性好，但性能一般较差</li><li>Protobuf：支持多种语言诸如C++、Java以及Python语言，二进制存储</li><li>Kryo：只支持Java，二进制存储</li></ul></li></ul><h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><p>本质上是一个继承了Annotation接口的特殊接口，可以看作是一种特殊的注释，主要用于修饰类、方法或者变量，提供某些信息供程序在编译或者运行时使用。</p><ul><li><p>5个元注解</p><ul><li>@ Retention用来定义该注解在哪一个级别可用，在源代码中(SOURCE)、类文件中(CLASS)或者运行时(RUNTIME)。</li><li>@Documented：生成文档信息的时候保留注解</li><li>@Target：用于描述注解的使用范围</li><li>@Inherited：说明子类可以继承父类中的该注解</li><li>@Repeatable 表示注解可以重复使用。</li></ul></li><li><p>注解作用</p><p>注解可以提供一些额外的信息，这些信息可以给编译器，使得编译器在编译过程中可以对代码进行检查或处理。例如，@Override注解用于指示方法应该覆盖父类中的方法，如果没有正确覆盖，编译器会产生警告或错误；也可以在运行时被读取和处理，从而改变程序的行为。</p></li><li><p>注解的解析方法有哪几种？</p><p>注解只有被解析之后才会生效，常见的解析方法有两种：</p><ul><li><strong>编译期直接扫描</strong>：编译器在编译 Java 代码的时候扫描对应的注解并处理，比如某个方法使用<code>@Override</code> 注解，编译器在编译的时候就会检测当前的方法是否重写了父类对应的方法。</li><li><strong>运行期通过反射处理</strong>：像框架中自带的注解(比如 Spring 框架的 <code>@Value</code>、<code>@Component</code>)都是通过反射来进行处理的。</li></ul></li></ul><h3 id="语法糖"><a href="#语法糖" class="headerlink" title="语法糖"></a>语法糖</h3><ul><li>switch支持String与枚举</li><li>for-each</li><li>try-with-resource</li><li>自动拆装箱</li></ul><h3 id="其他常见问题"><a href="#其他常见问题" class="headerlink" title="其他常见问题"></a>其他常见问题</h3><ul><li><p>创建对象的方式？</p><p>new、序列化和反序列化、</p><p>反射：通过Class.forName获取类对象，然后调用它的newInstance方法</p><p>克隆：调用Object的clone方法（需要实现cloneable接口）</p></li><li><p>浮点数精度怎么解决</p><p>BigDecimal：底层用BigInteger存数值，用int值scale存小数位数</p></li></ul><h3 id="Java8特性"><a href="#Java8特性" class="headerlink" title="Java8特性"></a>Java8特性</h3><h4 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 返回一个串行流</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">default</span> Stream&lt;E&gt; <span class="title function_">stream</span><span class="params">()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 返回一个并行流</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">default</span> Stream&lt;E&gt; <span class="title function_">parallelStream</span><span class="params">()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 返回T的流</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title function_">of</span><span class="params">(T t)</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 返回其元素是指定值的顺序流。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title function_">of</span><span class="params">(T... values)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Arrays.stream(values);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 过滤，返回由与给定predicate匹配的该流的元素组成的流</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Stream&lt;T&gt; <span class="title function_">filter</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> T&gt; predicate)</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 此流的所有元素是否与提供的predicate匹配。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">allMatch</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> T&gt; predicate)</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 此流任意元素是否有与提供的predicate匹配。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">anyMatch</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> T&gt; predicate)</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 使用 Collector对此流的元素进行归纳</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&lt;R, A&gt; R <span class="title function_">collect</span><span class="params">(Collector&lt;? <span class="built_in">super</span> T, A, R&gt; collector)</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回此流中的元素数。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">count</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 返回由该流的不同元素（根据 Object.equals(Object) ）组成的流。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Stream&lt;T&gt; <span class="title function_">distinct</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 遍历</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">forEach</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; action)</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 用于获取指定数量的流，截短长度不能超过 maxSize 。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Stream&lt;T&gt; <span class="title function_">limit</span><span class="params">(<span class="type">long</span> maxSize)</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 用于映射每个元素到对应的结果</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&lt;R&gt; Stream&lt;R&gt; <span class="title function_">map</span><span class="params">(Function&lt;? <span class="built_in">super</span> T, ? extends R&gt; mapper)</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* flatMap()简单来说就是将多个stream流合并成一个stream</span></span><br><span class="line"><span class="comment">List&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;();</span></span><br><span class="line"><span class="comment">List&lt;Integer&gt; collect = lists.stream().flatMap(item -&gt;  item.stream().filter(Objects::nonNull))</span></span><br><span class="line"><span class="comment">                .collect(Collectors.toList());</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 根据提供的 Comparator进行排序。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Stream&lt;T&gt; <span class="title function_">sorted</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> T&gt; comparator)</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 在丢弃流的第一个 n元素后，返回由该流的 n元素组成的流。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Stream&lt;T&gt; <span class="title function_">skip</span><span class="params">(<span class="type">long</span> n)</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 返回一个包含此流的元素的数组。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Object[] toArray();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 使用提供的 generator函数返回一个包含此流的元素的数组，以分配返回的数组，以及分区执行或调整大小可能需要的任何其他数组。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&lt;A&gt; A[] toArray(IntFunction&lt;A[]&gt; generator);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 合并流</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Stream&lt;T&gt; <span class="title function_">concat</span><span class="params">(Stream&lt;? extends T&gt; a, Stream&lt;? extends T&gt; b)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Java-IO"><a href="#Java-IO" class="headerlink" title="Java IO"></a>Java IO</h2><h3 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h3><p>IO 即 <code>Input/Output</code>，输入和输出。数据输入到计算机内存的过程即输入，反之输出到外部存储（比如数据库，文件，远程主机）的过程即输出。数据传输过程类似于水流，因此称为 IO 流。IO 流在 Java 中分为输入流和输出流，而根据数据的处理方式又分为字节流和字符流。</p><p>Java IO 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。</p><ul><li><code>InputStream</code>&#x2F;<code>Reader</code>: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li><li><code>OutputStream</code>&#x2F;<code>Writer</code>: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</li></ul><h4 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h4><h5 id="InputStream（字节输入流）"><a href="#InputStream（字节输入流）" class="headerlink" title="InputStream（字节输入流）"></a>InputStream（字节输入流）</h5><p><code>InputStream</code>用于从源头（通常是文件）读取数据（字节信息）到内存中，<code>java.io.InputStream</code>抽象类是所有字节输入流的父类。</p><p><code>InputStream</code> 常用方法：</p><ul><li><code>read()</code>：返回输入流中下一个字节的数据。返回的值介于 0 到 255 之间。如果未读取任何字节，则代码返回 <code>-1</code> ，表示文件结束。</li><li><code>read(byte b[ ])</code> : 从输入流中读取一些字节存储到数组 <code>b</code> 中。如果数组 <code>b</code> 的长度为零，则不读取。如果没有可用字节读取，返回 <code>-1</code>。如果有可用字节读取，则最多读取的字节数最多等于 <code>b.length</code> ， 返回读取的字节数。这个方法等价于 <code>read(b, 0, b.length)</code>。</li><li><code>read(byte b[], int off, int len)</code>：在<code>read(byte b[ ])</code> 方法的基础上增加了 <code>off</code> 参数（偏移量）和 <code>len</code> 参数（要读取的最大字节数）。</li><li><code>skip(long n)</code>：忽略输入流中的 n 个字节 ,返回实际忽略的字节数。</li><li><code>available()</code>：返回输入流中可以读取的字节数。</li><li><code>close()</code>：关闭输入流释放相关的系统资源。</li></ul><p><code>FileInputStream</code> 是一个比较常用的字节输入流对象，可直接指定文件路径，可以直接读取单字节数据，也可以读取至字节数组中。通常会配合 <code>BufferedInputStream</code>来使用。</p><p>像下面这段代码在我们的项目中就比较常见，我们通过 <code>readAllBytes()</code> 读取输入流所有字节并将其直接赋值给一个 <code>String</code> 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新建一个 BufferedInputStream 对象</span></span><br><span class="line"><span class="type">BufferedInputStream</span> <span class="variable">bufferedInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;input.txt&quot;</span>));</span><br><span class="line"><span class="comment">// 读取文件的内容并复制到 String 对象中</span></span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bufferedInputStream.readAllBytes());</span><br><span class="line">System.out.println(result);</span><br></pre></td></tr></table></figure><p><code>DataInputStream</code> 用于读取指定类型数据，不能单独使用，必须结合其它流，比如 <code>FileInputStream</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;input.txt&quot;</span>);</span><br><span class="line"><span class="comment">//必须将fileInputStream作为构造参数才能使用</span></span><br><span class="line"><span class="type">DataInputStream</span> <span class="variable">dataInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(fileInputStream);</span><br><span class="line"><span class="comment">//可以读取任意具体的类型数据</span></span><br><span class="line">dataInputStream.readBoolean();</span><br><span class="line">dataInputStream.readInt();</span><br><span class="line">dataInputStream.readUTF();</span><br></pre></td></tr></table></figure><p><code>ObjectInputStream</code> 用于从输入流中读取 Java 对象（反序列化），<code>ObjectOutputStream</code> 用于将对象写入到输出流(序列化)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ObjectInputStream</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;object.data&quot;</span>));</span><br><span class="line"><span class="type">MyClass</span> <span class="variable">object</span> <span class="operator">=</span> (MyClass) input.readObject();</span><br><span class="line">input.close();</span><br></pre></td></tr></table></figure><p>另外，用于序列化和反序列化的类必须实现 <code>Serializable</code> 接口，对象中如果有属性不想被序列化，使用 <code>transient</code> 修饰。</p><h5 id="OutputStream"><a href="#OutputStream" class="headerlink" title="OutputStream"></a>OutputStream</h5><p><code>OutputStream</code> 常用方法：</p><ul><li><code>write(int b)</code>：将特定字节写入输出流。</li><li><code>write(byte b[ ])</code> : 将数组<code>b</code> 写入到输出流，等价于 <code>write(b, 0, b.length)</code> 。</li><li><code>write(byte[] b, int off, int len)</code> : 在<code>write(byte b[ ])</code> 方法的基础上增加了 <code>off</code> 参数（偏移量）和 <code>len</code> 参数（要读取的最大字节数）。</li><li><code>flush()</code>：刷新此输出流并强制写出所有缓冲的输出字节。</li><li><code>close()</code>：关闭输出流释放相关的系统资源。</li></ul><p><code>FileOutputStream</code> 是最常用的字节输出流对象，可直接指定文件路径，可以直接输出单字节数据，也可以输出指定的字节数组。</p><p><code>FileOutputStream</code> 代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">FileOutputStream</span> <span class="variable">output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;output.txt&quot;</span>)) &#123;</span><br><span class="line">    <span class="type">byte</span>[] array = <span class="string">&quot;JavaGuide&quot;</span>.getBytes();</span><br><span class="line">    output.write(array);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h4><p>不管是文件读写还是网络发送接收，信息的最小存储单元都是字节。 <strong>那为什么 I&#x2F;O 流操作要分为字节流操作和字符流操作呢？</strong></p><p>个人认为主要有两点原因：</p><ul><li>字符流是由 Java 虚拟机将字节转换得到的，这个过程还算是比较耗时。</li><li>如果我们不知道编码类型就很容易出现乱码问题。</li></ul><p>乱码问题这个很容易就可以复现，我们只需要将上面提到的 <code>FileInputStream</code> 代码示例中的 <code>input.txt</code> 文件内容改为中文即可，原代码不需要改动。</p><p>因此，I&#x2F;O 流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。如果音频文件、图片等媒体文件用字节流比较好，如果涉及到字符的话使用字符流比较好。</p><p>字符流默认采用的是 <code>Unicode</code> 编码，我们可以通过构造方法自定义编码。顺便分享一下之前遇到的笔试题：常用字符编码所占字节数？<code>utf8</code> :英文占 1 字节，中文占 3 字节，<code>unicode</code>：任何字符都占 2 个字节，<code>gbk</code>：英文占 1 字节，中文占 2 字节。</p><h5 id="Reader（字符输入流）"><a href="#Reader（字符输入流）" class="headerlink" title="Reader（字符输入流）"></a>Reader（字符输入流）</h5><p><code>Reader</code>用于从源头（通常是文件）读取数据（字符信息）到内存中，<code>java.io.Reader</code>抽象类是所有字符输入流的父类。</p><p><code>Reader</code> 用于读取文本， <code>InputStream</code> 用于读取原始字节。</p><p><code>Reader</code> 常用方法：</p><ul><li><code>read()</code> : 从输入流读取一个字符。</li><li><code>read(char[] cbuf)</code> : 从输入流中读取一些字符，并将它们存储到字符数组 <code>cbuf</code>中，等价于 <code>read(cbuf, 0, cbuf.length)</code> 。</li><li><code>read(char[] cbuf, int off, int len)</code>：在<code>read(char[] cbuf)</code> 方法的基础上增加了 <code>off</code> 参数（偏移量）和 <code>len</code> 参数（要读取的最大字符数）。</li><li><code>skip(long n)</code>：忽略输入流中的 n 个字符 ,返回实际忽略的字符数。</li><li><code>close()</code> : 关闭输入流并释放相关的系统资源。</li></ul><p><code>InputStreamReader</code> 是字节流转换为字符流的桥梁，其子类 <code>FileReader</code> 是基于该基础上的封装，可以直接操作字符文件。</p><h5 id="Writer（字符输出流）"><a href="#Writer（字符输出流）" class="headerlink" title="Writer（字符输出流）"></a>Writer（字符输出流）</h5><p><code>Writer</code>用于将数据（字符信息）写入到目的地（通常是文件），<code>java.io.Writer</code>抽象类是所有字符输出流的父类。</p><p><code>Writer</code> 常用方法：</p><ul><li><code>write(int c)</code> : 写入单个字符。</li><li><code>write(char[] cbuf)</code>：写入字符数组 <code>cbuf</code>，等价于<code>write(cbuf, 0, cbuf.length)</code>。</li><li><code>write(char[] cbuf, int off, int len)</code>：在<code>write(char[] cbuf)</code> 方法的基础上增加了 <code>off</code> 参数（偏移量）和 <code>len</code> 参数（要读取的最大字符数）。</li><li><code>write(String str)</code>：写入字符串，等价于 <code>write(str, 0, str.length())</code> 。</li><li><code>write(String str, int off, int len)</code>：在<code>write(String str)</code> 方法的基础上增加了 <code>off</code> 参数（偏移量）和 <code>len</code> 参数（要读取的最大字符数）。</li><li><code>append(CharSequence csq)</code>：将指定的字符序列附加到指定的 <code>Writer</code> 对象并返回该 <code>Writer</code> 对象。</li><li><code>append(char c)</code>：将指定的字符附加到指定的 <code>Writer</code> 对象并返回该 <code>Writer</code> 对象。</li><li><code>flush()</code>：刷新此输出流并强制写出所有缓冲的输出字符。</li><li><code>close()</code>:关闭输出流释放相关的系统资源。</li></ul><p><code>OutputStreamWriter</code> 是字符流转换为字节流的桥梁，其子类 <code>FileWriter</code> 是基于该基础上的封装，可以直接将字符写入到文件。</p><ul><li><p>FileInputStream 和 FileWriter 读取文件时中文乱码问题</p><p>可能原因：读取本地磁盘中的文件是GBK编码，而读取的方式是UTF-8。文件是UTF-8编码，但是读取文件的类java文件是GBK方式，也会导致乱码。<br>解决方法：使用InputStreamReader 中带编码方式参数的构造器创建对象读取文件数据 （InputStreamReader的使用可以查看api文档或者百度案例）</p></li><li><p>javaIO流文件写出出现乱码是什么原因，怎么处理？</p><p>原因可能是<em>系统向目标文件写入时所使用的编码与目标文件自身的编码不同</em>。</p><p>解决办法：FileWriter构造时指定编码。</p><p>FileWriter的构造函数可以接受一个charset参数，以指定编码格式。常见的编码格式包括UTF-8、GB2312、GBK、ISO8859-1等等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">   <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> <span class="string">&quot;testEncoding.txt&quot;</span>;</span><br><span class="line">   <span class="type">String</span> <span class="variable">charset</span> <span class="operator">=</span> <span class="string">&quot;UTF-8&quot;</span>;</span><br><span class="line">   <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="string">&quot;中文字符测试&quot;</span>;</span><br><span class="line">   <span class="comment">//指定编码格式UTF-8</span></span><br><span class="line">   <span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(fileName, Charset.forName(charset));</span><br><span class="line">   fw.write(content);</span><br><span class="line">   fw.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="字节缓冲流"><a href="#字节缓冲流" class="headerlink" title="字节缓冲流"></a>字节缓冲流</h4><p>IO 操作是很消耗性能的，缓冲流将数据加载至缓冲区，一次性读取&#x2F;写入多个字节，从而避免频繁的 IO 操作，提高流的传输效率。</p><p>字节缓冲流这里采用了装饰器模式来增强 <code>InputStream</code> 和<code>OutputStream</code>子类对象的功能。</p><p>举个例子，我们可以通过 <code>BufferedInputStream</code>（字节缓冲输入流）来增强 <code>FileInputStream</code> 的功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新建一个 BufferedInputStream 对象</span></span><br><span class="line"><span class="type">BufferedInputStream</span> <span class="variable">bufferedInputStream</span> <span class="operator">=</span> </span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;input.txt&quot;</span>));</span><br></pre></td></tr></table></figure><p>字节流和字节缓冲流的性能差别主要体现在我们使用两者的时候都是调用 <code>write(int b)</code> 和 <code>read()</code> 这两个一次只读取一个字节的方法的时候。由于字节缓冲流内部有缓冲区（字节数组），因此，字节缓冲流会先将读取到的字节存放在缓存区，大幅减少 IO 次数，提高读取效率。</p><ul><li><p>BufferedInputStream（字节缓冲输入流）</p><p><code>BufferedInputStream</code> 从源头（通常是文件）读取数据（字节信息）到内存的过程中不会一个字节一个字节的读取，而是会先将读取到的字节存放在缓存区，并从内部缓冲区中单独读取字节。这样大幅减少了 IO 次数，提高了读取效率。</p><p><code>BufferedInputStream</code> 内部维护了一个缓冲区，这个缓冲区实际就是一个字节数组。</p></li><li><p>BufferedOutputStream（字节缓冲输出流）</p></li></ul><h4 id="字符缓冲流"><a href="#字符缓冲流" class="headerlink" title="字符缓冲流"></a>字符缓冲流</h4><p><code>BufferedReader</code> （字符缓冲输入流）和 <code>BufferedWriter</code>（字符缓冲输出流）类似于 <code>BufferedInputStream</code>（字节缓冲输入流）和<code>BufferedOutputStream</code>（字节缓冲输入流），内部都维护了一个字节数组作为缓冲区。不过，前者主要是用来操作字符信息。</p><h3 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h3><h4 id="BIO、NIO、AIO"><a href="#BIO、NIO、AIO" class="headerlink" title="BIO、NIO、AIO"></a>BIO、NIO、AIO</h4><ul><li><p>BIO (Blocking I&#x2F;O)<br>BIO 属于同步阻塞 IO 模型 。同步阻塞 IO 模型中，应用程序发起 read 调用后，会一直阻塞，直到内核把数据拷贝到用户空间。</p><p><img src="https://s2.loli.net/2023/06/20/W9VrPBbg2ynItu4.png" alt="BIO"></p></li><li><p>NIO</p><p>同步非阻塞 IO 模型中，应用程序会一直发起 read 调用，等待数据从内核空间拷贝到用户空间的这段时间里，线程依然是阻塞的，直到在内核把数据拷贝到用户空间。</p><p><img src="https://s2.loli.net/2023/06/20/QbVluM5sAS39i7x.png" alt="NIO"></p><p>相比于同步阻塞 IO 模型，同步非阻塞 IO 模型确实有了很大改进。通过轮询操作，避免了一直阻塞。</p><p>但是，这种 IO 模型同样存在问题：<strong>应用程序不断进行 I&#x2F;O 系统调用轮询数据是否已经准备好的过程是十分消耗 CPU 资源的。</strong></p><p>这个时候，<strong>I&#x2F;O 多路复用模型</strong> 就上场了。</p><p><img src="https://s2.loli.net/2023/06/20/OB1C3IZyfLFPH7j.png" alt="IO多路复用"></p><p>IO 多路复用模型中，线程首先发起 select 调用，询问内核数据是否准备就绪，等内核把数据准备好了，用户线程再发起 read 调用。read 调用的过程（数据从内核空间 -&gt; 用户空间）还是阻塞的。</p><blockquote><p>目前支持 IO 多路复用的系统调用，有 select，epoll 等等。select 系统调用，目前几乎在所有的操作系统上都有支持。</p><ul><li><strong>select 调用</strong>：内核提供的系统调用，它支持一次查询多个系统调用的可用状态。几乎所有的操作系统都支持。</li><li><strong>epoll 调用</strong>：linux 2.6 内核，属于 select 调用的增强版本，优化了 IO 的执行效率。</li></ul></blockquote><p><strong>IO 多路复用模型，通过减少无效的系统调用，减少了对 CPU 资源的消耗。</strong></p><p>Java 中的 NIO ，有一个非常重要的<strong>选择器 ( Selector )</strong> 的概念，也可以被称为 <strong>多路复用器</strong>。通过它，只需要一个线程便可以管理多个客户端连接。当客户端数据到了之后，才会为其服务。</p></li><li><h3 id="AIO-Asynchronous-I-O"><a href="#AIO-Asynchronous-I-O" class="headerlink" title="AIO (Asynchronous I&#x2F;O)"></a>AIO (Asynchronous I&#x2F;O)</h3><p>AIO 也就是 NIO 2。Java 7 中引入了 NIO 的改进版 NIO 2,它是异步 IO 模型。</p><p>异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。</p><p><img src="https://s2.loli.net/2023/06/20/RImdJGl8gLwtTED.png" alt="AIO"></p></li></ul><h2 id="Java集合"><a href="#Java集合" class="headerlink" title="Java集合"></a>Java集合</h2><p>Java 集合，主要是由两大接口派生而来：一个是 <code>Collection</code>接口，主要用于存放单一元素，包括<code>List</code>、<code>Set</code> 和 <code>Queue</code>；另一个是 <code>Map</code> 接口，主要用于存放键值对。</p><p><img src="https://s2.loli.net/2023/05/18/4EYwlI8PfNuHiMZ.png" alt="Java 集合框架概览"></p><p><code>List</code>: 存储的元素是有序的、可重复的。</p><p><code>Set</code>: 存储的元素是无序的（有有序的实现类）、不可重复的。</p><p><code>Queue</code>: 按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。</p><p><code>Map</code>: 使用键值对（key-value）存储，key 是无序的、不可重复的，value 是无序的、可重复的。</p><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><ul><li><code>ArrayList</code>：<code>Object[]</code> 数组，无参构造初始化时是一个空数组，第一次插入元素时创建大小为10的数组，超出限制时会增加50%的容量，并且数据以 System.arraycopy() 复制到新的数组。</li><li><code>Vector</code>：<code>Object[]</code> 数组</li><li><code>LinkedList</code>：<strong>双向</strong>链表</li></ul><h4 id="ArrayList-和-Array（数组）的区别？"><a href="#ArrayList-和-Array（数组）的区别？" class="headerlink" title="ArrayList 和 Array（数组）的区别？"></a>ArrayList 和 Array（数组）的区别？</h4><p><code>ArrayList</code> 内部基于动态数组实现，比 <code>Array</code>（静态数组） 使用起来更加灵活：</p><ul><li><code>ArrayList</code>会根据实际存储的元素动态地扩容或缩容，而 <code>Array</code> 被创建之后就不能改变它的长度了。</li><li><code>ArrayList</code> 允许你使用泛型来确保类型安全，<code>Array</code> 则不可以。</li><li><code>ArrayList</code> 中只能存储对象。对于基本类型数据，需要使用其对应的包装类（如 Integer、Double 等）。<code>Array</code> 可以直接存储基本类型数据，也可以存储对象。</li><li><code>ArrayList</code> 支持插入、删除、遍历等常见操作，并且提供了丰富的 API 操作方法，比如 <code>add()</code>、<code>remove()</code>等。<code>Array</code> 只是一个固定长度的数组，只能按照下标访问其中的元素，不具备动态添加、删除元素的能力。</li><li><code>ArrayList</code>创建时不需要指定大小，而<code>Array</code>创建时必须指定大小。</li></ul><h4 id="ArrayList-插入和删除元素的时间复杂度？"><a href="#ArrayList-插入和删除元素的时间复杂度？" class="headerlink" title="ArrayList 插入和删除元素的时间复杂度？"></a>ArrayList 插入和删除元素的时间复杂度？</h4><ul><li>头部插入&#x2F;删除：由于需要将所有元素都依次向后&#x2F;前移动一个位置，因此时间复杂度是 O(n)。</li><li>尾部插入：当 <code>ArrayList</code> 的容量未达到极限时，往列表末尾插入元素的时间复杂度是 O(1)，因为它只需要在数组末尾添加一个元素即可；当容量已达到极限并且需要扩容时，则需要执行一次 O(n) 的操作将原数组复制到新的更大的数组中，然后再执行 O(1) 的操作添加元素。</li><li>尾部删除：当删除的元素位于列表末尾时，时间复杂度为 O(1)。</li><li>指定位置插入&#x2F;删除：需要将目标位置之后的所有元素都向后&#x2F;前移动一个位置，这个过程需要移动平均 n&#x2F;2 个元素，因此时间复杂度为 O(n)。</li></ul><h4 id="LinkedList-插入和删除元素的时间复杂度？"><a href="#LinkedList-插入和删除元素的时间复杂度？" class="headerlink" title="LinkedList 插入和删除元素的时间复杂度？"></a>LinkedList 插入和删除元素的时间复杂度？</h4><ul><li>头部插入&#x2F;删除：只需要修改头结点的指针即可完成插入&#x2F;删除操作，因此时间复杂度为 O(1)。</li><li>尾部插入&#x2F;删除：只需要修改尾结点的指针即可完成插入&#x2F;删除操作，因此时间复杂度为 O(1)。</li><li>指定位置插入&#x2F;删除：需要先移动到指定位置，再修改指定节点的指针完成插入&#x2F;删除，因此需要移动平均 n&#x2F;2 个元素，时间复杂度为 O(n)。</li></ul><h4 id="LinkedList-为什么不能实现-RandomAccess-接口？"><a href="#LinkedList-为什么不能实现-RandomAccess-接口？" class="headerlink" title="LinkedList 为什么不能实现 RandomAccess 接口？"></a>LinkedList 为什么不能实现 RandomAccess 接口？</h4><p><code>RandomAccess</code> 是一个标记接口，用来表明实现该接口的类支持随机访问（即可以通过索引快速访问元素）。由于 <code>LinkedList</code> 底层数据结构是链表，内存地址不连续，只能通过指针来定位，不支持随机快速访问，所以不能实现 <code>RandomAccess</code> 接口</p><h4 id="ArrayList-与-LinkedList-区别"><a href="#ArrayList-与-LinkedList-区别" class="headerlink" title="ArrayList 与 LinkedList 区别?"></a>ArrayList 与 LinkedList 区别?</h4><ul><li><p><code>ArrayList</code> 底层使用的是 <strong><code>Object</code> 数组</strong>；而<code>LinkedList</code> 底层使用的是 <strong>双向链表</strong> 数据结构</p></li><li><p>那么在插入和删除时：</p><ul><li><code>ArrayList</code> 除了在尾部追加或删除元素复杂度为O(1)，其他位置都是O(n)，因为需要执行后移或前移操作（插入元素可能还需要扩容，然后拷贝元素）。</li><li>而<code>LinkedList</code> 在头尾插入或者删除元素时间复杂度都是 O(1)，如果是要在中间的指定位置插入和删除元素的话， 时间复杂度为 O(n) ，因为需要先定位到指定位置再插入和删除。</li></ul></li><li><p><strong>从随机访问的角度来说：</strong> <code>ArrayList</code>（实现了 <code>RandomAccess</code> 接口） 可以通过元素的下标快速获取对应位置的元素对象(对应于<code>get(int index)</code>方法)。 而<code>LinkedList</code> 因为是链表，地址空间不连续，故不支持。</p></li><li><p><strong>从内存空间占用：</strong><code>LinkedList</code>空间占用一般更大，因为每个节点都需要存前驱和后继两个引用； <code>ArrayList</code> 的空间浪费主要体现在在 list 列表的结尾会预留一定的容量空间。</p></li><li><p>插入海量数据，谁快？</p><p><strong>如果头插选linkedlist（ArrayList需要移动大量元素）,如果中间和尾部插入要选Arraylist（数组越大，每次扩容扩充的容量越大，扩容对性能影响越小）</strong></p></li></ul><h4 id="谈谈CopyOnWriteArrayList的原理"><a href="#谈谈CopyOnWriteArrayList的原理" class="headerlink" title="谈谈CopyOnWriteArrayList的原理"></a>谈谈CopyOnWriteArrayList的原理</h4><p>ArrayList进行add时不加锁。CopyOnWriteArrayList是Java并发包里提供的并发类，简单来说它就是一个<strong>线程安全且读操作无锁</strong>的ArrayList。正如其名字一样，在<strong>写操作时会复制一份新的List，在新的List上完成写操作，然后再将原引用指向新的List</strong>。这样就保证了写操作的线程安全。</p><ul><li>优点：读操作性能很高，因为无需任何同步措施，比较适用于读多写少的并发场景。在遍历传统的List时，若中途有别的线程对其进行修改，则会抛出ConcurrentModificationException异常。而CopyOnWriteArrayList由于其”读写分离”的思想，遍历和修改操作分别作用在不同的List容器，所以在使用迭代器进行遍历时候，也就不会抛出ConcurrentModificationException异常了。</li><li>缺点：一是内存占用问题，毕竟每次执行写操作都要将原容器拷贝一份，数据量大时，对内存压力较大，可能会引起频繁GC。二是无法保证实时性，Vector对于读写操作均加锁同步，可以保证读和写的强一致性。而CopyOnWriteArrayList由于其实现策略的原因，写和读分别作用在新老不同容器上，在写操作执行过程中，读不会阻塞但读取到的却是老容器的数据。</li></ul><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>HashSet是基于HashMap实现的，默认构造函数是构建一个初始容量为16，负载因子为0.75 的HashMap。它封装了一个 HashMap 对象来存储所有的集合元素，所有放入 HashSet 中的集合元素实际上由 HashMap 的 key 来保存，而 HashMap 的 value 则存储了一个 PRESENT，它是一个静态的 Object 对象。</p><h4 id="比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同"><a href="#比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同" class="headerlink" title="比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同"></a>比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同</h4><ul><li><code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 都是 <code>Set</code> 接口的实现类，都能保证元素唯一，并且都不是线程安全的。</li><li><code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 的主要区别在于底层数据结构不同。<code>HashSet</code> 的底层数据结构是哈希表（基于 <code>HashMap</code> 实现）。<code>LinkedHashSet</code> 的底层数据结构是链表和哈希表，元素的插入和取出顺序满足 FIFO。<code>TreeSet</code> 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序。</li><li>底层数据结构不同又导致这三者的应用场景不同。<code>HashSet</code> 用于不需要保证元素插入和取出顺序的场景，<code>LinkedHashSet</code> 用于保证元素的插入和取出顺序满足 FIFO 的场景，<code>TreeSet</code> 用于支持对元素自定义排序规则的场景</li></ul><h4 id="定制排序"><a href="#定制排序" class="headerlink" title="定制排序"></a>定制排序</h4><ul><li><p>重写CompareTo</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Person&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * T重写compareTo方法实现按年龄来排序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Person o)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.age - o.getAge();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>重写Compare</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(arrayList, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> o1 - o2;<span class="comment">//o1 &gt; o2，则o2排在o1前，即降序</span></span><br><span class="line">        <span class="comment">// return o2.compareTo(o1);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><h4 id="ArrayDeque-与-LinkedList-的区别"><a href="#ArrayDeque-与-LinkedList-的区别" class="headerlink" title="ArrayDeque 与 LinkedList 的区别"></a>ArrayDeque 与 LinkedList 的区别</h4><p><code>ArrayDeque</code> 和 <code>LinkedList</code> 都实现了 <code>Deque</code> 接口，两者都具有队列的功能，但两者有什么区别呢？</p><ul><li><code>ArrayDeque</code> 是基于可变长的数组和双指针来实现，而 <code>LinkedList</code> 则通过链表来实现。</li><li><code>ArrayDeque</code> 不支持存储 <code>NULL</code> 数据，但 <code>LinkedList</code> 支持。</li><li><code>ArrayDeque</code> 插入时可能存在扩容过程, 不过均摊后的插入操作依然为 O(1)。虽然 <code>LinkedList</code> 不需要扩容，但是每次插入数据时均需要申请新的堆空间，均摊性能相比更慢。</li></ul><p>从性能的角度上，选用 <code>ArrayDeque</code> 来实现队列要比 <code>LinkedList</code> 更好。</p><h4 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h4><p><code>BlockingQueue</code> （阻塞队列）是一个接口，继承自 <code>Queue</code>。<code>BlockingQueue</code>阻塞的原因是其支持当队列没有元素时一直阻塞，直到有元素；还支持如果队列已满，一直等到队列可以放入新元素时再放入。</p><p><code>BlockingQueue</code> 常用于生产者-消费者模型中，生产者线程会向队列中添加数据，而消费者线程会从队列中取出数据进行处理。</p><p>常见实现类：</p><ul><li><p><code>ArrayBlockingQueue</code>：使用数组实现的有界阻塞队列。</p></li><li><p><code>LinkedBlockingQueue</code>：使用单向链表实现的可选有界阻塞队列。</p></li></ul><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><h4 id="HashMap底层实现"><a href="#HashMap底层实现" class="headerlink" title="HashMap底层实现"></a>HashMap底层实现</h4><p>JDK1.8 之前 <code>HashMap</code> 底层是 <strong>数组，用拉链法解决Hash冲突</strong>。HashMap是懒加载的，第一次执行put时，会进行第一次扩容，初始化大小默认为16。put时，先把 key 的 <code>hashcode</code> 经过hash方法处理过后得到 hash 值，然后通过 <code>(n - 1) &amp; hash</code> 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果对应位置为空，则直接放入；存在元素的话，就先判断该元素的key与要存入的元素的 key的hash 值是否相等，相等再用&#x3D;&#x3D;或equals判断两个key是否相同，如果相同就直接覆盖，不相同就通过拉链法解决冲突。</p><p>因为链表查询复杂度是O（n），JDK1.8后引入红黑树（红黑树就是为了解决二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构）。</p><p>当链表长度大于等于阈值（默认为 8），先判断数组长度是否小于64，如是则执行一次扩容，否则将链表转化为红黑树。当树的节点数小于6的时候，红黑树又会退化成链表。</p><p>当HashMap的元素个数大于数组长度*负载因子的时候，也会执行扩容。负载因子默认是0.75，主要是时间和空间的权衡。如果负载因子太大，虽然空间利用率高了，但hash碰撞的可能性也高了，查询效率也就低了；负载因子太小，空间利用率就低了。</p><p>扩容时，会把数组容量扩充到原来两倍。扩容时将原hash表数据全部重新计算hash值，重新分配位置。之所以按2的幂次扩容，主要是为了让元素分布更加均匀，减少Hash冲突。因为HashMap计算数组下标时用“ <code>(n - 1) &amp; hash</code>”（n 代表数组长度），若数组长度为2的幂次，其二进制表示为全1，与运算只有二者都为1的时候其运算结果才是1，如果n-1的二进制表示其中一位是0，那么对应位的与运算结果只能是0，也就是说数组中一定会有无法散列到的位置。</p><ul><li><p>哈希冲突</p><p>开放寻址法：当遇到哈希冲突时，需要使用一种探测技术来寻找下一个可用的哈希槽。最简单的探测技术是线性探测，即从发生冲突的槽开始，逐一扫描直到找到一个空闲槽。</p><p>开放寻址法查找过程如下：</p><ul><li>计算关键字的哈希值</li><li>从哈希槽的位置开始查找，如果该位置存储的关键字与目标关键字相同，则找到了对应数据</li><li>如果该位置存储的关键字不是目标关键字，则按照相应的探测方式继续查找</li><li>如果查找到最后一个哈希槽仍未找到目标数据，则说明目标数据不存在于哈希表中</li></ul><p>为什么不用开放寻址？</p><p>元素较多时，可能连续冲突</p></li></ul><h4 id="为什么用红黑树"><a href="#为什么用红黑树" class="headerlink" title="为什么用红黑树"></a>为什么用红黑树</h4><p>红黑树是近似平衡的二叉树，不像AVL树，AVL 树是严格的平衡树，上述的最短路径与最长路径的差不能超过 1，AVL 允许的差值小；在进行大量插入和删除操作时，会频繁地进行平衡调整，严重降低效率；但查询时AVL略快于红黑树。</p><p>B&#x2F;B+树更矮胖，适用于数据存储在磁盘上的场景，如索引，可以减少磁盘IO次数。如果数据在内存中，查询性能低于红黑树，且在数据量不是很多的情况下，数据都会“挤在”一个结点里面。这个时候遍历效率就退化成了链表。</p><ul><li><p>为什么不用二叉查找树？</p><p>（1）若左子树不空，则左子树上所有结点的值均小于它的<a href="https://baike.baidu.com/item/%E6%A0%B9%E7%BB%93%E7%82%B9/9795570?fromModule=lemma_inlink">根结点</a>的值；</p><p>（2）若右<a href="https://baike.baidu.com/item/%E5%AD%90%E6%A0%91/1624505?fromModule=lemma_inlink">子树</a>不空，则右子树上所有结点的值均大于它的根结点的值；</p><p>（3）左、右子树也分别为二叉查找（排序）树；</p><p>缺点：不保持平衡，可能退化为链表</p><p>红黑树介于AVL树和二叉查找树之间，是近似平衡的二叉树，既可以避免退化成链表，又不需要频繁进行平衡性调整，性能相对较好</p></li></ul><ul><li><p>为什么不用跳表？</p><p>HashMap 的 各个Entry 之间并没有内在的排序关系。跳表需要元素之间存在排序关系，否则就无法跳跃查找</p><p>Java中也有跳表的应用：ConcurrentSkipListMap，是一个有序的map，可以看做是TreeMap的并发实现</p></li></ul><h4 id="树化阈值为什么是8"><a href="#树化阈值为什么是8" class="headerlink" title="树化阈值为什么是8"></a>树化阈值为什么是8</h4><p>如果 hashCode 分布良好，也就是 hash 计算的结果离散好的话，那么红黑树这种形式是很少会被用到的，因为各个值都均匀分布，很少出现链表很长的情况。在理想情况下，链表长度符合泊松分布，各个长度的命中概率依次递减，<strong>当长度为 8 的时候，概率仅为 0.00000006</strong>。这是一个小于千万分之一的概率，通常我们的 Map 里面是不会存储这么多的数据的，所以通常情况下，并不会发生从链表向红黑树的转换。</p><blockquote><p>在链表长度为6时，从红黑树退化为链表。因为红黑树的平衡维护成本较高，数据量小时性能还不如链表</p></blockquote><h4 id="Hash方法的作用"><a href="#Hash方法的作用" class="headerlink" title="Hash方法的作用"></a>Hash方法的作用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HashMap的数组默认长度是16，因为大多数情况来说数组长度都不会太大，所以影响 h &amp; (length-1)计算结果的主要因素就是h的低位数据。比如只有当数组长度length大于2^16即大于65536的时候，h的高16位才会对 h &amp; (length-1)的计算结果产生影响，所以在HashMap中我们也主要对h的低16位进行优化（异或运算结果等于1和0的概率是一样的），也就是让h的低16位的数据尽量分散，上面的 (h &#x3D; key.hashCode()) ^ (h &gt;&gt;&gt; 16)算法也是基于这个目的而设计的。</p><h4 id="HashMap的put流程"><a href="#HashMap的put流程" class="headerlink" title="HashMap的put流程"></a>HashMap的put流程</h4><ol><li><p>首次扩容：</p><p>先判断数组是否为空（懒加载，初始为空），若数组为空则进行第一次扩容（resize，初始化大小为16）；</p></li><li><p>计算索引：</p><p>通过hash算法，根据key的hashcode计算得到hash值，再用hash &amp; (数组长度 - 1)计算得到数据下标，即键值对在数组中的位置；</p></li><li><p>插入数据：</p><ul><li>如果当前位置元素为空，则直接插入数据；</li><li>如果当前位置元素非空，且key已存在（hash值相等并且 &#x3D;&#x3D; || equals），则直接覆盖其value；</li><li>如果当前位置元素非空，且key不存在，则将数据链到链表末端；</li><li>若链表长度达到8，先判断数组长度是否小于64，如是则执行resize扩容，否则将链表转化为红黑树</li></ul></li><li><p>再次扩容</p><p>如果数组中元素个数（size）超过threshold，则再次进行扩容操作。</p></li></ol><h4 id="HashMap的get流程"><a href="#HashMap的get流程" class="headerlink" title="HashMap的get流程"></a>HashMap的get流程</h4><p>步骤1：首先对传入值keya进行hash运算，依然是高位和地位进行^运算，得到的hash值和n-1进行&amp;运算，最终得到索引值</p><ul><li>为什么用&amp;？ 效果与%n一致，但更高效</li></ul><p>步骤2：首先判断该数组是否为空，是否长度为0，当前索引位置的第一个元素是否为null，满足任意一个条件返回null，结束</p><p>步骤3：将传入值key的hash值与当前索引位第一个元素的hash值进行比较，一样则继续比较是否为相同引用（&#x3D;&#x3D;），或者equals是否相等，若相等，返回其value,结束。</p><p>步骤4：不相等的话，会出现两种可能性，如果当前索引位置后面还有元素，则可能在后面，如果没有元素了，直接退出，返回null，结束。</p><p>步骤5：当前索引位置不止1个元素的情况下，首先判断，当前索引位置的第一个节点是否为树节点，如果是树节点，在红黑树里面进行遍历。</p><p>步骤6：如果不是树节点，那么就是链表，在while中进行遍历，判断当前元素是否传入值相等，不等则循环到链表的最后一个元素为止。相等则返回该value.</p><h4 id="HashMap长度为什么是2的幂次"><a href="#HashMap长度为什么是2的幂次" class="headerlink" title="HashMap长度为什么是2的幂次"></a>HashMap长度为什么是2的幂次</h4><p>HashMap计算数组下标时用“ <code>(n - 1) &amp; hash</code>”（n 代表数组长度），若数组长度为2的幂次，其二进制表示为全1，与运算只有二者都为1的时候其运算结果才是1，如果n-1的二进制表示其中一位是0，那么对应位的与运算结果只能是0，也就是说数组中一定会有无法散列到的位置。所以为了尽量使数据分布更加均匀，减少Hash碰撞，hashmap的长度最好是2的幂次。</p><p>注：如果初始化容量不是2的幂次，会设置为<strong>大于</strong>这个数的最近的2的幂次</p><h4 id="HashMap为什么线程不安全"><a href="#HashMap为什么线程不安全" class="headerlink" title="HashMap为什么线程不安全"></a>HashMap为什么线程不安全</h4><ul><li><p>并发put操作有数据覆盖的风险。</p><p>两个线程 1,2 同时进行 put 操作，hash 函数计算出的插入下标是相同的，并且对应位置为空。假设当前线程 1 执行完哈希冲突判断后，由于时间片耗尽而回到就绪态。而后线程 2 获得时间片先完成了插入操作。随后，线程 1 获得时间片，由于之前已经进行过 hash 碰撞的判断，所有此时会直接进行插入，这就导致线程 2 插入的数据被线程 1 覆盖了</p></li><li><p>JDK1.8前，扩容时有死循环的风险（简单来说，头插法在并发情况下rehash时可能导致环形链表）。</p><p>JDK1.7 及之前版本的 <code>HashMap</code> 在多线程环境下扩容操作可能存在死循环问题，这是由于当一个桶位中有多个元素需要进行扩容时，多个线程同时对链表进行操作，头插法可能会导致链表中的节点指向错误的位置，从而形成一个<strong>环形链表</strong>，进而使得查询元素的操作陷入死循环无法结束。</p><p>为了解决这个问题，JDK1.8 版本的 HashMap 采用了<strong>尾插法</strong>而不是头插法来避免链表倒置，使得插入的节点永远都是放在链表的末尾，避免了链表中的环形结构。但是还是不建议在多线程下使用 <code>HashMap</code>，因为多线程下使用 <code>HashMap</code> 还是会存在数据覆盖的问题。并发环境下，推荐使用 <code>ConcurrentHashMap</code> 。</p></li></ul><h4 id="HashMap遍历"><a href="#HashMap遍历" class="headerlink" title="HashMap遍历"></a>HashMap遍历</h4><p>HashMap <strong>遍历从大的方向来说，可分为以下 4 类</strong>：</p><ol><li><p>迭代器（Iterator）方式遍历（可以动态的删除元素）；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">*<span class="comment">// 创建并赋值 HashMap*</span></span><br><span class="line">Map&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">*<span class="comment">// 遍历*</span></span><br><span class="line">Iterator&lt;Integer&gt; iterator = map.keySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">  <span class="type">Integer</span> <span class="variable">key</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">  System.out.println(key);</span><br><span class="line">  System.out.println(map.get(key));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>For Each 方式遍历（keySet，性能较差）；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">*<span class="comment">// 遍历*</span></span><br><span class="line"><span class="keyword">for</span> (Integer key : map.keySet()) &#123;</span><br><span class="line">  System.out.println(key);</span><br><span class="line">  System.out.println(map.get(key));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Lambda 表达式遍历（JDK 1.8+）;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">map.forEach((key, value) -&gt; &#123;</span><br><span class="line">            System.out.println(key);</span><br><span class="line">            System.out.println(value);</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure></li><li><p>Streams API 遍历（JDK 1.8+）（entrySet性能较好）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">map.entrySet().stream().forEach((entry) -&gt; &#123;</span><br><span class="line">           System.out.println(entry.getKey());</span><br><span class="line">           System.out.println(entry.getValue());</span><br><span class="line">       &#125;);</span><br></pre></td></tr></table></figure></li></ol><h4 id="HashMap扩容（rehash）机制"><a href="#HashMap扩容（rehash）机制" class="headerlink" title="HashMap扩容（rehash）机制"></a>HashMap扩容（rehash）机制</h4><ol><li>如果数组为空，则进行首次扩容。数组的初始容量为16（懒加载），每次扩容变为原来2倍，一是为了提高性能使用足够大的数组，二是为了能使用位运算代替取模预算。</li><li>数组是否需要扩充是通过负载因子判断的，插入元素后，如果元素个数 &gt; 数组容量 * 负载因子时，就会扩充数组容量为原来两倍，将原hash表数据全部重新计算hash值（<em>JDK1.8中不需要重新计算 hash，只需要看看原来的 hash 值新增的那个 bit 是 1 还是 0 就可以了（旧值和新值按位与），是 0 的话索引没变，是 1 的话索引变成 “原位置 + 旧容量” ）</em>，重新分配位置。负载因子可由构造器传入。我们也可以设置大于1的负载因子，这样数组就不会扩充，牺牲性能，节省内存。</li><li>为了解决碰撞，数组中的元素是单向链表类型。当链表长度到达一个阈值时（8），先判断数组长度是否小于64，如是则执行resize来扩容，否则将链表转化为红黑树以提高性能。而当链表长度缩小到另一个阈值时（6），又会将红黑树转换回单向链表提高性能。</li></ol><p>具体流程：</p><p>①：先生成新数组；</p><p>②：遍历老数组中的每个位置上的链表或红黑树；</p><p>③：如果是链表，则直接将链表中的每个元素重新计算下标，并添加到新数组中去；</p><p>④：如果是红黑树，则先遍历红黑树，先计算出红黑树中每个元素对应在新数组中的下标位置；</p><p>a：统计每个下标位置的元素个数；</p><p>b：如果该位置下的元素个数超过了8，则生成一个新的红黑树，并将根节点添加到新数组的对应位置；</p><p>c：如果该位置下的元素个数没有超过8，那么则生成一个链表，并将链表的头节点添加到新数组的对应位置；</p><p>⑤：所有元素转移完了之后，将新数组赋值给HashMap对象的table属性。</p><p>刁钻问题：多线程环境，扩容时插入元素是放在旧的table还是新的table？</p><p>个人认为都有可能</p><h4 id="负载因子为什么是0-75"><a href="#负载因子为什么是0-75" class="headerlink" title="负载因子为什么是0.75"></a>负载因子为什么是0.75</h4><p>负载因子主要用来判断数组是否需要扩充，如果当前元素个数大于数组容量*负载因子时，就会扩充数组。源码注释中写了0.75提供了一个好的时空开销之间的权衡。如果负载因子太大，虽然空间利用率高了，但hash碰撞的可能性也高了，查询效率也就低了；负载因子太小，空间利用率就低了。</p><h4 id="HashMap-和-Hashtable-的区别"><a href="#HashMap-和-Hashtable-的区别" class="headerlink" title="HashMap 和 Hashtable 的区别"></a>HashMap 和 Hashtable 的区别</h4><ul><li><strong>线程安全：</strong> <code>HashMap</code> 是非线程安全的，<code>Hashtable</code> 是线程安全的,因为 <code>Hashtable</code> 内部的方法基本都经过<code>synchronized</code> 修饰。因为线程安全的问题，<code>HashMap</code> 要比 <code>Hashtable</code> 效率高一点。</li><li><strong>对 Null key 和 Null value 的支持：</strong> <code>HashMap</code> 可以存储 null 的 key（hash值为0） 和 value；Hashtable 不允许有 null 键和 null 值，否则会抛出 <code>NullPointerException</code>。</li><li><strong>初始容量大小和每次扩充容量大小的不同：</strong> ① 创建时如果不指定容量初始值，<code>HashMap</code> 默认的初始化大小为<strong>16</strong>。之后每次扩充，容量变为原来的 <strong>2 倍</strong>。<code>Hashtable</code> 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。② 创建时如果给定了容量初始值，<code>HashMap</code> 会将其扩充为 2 的幂次方大小。也就是说 <code>HashMap</code> 总是使用 2 的幂作为哈希表的大小； <code>Hashtable</code> 会直接使用你给定的大小。</li><li><strong>底层数据结构：</strong> JDK1.8 以后的 <code>HashMap</code> 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）时，将链表转化为红黑树（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树），以减少搜索时间。<code>Hashtable</code> 没有这样的机制。</li></ul><h4 id="ConcurrentHashMap-和-Hashtable-的区别"><a href="#ConcurrentHashMap-和-Hashtable-的区别" class="headerlink" title="ConcurrentHashMap 和 Hashtable 的区别"></a>ConcurrentHashMap 和 Hashtable 的区别</h4><p><code>ConcurrentHashMap</code> 和 <code>Hashtable</code> 的区别主要体现在实现线程安全的方式上不同。</p><ul><li><strong>底层数据结构：</strong> <code>Hashtable</code> 和 JDK1.8 之前的 <code>HashMap</code> 的底层数据结构类似都是采用 <strong>数组+链表</strong> 的形式。<code>ConcurrentHashMap</code>在JDK1.8 采用的数据结构跟 <code>HashMap</code> 的结构一样，数组+链表&#x2F;红黑树。</li><li>实现线程安全的方式（重要）：<ul><li>在 JDK1.7 的时候，<code>ConcurrentHashMap</code> 对整个桶数组进行了分割分段(<code>Segment</code>，分段锁)，每一把锁只锁容器其中一部分数据（下面有示意图），多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。</li><li>到了 JDK1.8 的时候，<code>ConcurrentHashMap</code> 已经摒弃了 <code>Segment</code> 的概念，而是直接用 <code>Node</code> 数组+链表+红黑树的数据结构来实现，并发控制使用 <code>synchronized</code> 和 CAS 来操作。（JDK1.6 以后 <code>synchronized</code> 锁做了很多优化） 整个看起来就像是优化过且线程安全的 <code>HashMap</code>，虽然在 JDK1.8 中还能看到 <code>Segment</code> 的数据结构，但是已经简化了属性，只是为了兼容旧版本；</li><li><strong><code>Hashtable</code>(同一把锁)</strong> :使用 <code>synchronized</code> 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</li></ul></li></ul><h4 id="ConcurrentHashMap-和-Hashtable-为什么不能存null？"><a href="#ConcurrentHashMap-和-Hashtable-为什么不能存null？" class="headerlink" title="ConcurrentHashMap 和 Hashtable 为什么不能存null？"></a>ConcurrentHashMap 和 Hashtable 为什么不能存null？</h4><p>多线程情况下可能产生歧义。</p><p>如果map.get(key)返回值是null，可能有两种情况：①key本身就不存在；②key存在，但value是null</p><p>对于HashMap，可以用contains方法判断key是否存在，不需要考虑多线程场景的问题。</p><p>但对于ConcurrentHashMap，在用contains方法判断key是否存在时，可能原本key不存在，但正好有其他线程插入了key并且value为null，导致contains方法返回true。也就是说没办法通过contains方法判断get返回值为null的原因。作为一个线程安全的集合，不能容忍这种情况（ConcurrentHashMap作者Doug lea说的。如果是null会抛空指针异常）。</p><h4 id="JDK-1-7-和-JDK-1-8-的-ConcurrentHashMap-实现有什么不同？"><a href="#JDK-1-7-和-JDK-1-8-的-ConcurrentHashMap-实现有什么不同？" class="headerlink" title="JDK 1.7 和 JDK 1.8 的 ConcurrentHashMap 实现有什么不同？"></a>JDK 1.7 和 JDK 1.8 的 ConcurrentHashMap 实现有什么不同？</h4><ul><li><strong>线程安全实现方式</strong>：JDK 1.7 采用 <code>Segment</code> 分段锁来保证安全，<code>segment</code>数组默认大小16，即默认并发度为16. <code>Segment</code> 是继承自 <code>ReentrantLock</code>。JDK1.8 放弃了 <code>Segment</code> 分段锁的设计，采用 <code>Node + CAS + synchronized</code> 保证线程安全，锁粒度更细，<code>synchronized</code> 只锁定当前链表或红黑二叉树的首节点。</li><li><strong>Hash 碰撞解决方法</strong> : JDK 1.7 采用拉链法，JDK1.8 采用拉链法结合红黑树（链表长度超过一定阈值时，将链表转换为红黑树）。</li><li><strong>并发度</strong>：JDK 1.7 最大并发度是 Segment 的个数，默认是 16。JDK 1.8 最大并发度是 Node 数组的大小，并发度更大。</li></ul><h4 id="说一说你对LinkedHashMap的理解"><a href="#说一说你对LinkedHashMap的理解" class="headerlink" title="说一说你对LinkedHashMap的理解"></a>说一说你对LinkedHashMap的理解</h4><p>LinkedHashMap继承于HashMap，它在HashMap的基础上，通过双向链表来维护key-value对的顺序（其实只需要考虑key的顺序），让迭代顺序与key-value对的插入顺序保持一致。</p><p>LinkedHashMap可以避免对HashMap、Hashtable里的key-value对进行排序（只要插入key-value对时保持顺序即可），同时又可避免使用TreeMap所增加的成本。</p><p>LinkedHashMap需要维护元素的插入顺序，因此性能略低于HashMap的性能。但因为它以链表来维护内部顺序，所以在迭代访问Map里的全部元素时将有较好的性能。</p><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h3 id="内存结构（运行时数据区）"><a href="#内存结构（运行时数据区）" class="headerlink" title="内存结构（运行时数据区）"></a>内存结构（运行时数据区）</h3><ul><li><p>方法区</p><p>属于共享内存区域，存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。<strong>运行时常量池</strong>，属于方法区的一部分，用于存放<strong>编译期生成的各种字面量和符号引用</strong>。</p><p>JDK1.8之前，Hotspot虚拟机对方法区的实现叫做永久代，1.8之后改为元空间。二者区别主要在于<strong>永久代是在JVM虚拟机中分配内存，而元空间则是在本地内存（本机）中分配的</strong>。很多类是在运行期间加载的，它们所占用的空间完全不可控，所以改为使用本地内存，避免对JVM内存的影响。根据《Java虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出OutOfMemoryError异常。</p></li><li><p>堆</p><p>线程共享，主要是存放对象实例和数组。如果在Java堆中没有内存完成实例分配，并且堆也无法再扩展时，Java虚拟机将会抛出OutOfMemoryError异常。</p><p>JDK1.7 之前，字符串常量池存放在永久代。JDK1.7 字符串常量池（StringTable，可以简单理解为一个固定大小的<code>HashTable</code>）从永久代移动了 Java 堆中。</p><p>PS：实际上写入时并不完全共享，JVM会为线程在堆上划分一块专属的分配缓冲区来提高对象分配效率。详见：TLAB</p></li><li><p>虚拟机栈</p><p>线程私有，方法执行的过程就是一个个栈帧从入栈到出栈的过程。每个方法在执行时都会创建一个栈帧(Stack Frame)用于存储局部变量表、操作数栈、动态链接、方法出口、<strong>程序计数器</strong>等信息。如果线程入栈的栈帧超过限制就会抛出StackOverFlowError，如果支持动态扩展，那么扩展时申请内存失败则抛出OutOfMemoryError。</p></li><li><p>本地方法栈</p><p>和虚拟机栈的功能类似，区别是作用于Native方法。</p></li><li><p>程序计数器</p><p>线程私有，记录着当前线程所执行的字节码的行号。其作用主要是多线程场景下，记录线程中指令的执行位置。以便被挂起的线程再次被激活时，CPU能从其挂起前执行的位置继续执行。唯一一个在 Java 虚拟机规范中没有规定任何 OutOfMemoryError 情况的区域。注意：如果线程执行的是个java方法，那么计数器记录虚拟机字节码指令的地址。如果为native（底层方法），那么计数器为空。</p></li></ul><h3 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h3><p>从原理聊JVM：染色标记和垃圾回收算法<a href="https://mp.weixin.qq.com/s/dvDYRi9SONhfItIafLnsYw">https://mp.weixin.qq.com/s/dvDYRi9SONhfItIafLnsYw</a></p><h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><p><img src="https://s2.loli.net/2023/06/12/4lBUQHu9t2RLKYb.png" alt="强软弱虚"></p><p><strong>1．强引用（StrongReference）</strong></p><p>以前我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，那就类似于<strong>必不可少的生活用品</strong>，垃圾回收器绝不会回收它。当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。</p><p><strong>2．软引用（SoftReference）</strong></p><p>如果一个对象只具有软引用，那就类似于<strong>可有可无的生活用品</strong>。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。</p><p>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA 虚拟机就会把这个软引用加入到与之关联的引用队列中。</p><p><strong>3．弱引用（WeakReference）</strong></p><p>如果一个对象只具有弱引用，那就类似于<strong>可有可无的生活用品</strong>。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。</p><p>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p><p><strong>4．虚引用（PhantomReference）</strong></p><p>“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。</p><p><strong>虚引用主要用来跟踪对象被垃圾回收的活动</strong>。</p><p><strong>虚引用与软引用和弱引用的一个区别在于：</strong> 虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</p><p>特别注意，在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为<strong>软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生</strong>。</p><p>finalize</p><p>当一个对象没有引用的时候，对象的垃圾回收器会调用finalize方法。</p><ul><li>当对象被回收时，系统自动调用该对象的finalize方法，子类可以重写该方法，做一些释放资源的操作。</li><li>什么时候被回收：当某个对象没有任何引用时，jvm就认为这个对象是一个垃圾对象，就会使用垃圾回收机制来销毁该对象，在销毁对象前，会先调用finalize方法。</li></ul><p>垃圾回收机制的调用，是由系统来决定(有自己的GC算法)，也可以通过System.gc()主动触发垃圾回收机制。</p><h4 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h4><ul><li><p>方法区溢出场景</p><ul><li><p>spring、mybatis都采用动态代理，会在运行时动态生成大量代理类</p></li><li><p>当应用程序频繁地使用反射进行类的动态加载、方法的调用和字段的访问时，会导致方法区不断增加新的类定义和相关信息，从而消耗掉方法区的内存。</p></li></ul></li></ul><ul><li><p>一个线程OOM后，其他线程还能执行吗</p><p>当一个线程OOM时，它通常是因为它的JVM Stack或堆已经用尽了可用内存。这意味着该线程将无法继续执行，并将抛出OutOfMemoryError异常。<strong>但是，这不会影响其他线程的运行，因为每个线程都有自己的JVM Stack和堆。</strong></p></li></ul><h4 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h4><ul><li>场景<ul><li>资源未关闭或释放导致内存泄露。常见的资源类有网络连接，数据库连接以及 IO 流</li><li>ThreadLocal</li></ul></li></ul><h3 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h3><p>类从被加载到虚拟机内存中开始到卸载出内存为止，它的整个生命周期可以简单概括为 7 个阶段：：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）。其中，验证、准备和解析这三个阶段可以统称为连接（Linking）</p><h4 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h4><p>系统加载 Class 类型的文件主要三步：<strong>加载-&gt;连接-&gt;初始化</strong>。连接过程又可分为三步：<strong>验证-&gt;准备-&gt;解析</strong>。</p><h2 id="并发编程（JUC）"><a href="#并发编程（JUC）" class="headerlink" title="并发编程（JUC）"></a>并发编程（JUC）</h2><h3 id="并发编程三个重要特性"><a href="#并发编程三个重要特性" class="headerlink" title="并发编程三个重要特性"></a>并发编程三个重要特性</h3><p>腾讯技术：<a href="https://mp.weixin.qq.com/s/sU_P9CHnNlxnLPf2UdstRg">https://mp.weixin.qq.com/s/sU_P9CHnNlxnLPf2UdstRg</a></p><p>JMM：Java定义的一组规范，用以屏蔽操作系统内存模型的差异，主要</p><p>定义了共享变量的访问方式，围绕原子性、可见性、有序性来解决并发编程中的线程安全问题。</p><ul><li><p>原子性</p><p><strong>一次操作或者多次操作，要么所有的操作全部都得到执行并且不会受到任何因素的干扰而中断，要么都不执行</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;Thread&gt; ts = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">10000</span>; j++) &#123;</span><br><span class="line">                count += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        ts.add(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...start启动线程，join等待线程</span></span><br><span class="line">    <span class="keyword">assert</span> count == <span class="number">100</span> * <span class="number">10000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 Java 这样的高级语言，一条语句最终会被转换成多条 CPU 指令完成，例如上面代码中的 count+&#x3D;1，至少需要三条 CPU 指令：</p><p>1）指令 1：把变量 count 从内存加载到 CPU 的寄存器；</p><p>2）指令 2：在寄存器中执行+1 操作；</p><p>3）指令 3：将结果写入内存（缓存机制导致可能写入的是处理器缓存而不是内存）。</p><p>Java 语言提供了大量的原子操作类，来实现对应的 CAS 操作。比如 AtomicBoolean，AtomicInteger，AtomicLong 等。CAS 虽然很高效解决了原子操作，但是 CAS 也存在一些问题，比如 ABA 问题，循环时间长开销大，只能保障一个共享变量的原子操作。</p><p>在 Java 中，可以借助<code>synchronized</code>、各种 <code>Lock</code> 以及各种原子类实现原子性。</p><p><code>synchronized</code> 和各种 <code>Lock</code> 可以保证任一时刻只有一个线程访问该代码块，因此可以保障原子性。各种原子类是利用 CAS (compare and swap) 操作（可能也会用到 <code>volatile</code>或者<code>final</code>关键字）来保证原子操作。</p></li><li><p>可见性</p><p><strong>当一个线程对共享变量进行了修改，那么另外的线程都是立即可以看到修改后的最新值</strong>。</p><p>由于处理器和内存的速度差距太大。为了提高处理速度，处理器不直接和内存进行通信，而是先将系统内存的数据读到内部缓存（L1，L2 或其他）后再进行操作。基于局部性原理，处理器在读取内存数据时，是一块块地读取，每一小块数据也叫缓存行（cache line）。当<strong>处理器操作完数据，也不直接写回内存，而且先写入缓存中，并将当前缓存标记为脏（dirty）。等到当前缓存被替换时，才将数据写回内存</strong>。这个过程叫写回策略（write-back）。</p><p>要达到可见性，需要处理器及时回写共享变量最新值到内存，也需要其他处理器及时从内存中读取到共享变量最新值。因此也可以说只要满足上述两个条件。那么就可以保证对共享变量的操作，在并发情况下是线程安全的。在 Java 语言中，是通过 volatile 关键字实现。volatile 关键字并不是 Java 语言的特产，古老的 C 语言里也有，它最原始的意义就是禁用 CPU 缓存。</p><p>在 Java 中，可以借助<code>synchronized</code>、<code>volatile</code> 以及各种 <code>Lock</code> 实现可见性。</p><p>如果我们将变量声明为 <code>volatile</code> ，每次修改变量都将当前处理器缓存行的数据写回到系统内存，每次使用它都到主存中进行读取。</p></li><li><p>有序性</p><p>重排序是指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段。重排序需要遵守两点：</p><p>1）数据依赖性：如果两个操作之间存在数据依赖，那么编译器和处理器不能调整它们的顺序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写后读</span></span><br><span class="line">a = <span class="number">1</span>;</span><br><span class="line">b = a;</span><br><span class="line"><span class="comment">// 写后写</span></span><br><span class="line">a = <span class="number">1</span>;</span><br><span class="line">a = <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 读后写</span></span><br><span class="line">a = b;</span><br><span class="line">b = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>上面 3 种情况，编译器和处理器不能调整它们的顺序，否则将会造成程序语义的改变。</p><p>2）as-if-serial 语义：即给程序一个顺序执行的假象。即经过重排序的执行结果要与顺序执行的结果保持一致。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span>;</span><br><span class="line">b = <span class="number">2</span>;</span><br><span class="line">c = a * b;</span><br></pre></td></tr></table></figure><p>如上对变量 a 的赋值和对变量 b 的赋值，不存在数据依赖关系。因此对变量 a 和 b 重排序不会影响变量 c 的结果。</p><p>但数据依赖性和 as-if-serial 语义<strong>只保证单个处理器中执行的指令序列和单个线程中执行的操作</strong>，并不考虑多处理器和多线程之间的数据依赖情况。因此在<strong>多线程程序中，对存在数据依赖的操作重排序，可能会改变程序的执行结果</strong>。因此要避免程序的错误的执行，便是需要禁止这种编译和处理器优化导致的重排序。</p><p>这种方式叫做<strong>内存屏障</strong>（memory barriers）。内存屏障是一组处理器指令，用户实现对内存操作的顺序限制。以我们日常接触的 X86_64 架构来说，读读（loadload）、读写（loadstore）以及写写（storestore）内存屏障是空操作（no-op），只有写读（storeload）内存屏障会被替换成具体指令。</p><p>在 Java 语言中，内存屏障通过 <strong>volatile</strong> 关键字实现，<strong>禁止被它修饰的变量发生指令重排序操作</strong>：</p><p>1）不允许 volatile 字段写操作之前的内存访问被重排序至其之后。</p><p>2）不允许 volatile 字段读操作之后的内存访问被重排序至其之前。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  变量a，b通过volatile修饰</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> a, b;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> x, y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        a = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 编译器插入storeload内存屏障指令</span></span><br><span class="line">        <span class="comment">// 1）禁止代码和指令重排序</span></span><br><span class="line">        <span class="comment">// 2）强制刷新变量a的最新值到内存</span></span><br><span class="line">        x = b;</span><br><span class="line">        <span class="comment">// 1）强制从内存中读取变量b的最新值</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        b = <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 编译器插入storeload内存屏障指令</span></span><br><span class="line">        <span class="comment">// 1）禁止代码和指令重排序</span></span><br><span class="line">        <span class="comment">// 2）强制刷新变量b的最新值到内存</span></span><br><span class="line">        y = a;</span><br><span class="line">        <span class="comment">// 1）强制从内存中读取变量a的最新值</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// ...start启动线程，join等待线程</span></span><br><span class="line">    <span class="keyword">assert</span> x == <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">assert</span> y == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举例：单例模式的双重校验锁</p><ul><li><h3 id="指令重排序"><a href="#指令重排序" class="headerlink" title="指令重排序"></a>指令重排序</h3><p>为了提升执行速度&#x2F;性能，计算机在执行程序代码的时候，会对指令进行重排序。</p><p><strong>什么是指令重排序？</strong> 简单来说就是系统在执行代码的时候并不一定是按照你写的代码的顺序依次执行。</p><p>常见的指令重排序有下面 2 种情况：</p><ul><li><strong>编译器优化重排</strong>：编译器（包括 JVM、JIT 编译器等）在不改变单线程程序语义的前提下，重新安排语句的执行顺序。</li><li><strong>指令并行重排</strong>：现代处理器采用了指令级并行技术(Instruction-Level Parallelism，ILP)来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</li></ul><p>另外，内存系统也会有“重排序”，但又不是真正意义上的重排序。在 JMM 里表现为主存和本地内存的内容可能不一致，进而导致程序在多线程下执行可能出现问题。</p><p>Java 源代码会经历 <strong>编译器优化重排 —&gt; 指令并行重排 —&gt; 内存系统重排</strong> 的过程，最终才变成操作系统可执行的指令序列。</p><p><strong>指令重排序可以保证串行语义一致，但是没有义务保证多线程间的语义也一致</strong> ，所以在多线程下，指令重排序可能会导致一些问题。</p><p>编译器和处理器的指令重排序的处理方式不一样。对于编译器，通过禁止特定类型的编译器重排序的方式来禁止重排序。对于处理器，通过插入内存屏障（Memory Barrier，或有时叫做内存栅栏，Memory Fence）的方式来禁止特定类型的处理器重排序。指令并行重排和内存系统重排都属于是处理器级别的指令重排序。</p><blockquote><p>内存屏障（Memory Barrier，或有时叫做内存栅栏，Memory Fence）是一种 CPU 指令，用来禁止处理器指令发生重排序（像屏障一样），从而保障指令执行的有序性。另外，为了达到屏障的效果，它也会使处理器写入、读取值之前，将主内存的值写入高速缓存，清空无效队列，从而保障变量的可见性。</p></blockquote></li></ul></li></ul><h3 id="ThreadLocal（java-lang）"><a href="#ThreadLocal（java-lang）" class="headerlink" title="ThreadLocal（java.lang）"></a>ThreadLocal（java.lang）</h3><blockquote><p><code>ThreadLocal</code>可以看做是线程私有的变量存储容器，如果你创建了一个<code>ThreadLocal</code>变量，那么访问这个变量的每个线程都会有这个变量的本地副本，如果需要修改<code>ThreadLocal</code> 中存储的变量的值,并不会影响其他的线程，所以可以用来解决线程内参数传递或共享变量的线程安全问题。</p><p>原理：<code>ThreadLocal</code>类中有一个静态内部类<code>ThreadLocalMap</code>，<strong>可以存储以<code>ThreadLocal</code>为 key ，Object 对象为 value 的键值对。</strong></p><p><strong>Thread类中有一个ThreadLocalMap类型的成员变量<code>threadLocals</code>(<code>ThreadLocal.ThreadLocalMap threadLocals = null;</code> )，默认情况下是 null。</strong>当线程第一次调用 <code>ThreadLocal</code> 类的 <code>set</code>或<code>get</code>方法时才会创建它。调用这两个方法的时候，实际上调用的是线程内<code>ThreadLocalMap</code>类成员对应的 <code>get()</code>、<code>set()</code>方法。<strong>也就是说最终的变量是放在了当前线程的 <code>ThreadLocalMap</code> 中，并不是存在 <code>ThreadLocal</code> 上，<code>ThreadLocal</code> 可以理解为只是<code>ThreadLocalMap</code>的封装，传递了变量值。</strong></p><p>内存泄漏问题：</p><p><code>ThreadLocalMap</code> 中使用的 key 为 <code>ThreadLocal</code> 的弱引用，而 value 是强引用。所以，如果 <code>ThreadLocal</code> 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。</p><p>这样一来，<code>ThreadLocalMap</code> 中就会出现 key 为 null 的 Entry（键值对）。假如我们不做任何措施的话，value 永远无法被 GC 回收，这个时候就可能会产生内存泄露。<code>ThreadLocalMap</code> 实现中已经考虑了这种情况，在调用 <code>set()</code>、<code>get()</code>方法的时候，会清理掉 key 为 null 的记录。使用完 <code>ThreadLocal</code>方法后最好手动调用<code>remove()</code>方法。</p></blockquote><p>通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。<strong>如果想实现每一个线程都有自己的专属本地变量该如何解决呢？</strong></p><p>JDK 中自带的<code>ThreadLocal</code>类正是为了解决这样的问题。 <strong><code>ThreadLocal</code>类主要解决的就是让每个线程绑定自己的值，可以将<code>ThreadLocal</code>类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据。</strong></p><p><code>ThreadLocal</code>是线程私有的变量存储容器，如果你创建了一个<code>ThreadLocal</code>变量，那么访问这个变量的每个线程都会有这个变量的本地副本，<code>ThreadLocal</code> 对象存储的值发生改变时,并不会影响其他的线程，可以用来解决线程内参数传递或共享变量的线程安全问题（比synchronize高效，空间换时间）。他们可以使用 <code>get()</code> 和 <code>set()</code> 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。</p><h4 id="ThreadLocal原理"><a href="#ThreadLocal原理" class="headerlink" title="ThreadLocal原理"></a>ThreadLocal原理</h4><p><code>ThreadLocal</code>类的静态内部类<code>ThreadLocalMap</code>，<strong>可以存储以<code>ThreadLocal</code>为 key ，Object 对象为 value 的键值对。</strong></p><p><strong>Thread类中有一个ThreadLocalMap类型的成员变量<code>threadLocals</code>(<code>ThreadLocal.ThreadLocalMap threadLocals = null;</code> )，默认情况下是 null。</strong>当线程第一次调用 <code>ThreadLocal</code> 类的 <code>set</code>或<code>get</code>方法时才会创建它。调用这两个方法的时候，实际上调用的是<code>ThreadLocalMap</code>类对应的 <code>get()</code>、<code>set()</code>方法。<strong>也就是说最终的变量是放在了当前线程的 <code>ThreadLocalMap</code> 中，并不是存在 <code>ThreadLocal</code> 上，<code>ThreadLocal</code> 可以理解为只是<code>ThreadLocalMap</code>的封装，传递了变量值。</strong></p><ul><li><p>内存泄漏？</p><p>由于<code>ThreadLocalMap</code>的中key是弱引用，而Value是强引用。这就导致了一个问题，<code>ThreadLocal</code>在没有外部对象强引用时，发生GC时弱引用Key会被回收，而Value不会回收，从而Entry里面的元素出现<code>&lt;null,value&gt;</code>的情况。如果持有ThreadLocalMap的线程一直持续运行（比如线程池场景），那么这个Entry对象中的value就有可能一直得不到回收，这样可能会导致内存泄露。<code>ThreadLocalMap</code> 实现中已经考虑了这种情况，在调用 <code>set()</code>、<code>get()</code>方法的时候，会清理掉 key 为 null 的记录。使用完 <code>ThreadLocal</code>方法后最好手动调用<code>remove()</code>方法。</p><blockquote><p>为什么用弱引用？为什么不用强引用</p></blockquote><p>若使用强引用类型，则threadlocal的引用链为：Thread -&gt; ThreadLocal.ThreadLocalMap -&gt; Entry[] -&gt; Entry -&gt; key（threadLocal对象）和value；在这种场景下，只要这个线程还在运行（如线程池场景），若不调用remove方法，则该对象及关联的所有强引用对象都不会被垃圾回收器回收。</p></li></ul><ul><li><p>众所周知，在java中SimpleDateFormat有线程安全问题，为了安全地使用SimpleDateFormat，除了1）创建SimpleDateFormat局部变量；和2）加同步锁 两种方案外，我们还可以使用3）ThreadLocal的方案。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 使用 ThreadLocal 定义一个全局的 SimpleDateFormat</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;SimpleDateFormat&gt; simpleDateFormatThreadLocal = <span class="keyword">new</span></span><br><span class="line"><span class="title class_">ThreadLocal</span>&lt;SimpleDateFormat&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> SimpleDateFormat <span class="title function_">initialValue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 用法</span></span><br><span class="line"><span class="type">String</span> <span class="variable">dateString</span> <span class="operator">=</span> simpleDateFormatThreadLocal.get().format(calendar.getTime());</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>最佳实践</p></blockquote><ul><li><p>ThreadLocal变量建议使用static进行修饰</p><p>若使用static关键字进行修饰，则一个线程仅对应一个线程变量；否则，threadlocal语义变为perThread-perInstance，容易引发内存泄漏.</p><p>我们在使用ThreadLocal时，通常期望的语义是perThread，若不使用static进行修饰，则语义变为perThread-perInstance；在线程池场景下，若不用static进行修饰，创建的线程相关实例可能会达到 M * N个（其中M为线程数，N为对应类的实例数）</p></li><li><p>ThreadLocal变量值初始化和清理建议成对出现</p><p>如果不执行清理操作，则可能会出现：</p><p>1）内存泄漏：由于ThreadLocalMap的中key是弱引用，而Value是强引用。这就导致了一个问题，ThreadLocal在没有外部对象强引用时，发生GC时弱引用Key会被回收，而Value不会回收，从而Entry里面的元素出现&lt;null,value&gt;的情况。如果创建ThreadLocal的线程一直持续运行，那么这个Entry对象中的value就有可能一直得不到回收，这样可能会导致内存泄露。</p><p>2）脏数据：由于线程复用，在用户1请求时，可能保存了业务数据在ThreadLocal中，若不清理，则用户2的请求进来时，可能会读到用户1的数据。</p><p>建议使用try…finally 进行清理</p></li></ul><h3 id="Synchronize"><a href="#Synchronize" class="headerlink" title="Synchronize"></a>Synchronize</h3><p><code>synchronized</code> 是 Java 中的一个关键字，翻译成中文是同步的意思，主要解决的是多个线程之间访问资源的同步性，可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。</p><p>在 Java 早期版本中，<code>synchronized</code> 属于 <strong>重量级锁</strong>，效率低下。这是因为监视器锁（monitor）是依赖于底层的操作系统的 <code>Mutex Lock</code> 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高。</p><p>不过，在 Java 6 之后， <code>synchronized</code> 引入了大量的优化如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销，这些优化让 <code>synchronized</code> 锁的效率提升了很多。</p><p><code>synchronized</code> 关键字的使用方式主要有下面 3 种：</p><ol><li><p>修饰实例方法：给<strong>当前对象实例</strong>加锁，进入同步代码前要获得 <strong>当前对象实例的锁</strong> 。</p></li><li><p>修饰静态方法：给当前类加锁，会作用于类的所有对象实例 ，进入同步代码前要获得 <strong>当前 class 的锁</strong>。</p></li><li><p>修饰代码块</p><p>对括号里指定的对象&#x2F;类加锁：</p><ul><li><code>synchronized(object)</code> 表示进入同步代码库前要获得 <strong>给定对象的锁</strong>。一般对什么对象加锁？多线程共享、需要保证线程安全对象</li><li><code>synchronized(类.class)</code> 表示进入同步代码前要获得 <strong>给定 Class 的锁</strong></li></ul></li></ol><h4 id="synchronized可以修饰静态方法和静态代码块吗？"><a href="#synchronized可以修饰静态方法和静态代码块吗？" class="headerlink" title="synchronized可以修饰静态方法和静态代码块吗？"></a>synchronized可以修饰静态方法和静态代码块吗？</h4><p>synchronized可以修饰静态方法，但不能修饰静态代码块。</p><p>当修饰静态方法时，监视器锁（monitor）便是对象的Class实例，因为Class数据存在于永久代，因此静态方法锁相当于该类的一个全局锁。</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><h5 id="同步语句块"><a href="#同步语句块" class="headerlink" title="同步语句块"></a>同步语句块</h5><p><strong><code>synchronized（this、object、class）</code> 同步语句块的实现使用的是 <code>monitorenter</code> 和 <code>monitorexit</code> 指令，其中 <code>monitorenter</code> 指令指向同步代码块的开始位置，<code>monitorexit</code> 指令则指明同步代码块的结束位置。</strong></p><p>上面的<em>字节码</em>中包含一个 <code>monitorenter</code> 指令以及两个 <code>monitorexit</code> 指令，这是为了保证锁在同步代码块代码正常执行以及出现异常的这两种情况下都能被正确释放。</p><p>当执行 <code>monitorenter</code> 指令时，线程试图获取锁也就是获取 <strong>对象监视器 <code>monitor</code></strong> 的持有权。</p><blockquote><p>在 Java 虚拟机(HotSpot)中，Monitor 是基于 C++实现的，由<a href="https://github.com/openjdk-mirror/jdk7u-hotspot/blob/50bdefc3afe944ca74c3093e7448d6b889cd20d1/src/share/vm/runtime/objectMonitor.cpp">ObjectMonitor</a>实现的。每个对象中都内置了一个 <code>ObjectMonitor</code>对象。</p><p>另外，<code>wait/notify</code>等方法也依赖于<code>monitor</code>对象，这就是为什么只有在同步的块或者方法中才能调用<code>wait/notify</code>等方法，否则会抛出<code>java.lang.IllegalMonitorStateException</code>的异常的原因。</p></blockquote><p>在执行<code>monitorenter</code>时，会尝试获取对象的monitor，如果monitor的计数器为 0 则表示锁可以被获取，获取后将锁计数器设为 1 也就是加 1。</p><p>对象锁的的拥有者线程才可以执行 <code>monitorexit</code> 指令来释放锁。在执行 <code>monitorexit</code> 指令后，将锁计数器设为 0，表明锁被释放，其他线程可以尝试获取锁。</p><p>如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。</p><h5 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h5><p><code>synchronized</code> 修饰的方法并没有 <code>monitorenter</code> 指令和 <code>monitorexit</code> 指令，取得代之的确实是 <code>ACC_SYNCHRONIZED</code> 标识，该标识指明了该方法是一个同步方法。JVM 通过该 <code>ACC_SYNCHRONIZED</code> 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。</p><p>如果是实例方法，JVM 会尝试获取实例对象的锁。如果是静态方法，JVM 会尝试获取当前 class 的锁（每个类只有一个class对象）。</p><h5 id="Synchronize保证的特性"><a href="#Synchronize保证的特性" class="headerlink" title="Synchronize保证的特性"></a>Synchronize保证的特性</h5><p>1.原子性：synchronized依靠两个字节码指令monitorenter和monitorexit，可以保证被synchronized修饰的代码在同一时间只能被一个线程访问。</p><p>2.可见性：JMM（Java内存模型）规定，内存主要分为主内存和工作内存两种，每个线程拥有不同的工作内存,线程工作时会从主内存中拷贝一份变量到工作内存中。代码执行后，有时工作内存中的变量无法及时刷新到主内存中,或者工作内存无法及时获取主内存的最新值,导致共享变量在不同线程间处于不可见性,由此JMM对synchronized做了2条规定：</p><p>线程加锁时，先清空工作内存中的变量值，从主内存中重新获取最新值到工作内存中。</p><p>线程解锁前，必须把变量的最新值刷新到主内存中。</p><p>3.有序性：有时候编译器和处理器为了提升代码效率,会进行指令重排序,但是as-if-serial规定无论怎么重排序,单线程程序的执行结果都不能被改变,而synchronized保证了被修饰的程序在同一时间内只能被同一线程访问，所以其也算是保证了有序性,但synchronized实际上并不是禁止了被修饰的代码指令重排序。</p><h4 id="四种状态"><a href="#四种状态" class="headerlink" title="四种状态"></a>四种状态</h4><p>锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。</p><p><a href="https://mp.weixin.qq.com/s/2yxexZUr5MWdMZ02GCSwdA">https://mp.weixin.qq.com/s/2yxexZUr5MWdMZ02GCSwdA</a></p><p>首先明确早期jdk1.2效率非常低。那时候syn就是重量级锁，申请锁必须要经过操作系统老大kernel进行<strong>系统调用</strong>，入队进行排序操作，操作完之后再返回给用户态。</p><p>内核态：用户态如果要做一些比较危险的操作直接访问硬件，很容易把硬件搞死（格式化，访问网卡，访问内存干掉、）操作系统为了系统安全分成两层，用户态和内核态 。申请锁资源的时候用户态要向操作系统老大内核态申请。Jdk1.2的时候用户需要跟内核态申请锁，然后内核态还会给用户态。这个过程是非常消耗时间的，导致早期效率特别低。有些jvm就可以处理的为什么还交给操作系统做去呢？能不能把jvm就可以完成的锁操作拉取出来提升效率，所以也就有了锁优化。</p><ol><li><strong>无锁状态</strong>：当对象没有被锁定时，处于无锁状态。任何线程都可以访问该对象。</li><li><strong>偏向锁状态</strong>：当只有一个线程访问对象时，该对象处于偏向锁状态。偏向锁可以减少无竞争情况下的同步操作的开销。</li><li><strong>轻量级锁状态</strong>：当有多个线程竞争访问同一个对象时，对象会从偏向锁升级为轻量级锁状态。轻量级锁使用CAS（Compare and Swap）操作来避免真正的互斥操作。</li><li><strong>重量级锁状态</strong>：当多个线程竞争访问同一个对象的时候，如果轻量级锁获取不到，对象会膨胀为重量级锁状态。在重量级锁状态下，使用操作系统的互斥量来实现线程的同步。</li></ol><h3 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h3><p>synchronize和lock区别？</p><ul><li>synchronized是Java内置的关键字。Lock是J.U.C包下的接口，有很多实现类</li><li>Lock可以自主地去决定什么时候加锁，什么时候释放锁。Lock比synchronized在使用上相对来说要更加灵活一些。只需要调用lock()和unlock()这两个方法就可以了。需要注意的是，为了避免死锁，一般我们unlock()方法写在finally块中。</li><li>lock可以让等待锁的线程响应中断。当一个线程通过lockInterruptibly()方法获取锁时，其他等待锁的线程可以响应中断（thread.interrupt()，设置中断标志）。当两个线程同时通过lock.lockInterruptibly()获取某个锁时，假若此时线程A获取到了锁，而线程B只有等待，那么对线程B调用threadB.interrupt()方法能够中断线程B的等待过程。而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断；</li><li>lock有非阻塞的竞争锁的方法trylock()，这个方法可以通过返回true或者fasle来告诉当前线程是否获取到锁。而synchronized却无法办到。</li><li>性能比较：在资源竞争不是很激烈的情况下，Synchronized的性能要优于ReetrantLock，但是在资源竞争很激烈的情况下，Synchronized的性能会下降几十倍，但是ReetrantLock的性能能维持常态；</li></ul><h4 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h4><p>如果一个系统中<strong>读多写少</strong>，可以考虑使用读写锁（ReadWriteLock）来提高系统的并发性能。</p><p>读写锁是一种特殊的锁，它允许多个线程同时读共享数据，但只允许一个线程写共享数据。在读写锁中，读操作不会阻塞其他读操作，只有写操作会阻塞所有读操作和写操作。这样可以提高系统的并发性能，减少写操作的竞争。</p><p>在 Java 中，可以使用 ReentrantReadWriteLock 类来实现读写锁。ReentrantReadWriteLock 类有两个锁：读锁和写锁。读锁是共享锁，写锁是独占锁。多个线程可以同时获取读锁，但只有一个线程可以获取写锁。当一个线程获取写锁时，其他线程无法获取读锁或写锁，直到写锁被释放。</p><h3 id="进程、线程、协程"><a href="#进程、线程、协程" class="headerlink" title="进程、线程、协程"></a>进程、线程、协程</h3><p><strong>进程</strong></p><p><strong>进程是系统资源分配的最小单位</strong>。是的，系统由一个个程序，也就是进程组成的，一般情况下，分为文本区域、数据区域和堆栈区域。</p><p>文本区域存储处理器执行的代码(机器码)，通常来说，这是一个只读区域，防止运行的程序被意外修改。</p><p>数据区域存储所有的变量和动态分配的内存，又细分为初始化的数据区(所有初始化的全局、静态、常量，以及外部变量)和为初始化的数据区(初始化为0的全局变量和静态变量)，初始化的变量最初保存在文本区，程序启动后被拷贝到初始化的数据区。</p><p>堆栈区域存储着活动过程调用的指令和本地变量，在地址空间里，栈区紧连着堆区，他们的增长方向相反，内存是线性的，所以我们代码放在低地址的地方，由低向高增长，栈区大小不可预测，随开随用，因此放在高地址的地方，由高向低增长。当堆和栈指针重合的时候，意味着内存耗尽，造成内存溢出。</p><p>进程的创建和销毁都是相对于系统资源，非常消耗资源，是一种比较昂贵的操作。进程为了自身能得到运行，必须要抢占式的争夺CPU。对于单核CPU来说，在同一时间只能执行一个进程的代码，所以在单核CPU上实现多进程，是通过CPU快速的切换不同进程，看上去就像是多个进程在同时进行。</p><p>由于进程间是隔离的，各自拥有自己的内存内存资源，相比于线程的共同共享内存来说，相对安全，不同进程之间的数据只能通过 IPC(Inter-Process Communication) 进行通信共享。</p><ul><li><p>进程通信方式？</p><p>操作系统进程通信的方式有以下几种：</p><ol><li>管道（Pipe）：管道是一种半双工的通信方式，它可以在两个进程之间传递数据。管道可以是匿名的，也可以是命名的。匿名管道只能在有亲缘关系的进程之间使用，而命名管道可以在任何进程之间使用。</li><li>共享内存（Shared Memory）：共享内存是一种高效的进程通信方式，它允许多个进程访问同一块物理内存。共享内存通常用于需要频繁交换大量数据的进程之间的通信。</li><li>信号量（Semaphore）：信号量是一种计数器，用于控制多个进程对共享资源的访问。信号量可以用于进程同步和互斥。</li><li>消息队列（Message Queue）：消息队列是一种消息传递机制，它允许一个进程向另一个进程发送消息。消息队列通常用于进程之间的异步通信。</li><li>套接字（Socket）：套接字是一种网络通信方式，它允许不同主机之间的进程进行通信。套接字通常用于进程之间的跨主机通信。</li></ol></li></ul><p><strong>线程</strong></p><p><strong>线程是CPU调度的最小单位</strong>。如果进程是一个容器，线程就是运行在容器里面的程序，线程是属于进程的，<strong>同个进程的多个线程共享进程的内存地址空间</strong>。</p><p>线程间的通信可以直接通过全局变量进行通信，所以相对来说，线程间通信是不太安全的，因此引入了各种锁的场景。当一个线程崩溃了,会导致整个进程也崩溃了,即其他线程也挂了, 但多进程而不会,一个进程挂了，另一个进程依然照样运行。</p><p>在多核操作系统中，默认进程内只有一个线程，所以对多进程的处理就像是一个进程一个核心。</p><p><strong>协程</strong></p><p>协程是属于线程的，又称微线程，纤程，英文名Coroutine。举个例子，在执行函数A时，我希望随时中断去执行函数B，然后中断B的执行，切换回来执行A。这就是协程的作用，由调用者自由切换。这个切换过程并不是等同于函数调用，因为它没有调用语句。执行方式与多线程类似，但是协程只有一个线程执行。</p><p>协程的优点是执行效率非常高，因为协程的切换由程序自身控制，不需要切换线程，即没有切换线程的开销。同时，由于只有一个线程，不存在冲突问题，不需要依赖锁(加锁与释放锁存在很多资源消耗)。</p><p>协程主要的使用场景在于<strong>处理IO密集型程序</strong>，解决效率问题，不适用于CPU密集型程序的处理。然而实际场景中这两种场景非常多，如果要充分发挥CPU利用率，可以结合多进程+协程的方式。</p><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong>资源，但每个线程有自己的<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong>，所以创建线程、线程切换的开销比进程小。</p><ul><li><p>JVM程序计数器为什么私有？</p><p>程序计数器用来存储指向下一条指令的地址。如果程序计数器是线程私有的，那么每个线程都有自己独立的程序计数器，线程切换时只需要保存和恢复当前线程的程序计数器的值，可以保证线程执行字节码指令时不会相互干扰，从而保证程序的正确性。</p></li></ul><ul><li><p>什么是线程上下文切换?</p><p>线程在执行过程中会有自己的运行条件和状态（也称上下文），比如上文所说到过的程序计数器，栈信息等。当出现如下情况的时候，线程会从占用 CPU 状态中退出。</p><ul><li><p>主动让出 CPU，比如调用了 <code>sleep()</code>, <code>wait()</code> 等。</p></li><li><p>时间片用完，因为操作系统要防止一个线程或者进程长时间占用 CPU 导致其他线程或者进程饿死。</p></li><li><p>调用了阻塞类型的系统中断，比如请求 IO，线程被阻塞。</p></li><li><p>被终止或结束运行</p><p>这其中前三种都会发生线程切换，线程切换意味着需要保存当前线程的上下文，留待线程下次占用 CPU 的时候恢复现场。并加载下一个将要占用 CPU 的线程上下文。这就是所谓的 <strong>上下文切换</strong>。</p><p>上下文切换是现代操作系统的基本功能，因其每次需要保存信息恢复信息，这将会占用 CPU，内存等系统资源进行处理，也就意味着效率会有一定损耗，如果频繁切换就会造成整体效率低下。</p></li></ul></li><li><p>为什么要使用多线程?</p><p>提高并发执行程度、线程占用内存小、线程调度切换开销小</p><ul><li><p><strong>从计算机底层来说：</strong> 线程可以比作是轻量级的进程，是程序执行的最小单位,线程间的<strong>切换和调度的成本远远小于进程</strong>。另外，多核 CPU 时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。</p></li><li><p>多核时代多线程主要是为了<strong>提高进程利用多核 CPU 的能力</strong>。举个例子：假如我们要计算一个复杂的任务，我们只用一个线程的话，不论系统有几个 CPU 核心，都只会有一个 CPU 核心被利用到。而创建多个线程，这些线程可以被映射到底层多个 CPU 上执行，在任务中的多个线程没有资源竞争的情况下，任务执行的效率会有显著性的提高，约等于（单核时执行时间&#x2F;CPU 核心数）</p></li></ul><p>个人理解：CPU负载低时最大程度发挥CPU效能。高并发时本身cpu负载高，多线程没啥提升。</p><p><strong>异步改同步：小于10ms 的不使用多线程</strong></p><p>高并发的场景下线程太多，线程调度时间得不到保障，一次任务需要多个 CPU 时间片，下一次调度的时间无法得到保障。</p><ul><li><p>为什么不用多进程？</p><p>线程可以共享进程资源，内存占用小，线程切换的开销小。</p><p>但多进程也有应用，比如Chrome浏览器每个页面都是一个进程，主要优点是一个页面崩了不会影响其他页面。以前IE浏览器就是多线程，一个页面崩了整个浏览器都崩了。</p></li></ul></li><li><p>如何理解线程安全</p><p>同个进程的多个线程共享进程的内存地址空间，多个线程并发访问某个共享数据，可以保证数据的正确性，不会出现意料之外的结果。</p><p>例如两个线程同时对某个值为0的int变量执行100次自加（非原子，读、改、写回）操作，预期值为200，但实际可能不是200，这既是线程不安全的情况。</p></li><li><p>死锁</p><p>例如两个线程互相占有对方所需要的资源，同时又申请对方所占有的资源，这两个线程就会互相等待而进入死锁状态。</p><p>死锁的四个必要条件：</p><ol><li>互斥：该资源任意一个时刻只由一个线程占用。</li><li>请求与保持：一个线程因请求资源而阻塞时，不释放已获得的资源。</li><li>不可抢占：不能强行占有其他线程拥有的资源。线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</li><li>循环等待:若干线程之间形成一种头尾相接的循环等待资源关系。</li></ol><p><strong>如何预防死锁？</strong> 破坏死锁的产生的必要条件即可：</p><ol><li><strong>破坏请求与保持条件</strong>：一次性申请所有的资源。</li><li><strong>破坏不剥夺条件</strong>：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</li><li><strong>破坏循环等待条件</strong>：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</li></ol><p><strong>如何避免死锁？</strong></p><p>避免死锁就是在资源分配时，借助于算法（比如银行家算法）对资源分配进行计算评估，使其进入安全状态。</p><p><strong>Java程序死锁怎么办？</strong></p><ul><li>jps列出所有正在运行中的 Java 虚拟机进程；然后使用<strong>jstack</strong>工具可以检测出程序中的死锁情况，并打印出死锁的线程堆栈信息。这可以帮助我们了解死锁的原因，从而找出解决方案。</li><li>使用 <code>java.lang.management</code> 中 <code>ThreadMXBean</code> 类的 <code>findDeadlockedThreads()</code> 方法得到死锁的线程id数组，通过<code>getThreadInfo()</code>方法获取线程信息。</li></ul><p>最简单解决：通过<code>Thread.getThreadById()</code>方法获取线程，然后调用<code>interrupt()</code>方法终止线程</p></li><li><p>wait和sleep区别</p><p><strong>共同点</strong>：两者都可以暂停线程的执行</p><ol><li>sleep()是Thread类中的静态方法，而wait()是Object类中的成员方法；</li><li>sleep()可以在任何地方使用，而wait()只能在同步方法或同步代码块（synchronize）中使用（依赖于对象的监视器锁），否则运行时会抛IllegalMonitorStateException；</li><li>sleep()不会释放锁（synchronize），而wait()会释放锁，并需要通过notify()&#x2F;notifyAll()重新获取锁。</li><li>sleep 方法必须要传递一个超时时间的参数，且过了超时时间之后，线程会自动唤醒。而 wait 方法可以不传递任何参数，不传递任何参数时表示永久休眠，直到另一个线程调用了 notify 或 notifyAll 之后，休眠的线程才能被唤醒。也就是说 <strong>sleep 方法具有主动唤醒功能，而不传递任何参数的 wait 方法只能被动的被唤醒</strong>。</li></ol></li></ul><h4 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h4><blockquote><p>Java中的线程状态分为6种。首先，线程创建后会处于NEW状态，调用start()后进入RUNNABLE状态。RUNNABLE状态又分为READY和RUNNING（操作系统中的就绪和运行态）。RUNNABLE状态执行Object.wait()方法会进入WAITING状态，表示该线程需要等待其他线程做出一些特定动作，例如Object.notify()；RUNNABLE状态执行了Thread.sleep()就会进入TIMED_WAITING，相当于在WAITING状态的基础上增加了超时限制，在超时时间结束后，线程将会返回到 RUNNABLE 状态。RUNNABLE状态执行到synchronize语句块，而没有获取到锁，就会进入BLOCKED状态，获取到锁之后又回到RUNNABLE状态。最后，线程执行结束（run()）或线程抛出一个未捕获的Exception或Error，就进入TERMINATE状态，表示已经运行完成。</p></blockquote><p>NEW: 初始状态，线程被创建出来但没有被调用 <code>start()</code> 。</p><p>RUNNABLE: 运行状态，线程被调用了 <code>start()</code>等待运行的状态。</p><ul><li><strong>为什么 JVM 没有区分就绪和运行这两种状态呢？</strong> （摘自：<a href="https://www.zhihu.com/question/56494969/answer/154053599">Java 线程运行怎么有第六种状态？ - Dawell 的回答open in new window</a> ） 现在的时分（time-sharing）多任务（multi-task）操作系统架构通常都是用所谓的“时间分片（time quantum or time slice）”方式进行抢占式（preemptive）轮转调度（round-robin 式）。这个时间分片通常是很小的，一个线程一次最多只能在 CPU 上运行比如 10-20ms 的时间（此时处于 running 状态），也即大概只有 0.01 秒这一量级，时间片用后就要被切换下来放入调度队列的末尾等待再次调度。（也即回到 ready 状态）。线程切换的如此之快，区分这两种状态就没什么意义了。</li></ul><p>BLOCKED：阻塞状态，需要等待锁释放。</p><p>WAITING：等待状态，表示该线程需要等待其他线程做出一些特定动作（通知或中断）。</p><p>TIME_WAITING：超时等待状态，可以在指定的时间后自行返回而不是像 WAITING 那样一直等待。</p><p>TERMINATED：终止状态，表示该线程已经运行完毕。</p><p><img src="https://s2.loli.net/2023/06/02/zrSyQnW6hRdiAsg.png" alt="Java 线程状态变迁图"></p><p>线程创建之后它将处于 <strong>NEW（新建）</strong> 状态，调用 <code>start()</code> 方法后开始运行，线程这时候处于 <strong>READY（可运行）</strong> 状态。可运行状态的线程获得了 CPU 时间片（timeslice）后就处于 <strong>RUNNING（运行）</strong> 状态。</p><p>当线程执行 <code>wait()</code>方法之后，线程进入 <strong>WAITING（等待）</strong> 状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态（wait()方法可以让当前线程释放对象锁并进入阻塞状态。notify()方法用于唤醒一个正在等待相应对象锁的线程，使其进入就绪队列）。</p><p><strong>TIMED_WAITING(超时等待)</strong> 状态相当于在等待状态的基础上增加了超时限制，比如通过 <code>sleep（long millis）</code>方法或 <code>wait（long millis）</code>方法可以将线程置于 TIMED_WAITING 状态。当超时时间结束后，线程将会返回到 RUNNABLE 状态。</p><p>当线程进入 <code>synchronized</code> 方法&#x2F;块或者调用 <code>wait</code> 后（被 <code>notify</code>）重新进入 <code>synchronized</code> 方法&#x2F;块，但是锁被其它线程占有，这个时候线程就会进入 <strong>BLOCKED（阻塞）</strong> 状态。</p><p>线程在执行完了 <code>run()</code>方法之后将会进入到 <strong>TERMINATED（终止）</strong> 状态</p><h4 id="线程创建方式"><a href="#线程创建方式" class="headerlink" title="线程创建方式"></a>线程创建方式</h4><p>创建线程有四种方式，分别是继承Thread类、实现Runnable接口、实现Callable接口、线程池。</p><ul><li><p>通过<strong>继承Thread类</strong>来创建并启动线程的步骤如下：</p><ol><li>定义Thread类的子类，并<strong>重写该类的run()方法</strong>，该run()方法将作为线程执行体。</li><li><strong>创建Thread子类的实例（或new Thread，使用匿名内部类，并重写run方法）</strong>，即创建了线程对象。</li><li><strong>调用线程对象的start()方法来启动该线程</strong>。</li></ol></li><li><p>通过<strong>实现Runnable接口</strong>来创建并启动线程的步骤如下：</p><ol><li><p>定义Runnable接口的实现类，<strong>并实现该接口的run()方法</strong>，该run()方法将作为线程执行体。</p></li><li><p><strong>创建Runnable实现类的实例，并将其作为Thread构造方法的target来创建Thread对象</strong>，Thread对象为线程对象。</p></li><li><p>调用线程对象的start()方法来启动该线程。</p></li></ol></li><li><p>通过<strong>实现Callable接口</strong>来创建并启动线程的步骤如下：</p><ol><li><p>创建Callable接口的实现类，<strong>并实现call()方法</strong>，该call()方法将作为线程执行体，且该call()方法有返回值。然后再创建Callable实现类的实例。</p></li><li><p><strong>使用FutureTask类来包装Callable对象</strong>，该FutureTask对象封装了该Callable对象的call()方法的返回值。</p></li><li><p>使用FutureTask对象<strong>作为Thread构造方法的target</strong>创建并调用start启动新线程。</p></li><li><p>调用FutureTask对象的get()方法来获得子线程执行结束后的返回值。</p></li></ol></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">T</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;我是继承Thread的任务&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">R</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;我是实现Runnable的任务&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        log.info(<span class="string">&quot;我是实现Callable的任务&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动继承Thread类的任务</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">T</span>().start();</span><br><span class="line"><span class="comment">// 启动继承Thread匿名内部类的任务 可用lambda优化</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    log.info(<span class="string">&quot;我是Thread匿名内部类的任务&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  启动实现Runnable接口的任务</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">R</span>()).start();</span><br><span class="line"><span class="comment">//  启动实现Runnable匿名实现类的任务</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;我是Runnable匿名内部类的任务&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="comment">//  启动实现Runnable的lambda简化后的任务</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; log.info(<span class="string">&quot;我是Runnable的lambda简化后的任务&quot;</span>)).start();</span><br><span class="line"><span class="comment">// 启动实现了Callable接口的任务 结合FutureTask 可以获取线程执行的结果</span></span><br><span class="line">FutureTask&lt;String&gt; target = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">C</span>());</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(target).start();</span><br><span class="line">log.info(target.get());</span><br></pre></td></tr></table></figure><p>采用实现Runnable、Callable接口的方式创建多线程的优缺点：</p><ul><li>线程类只是实现了Runnable接口或Callable接口，还可以继承其他类。</li><li>在这种方式下，<strong>多个线程可以共享同一个target对象，所以非常适合多个相同线程来处理同一份资源的情况</strong>，从而可以将CPU、代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。</li><li>劣势是，编程稍稍复杂，如果需要访问当前线程，则必须使用Thread.currentThread()方法。</li><li>区别：Callable接口里定义的方法有返回值，可以抛出异常；Runnable接口没有返回值，实现类中run方法的异常必须在内部处理，不能抛出</li></ul><p>采用继承Thread类的方式创建多线程的优缺点：</p><ul><li>劣势是，Java是单继承，线程类继承了Thread类就不能再继承其他父类。</li><li>优势是，编写简单，如果需要访问当前线程，则无须使用Thread.currentThread()方法，直接使用this即可获得当前线程。</li></ul><h5 id="start和run"><a href="#start和run" class="headerlink" title="start和run"></a>start和run</h5><p>start()会导致run()方法被调用，run()方法中的内容称为<strong>线程体</strong>，它就是这个线程需要执行的工作。</p><p>用<strong>start()来启动线程</strong>，实现了真正意义上的启动线程，此时会出现<strong>异步执行</strong>的效果，即在线程的创建和启动中所述的随机性。 </p><p>run方法是Thread类的一个普通方法，如果使用<strong>run()来启动线程</strong>，就不是异步执行了，而是<strong>同步执行</strong>，不会达到使用线程的意义。</p><p>注：一个线程只能调用一次start()方法,第二次调用会抛出IllegalThreadStateException。</p><h5 id="终止线程"><a href="#终止线程" class="headerlink" title="终止线程"></a>终止线程</h5><p>interrupt、interrupted和isInterrupted。</p><p>interrupt是给线程<strong>设置中断标志（并不会真正的停止线程）</strong>；interrupted是检测中断并清除中断状态；isInterrupted只检测中断。还有重要的一点就是interrupted是类方法，作用于当前线程，interrupt和isInterrupted作用于此线程，即代码中调用此方法的实例所代表的线程。</p><p>interrupt就是中断的方法，它的工作流程如下：</p><ul><li>如果当前线程实例在调用Object类的wait（），wait（long）或wait（long，int）方法或join（），join（long），join（long，int）方法，或者在该实例中调用了Thread.sleep（long）或Thread.sleep（long，int）方法，并且正在阻塞状态中时，则其中断状态将被清除，并将收到InterruptedException。</li><li>如果此线程在InterruptibleChannel上的I&#x2F;O操作中处于被阻塞状态，则该channel将被关闭，该线程的中断状态将被设置为true，并且该线程将收到java.nio.channels.ClosedByInterruptException异常。</li><li>如果此线程在java.nio.channels.Selector中处于被被阻塞状态，则将设置该线程的中断状态为true，并且它将立即从select操作中返回。</li><li>如果上面的情况都不成立，则设置中断状态为true。</li></ul><p>stop：强行终止，不推荐</p><h4 id="Fork-Join"><a href="#Fork-Join" class="headerlink" title="Fork&#x2F;Join"></a>Fork&#x2F;Join</h4><p>Java提供Fork&#x2F;Join框架用于并行执行任务，核心的思想就是将一个大任务切分成多个小任务，然后汇总每个小任务的执行结果得到这个大任务的最终结果。</p><ol><li><p>分割任务Fork：把大任务分割成子任务，如果分割的子任务还是很大，可以继续分割</p></li><li><p>执行结果并合并结果Join：分割的子任务被存储在双端队列中，然后启动线程分别从双端队列获取任务执行。子任务执行完的结果都统一存储在一个队列中，启动一个线程从队列中拿数据，然后合并这些数据。</p></li></ol><p>Fork &#x2F; Join框架使用两个类完成上面两件事：</p><ol><li><p>ForkJoinTask：要使用ForkJoin框架就首先需要创建一个ForkJoin任务。它提供在任务中执行fork() （让task异步执行）和 join()（让task同步执行，可以获取返回值）操作的机制，我们通常只需要继承他的子类即可，Fork&#x2F;Join框架提供了以下两个子类：</p><p>RecursiveTask：用于没有返回结果的任务。</p><p>RecursiveAction：用于有返回结果的任务</p></li><li><p>ForkJoinPool：就是用来执行 <code>ForkJoinTask</code> 的线程池</p></li></ol><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p><a href="https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html">Java线程池实现原理及其在美团业务中的实践</a></p><p>池化思想典型应用：</p><ol><li>内存池(Memory Pooling)：预先申请内存，提升申请内存速度，减少内存碎片。</li><li>连接池(Connection Pooling)：预先申请数据库连接，提升申请连接的速度，降低系统的开销。</li><li>实例池(Object Pooling)：循环使用对象，减少资源在初始化和释放时的昂贵损耗。</li></ol><p>线程池就是管理一系列线程的资源池。当有任务要处理时，可以直接从线程池中获取线程来处理，处理完之后线程并不会立即被销毁，而是归还给线程池等待下一个任务。</p><ul><li><p>为什么要用线程池</p><ul><li>Java中的每个线程都对应于操作系统中的一个线程（Windows、Linux），创建或销毁一个线程的时间开销是比较高的，因为它涉及与操作系统交互（系统调用、核心态转换）；使用线程池可以重复利用已创建好的线程，<strong>降低线程创建和销毁所消耗的时间以及系统资源开销</strong>；</li><li>1个线程默认占1M内存，如果无限制的创建，并发高的时候会占用大量内存资源，有内存耗尽的风险；线程数量太多，大量线程可能会同时在争取 CPU 资源，这样会导致频繁的上下文切换（时间片耗尽让出CPU），影响了整体执行效率。使用线程池可以统一地分配和监控线程，限制线程的数量。</li><li><strong>降低资源消耗</strong>：通过池化技术重复利用已创建的线程，降低线程创建和销毁造成的损耗。</li><li><strong>提高响应速度</strong>：任务到达时，无需等待线程创建即可立即执行。</li><li><strong>提高线程的可管理性</strong>：线程是稀缺资源，如果无限制创建，不仅会消耗系统资源，还会因为线程的不合理分布导致资源调度失衡，降低系统的稳定性。使用线程池可以进行统一的分配、调优和监控。</li><li><strong>提供更多更强大的功能</strong>：线程池具备可拓展性，允许开发人员向其中增加更多的功能。比如延时定时线程池ScheduledThreadPoolExecutor，就允许任务延期执行或定期执行。</li></ul><p>线程池解决的问题：</p><p>线程池解决的核心问题就是资源管理问题。在并发环境下，系统不能够确定在任意时刻中，有多少任务需要执行，有多少资源需要投入。这种不确定性将带来以下若干问题：</p><ol><li>频繁申请&#x2F;销毁资源和调度资源，将带来额外的消耗，可能会非常巨大。</li><li>对资源无限申请缺少抑制手段，易引发系统资源耗尽的风险。</li><li>系统无法合理管理内部的资源分布，会降低系统的稳定性。</li></ol></li><li><p>提交任务<strong>execute、submit</strong>：</p><ol><li>execute只能提交Runnable类型的任务，没有返回值，而submit既能提交Runnable类型任务也能提交Callable类型任务，返回Future类型。</li><li>遇到未检查异常时，execute方法提交的任务异常是直接抛出的，而submit方法会将该异常包装在一个ExecutionException中并重新抛出，当调用FutureTask的get方法时，才会抛出异常。</li></ol></li></ul><h4 id="如何创建线程池"><a href="#如何创建线程池" class="headerlink" title="如何创建线程池"></a>如何创建线程池</h4><ul><li><p><strong>通过<code>ThreadPoolExecutor</code>构造函数来创建</strong>（推荐，让写的同学更加明确线程池的运行规则，规避资源耗尽的风险）</p></li><li><p>通过Executors（JDK内置的实现）</p><p><strong><code>FixedThreadPool</code><strong>：该方法返回一个</strong>固定线程数量</strong>的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。</p><p><strong><code>SingleThreadExecutor</code>：</strong> 该方法返回一个<strong>只有一个线程</strong>的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。</p><p><strong><code>CachedThreadPool</code>：</strong> 该方法返回一个创建一个具有缓存功能的线程池，<strong>可根据实际情况调整线程数量</strong>。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。</p><p>**<code>ScheduledThreadPool</code>**：该方法创建具有指定线程数（corePoolSize）的线程池，在给定的延迟后运行任务或者定期执行任务。</p></li></ul><h4 id="为什么不推荐使用内置线程池（阿里Java开发手册）"><a href="#为什么不推荐使用内置线程池（阿里Java开发手册）" class="headerlink" title="为什么不推荐使用内置线程池（阿里Java开发手册）"></a>为什么不推荐使用内置线程池（阿里Java开发手册）</h4><ul><li><p>**<code>FixedThreadPool</code> 和 <code>SingleThreadExecutor</code>**：任务队列（workQueue）使用的是无界的 <code>LinkedBlockingQueue</code>，允许的最大长度为 <code>Integer.MAX_VALUE</code>, 可能堆积大量的请求，从而导致 OOM。</p></li><li><p><code>CachedThreadPool</code>和 <code>ScheduledThreadPool</code>:  允许的创建线程数量（maximumPoolSize）为Integer.MAX_VALUE，可能会创建大量的线程，从而导致OOM。</p></li></ul><h4 id="线程池参数（可通过set方法动态修改）"><a href="#线程池参数（可通过set方法动态修改）" class="headerlink" title="线程池参数（可通过set方法动态修改）"></a>线程池参数（可通过set方法动态修改）</h4><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&mid=2651751537&idx=1&sn=c50a434302cc06797828782970da190e&scene=21#wechat_redirect">Java线程池实现原理及其在美团业务中的实践</a></p><p><strong><code>ThreadPoolExecutor</code> 3 个核心参数：</strong></p><ul><li><strong><code>corePoolSize</code> :</strong> 任务队列未达到队列容量时，最大可以同时运行的线程数量。</li><li><strong><code>maximumPoolSize</code> :</strong> 任务队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。不能小于核心线程数。线程数太多，会影响其他功能的执行。</li><li><strong><code>workQueue</code>:</strong> 新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</li></ul><blockquote><p>为什么是核心&#x2F;缺一不可？</p><p>从线程池的处理流程说起：</p><p><img src="https://s2.loli.net/2023/06/02/o4xg2qp6U9yYW87.png" alt="线程池处理流程"></p><ol><li><p>新来一个任务，首先检测线程池运行状态，如果不是RUNNING，则直接拒绝，线程池要保证在RUNNING的状态下执行任务</p></li><li><p>如果<strong>当前运行的线程数小于核心线程数</strong>，那么就会新建一个线程来执行任务。</p></li><li><p>如果当前运行的线程数等于或大于核心线程数，但是小于最大线程数，那么就把该任务放入到任务队列里等待执行。</p></li><li><p>如果向任务队列投放任务失败（任务队列已经满了），但是当前运行的线程数是小于最大线程数的，就新建一个线程来执行任务。</p></li><li><p>如果当前运行的线程数已经等同于最大线程数了，就按拒绝策略处理（默认抛异常AbortPolicy）。</p></li></ol></blockquote><p><code>ThreadPoolExecutor</code>其他常见参数 :</p><ul><li><strong><code>keepAliveTime</code></strong>:线程池中的线程数量大于 <code>corePoolSize</code> 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 <code>keepAliveTime</code>才会被回收销毁；</li><li><strong><code>unit</code></strong> : <code>keepAliveTime</code> 参数的时间单位。</li><li><strong><code>threadFactory</code></strong> :executor 创建新线程的时候会用到。</li><li><strong><code>handler</code></strong> :饱和策略。</li></ul><h4 id="如何设定线程池大小"><a href="#如何设定线程池大小" class="headerlink" title="如何设定线程池大小"></a>如何设定线程池大小</h4><p><strong>CPU 密集型任务(N+1)：</strong> 这种任务消耗的主要是 CPU 资源，可以将线程数设置为 N（CPU 核心数）+1，通常能实现最优的效率。比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。CPU 的每个核心工作基本都是满负荷的，如果设置了过多的线程，每个线程都想去利用 CPU 资源来执行自己的任务，这就会造成不必要的上下文切换，此时线程数的增多并没有让性能提升，反而由于线程数量过多会导致性能下降。</p><p><strong>I&#x2F;O 密集型任务(2N)：</strong> 这种任务应用起来，系统会用大部分的时间来处理 I&#x2F;O 交互，而线程在处理 I&#x2F;O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用。因此在 I&#x2F;O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 2N。</p><p>以下来自《Java并发编程实战》：</p><p><img src="http://img.ripplesu.top/blog/Typora/image-20230924113351761.png" alt="线程池最优大小计算公式"></p><h4 id="饱和-拒绝策略"><a href="#饱和-拒绝策略" class="headerlink" title="饱和&#x2F;拒绝策略"></a>饱和&#x2F;拒绝策略</h4><p><img src="https://s2.loli.net/2023/06/02/ZxfLp8bmOjro7nM.png" alt="图片"></p><h4 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h4><p>不同的线程池会选用不同的阻塞队列，我们可以结合内置线程池来分析。</p><ul><li>容量为 <code>Integer.MAX_VALUE</code> 的 <code>LinkedBlockingQueue</code>（无界队列）：<code>FixedThreadPool</code> 和 <code>SingleThreadExector</code> 。由于队列永远不会被放满，因此<code>FixedThreadPool</code>最多只能创建核心线程数的线程。</li><li><code>SynchronousQueue</code>（同步队列）：<code>CachedThreadPool</code> 。<code>SynchronousQueue</code> 没有容量，不存储元素，目的是保证对于提交的任务，如果有空闲线程，则使用空闲线程来处理；否则新建一个线程来处理任务。也就是说，<code>CachedThreadPool</code> 的最大线程数是 <code>Integer.MAX_VALUE</code> ，可以理解为线程数是可以无限扩展的，可能会创建大量线程，从而导致 OOM。</li><li><code>DelayedWorkQueue</code>（延迟阻塞队列）：<code>ScheduledThreadPool</code> 和 <code>SingleThreadScheduledExecutor</code> 。<code>DelayedWorkQueue</code> 的内部元素并不是按照放入的时间排序，而是会按照延迟的时间长短对任务进行排序，内部采用的是“堆”的数据结构，可以保证每次出队的任务都是当前队列中执行时间最靠前的。<code>DelayedWorkQueue</code> 添加元素满了之后会自动扩容原来容量的 1&#x2F;2，即永远不会阻塞，最大扩容可达 <code>Integer.MAX_VALUE</code>，所以最多只能创建核心线程数的线程。</li></ul><p><img src="https://s2.loli.net/2023/07/10/sZaWld4pr2wmAQg.png" alt="阻塞队列"></p><h4 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h4><p><img src="https://s2.loli.net/2023/06/02/IBxuikaj82Qzrc6.png" alt="图片"></p><p>生命周期转换：</p><p><img src="https://s2.loli.net/2023/06/02/l3gLmiW9RwTUsG4.png" alt="图片"></p><h4 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h4><ul><li><p>corePoolSize&#x3D;0会怎么样</p><p>在1.6版本之后，如果corePoolSize&#x3D;0，提交任务时如果线程池为空，则会立即创建一个线程来执行任务（先排队再获取）；如果提交任务的时候，线程池不为空，则先在等待队列中排队，只有队列满了才会创建新线程。</p></li><li><p>线程池被创建后里面有线程吗？如果没有的话，你知道有什么方法对线程池进行预热吗？</p><p>线程池被创建后如果没有任务过来，里面是不会有线程的。如果需要预热的话可以调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prestartAllCoreThreads、prestartCoreThreads（一个）</span><br></pre></td></tr></table></figure></li><li><p>核心线程数会被回收吗？需要什么设置？</p><p>核心线程数默认是不会被回收的，如果需要回收核心线程数，需要调用下面的方法：</p><p>allowCoreThreadTimeOut 该值默认为 false。</p></li><li><p><strong>怎么进行异常处理</strong></p><p>很多代码的写法，我们都习惯按照常见范式去编写，而没有去思考为什么。比如：</p><ul><li><p>如果我们使用execute()提交任务，我们一般要在Runable任务的代码加上try-catch进行异常处理。</p></li><li><p>如果我们使用submit()提交任务，我们一般要在主线程中，对Future.get()进行try-catch进行异常处理。</p></li></ul></li><li><p>线程池原理</p><p><a href="https://mp.weixin.qq.com/s/6fXHJGQJOyA8Q0KgBYqb4w">https://mp.weixin.qq.com/s/6fXHJGQJOyA8Q0KgBYqb4w</a></p><p><a href="https://pdai.tech/md/java/thread/java-thread-x-juc-executor-ThreadPoolExecutor.html#threadpoolexecutor%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3">JUC线程池: ThreadPoolExecutor详解 | Java 全栈知识体系 (pdai.tech)</a></p></li><li><p>优雅关闭</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">shutdownThreadPool</span><span class="params">(ExecutorService executor, Logger logger)</span> &#123;</span><br><span class="line">    <span class="comment">// 调用 shutdown()方法后线程池会在执行完正在执行的任务和队列中等待的任务后才彻底关闭</span></span><br><span class="line">    <span class="comment">// 调用 shutdown()方法后如果还有新的任务被提交，线程池则会根据拒绝策略直接拒绝后续新提交的任务。</span></span><br><span class="line">    executor.shutdown();</span><br><span class="line">    <span class="type">int</span> <span class="variable">retry</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">while</span> (retry &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        retry--;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (executor.awaitTermination(<span class="number">100</span>, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            executor.shutdownNow();</span><br><span class="line">            Thread.interrupted();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger != <span class="literal">null</span>) &#123;</span><br><span class="line">                logger.error(<span class="string">&quot;ThreadPoolManager shutdown executor has error : &quot;</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    executor.shutdownNow();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>动态线程池</p><p>美团文章：<a href="https://mp.weixin.qq.com/s/baYuX8aCwQ9PP6k7TDl2Ww">https://mp.weixin.qq.com/s/baYuX8aCwQ9PP6k7TDl2Ww</a></p><p><a href="https://github.com/opengoofy/hippo4j">https://github.com/opengoofy/hippo4j</a></p></li></ul><h3 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h3><p><code>Future</code> 类是异步思想的典型运用，主要用在一些需要执行耗时任务的场景，避免程序一直原地等待耗时任务执行完成，执行效率太低。具体来说是这样的：当我们执行某一耗时的任务时，可以将这个耗时任务交给一个子线程去异步执行，同时我们可以干点其他事情，不用傻傻等待耗时任务执行完成。等我们的事情干完后，我们再通过 <code>Future</code> 类获取到耗时任务的执行结果。这样一来，程序的执行效率就明显提高了。</p><p>这其实就是多线程中经典的 <strong>Future 模式</strong>，你可以将其看作是一种设计模式，核心思想是异步调用，主要用在多线程领域，并非 Java 语言独有。</p><p>在 Java 中，<code>Future</code> 类只是一个泛型接口，位于 <code>java.util.concurrent</code> 包下，其中定义了 5 个方法，主要包括下面这 4 个功能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// V 代表了Future执行的任务返回值的类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Future</span>&lt;V&gt; &#123;</span><br><span class="line">    <span class="comment">// 取消任务执行</span></span><br><span class="line">    <span class="comment">// 成功取消返回 true，否则返回 false</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">cancel</span><span class="params">(<span class="type">boolean</span> mayInterruptIfRunning)</span>;</span><br><span class="line">    <span class="comment">// 判断任务是否被取消</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isCancelled</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 判断任务是否已经执行完成</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isDone</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 获取任务执行结果</span></span><br><span class="line">    V <span class="title function_">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException;</span><br><span class="line">    <span class="comment">// 指定时间内没有返回计算结果就抛出 TimeOutException 异常</span></span><br><span class="line">    V <span class="title function_">get</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutExceptio</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单理解就是：我有一个任务，提交给了 <code>Future</code> 来处理。任务执行期间我自己可以去做任何想做的事情。并且，在这期间我还可以取消任务以及获取任务的执行状态。一段时间之后，我就可以 <code>Future</code> 那里直接取出任务执行结果。</p><h4 id="Callable-和-Future-有什么关系？"><a href="#Callable-和-Future-有什么关系？" class="headerlink" title="Callable 和 Future 有什么关系？"></a>Callable 和 Future 有什么关系？</h4><p>我们可以通过 <code>FutureTask</code> 来理解 <code>Callable</code> 和 <code>Future</code> 之间的关系。</p><p><code>FutureTask</code> 提供了 <code>Future</code> 接口的基本实现，常用来封装 <code>Callable</code> 和 <code>Runnable</code>，具有取消任务、查看任务是否执行完成以及获取任务执行结果的方法。<code>ExecutorService.submit()</code> 方法返回的其实就是 <code>Future</code> 的实现类 <code>FutureTask</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Callable&lt;T&gt; task)</span>;</span><br><span class="line">Future&lt;?&gt; submit(Runnable task);</span><br></pre></td></tr></table></figure><p><code>FutureTask</code> 不光实现了 <code>Future</code>接口，还实现了<code>Runnable</code> 接口，因此可以作为任务直接被线程执行。</p><p><code>FutureTask</code> 有两个构造函数，可传入 <code>Callable</code> 或者 <code>Runnable</code> 对象。实际上，传入 <code>Runnable</code> 对象也会在方法内部转换为<code>Callable</code> 对象。</p><p><code>FutureTask</code>相当于对<code>Callable</code> 进行了封装，管理着任务执行的情况，存储了 <code>Callable</code> 的 <code>call</code> 方法的任务执行结果。</p><h4 id="CompletableFuture-类有什么用？"><a href="#CompletableFuture-类有什么用？" class="headerlink" title="CompletableFuture 类有什么用？"></a>CompletableFuture 类有什么用？</h4><p>美团：<a href="https://mp.weixin.qq.com/s/GQGidprakfticYnbVYVYGQ">https://mp.weixin.qq.com/s/GQGidprakfticYnbVYVYGQ</a></p><p>CompletableFuture是由Java 8引入的，在Java8之前我们一般通过Future实现异步。</p><ul><li>Future用于表示异步计算的结果，只能通过<strong>阻塞（get方法）或者轮询（isDone）</strong>的方式获取结果，而且不支持设置回调方法，Java 8之前若要设置回调一般会使用guava的ListenableFuture，回调的引入又会导致臭名昭著的回调地狱（由于每次异步操作都需要有一个回调函数来执行就绪后的后续逻辑，因此当遇上各个异步操作之前有先后关系时，势必就要回调套回调。当业务代码一复杂，回调套回调写多了，造成代码难以阅读和调试，就成了所谓的回调地狱。）。</li><li>CompletableFuture对Future进行了扩展，可以通过设置回调的方式处理计算结果，同时也支持组合操作，支持进一步的编排，同时一定程度解决了回调地狱的问题。还提供了函数式编程、异步任务编排组合（可以将多个异步任务串联起来，组成一个完整的链式调用）等能力。</li><li>Future要捕获异常只能通过get方法，completableFuture可以通过exceptionally回调处理异常</li></ul><h5 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h5><p><code>CompletableFuture</code> 同时实现了 <code>Future</code> 和 <code>CompletionStage</code> 接口。<code>CompletionStage</code> 接口描述了一个异步计算的阶段。Future表示异步计算的结果，CompletionStage用于表示异步执行过程中的一个步骤（Stage），这个步骤可能是由另外一个CompletionStage触发的，随着当前步骤的完成，也可能会触发其他一系列CompletionStage的执行。从而我们可以根据实际业务对这些步骤进行多样化的编排组合，CompletionStage接口正是定义了这样的能力，我们可以通过其提供的thenAppy、thenCompose等函数式编程方法来组合编排这些步骤。</p><p>默认使用ForkJoinPool.commonPool（进程公共线程池CommonPool的大小是CPU核数-1，如果是IO密集的应用，线程数可能成为瓶颈）；</p><p>类似观察者模式：每个CompletableFuture都可以被看作一个被观察者，其内部有一个Completion类型的链表成员变量stack，用来存储注册到其中的所有观察者。当被观察者执行完成后会弹栈stack属性，依次通知注册到其中的观察者。</p><h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><p>CompletableFuture实现了CompletionStage接口，通过丰富的回调方法，支持各种组合操作，每种组合场景都有同步和异步两种方法。</p><p>同步方法（即不带Async后缀的方法）有两种情况。</p><ul><li>如果注册时被依赖的操作<strong>已经执行完成</strong>，则直接由<strong>当前线程</strong>执行。</li><li>如果注册时被依赖的操作<strong>还未执行完</strong>，则由<strong>回调线程</strong>执行。</li></ul><p>异步方法（即带Async后缀的方法）：可以选择是否传递线程池参数Executor运行在指定线程池中；当不传递Executor时，会使用ForkJoinPool中的共用线程池CommonPool（CommonPool的大小是CPU核数-1，如果是IO密集的应用，线程数可能成为瓶颈）。</p><h3 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h3><p>AQS 的全称为 <code>AbstractQueuedSynchronizer</code> ，翻译过来的意思就是抽象队列同步器。这个类在 <code>java.util.concurrent.locks</code> 包下面。</p><p>AQS 就是一个抽象类，主要用来构建锁和同步器。</p><p>AQS 为构建锁和同步器提供了一些通用功能的实现，因此，使用 AQS 能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的 <code>ReentrantLock</code>，<code>Semaphore</code>，其他的诸如 <code>ReentrantReadWriteLock</code>，<code>SynchronousQueue</code>等等皆是基于 AQS 的。</p><h4 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h4><p><code>CountDownLatch</code> 允许 <code>count</code> 个线程阻塞在一个地方，直至所有线程的任务都执行完毕。</p><p><code>CountDownLatch</code> 是一次性的，计数器的值只能在构造方法中初始化一次，之后没有任何机制再次对其设置值，当 <code>CountDownLatch</code> 使用完毕后，它不能再次被使用。</p><ul><li><p>原理</p><p><code>CountDownLatch</code> 是共享锁的一种实现,它默认构造 AQS 的 <code>state</code> 值为 <code>count</code>。当线程使用 <code>countDown()</code> 方法时,其实使用了<code>tryReleaseShared</code>方法以 CAS 的操作来减少 <code>state</code>,直至 <code>state</code> 为 0 。当调用 <code>await()</code> 方法的时候，如果 <code>state</code> 不为 0，那就证明任务还没有执行完毕，<code>await()</code> 方法就会一直阻塞，也就是说 <code>await()</code> 方法之后的语句不会被执行。然后，<code>CountDownLatch</code> 会自旋 CAS 判断 <code>state == 0</code>，如果 <code>state == 0</code> 的话，就会释放所有等待的线程，<code>await()</code> 方法之后的语句得到执行。</p></li><li><p>应用场景</p><p>例如：我们要读取处理 6 个文件，这 6 个任务都是没有执行顺序依赖的任务，但是我们需要返回给用户的时候将这几个文件的处理的结果进行统计整理。</p><p>为此我们定义了一个线程池和 count 为 6 的<code>CountDownLatch</code>对象 。使用线程池处理读取任务，每一个线程处理完之后就调用countDownLatch.countDown()使count-1;，调用<code>CountDownLatch</code>对象的 <code>await()</code>方法，直到所有文件读取完之后，才会接着执行后面的逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理文件的数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadCount</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 创建一个具有固定线程数量的线程池对象（推荐使用构造方法创建）</span></span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(threadCount);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadnum</span> <span class="operator">=</span> i;</span><br><span class="line">        threadPool.execute(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//处理文件的业务操作</span></span><br><span class="line">                <span class="comment">//......</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//表示一个文件已经被完成</span></span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    countDownLatch.await();</span><br><span class="line">    threadPool.shutdown();</span><br><span class="line">    System.out.println(<span class="string">&quot;finish&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a><strong>CyclicBarrier</strong></h4><p>CyclicBarrier 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。</p><p>这个屏障之所以用循环修饰，是因为在所有的线程释放彼此之后，这个屏障是可以重新使用的（reset()方法重置屏障点），这一点与CountDownLatch不同。</p><p>CyclicBarrier是一种同步机制允许一组线程相互等待，等到所有线程都到达一个屏障点才退出await方法，它没有直接实现AQS而是借助ReentrantLock来实现的同步机制。它是<strong>可循环使用的，而CountDownLatch是一次性的</strong>，另外它体现的语义也跟CountDownLatch不同，CountDownLatch减少计数到达条件采用的是release方式，而CyclicBarrier走向屏障点（await）采用的是Acquire方式，Acquire是会阻塞的，这也实现了CyclicBarrier的另外一个特点，<strong>只要有一个线程中断那么屏障点就被打破，所有线程都将被唤醒</strong>（CyclicBarrier自己负责这部分实现，不是由AQS调度的），这样也避免了因为一个线程中断引起永远不能到达屏障点而导致其他线程一直等待。屏障点被打破的CyclicBarrier将不可再使用（会抛出BrokenBarrierException）除非执行reset操作。</p><ul><li>CountDownLatch：一个或者多个线程，等待其他多个线程完成某件事情之后才能执行；</li><li>CyclicBarrier：多个线程互相等待，直到到达同一个同步点，再继续一起执行。</li></ul><h3 id="Java中乐观锁和悲观锁的区别"><a href="#Java中乐观锁和悲观锁的区别" class="headerlink" title="Java中乐观锁和悲观锁的区别"></a>Java中乐观锁和悲观锁的区别</h3><p>悲观锁：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。Java中悲观锁是通过synchronized关键字或Lock接口来实现的。</p><p>乐观锁：顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据。乐观锁适用于多读的应用类型，这样可以提高吞吐量。在JDK1.5 中新增 java.util.concurrent (J.U.C)就是建立在CAS之上的。相对于对于 synchronized 这种阻塞算法，CAS是非阻塞算法的一种常见实现。所以J.U.C在性能上有了很大的提升。但是，如果冲突频繁发生（写占比非常多的情况），会频繁失败和重试，这样同样会非常影响性能，导致 CPU 飙升。</p><ul><li>悲观锁通常多用于写比较多的情况下（多写场景，竞争激烈），这样可以避免频繁失败和重试影响性能，悲观锁的开销是固定的。不过，如果乐观锁解决了频繁失败和重试这个问题的话（比如<code>LongAdder</code>），也是可以考虑使用乐观锁的，要视实际情况而定。</li><li>乐观锁通常多于写比较少的情况下（多读场景，竞争较少），这样可以避免频繁加锁影响性能。不过，乐观锁主要针对的对象是单个共享变量（参考<code>java.util.concurrent.atomic</code>包下面的原子变量类）。</li></ul><h4 id="如何实现乐观锁？"><a href="#如何实现乐观锁？" class="headerlink" title="如何实现乐观锁？"></a>如何实现乐观锁？</h4><p>乐观锁一般会使用版本号机制或 CAS 算法实现，CAS 算法相对来说更多一些，这里需要格外注意。</p><h5 id="版本号机制"><a href="#版本号机制" class="headerlink" title="版本号机制"></a>版本号机制</h5><p>一般是在数据表中加上一个数据版本号 <code>version</code> 字段，表示数据被修改的次数。当数据被修改时，<code>version</code> 值会加一。当线程 A 要更新数据值时，在读取数据的同时也会读取 <code>version</code> 值，在提交更新时，若刚才读取到的 version 值为当前数据库中的 <code>version</code> 值相等（where version&#x3D;oldVersion）时才更新，否则重试更新操作，直到更新成功。</p><h5 id="CAS-算法"><a href="#CAS-算法" class="headerlink" title="CAS 算法"></a>CAS 算法</h5><p>CAS 的全称是 <strong>Compare And Swap（比较与交换）</strong> ，用于实现乐观锁，被广泛应用于各大框架中。CAS 的思想很简单，就是用一个预期值和要更新的变量值进行比较，两值相等才会进行更新。</p><p>CAS 是一个<strong>原子操作</strong>，底层依赖于一条 CPU 的原子指令。</p><blockquote><p><strong>原子操作</strong> 即最小不可拆分的操作，也就是说操作一旦开始，就不能被打断，直到操作完成。</p></blockquote><p>CAS 涉及到三个操作数：</p><ul><li><strong>V</strong>：要更新的变量值(Var)</li><li><strong>E</strong>：预期值(Expected)</li><li><strong>N</strong>：拟写入的新值(New)</li></ul><p>当且仅当 V 的值等于 E 时，CAS 通过原子方式用新值 N 来更新 V 的值。如果不等，说明已经有其它线程更新了 V，则当前线程放弃更新。当多个线程同时使用 CAS 操作一个变量时，只有一个会胜出，并成功更新，其余均会失败，但失败的线程并不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作。</p><ul><li><p>ABA 问题</p><p>如果一个变量 V 初次读取的时候是 A 值，并且在准备赋值的时候检查到它仍然是 A 值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回 A，那 CAS 操作就会误认为它从来没有被修改过。这个问题被称为 CAS 操作的 <strong>“ABA”问题。</strong></p><p>ABA 问题的解决思路是在变量前面追加上<strong>版本号或者时间戳</strong>。JDK 1.5 以后的 <code>AtomicStampedReference</code> 类就是用来解决 ABA 问题的，其中的 <code>compareAndSet()</code> 方法就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p></li><li><p>循环时间长开销大</p><p>CAS 经常会用到<strong>自旋</strong>操作来进行重试（CAS基于硬件实现，不需要进入核心态，不需要切换线程），也就是不成功就一直循环执行直到成功。如果长时间不成功，会给 CPU 带来非常大的执行开销。</p><p>如果 JVM 能支持处理器提供的 pause 指令那么效率会有一定的提升，pause 指令有两个作用：</p><ol><li>可以延迟流水线执行指令，使 CPU 不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。</li><li>可以避免在退出循环的时候因内存顺序冲而引起 CPU 流水线被清空，从而提高 CPU 的执行效率。</li></ol></li><li><p>只能保证一个共享变量的原子操作</p><p>CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效。但是从 JDK 1.5 开始，提供了<code>AtomicReference</code>类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作.所以我们可以使用锁或者利用<code>AtomicReference</code>类把多个共享变量合并成一个共享变量来操作。</p></li></ul><h3 id="相关面试题"><a href="#相关面试题" class="headerlink" title="相关面试题"></a>相关面试题</h3><h4 id="线程交替打印"><a href="#线程交替打印" class="headerlink" title="线程交替打印"></a>线程交替打印</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 交替打印ABC</span></span><br><span class="line"><span class="type">char</span>[] abc = <span class="string">&quot;ABC&quot;</span>.toCharArray();</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="built_in">this</span>::printABC).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="built_in">this</span>::printABC).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="built_in">this</span>::printABC).start();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printABC</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (i)&#123;</span><br><span class="line">        <span class="keyword">while</span> (count &lt; <span class="number">5</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">                System.out.println(abc[i++]);</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">3</span>) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    i = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印0-100</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="built_in">this</span>::print).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="built_in">this</span>::print).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="built_in">this</span>::print).start();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (i)&#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">            System.out.println(i++);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="死锁例子"><a href="#死锁例子" class="headerlink" title="死锁例子"></a>死锁例子</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadlockExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">lock1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">lock2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span>(lock1) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Thread 1 acquired lock 1&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">                    <span class="keyword">synchronized</span>(lock2) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;Thread 1 acquired lock 2&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span>(lock2) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Thread 2 acquired lock 2&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">                    <span class="keyword">synchronized</span>(lock1) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;Thread 2 acquired lock 1&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><ul><li><p>怎么理解面向对象</p><p>面向对象就是把现实中客观存在的事物看做一个对象，然后将对象中共有的数据和行为抽象为软件中的类。面向对象的思维更注重解决问题的过程中需要有哪些参与者，每个参与者各自负责什么事情，参与者之间如何协作；而面向过程的思维方式更注重解决问题的步骤，自顶向下顺序执行。</p></li><li><p>面向对象三大特征</p><ul><li><p>封装</p><p>封装就是把事物的属性和行为包装到对象中，通过可以被外界访问的方法有选择性（通过访问修饰符）的暴露对象的数据和功能。</p><p>目的：</p><ul><li>隐藏类的实现细节</li><li>让使用者只能通过事先预定的方法来访问数据，限制对成员变量的不合理访问</li></ul></li><li><p>继承</p><p>继承是实现软件复用的重要手段。不同类型对象间存在共同点，可以这些共同点抽取出来封装在父类中，当子类继承父类后，将直接获得父类的属性和方法。</p><ul><li><p>为什么Java只能单继承</p><p>Java中一个类只能有一个直接的父类。多继承容易产生混淆。比如，两个父类中包含相同的方法时，子类在调用该方法时就会迷惑（需要额外机制解决）。</p><p>单一继承模型可以使类的层次结构更加清晰和简洁，易于理解和使用。如果允许多重继承，类的继承层次将变得复杂和难以理解，同时也会增加代码的维护难度和复杂性。</p></li><li><p>接口为什么多继承</p><p>接口中的方法都是抽象方法，没有具体实现，因此不会混淆。</p></li></ul></li><li><p>多态</p><p>对象在执行同一个方法时，可能表现出多种行为特征。最常见的就是子类对象可以直接赋给父类变量，父类变量运行时就可以表现出子类的行为特征</p><p>常见例子：List list &#x3D; new ArrayList&lt;&gt;();</p><p>优点：灵活，解耦（不依赖于某个具体的子类）</p><blockquote><p>Java中多态怎么实现？</p></blockquote><p>重载式多态,也叫编译时多态。编译时多态是静态的,主要是指方法的重载,它是根据参数列表来区分不同的方法，编译后变成两个不同方法。</p><p>Java中运行时多态性的实现方式是通过<strong>方法重写</strong>和<strong>向上转型</strong>（Upcasting）来实现的。</p><ul><li><p>方法重写是指子类覆盖父类的方法，并且方法名、参数列表和返回值类型都相同。或实现抽象类&#x2F;接口的某些抽象方法。</p></li><li><p>向上转型则是指将一个子类对象赋给一个父类引用，从而使得这个对象能够以父类的形式来被访问。</p><p>设计程序时，我们可以将参数的类型定义为父类型。在调用程序时，则可以根据实际情况，传入子类的实例。</p><p><strong>向上转型</strong>是安全的。但是缺点是：一旦向上转型，子类会<strong>丢失</strong>的子类的扩展方法</p><blockquote><p>向下转型：父类对象赋给子类引用，需要强转</p></blockquote></li></ul></li></ul></li></ul><h3 id="SOLID原则"><a href="#SOLID原则" class="headerlink" title="SOLID原则"></a>SOLID原则</h3><ul><li><p>单一责任原则<br>指的是一个类或者一个方法只做一件事。如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化就可能对其他职责产生影响。</p></li><li><p>开放封闭原则——核心，即其他原则都是开闭原则的手段和工具<br>对扩展开放，对修改关闭。需求改变时，尽可能少地改变软件实体源代码（类、接口、方法等），通过扩展功能使其满足新的需求。例如接口，需求变动时只需增加一个新的实现类，无需修改原有接口。</p><p>提高复用性（复用接口或抽象类中的定义和代码）和可维护性（需求变动只需修改具体实现类）</p></li><li><p>里氏替换原则<br>所有基类出现的地方都可以用派生类替换而不会程序产生错误。子类可以扩展父类的功能，但不能改变父类原有的功能。</p></li><li><p>接口隔离原则<br>类不应该依赖不需要的接口。如果类被强迫依赖于他们不需要的接口，当这些接口发生改变时，他们也不得不跟着改变。</p></li><li><p>依赖倒置原则<br>高层模块不应该依赖低层模块，双方应该依赖抽象。抽象不应该依赖细节，而细节应该依赖抽象。遵循依赖倒置原则可以使高层模块与低层模块解耦，避免当低层模块需要替换或者修改时对高层模块的影响。</p><p><img src="https://s2.loli.net/2023/05/28/dfm4WClIv9Kiwq2.png" alt="依赖倒置"></p></li></ul><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><p>设计模式，是面向对象设计中常见问题的典型解决方案。模式并不是一段特定的代码， 而是前人根据实践验证的解决特定问题的一般性概念。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性、程序的重用性。</p><ul><li>创建型模式，共五种：<strong>工厂方法模式、抽象工厂模式</strong>、<strong>单例模式</strong>、建造者模式、原型模式。</li></ul><ul><li><p>结构型模式，共七种：适配器模式、装饰器模式、<strong>代理模式</strong>、外观模式、桥接模式、组合模式、享元模式。</p></li><li><p>行为型模式，共十一种：<strong>策略模式</strong>、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</p></li></ul><p>适当的使用设计模式，让我们的代码更加简洁、易读、可扩展。</p><p>设计模式（Design Pattern）是一套被反复使用、多人知晓、分类编目、代码设计经验的总结。使用设计模式可以带来如下益处。</p><ul><li>简洁。比如单例模式，减少多实例创建维护的成本，获取实例只需要一个 Get 函数。</li><li>易读。业界经验，多人知晓。如果告知他人自己使用了相应的设计模式实现某个功能，那么他人便大概知晓了你的实现细节，更加容易读懂你的代码。</li><li>可扩展。设计模式不仅能简洁我们的代码，还可以增加代码的可扩展性。比如 Go 推崇的 Option 模式，既避免了书写不同参数版本的函数，又达到了无限扩增函数参数的效果，增加了函数扩展性。</li></ul><h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><p><strong>单例模式</strong>是一种创建型设计模式， 可以保证一个类只有一个实例， 并提供一个访问该实例的方法。</p><p>所有单例的实现都包含以下两个相同的步骤：</p><ul><li>将默认构造函数设为私有， 防止其他对象使用<code>new</code>来获得单例类的实例。</li><li>新建一个对外开放的静态方法作为构造和获取单例对象的函数。</li></ul><p><img src="https://s2.loli.net/2023/06/11/38jOeamYTL2GiVo.png" alt="image-20230611190600016"></p><p>具体而言，在Java中单例模式一般有五种实现：</p><ul><li><p>饿汉式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 优点：线程安全,不加锁，调用效率高</span></span><br><span class="line"><span class="comment">// 缺点：类初始化时,会立即加载该对象（可能浪费内存）；</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();  </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span> <span class="params">()</span>&#123;&#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>懒汉式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非线程安全，懒加载</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;  </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span> <span class="params">()</span>&#123;&#125;  </span><br><span class="line">    <span class="comment">// 如果加了锁，性能差，只要有一个线程执行getInstance，其他线程只能等待</span></span><br><span class="line">    <span class="comment">// 为什么不用volatile？锁住了整个方法，无线程安全问题</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">static</span> <span class="params">(<span class="keyword">synchronized</span>)</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;  </span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>双重校验锁（DCL）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 懒加载，线程安全，性能较上一种好（锁粒度小）；但实现复杂</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;  </span><br><span class="line">    <span class="comment">// volatile变量  保证可见性、禁止指令重排序</span></span><br><span class="line">    <span class="comment">/* singleton = new Singleton() 并非是一个原子操作，在 JVM 中上述语句至少做了以下这 3 件事：</span></span><br><span class="line"><span class="comment">                    第一步是给 singleton 分配内存空间；</span></span><br><span class="line"><span class="comment">                    第二步开始调用 Singleton 的构造函数等，来初始化 singleton；</span></span><br><span class="line"><span class="comment">                    第三步将 singleton 对象指向分配的内存空间（执行完这步 singleton 就不是 null 了）。</span></span><br><span class="line"><span class="comment">                    由于JVM具有指令重排的特性，执行的顺序可能是1-&gt;3-&gt;2,</span></span><br><span class="line"><span class="comment">                    指令重排在单线程下不会有线程安全问题，但在多线程环境下，会导致一个线程获得还没有初始化的实例。</span></span><br><span class="line"><span class="comment">                    例如线程T1执行1、3，此时线程T2调用getSingleton()方法后发现singleton不为空,因此返回singleton,但此时singleton 还未被实例化</span></span><br><span class="line"><span class="comment">                    使用volatile关键字可以禁止指令重排序，保证在多线程环境下能正常运行*/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;  </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span> <span class="params">()</span>&#123;&#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getSingleton</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="comment">// 如果已经实例化，则无需等待</span></span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;  </span><br><span class="line">            <span class="comment">// 假设有两个线程T1和T2，都进行完第一次判空了，且都阻塞在此位置</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;  </span><br><span class="line">                <span class="comment">// 如果这里不判空T1和T2都会创建singleton实例，这就违背了单例模式设计的初衷</span></span><br><span class="line">                <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;  </span><br><span class="line">                    singleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>() </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> singleton;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>静态内部类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 与DCL效果一致，静态内部类使用时才加载，线程安全</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;  </span><br><span class="line">    <span class="comment">// 外部类加载时并不会立即加载内部类，只有当getInstance()方法第一次被调用时，才会去加载SingletonHolder类，初始化INSTANCE。具体与JVM类加载机制有关</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span> <span class="params">()</span>&#123;&#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>枚举</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程安全，实现简单，非懒加载</span></span><br><span class="line"><span class="comment">// JVM会保证枚举对象的唯一性、不存在线程安全问题，在很多书和文章中都强烈推荐将该方法作为单例模式的最佳实现方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">doSomeThing</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// Do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用方法</span></span><br><span class="line">Singleton.INSTANCE.doSomething();</span><br></pre></td></tr></table></figure></li></ul><h4 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h4><p>结构型设计模式的一种。思想是通过代理控制对目标对象的访问，在不改变目标类方法的代码的情况下对目标类的方法进行增强，比如在这个调用目标方法前后增加一些非核心业务逻辑的处理或添加新的功能。</p><p><img src="https://s2.loli.net/2023/06/12/SIsu3PbTZxirLYO.png" alt="代理模式类图"></p><p>应用场景：Spring AOP、日志打印、访问控制、异常处理等</p><ul><li><p>静态代理</p><p>程序员自己写代理类。所谓静态也就是代理关系在编译期间就已经确定了，运行前代理类的字节码文件就已经存在。</p><p>缺点：每个需要代理的对象都需要自己重复编写代理。</p></li><li><p>动态代理</p><p>代理类在程序运行时创建的代理方式被成为动态代理。</p><ul><li><p>JDK动态代理：只能代理接口，故目标类必须实现接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;保存数据方法&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每次生成动态代理类对象时,实现了InvocationHandler接口的调用处理器对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InvocationHandlerImpl</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这目标类对象，用来调用具体的业务方法</span></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过构造函数传入目标对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">InvocationHandlerImpl</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 动态生成代理类对象,Proxy.newProxyInstance</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回代理类的实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">newProxyInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">                <span class="comment">//指定代理对象的类加载器</span></span><br><span class="line">                target.getClass().getClassLoader(),</span><br><span class="line">                <span class="comment">//代理对象需要实现的接口，可以同时指定多个接口</span></span><br><span class="line">                target.getClass().getInterfaces(),</span><br><span class="line">                <span class="comment">//方法调用的实际处理者，代理对象的方法调用都会转发到这里</span></span><br><span class="line">                <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//动态代理实际运行的代理方法</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用开始处理&quot;</span>);</span><br><span class="line">        <span class="comment">//下面invoke()方法是以反射的方式来创建对象，第一个参数是要创建的对象，第二个是构成方法的参数，由第二个参数来决定创建对象使用哪个构造方法</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;调用结束处理&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 被代理对象</span></span><br><span class="line">        <span class="type">UserDao</span> <span class="variable">userDaoImpl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>();</span><br><span class="line">        <span class="type">InvocationHandlerImpl</span> <span class="variable">invocationHandlerImpl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvocationHandlerImpl</span>(userDaoImpl);</span><br><span class="line"></span><br><span class="line">        <span class="type">UserDao</span> <span class="variable">newProxyInstance</span> <span class="operator">=</span> </span><br><span class="line">            (UserDao) invocationHandlerImpl.newProxyInstance();</span><br><span class="line">        newProxyInstance.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>为什么只能代理接口？</p><p>JDK动态代理会在程序运行期动态生成代理类，这个代理类会继承java.lang.reflect.Proxy类，同时实现被代理类的接口。由于Java只支持单继承，所以不支持代理类。</p></li></ul></li><li><p>CGLIB动态代理：代理类去继承目标类（final类不能代理），然后重写其中目标类的方法</p><p>需要导入第三方框架的jar包。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 被代理类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;保存数据方法&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cglib.proxy.MethodProxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代理主要类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CglibProxy</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * CGLIB 增强类对象，代理类对象是由 Enhancer 类创建的，</span></span><br><span class="line"><span class="comment">    * Enhancer 是 CGLIB 的字节码增强器，可以很方便的对类进行拓展</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>  Object <span class="title function_">newProxyInstance</span><span class="params">(Class&lt;?&gt; c)</span> &#123;</span><br><span class="line">       <span class="comment">// 设置产生的代理对象的父类,增强类型</span></span><br><span class="line">       enhancer.setSuperclass(c);</span><br><span class="line">       <span class="comment">// 定义代理逻辑对象为当前对象，要求当前对象实现 MethodInterceptor 接口</span></span><br><span class="line">       enhancer.setCallback(<span class="built_in">this</span>);</span><br><span class="line">       <span class="comment">// 使用默认无参数的构造函数创建目标对象,这是一个前提,被代理的类要提供无参构造方法</span></span><br><span class="line">       <span class="keyword">return</span> enhancer.create();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代理实际方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;开启代理&quot;</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> proxy.invoke(obj, args);</span><br><span class="line">System.out.println(<span class="string">&quot;关闭代理&quot;</span>);</span><br><span class="line"><span class="comment">// 返回代理对象</span></span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainCglibProxy</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">CglibProxy</span> <span class="variable">cglibProxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CglibProxy</span>();</span><br><span class="line">        <span class="type">UserDao</span> <span class="variable">userDao</span> <span class="operator">=</span> </span><br><span class="line">            (UserDao) cglibProxy.getInstance(UserDao.class);</span><br><span class="line">        userDao.save();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h4><blockquote><p>话术</p><p>工厂模式就是通过工厂类来实例化对象。它适合用来创建复杂对象，对外隐藏实现细节。</p><p>工厂模式一般可以分为简单工厂、工厂方法和抽象工厂三种。</p><p>简单工厂模式不属于GOF的23种经典设计模式，相当于一种编程习惯。它主要包含一个抽象产品类、若干个具体产品类和一个具体工厂类。具体工厂类中提供了创建产品的方法，通过方法中传入的参数来判断要创建哪种产品的实例。如果后续需求变动，例如增加了产品的种类，就需要修改工厂类的代码，不符合开闭原则。</p><p>工厂方法模式，在简单工厂模式基础上增加了一个抽象工厂。抽象工厂不负责具体产品的创建，只提供一个用于创建产品的接口，把具体的创建工作交给子类完成。当增加新的具体产品类时只需要新增对应的抽象工厂的子类，并实现创建具体产品的方法，无须对抽象工厂进行任何修改，满足开闭原则；</p><p>抽象工厂模式与工厂方法类似，区别是</p><ul><li>工厂方法模式只有一个抽象产品类，而抽象工厂模式有多个。</li><li>工厂方法模式的具体工厂类只能创建一个具体产品类的实例，而抽象工厂模式可以创建多个。</li><li>工厂方法是由子类自行决定实例化那个类，而抽象工厂是自己决定实例化哪个类。</li></ul></blockquote><p>通过工厂类来实例化对象。适合用来创建复杂对象，对外隐藏实现细节。</p><ul><li><p>简单工厂：非GoF23种之一，是一种编程习惯</p><p>简单工厂模式包含如下三种角色：</p><ul><li>抽象产品：定义了产品的规范，描述了产品的主要特性和功能。</li><li>具体产品：实现或者继承抽象产品的子类。</li><li>具体工厂：提供了创建产品的方法，使用者通过该方法来获取产品。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 在工厂方法中根据类型创建不同的具体对象</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleCoffeeFactory</span> &#123;</span><br><span class="line"><span class="comment">// 根据type判断类型，实例化并返回对应对象</span></span><br><span class="line">    <span class="keyword">public</span> Coffee <span class="title function_">createCoffee</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        <span class="type">Coffee</span> <span class="variable">coffee</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;americano&quot;</span>.equals(type)) &#123;</span><br><span class="line">            coffee = <span class="keyword">new</span> <span class="title class_">AmericanoCoffee</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;latte&quot;</span>.equals(type)) &#123;</span><br><span class="line">            coffee = <span class="keyword">new</span> <span class="title class_">LatteCoffee</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> coffee;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>缺点：不遵循开闭原则，每增加一个新的产品就需要修改代码。</p></li><li><p>工厂方法模式</p><p>它的核心结构有四个角色，分别是抽象工厂、具体工厂、抽象产品、具体产品。</p><p>四个角色：</p><ul><li>抽象工厂（Abstract Factory）：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法来创建产品。允许子类决定实例化对象的类型。</li><li>具体工厂（ConcreteFactory）：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。</li><li>抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能。</li><li>具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。</li></ul><p>一个抽象产品类，可以派生出多个具体产品类。一个抽象工厂类，可以派生出多个具体工厂类。</p><p><strong>每个具体工厂类只能创建一个具体产品类的实例</strong>。</p><p>优点：增加新的类时只需要添加对应的具体工厂类，无须对原工厂进行任何修改，满足开闭原则；</p><p>缺点：每增加一个类就要增加一个对应的具体工厂类，增加了系统的复杂度。</p><p><img src="https://s2.loli.net/2023/05/28/sENRAtVWPmhypY9.png" alt="image-20230528152217369"></p></li><li><p>抽象工厂</p><p><strong>多个抽象产品类，每个抽象产品类可以派生出多个具体产品类</strong>。一个抽象工厂类，可以派生出多个具体工厂类。<br><strong>每个具体工厂类可以创建多个具体产品类的实例</strong>。</p><p><strong>与工厂方法区别</strong>：</p><ul><li>工厂方法模式只有一个抽象产品类，而抽象工厂模式有多个。</li><li>工厂方法模式的具体工厂类只能创建一个具体产品类的实例，而抽象工厂模式可以创建多个。</li><li>工厂方法是由子类自行决定实例化那个类，而抽象工厂是自己决定实例化哪个类。</li></ul><p>抽象工厂模式的主要角色如下：</p><ul><li>抽象工厂（Abstract Factory）：提供了创建产品的接口，它包含多个创建产品的方法，可以创建多个不同等级的产品。</li><li>具体工厂（Concrete Factory）：主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建。</li><li>抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。</li><li>具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它 同具体工厂之间是多对一的关系。</li></ul><p><img src="https://s2.loli.net/2023/05/28/FkgBex4KvX8AQVj.png" alt="image-20230528153749597"></p></li></ul><h4 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h4><p><a href="https://refactoringguru.cn/design-patterns/decorator">https://refactoringguru.cn/design-patterns/decorator</a></p><p>在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式，它属于对象结构型模式。</p><ul><li><p>为什么要用装饰器模式？</p><p>通常情况下，扩展一个类的功能会使用继承方式来实现。但继承有如下缺点：</p><ul><li><p>继承是静态的。 你无法在运行时更改已有对象的行为， 只能使用由不同子类创建的对象来替代当前的整个对象。</p></li><li><p>子类只能有一个父类。 大部分编程语言不允许一个类同时继承多个类的行为。</p></li></ul><p>随着扩展功能的增多，子类会很膨胀。</p><p>通过装饰器模式，可以在程序运行时动态给被装饰对象增加功能，比使用继承更加灵活。</p></li></ul><p>装饰器模式主要包含以下角色。</p><ol><li>抽象构件（Component）角色：定义一个抽象接口以规范准备接收附加责任的对象。</li><li>具体构件（ConcreteComponent）角色：实现抽象构件，通过装饰角色为其添加一些职责。</li><li>抽象装饰（Decorator）角色：继承抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能。</li><li>具体装饰（ConcreteDecorator）角色：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。</li></ol><p><img src="https://s2.loli.net/2023/05/22/6s1YednO5AMTtQi.png" alt="image-20230522160320463"></p><p>代理模式与装饰器模式的区别：</p><ul><li>代理：偏重因自己无法完成或自己无需关心，需要他人干涉事件流程，更多的是对对象的控制，通过代理对象来控制对原对象的访问。</li><li>装饰：通过层层嵌套来完成对原功能的拓展，扩展后的对象仍是是对象本身。</li></ul><h4 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h4><p><strong>策略模式</strong>是一种行为设计模式，<em>把具体的算法实现从业务逻辑（if - else）中剥离出来，成为一系列独立算法类，使得它们可以相互替换（继承自同一个父类）</em>。即可在运行时动态选择算法。</p><p><strong>使用场景：</strong> 1、如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。 2、一个系统需要动态地在几种算法中选择一种。</p><p>例如：旅行的出游方式，选择骑自行车、坐汽车，每一种旅行方式都是一个策略</p><p><img src="https://s2.loli.net/2023/05/28/EuGqMwxPIbYydmF.png" alt="image-20230528182345483"></p><h4 id="模板方法"><a href="#模板方法" class="headerlink" title="模板方法"></a>模板方法</h4><p>模板方法模式建议将复杂方法分解为一系列步骤， 然后将这些步骤改写为小方法， 最后在 “模板方法” 中依次调用这些方法。 步骤可以是 <code>抽象</code>的， 也可以有一些默认的实现。 为了能够使用算法， 客户端需要自行提供子类并实现所有的抽象步骤。 如有必要还需重写一些步骤 （但这一步中不包括模板方法自身）。</p><p>适用场景：</p><p> 当你只希望客户端扩展某个特定算法步骤， 而不是整个算法或其结构时， 可使用模板方法模式。</p><p> 当多个类的算法除一些细微不同之外几乎完全一样时， 你可使用该模式。 但其后果就是， 只要算法发生变化， 你就可能需要修改所有的类。</p><p><img src="https://s2.loli.net/2023/08/04/67o1xEV9PDkuTBS.png" alt="模板方法设计模式的结构"></p><h4 id="责任链"><a href="#责任链" class="headerlink" title="责任链"></a>责任链</h4><p>过滤器</p><h3 id="内聚、耦合"><a href="#内聚、耦合" class="headerlink" title="内聚、耦合"></a>内聚、耦合</h3><ul><li><p>内聚</p><p>度量模块内部各个元素彼此结合的紧密程度，信息隐藏和局部化概念的自然扩展。</p><p>最高的内聚：</p><ul><li>功能内聚：模块内所有处理元素属于同一整体，完成一个单一的功能</li></ul></li><li><p>耦合</p><p>软件结构内<strong>不同模块</strong>之间互联程序的度量。取决于模块接口的复杂程度、通过接口的数据等。</p><p>最低：</p><ul><li><p>完全独立（不可能）</p></li><li><p>数据耦合（通过参数交换信息，交换的信息只是数据。至少必须存在）</p></li></ul></li></ul><ul><li>内聚与耦合<ul><li>二者密切相关，高内聚往往低耦合</li><li>内聚更重要</li></ul></li></ul><h2 id="MySQL数据库"><a href="#MySQL数据库" class="headerlink" title="MySQL数据库"></a>MySQL数据库</h2><h3 id="数据库基础"><a href="#数据库基础" class="headerlink" title="数据库基础"></a>数据库基础</h3><ul><li><p>数据库设计</p><p>需求分析、概念结构设计（E-R图）、逻辑结构设计（关系模式）、物理结构设计（表）</p></li></ul><ul><li><p>DML、DDL、DCL</p><p>1、DML（data manipulation language）</p><p>有SELECT、UPDATE、INSERT、DELETE，就像它的名字一样，这4条命令是用来对数据库里的数据进行操作的语言。</p><p>2、DDL（data definition language）</p><p>DDL比DML要多，主要的命令有CREATE、ALTER、DROP等，DDL主要是用在定义或改变表（TABLE）的结构，数据类型，表之间的连接和约束等初始化工作上，他们大多在建立表时使用。</p><p>3、DCL（Data Control Language）</p><p>是数据库控制功能。是用来设置或更改数据库用户或角色权限的语句，包括（grant，deny，revoke等）语句。在默认状态下，只有sysadmin，dbcreator，db_owner或db_securityadmin等人员才有权力执行DCL。</p></li><li><p>三大范式</p><ul><li><p>1NF(第一范式)：属性不可再分。数据库表的每一列都是不可分割的基本数据项。关系型数据库中创建的表一定满足第一范式。</p></li><li><p>2NF(第二范式)：1NF 的基础之上，消除了非主属性对于主属性的部分函数依赖，即非主属性必须完全依赖于主属性。例如一张表存了（学号，课程号，成绩，课程名），（学号，课程号）-&gt;成绩，课程号-&gt;课程名，即课程名部分函数依赖于（学号，课程号）。</p></li><li><p>3NF(第三范式)：3NF 在 2NF 的基础之上，消除了非主属性对于主码的传递函数依赖 。比如在关系 R(学号 , 姓名, 学院号，学院名)中，学号 → 学院号，学院号 → 学院名，所以存在非主属性学院名对于学号的传递函数依赖。</p></li></ul></li><li><p>drop、delete 与 truncate 区别？</p><ul><li><code>drop</code>(丢弃数据): <code>drop table 表名</code> ，直接将表都删除掉，在删除表的时候使用。</li><li><code>truncate</code> (清空数据) : <code>truncate table 表名</code> ，只删除表中的数据（不清理索引），再插入数据的时候自增长 id 又从 1 开始，在清空表中数据的时候使用。</li><li><code>delete</code>（删除数据） : <code>delete from 表名 where 列名=值</code>，删除某一行的数据，如果不加 <code>where</code> 子句和<code>truncate table 表名</code>作用类似。</li></ul></li><li><p>表跟表是怎么关联的？</p><p>表与表之间常用的关联方式有两种：内连接、外连接，下面以MySQL为例来说明这两种连接方式。</p><p>内连接：内连接通过INNER JOIN来实现，它将返回两张表中满足连接条件的数据，<strong>不满足条件的数据不会查询出来</strong>。</p><p>外连接：外连接通过OUTER JOIN来实现，它会返回两张表中满足连接条件的数据，同时返回不满足连接条件的数据，但对应字段值为空。外连接有两种形式：左外连接（LEFT OUTER JOIN）、右外连接（RIGHT OUTER JOIN）。</p><ul><li>左外连接：可以简称为左连接（LEFT JOIN），它会返回左表中的所有记录和右表中满足连接条件的记录，右表没有则对应字段为空。</li><li>右外连接：可以简称为右连接（RIGHT JOIN），它会返回右表中的所有记录和左表中满足连接条件的记录，左表没有则对应字段为空。</li></ul><p>另：全连接：按照关联字段取出两个表中的记录，保留左右两表中所有的记录，不满足连接条件的均被置为null。mysql用union</p><p>除此之外，还有一种常见的连接方式：等值连接。这种连接是通过WHERE子句中的条件，将两张表连接在一起，它的实际效果等同于内连接。</p><ul><li><p>一对多关联：这种关联形式最为常见，一般是两张表具有主从关系，并且以主表的主键关联从表的外键来实现这种关联关系。另外，以从表的角度来看，它们是具有多对一关系的，所以不再赘述多对一关联了。</p></li><li><p>多对多关联：这种关联关系比较复杂，如果两张表具有多对多的关系，那么它们之间需要有一张中间表来作为衔接，以实现这种关联关系。这个中间表要设计两列，分别存储那两张表的主键。因此，这两张表中的任何一方，都与中间表形成了一对多关系，从而在这个中间表上建立起了多对多关系。</p></li><li><p>自关联：自关联就是一张表自己与自己相关联，为了避免表名的冲突，需要在关联时通过别名将它们当做两张表来看待。一般在表中数据具有层级（树状）时，可以采用自关联一次性查询出多层级的数据。</p></li></ul><blockquote><p>两张不相关的表join结果（不带条件join）？ 笛卡尔积 </p></blockquote></li><li><p>SQL注入</p><p>SQL注入的原理是将SQL代码伪装到输入参数中，传递到服务器解析并执行。</p><p>如何解决SQL注入</p><ol><li><p>严格的参数校验</p><p>参数校验就没得说了，在一些不该有特殊字符的参数中提前进行特殊字符校验即可。</p></li><li><p>SQL预编译</p><p>JDBC的preparedStatement，不仅提升性能，而且防止SQL注入。</p></li></ol></li></ul><ul><li><p>Union和Union All：取结果的并集</p><p>UNION 会把两个结果集的所有数据放到临时表中后再进行去重操作，同时进行默认规则的排序；</p><p>UNION ALL 不会再对结果集进行去重操作，不进行排序；</p></li><li><p>count(列名)和count(*)</p><p>count(*&#x2F;1)会统计值为NULL的行，而count(列名)不会统计此列为NULL值的行。</p></li></ul><ul><li><p>自增ID与UUID的比较</p><ol><li><p>自增ID是有序的，而UUID是随机的。如果主键是有序的，mysql可以具有更好的性能</p></li><li><p>自增ID所需的存储空间比UUID要小</p></li><li><p>由于自增ID比UUID更加简单，因此生成自增ID的生成速度也比UUID更快</p></li><li><p>自增ID与数据相关，主键会暴露出去的话，自增ID会显示当前表中的数据规模；而UUID则无此风险</p></li><li><p>自增ID在不同的数据库中可能重复，在分布式的环境下无法保证唯一。而UUID在分布式环境下也可以保证唯一（可能有极小概率不一致，但可以忽略）</p><p>具体而言，自增ID在性能上更有优势，而UUID则更加适应分布式场景</p></li></ol><ul><li><p>何时使用自增ID，何时使用UUID</p><p>如果数据量非常大需要分库，或者需要更好的安全性，那么使用UUID<br>对于非敏感数据或者数据量没有大需要分库，使用自增id能节省存储空间并获得更好的性能</p></li></ul></li><li><p>char和varchar</p><p>char是定长的，不足的部分用隐藏空格填充；varchar是不定长的，占用空间就是实际存储字符串长度，使用额外的1-2字节来存储值长度，列长度&lt;&#x3D;255使用1字节保存，其它情况使用2字节保存。</p><p>因为 char 类型长度固定，因此 char 的存取效率比 varchar 要快得多，方便程序的存储与查找。varchar每次修改数据要更新长度，效率略低。</p><p>如果分配给CHAR或VARCHAR列的值超过列的最大长度，则对值进行裁剪以使其适合。如果被裁掉的字符不是空格，则会产生一条警告。严格模式（sql_mode）下会报错。</p></li><li><p>on dupdate key update </p><p>语句基本功能是：<strong>根据主键id或唯一索引来判断</strong>表中是否存在记录，不存在就插入（影响行数1），有的话就更新（影响行数2）。</p><ol><li>相较于replace into（insert加强版，不存在时insert，存在时先delete后insert）虽然也能达到批量更新目的，但因为删除和添加需要重复维护索引，所以大批量比on duplicate key update 性能要差，小量可忽略，需使用者自行选择。</li></ol></li></ul><h3 id="sql执行顺序"><a href="#sql执行顺序" class="headerlink" title="sql执行顺序"></a>sql执行顺序</h3><p>MySQL 主要分为 Server 层和引擎层，Server 层主要包括连接器、查询缓存、分析器、优化器、执行器，</p><p>1）连接器负责客户端与 MySQL 服务器建立连接，和身份认证和权限相关的功能相关；</p><p>2）查询缓存（8.0 之后移除）；</p><p>3）分析器进行词法和语法解析；</p><p>词法分析，一条 SQL 语句有多个字符串组成，首先要提取关键字，比如 select，提出查询的表，提出字段名，提出查询条件等等。做完这些操作后，就会进入第二步。</p><p>语法分析，主要就是判断你输入的 sql 是否正确，是否符合 MySQL 的语法。</p><p>4）优化器选择索引，生成执行计划；优化器的作用就是它认为的最优的执行方案去执行（有时候可能也不是最优），比如多个索引的时候该如何选择索引，多表查询的时候如何选择关联顺序等。</p><p>5）执行器操作存储引擎，返回结果。</p><ul><li>关键词执行顺序<ol><li><strong>FROM</strong>：指定要查询的数据表。</li><li><strong>WHERE</strong>：对数据进行筛选，仅返回符合条件的行。</li><li><strong>GROUP BY</strong>：按照指定的列对数据进行分组。</li><li><strong>HAVING</strong>：对分组后的数据进行筛选。</li><li><strong>SELECT</strong>：选择要返回的列。</li><li><strong>ORDER BY</strong>：对结果集进行排序。</li><li><strong>LIMIT</strong>：限制返回的行数。</li></ol></li></ul><h3 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h3><ul><li><p>MyISAM 和 InnoDB 有什么区别？</p><p>最常用的引擎是InnoDB和MyISAM。MySQL 5.5 之前，MyISAM 引擎是 MySQL 的默认存储引擎。MySQL 5.5 版本之后，InnoDB 是 MySQL 的默认存储引擎。</p><ul><li><p>MyISAM 只有表级锁(table-level locking)，而 InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁。</p></li><li><p>MyISAM 不提供事务支持，但每次查询都是原子的。</p><p>InnoDB 提供事务支持，实现了 SQL 标准定义了四个隔离级别，具有提交(commit)和回滚(rollback)事务的能力。并且，InnoDB 默认使用的 REPEATABLE-READ（可重读）隔离级别是可以解决幻读问题发生的（基于 MVCC 和 Next-Key Lock）。</p></li><li><p>MyISAM 不支持外键，而 InnoDB 支持。</p></li><li><p>InnoDB 支持异常崩溃后的恢复，数据库重新启动的时候会保证数据库恢复到崩溃前的状态。这个恢复的过程依赖于 <code>redo log</code>。MyISAM不支持。</p></li><li><p>MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但InnoDB 引擎主键索引采用聚簇索引，索引和数据在同一个文件中存储（.idb），数据按照索引的顺序存放。MyISAM都是非聚集索引，索引文件和数据文件是分离的（.myd、.myi），索引文件的数据域存储指向数据文件的指针。</p></li><li><p>MyISAM 可以没有主键；如果表定义时没有显式指定主键，InnoDB会选择第一个不包含 NULL 值的唯一列作为聚簇索引的索引键，或为每一行生成一个ROWID，并以此作为主键。</p></li><li><p>（不重要）InnoDB可以更好地发挥CPU的性能，MyISAM效率与CPU核数无关；MyISAM存储表的总行数</p></li><li><p>什么时候用Myisam？</p><p>据说MyISAM查询比InnoDB快，所以适合读多写少，比如离线数据库。但我还没找到令我信服的说法。</p><p>可能是如下原因：由于innodb支持事务，所以会有mvvc的一个比较。这个过程会损耗性能；查询的时候，如果走了索引，而索引又不是主键索引，可能需要根据叶结点存的主键id回表，到聚簇索引树查，最后找到需要的数据。而myisam是非聚集索引，而且叶子节点存储的是磁盘地址，所以，查询的时候查到的最后结果不是聚簇索引树的key，而是会直接去查询磁盘</p></li></ul></li><li><p>行溢出后，MySQL 是怎么处理的？</p><p>MySQL 中磁盘和内存交互的基本单位是页，一个页的大小一般是 <code>16KB</code>，也就是 <code>16384字节</code>，而一个 varchar(n) 类型的列最多可以存储 <code>65532字节</code>，一些大对象如 TEXT、BLOB 可能存储更多的数据，这时一个页可能就存不了一条记录。这个时候就会<strong>发生行溢出，多的数据就会存到另外的「溢出页」中</strong>。</p><p>如果一个数据页存不了一条记录，InnoDB 存储引擎会自动将溢出的数据存放到「溢出页」中。在一般情况下，InnoDB 的数据都是存放在 「数据页」中。但是当发生行溢出时，溢出的数据会存放到「溢出页」中。</p><p>当发生行溢出时，在记录的真实数据处只会保存该列的一部分数据，而把剩余的数据放在「溢出页」中，然后真实数据处用 20 字节存储指向溢出页的地址，从而可以找到剩余数据所在的页。</p></li></ul><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><ul><li>说一说你对MySQL索引的理解</li></ul><p>索引是一个单独的、存储在磁盘上的按若干个列排序的存储结构，包含着索引列的值及对数据表里所有记录的引用指针。使用索引可以快速找出在某个或多个列中有一特定值的行，所有MySQL列类型都可以被索引，对相关列使用索引是提高查询操作速度的最佳途径。</p><p>索引是在存储引擎中实现的，因此，每种存储引擎的索引都不一定完全相同，并且每种存储引擎也不一定支持所有索引类型。</p><ul><li>索引的<strong>优点</strong>主要有以下几条：</li></ul><ol><li>通过创建唯一索引，可以保证数据库表中每一行数据的唯一性。</li><li>可以大大加快数据的查询速度，这也是创建索引的主要原因。</li><li>在实现数据的参考完整性方面，可以加速表和表之间的连接。</li><li>在使用分组和排序子句进行数据查询时，也可以显著减少查询中分组和排序的时间。</li></ol><ul><li>索引越多越好？</li></ul><p>增加索引也有许多不利的方面，主要表现在如下几个方面：</p><ol><li>创建索引和维护索引要耗费时间，并且随着数据量的增加所耗费的时间也会增加。</li><li>索引需要占磁盘空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果有大量的索引，索引文件可能比数据文件更快达到最大文件尺寸。</li></ol><ul><li><p>索引为什么可以加速查询</p><p>个人认为，查索引是一个慢慢细化范围的过程，类似于书的目录，先将整本书划分为若干个章节，每个章节又分为若干个小节。当你要查找某块内容的时候，会先通过章节确定一个大致的范围，再通过小节进一步细化范围，然后再从这个小节开始的页码一页一页翻，最后找到所要找的内容。如果没有目录，你就需要从头开始一页一页翻书，效率就比较低。</p></li></ul><h4 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h4><p>按「数据结构」分类：<strong>B+tree索引、Hash索引、Full-text索引</strong>、RTree 索引（仅支持 geometry 数据类型）。</p><p>按「物理存储」分类：<strong>聚簇索引（主键索引）、二级索引（辅助索引）</strong>。</p><p>按「字段特性」分类：<strong>主键索引、普通索引、唯一索引、前缀索引</strong>。</p><p>按「字段个数」分类：<strong>单列索引、联合索引</strong>。</p><ul><li><p><strong>主键索引（PRIMARY KEY）</strong>：一张数据表有只能有一个主键，并且主键不能为 null，不能重复。</p><p>在创建表时，InnoDB 存储引擎会根据不同的场景选择不同的列作为索引：</p><ul><li>如果有主键，默认会使用主键作为聚簇索引的索引键（key）；</li><li>如果没有主键，就选择第一个不包含 NULL 值的唯一列作为聚簇索引的索引键（key）；</li><li>在上面两个都没有的情况下，InnoDB 将自动生成一个隐式自增 rowid （6Byte）列作为聚簇索引的索引键（key）；</li></ul><p><img src="https://s2.loli.net/2023/05/20/8DZ71S6AOcWJGdr.png" alt="主键索引"></p></li><li><p>二级索引（Secondary Index）又称为辅助索引，是因为二级索引的叶子节点存储的数据是主键。也就是说，通过二级索引，可以定位主键的位置；然后再通过主键索引中的 B+Tree 树查询到对应的叶子节点，然后获取整行数据。这个过程叫<strong>「回表」</strong>，也就是说要查两个 B+Tree 才能查到数据。</p><p><img src="https://s2.loli.net/2023/05/20/y6RMZJboxuHQvWs.png" alt="二级索引"></p><ol><li><p><strong>普通索引(Index)<strong>：</strong>普通索引的唯一作用就是为了快速查询数据，一张表允许创建多个普通索引，并允许数据重复和 NULL。</strong></p></li><li><p><strong>唯一索引(Unique Key)<strong>：唯一索引也是一种约束。</strong>唯一索引的属性列不能出现重复的数据，但是允许数据为 NULL，一张表允许创建多个唯一索引。</strong> 建立唯一索引的目的大部分时候都是为了该属性列的数据的唯一性，而不是为了查询效率。</p><p>创建唯一索引使用 <strong>UNIQUE</strong> 关键字。</p></li><li><p>前缀索引(Prefix)：前缀索引只适用于<strong>字符串</strong>类型的数据。前缀索引是对文本的前几个字符创建索引，相比普通索引建立的数据更小， 因为只取前几个字符。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX index_name <span class="keyword">ON</span> table_name(column_name(length)); </span><br></pre></td></tr></table></figure></li><li><p>**全文索引(Full Text)**：全文索引主要是为了检索大文本数据中的关键字的信息，是目前搜索引擎数据库使用的一种技术。只有 <code>CHAR</code>、<code>VARCHAR</code> ，<code>TEXT</code> 列上可以创建全文索引。Mysql5.6 之前只有 MYISAM 引擎支持全文索引，5.6 之后 InnoDB 也支持了全文索引。</p><p>创建全文索引使用 <strong>FULLTEXT</strong> 关键字。</p></li></ol></li><li><p><strong>联合索引</strong>：多列值组成一个索引，专门用于组合搜索。叶子节点包含索引列的值以及指向对应行数据的指针</p><ul><li><p>最左匹配（左优先）原则</p><p>假设建立联合索引（product_no，name），示意图如下：</p><p><img src="https://s2.loli.net/2023/05/21/3xOHME2SpwiYDrs.png" alt="联合索引"></p><p>可以看到，联合索引的非叶子节点用两个字段的值作为 B+Tree 的 key 值。当在联合索引查询数据时，先按 product_no 字段比较，在 product_no 相同的情况下再按 name 字段比较。</p><p>也就是说，联合索引查询的 B+Tree 是从左到右排序，先按 product_no 进行排序，然后再 product_no 相同的情况再按 name 字段排序。</p><p>因此，使用联合索引时，存在<strong>最左匹配原则</strong>，也就是按照最左优先的方式进行索引的匹配。在使用联合索引进行查询的时候，如果不遵循「最左匹配原则」，联合索引会失效，这样就无法利用到索引快速查询的特性了。</p><p>比如，如果创建了一个 <code>(a, b, c)</code> 联合索引，如果查询条件是以下这几种，就可以匹配上联合索引：</p><ul><li>where a&#x3D;1；</li><li>where a&#x3D;1 and b&#x3D;2 and c&#x3D;3；</li><li>where a&#x3D;1 and b&#x3D;2；</li></ul><p>需要注意的是，因为有查询优化器，所以 a 字段在 where 子句的顺序并不重要。</p><p>但是，如果查询条件是以下这几种，因为不符合最左匹配原则，所以就无法匹配上联合索引，联合索引就会失效:</p><ul><li>where b&#x3D;2；</li><li>where c&#x3D;3；</li><li>where b&#x3D;2 and c&#x3D;3；</li></ul><p>上面这些查询条件之所以会失效，是因为<code>(a, b, c)</code> 联合索引，是先按 a 排序，在 a 相同的情况再按 b 排序，在 b 相同的情况再按 c 排序。所以，<strong>b 和 c 是全局无序，局部相对有序的</strong>，这样在没有遵循最左匹配原则的情况下，是无法利用到索引的。</p><blockquote><p>注：联合索引遵循最左前缀匹配原则，mysql会一直匹配直到遇到范围查询（&lt;、&gt;、like、between）就停止匹配。等于和in可以乱序，mysql会自动优化顺序</p></blockquote></li><li><p>索引下推（ICP）</p><p>将部分上层（服务层）负责的事情，交给了下层（引擎层）去处理。</p><p>对于联合索引（a, b），在执行 <code>select * from table_name where a &gt; 1 and b = 2</code> 语句的时候（若条件为a&#x3D;1则extra为空，&gt;&#x3D;则为using where回表；也不一定，与具体数据有关）（**联合索引当遇到范围查询 (&gt;、&lt;) 就会停止匹配**，即只有a &gt; 1 能用索引）：</p><ul><li>在 MySQL 5.6 之前<ol><li><strong>首先</strong> MySQL 的 server 层调用存储引擎<strong>获取 a&gt;1 的第一条记录</strong>。</li><li>存储引擎找到 a&gt;1 的第一条记录后，在 B+Tree 的叶子结点中保存着主键 id，此时<strong>通过回表操作，去主键索引中找到该条记录的完整数据</strong>，并返回给 server 层。</li><li>server 层拿到数据之后，<strong>再判断该条记录的 b 是否为 2（以及其他where条件），如果 b &#x3D; 2，就把该条记录返回给客户端，如果 b!&#x3D;2，那就就丢弃该记录</strong>。</li><li>a 字段的存储是有序的，即 a&gt;1 的记录都是挨着的，而 B+Tree 的叶子结点之间通过双向链表关联，<strong>通过B+Tree叶结点链表的next指针找到下一条数据，重复回表</strong></li></ol></li><li>而 MySQL 5.6 引入的<strong>索引下推优化</strong>（index condition pushdown)， <strong>可以在联合索引遍历过程中，对联合索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数</strong>。即上述步骤2中判断a&gt;1后接着判断b是否&#x3D;2，如是再回表，将记录返回给server层，然后再判断其他where条件是否成立；否则接着判断下一条记录。</li></ul><p>当你的查询语句的执行计划里，出现了 Extra 为 <code>Using index condition</code>，那么说明使用了索引下推的优化</p></li></ul></li><li><p><strong>空间索引</strong>：对空间数据类型的字段建立的索引，MySQL中的空间数据类型有4种，分别是GEOMETRY、POINT、LINESTRING和POLYGON。MySQL使用<strong>SPATIAL</strong>关键字进行扩展，使得能够用创建正规索引类似的语法创建空间索引。创建空间索引的列，必须将其声明为<strong>NOT NULL</strong>，空间索引只能在存储引擎为MyISAM和InnoDB（MySQL8.0之后）的表中创建。</p></li></ul><ul><li><p>聚簇索引与非聚簇索引</p><ul><li><p>聚簇索引（Clustered Index）即索引结构和数据一起存放的索引，并不是一种单独的索引类型。InnoDB 中的主键索引就属于聚簇索引，该表的索引(B+树)的每个非叶子节点存储索引，叶子节点存储索引和索引对应的数据。</p><p><strong>优点</strong>：</p><ul><li><strong>查询速度非常快</strong>：聚簇索引的查询速度非常的快，因为整个 B+树本身就是一颗多叉平衡树，叶子节点也都是有序的，定位到索引的节点，就相当于定位到了数据。相比于非聚簇索引， 聚簇索引少了一次读取数据的 IO 操作。</li><li><strong>对排序查找和范围查找优化</strong>：聚簇索引对于主键的排序查找和范围查找速度非常快。</li></ul><p><strong>缺点</strong>：</p><ul><li><strong>依赖于有序的数据</strong>：因为 B+树是多路平衡树，如果索引的数据不是有序的，那么就需要在插入时排序。</li><li><strong>更新代价大</strong>：如果对索引列的数据被修改时，那么对应的索引也将会被修改，而且聚簇索引的叶子节点还存放着数据，修改代价肯定是较大的，所以对于主键索引来说，主键一般都是不可被修改的。</li></ul></li><li><p>非聚簇索引(Non-Clustered Index)即索引结构和数据分开存放的索引，并不是一种单独的索引类型。二级索引(辅助索引)就属于非聚簇索引。MySQL 的 MyISAM 引擎，不管主键还是非主键，使用的都是非聚簇索引。非聚簇索引的叶子节点并不一定存放数据的指针，因为二级索引的叶子节点就存放的是主键，根据主键再回表查数据。</p><p><strong>优点</strong>：</p><p>更新代价比聚簇索引要小 。非聚簇索引的更新代价就没有聚簇索引那么大了，非聚簇索引的叶子节点是不存放数据的</p><p><strong>缺点</strong>：</p><ul><li><strong>依赖于有序的数据</strong>：跟聚簇索引一样，非聚簇索引也依赖于有序的数据</li><li>**可能会二次查询(回表)**：这应该是非聚簇索引最大的缺点了。 当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询</li></ul></li><li><p><strong>非聚簇索引怎么避免回表&#x2F;一定会回表吗</strong></p><p>当查询的数据能在二级索引的 B+Tree 的叶子节点（存的数据是主键）里查询到，这时就不用再查主键索引查，例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 主键 <span class="keyword">from</span> table_name <span class="keyword">where</span> 索引列 <span class="operator">=</span> 条件</span><br></pre></td></tr></table></figure><p>这种在二级索引的 B+Tree 就能查询到结果的过程就叫作<strong>「覆盖索引」</strong>，也就是只需要查一个 B+Tree 就能找到数据.</p><p>或用户准备使用 SQL 查询name，而name字段正好建立了索引：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name <span class="keyword">from</span> table_name <span class="keyword">where</span> name <span class="operator">=</span> 条件</span><br></pre></td></tr></table></figure><p>那么这个索引的 key 本身就是 name，查到对应的 name 直接返回就行了，无需回表查询。</p><p>如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为 <strong>覆盖索引（Covering Index）</strong> 。如果需要查询的字段正好是索引的字段，那么根据该索引就可以查到数据，而无需回表查询。</p></li></ul><p><img src="https://s2.loli.net/2023/05/20/Tf6VnlWvcoL3esK.png" alt="image-20230520221047487"></p></li></ul><h4 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h4><ul><li><p>适合建索引的情况</p><ul><li><p><strong>不为 NULL 的字段</strong>：索引字段的数据应该尽量不为 NULL，因为对于数据为 NULL 的字段，数据库较难优化，需要做额外处理。如果字段频繁被查询，但又避免不了为 NULL，建议使用 0,1,true,false 这样语义较为清晰的短值或短字符作为替代。</p></li><li><p><strong>被频繁查询的字段</strong>：我们创建索引的字段应该是查询操作非常频繁的字段。</p></li><li><p><strong>被作为条件查询的字段</strong>：被作为 WHERE 条件查询的字段，应该被考虑建立索引。</p></li><li><p><strong>频繁需要排序的字段</strong>：索引已经排序，这样查询可以利用索引的排序，加快排序查询时间。</p></li><li><p>用于分组的字段</p></li><li><p><strong>被经常频繁用于连接的字段</strong>：经常用于连接的字段可能是一些外键列，对于外键列并不一定要建立外键，只是说该列涉及到表与表的关系。对于频繁被连接查询的字段，可以考虑建立索引，提高多表连接查询的效率。</p></li></ul></li><li><p>高性能索引</p><p>1、独立的列：索引列不能是表达式的一部分；</p><p>2、选择区分度高的列作为索引；建组合索引的时候，区分度最高的在最左边。 </p><p>​正例：如果where a&#x3D;? and b&#x3D;? ，a列的几乎接近于唯一值，那么只需要单建idx_a索引即 可。  </p><p>​说明：存在非等号和等号混合判断条件时，在建索引时，请把等号条件的列前置。</p><p>​如：where a&gt;?  and b&#x3D;? 那么即使a的区分度更高，也必须把b放在索引的最前列。</p><p>区分度公式：count(distinct col) &#x2F; count(*)</p><p>3、选择合适的索引列顺序：将选择性高的索引列放在最前列；</p><p>4、覆盖索引：查询的列均在索引中，不需要回查聚簇索引；</p><p>5、使用索引扫描来做排序;</p><p>6、在遵守最左前缀的原则下，尽量扩展索引，而不是创建索引。</p></li></ul><ul><li><p>前缀索引优化</p><p>对于一些比较长的文本字段，如果只看前几位就可以有比较高的区分度（索引选择性高：不重复的索引值（也称为基数）和数据表的记录总数的比值，取值范围在 <code>[0,1]</code> 之间），那么就适合建立前缀索引。可以减小索引文件大小，提高查询速度。</p></li><li><p>覆盖索引</p><p>覆盖索引是指 SQL 中所有查询字段(where,select,order by,group by 包含的字段)，在二级索引 B+Tree 的叶子节点上都能找得到的那些索引。从二级索引中就查询得到记录，而不需要通过聚簇索引查询获得，可以避免回表的操作。</p><p><strong>避免 InnoDB 表进行索引的二次查询:</strong> InnoDB 是以聚集索引的顺序来存储的，对于 InnoDB 来说，二级索引在叶子节点中所保存的是行的主键信息，如果是用二级索引查询数据的话，在查找到相应的键值后，还要通过主键进行二次查询才能获取我们真实所需要的数据。而在覆盖索引中，二级索引的键值中可以获取所有的数据，避免了对主键的二次查询 ，减少了 IO 操作，提升了查询效率。</p><p><strong>可以把随机 IO 变成顺序 IO 加快查询效率:</strong> 由于覆盖索引是按键值的顺序存储的，对于 IO 密集型的范围查找来说，对比随机从磁盘读取每一行的数据 IO 要少的多，因此利用覆盖索引在访问时也可以把磁盘的随机读取的 IO 转变成索引查找的顺序 IO。</p><ul><li><p>禁止使用select *</p><p><img src="https://s2.loli.net/2023/06/02/Ft2MzYmDKV8rj6w.png" alt="image-20230602112750818"></p><p>另：无法使用覆盖索引</p><p>[以后面试官问你 为啥不建议使用Select *，请你大声回答他!_小目标青年的博客-CSDN博客](<a href="https://blog.csdn.net/qq_35387940/article/details/125921218?ops_request_misc=&request_id=&biz_id=102&utm_term=select">https://blog.csdn.net/qq_35387940/article/details/125921218?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=select</a> *一定会回表吗&amp;utm_medium&#x3D;distribute.pc_search_result.none-task-blog-2<del>all</del>sobaiduweb~default-1-125921218.142^v47^control,201^v3^control_1&amp;spm&#x3D;1018.2226.3001.4187)</p></li></ul></li><li><p>主键最好是自增的</p><p><strong>如果我们使用自增主键</strong>，那么每次插入的新数据就会按顺序添加到当前索引节点的位置，不需要移动已有的数据，当页面写满，就会自动开辟一个新页面。因为每次<strong>插入一条新记录，都是追加操作，不需要重新移动数据</strong>，因此这种插入数据的方法效率非常高。</p><p><strong>如果我们使用非自增主键</strong>，由于每次插入主键的索引值都是随机的，因此每次插入新的数据时，就可能会插入到现有数据页中间的某个位置，这将不得不移动其它数据来满足新数据的插入，甚至需要从一个页面复制数据到另外一个页面（新开一个页），我们通常将这种情况称为<strong>页分裂</strong>。<strong>页分裂还有可能会造成大量的内存碎片，导致索引结构不紧凑，从而影响查询效率</strong>。</p><p>详情：<a href="https://blog.csdn.net/weixin_47600880/article/details/122273377">https://blog.csdn.net/weixin_47600880/article/details/122273377</a></p></li><li><p>索引列最好not null</p><ul><li>第一原因：索引列存在 NULL 就会导致优化器在做索引选择的时候更加复杂，更加难以优化，因为可为 NULL 的列会使索引、索引统计和值比较都更复杂，比如进行索引统计时，count 会省略值为NULL 的行。</li><li>（了解）第二个原因：NULL 值是一个没意义的值，但是它会占用物理空间，所以会带来的存储空间的问题，因为 InnoDB 存储记录的时候，如果表中存在允许为 NULL 的字段，那么每行中<strong>至少会用 1 字节空间存储 NULL 值列表</strong>。</li></ul><p><a href="https://segmentfault.com/a/1190000039774659">https://segmentfault.com/a/1190000039774659</a></p></li></ul><ul><li><p>下列几种情况，是不适合创建索引的：</p><ul><li>频繁更新的字段不适合建立索引；</li></ul><ul><li><p>where条件中用不到的字段不适合建立索引；</p></li><li><p>数据比较少的表不需要建索引；</p></li><li><p>数据重复度高且分布比较均匀的的字段不适合建索引，例如性别、真假值（查询结果集超过总行数的某个比例，查询优化器就认为没必要走索引）；</p><blockquote><p>注：如果是联合索引，能用上覆盖索引、索引下推这些特性可以考虑。单列索引一般就不用考虑。</p></blockquote></li><li><p>参与列计算的列不适合建索引。</p></li></ul></li></ul><h4 id="避免索引失效"><a href="#避免索引失效" class="headerlink" title="避免索引失效"></a>避免索引失效</h4><p>索引失效的大致原因可以分为八类，这些场景通过查看执行计划都会发现产生type&#x3D;ALL或者type&#x3D;index的全表扫描。</p><ul><li><p><strong>左模糊匹配</strong>，如‘like %xx’</p><p>为什么右模糊匹配可以？</p><p>假设我们要查询 name 字段前缀为「苏」的数据，也就是 <code>name like &#39;苏%&#39;</code>，扫描索引的过程：</p><ul><li>首节点查询比较：苏这个字的拼音大小比首节点的第一个索引值中的刘字大，但是比首节点的第二个索引值中的周字小，所以选择去节点1的子节点3继续查询；</li><li>节点 3 查询比较：节点3的第一个索引值中的刘字的拼音大小比苏字小，所以继续看下一个索引值，发现节点2有与苏字前缀匹配的索引值，于是就往叶子节点查询，即叶子节点4；</li><li>节点 4 查询比较：节点4的第一个索引值的前缀符合苏字，于是就读取该行数据，接着继续往右匹配，直到匹配不到前缀为苏的索引值。</li></ul><p>如果使用 <code>name like &#39;%苏&#39;</code> 方式来查询，因为查询的结果可能是「苏苏、流苏」等之类的，不知道从哪个索引值开始比较，于是就只能通过全表扫描的方式来查询。</p></li><li><p>对索引字段使用<strong>函数</strong></p><p>有时候我们会用一些 MySQL 自带的函数来得到我们想要的结果，这时候要注意了，如果查询条件中对索引字段使用函数，就会导致索引失效。</p><p>比如下面这条语句查询条件中对 name 字段使用了 LENGTH 函数，执行计划中的 type&#x3D;ALL，代表了全表扫描：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span> name 为二级索引</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_user <span class="keyword">where</span> length(name)<span class="operator">=</span><span class="number">6</span>;</span><br></pre></td></tr></table></figure><p>MySQL 8.0 开始，索引特性增加了函数索引，即可以针对函数计算后的值建立一个索引，可解决上述问题。</p></li><li><p>对索引字段进行表达式<strong>计算</strong></p><p>比如，下面这条查询语句，执行计划中 type &#x3D; ALL，说明是通过全表扫描的方式查询数据的：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_user <span class="keyword">where</span> id <span class="operator">+</span> <span class="number">1</span> <span class="operator">=</span> <span class="number">10</span>;<span class="operator">/</span><span class="operator">/</span> 改成 id <span class="operator">=</span> <span class="number">10</span> <span class="operator">-</span> <span class="number">1</span> 就行 </span><br></pre></td></tr></table></figure></li><li><p>对索引字段进行隐式<strong>类型转换</strong></p><p>如果索引字段是字符串类型，但是在条件查询中，输入的参数是整型，就不会走索引。</p><p>反过来就可以，因为<strong>MySQL 在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较</strong></p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;两个参数都是字符串，会按照字符串来比较，不做类型转换。</span><br><span class="line">&gt;两个参数都是整数，按照整数来比较，不做类型转换。</span><br><span class="line">&gt;十六进制的值和非数字做比较时，会被当做二进制串。</span><br><span class="line">&gt;有一个参数是 TIMESTAMP 或 DATETIME，并且另外一个参数是常量，常量会被转换为 timestamp</span><br><span class="line">&gt;有一个参数是 decimal 类型，如果另外一个参数是 decimal 或者整数，会将整数转换为 decimal 后进行比较，如果另外一个参数是浮点数，则会把 decimal 转换为浮点数进行比较</span><br><span class="line">&gt;所有其他情况下，两个参数都会被转换为浮点数再进行比较</span><br></pre></td></tr></table></figure></blockquote></li><li><p>联合索引不遵循最左匹配原则（见索引分类联合索引部分）</p></li><li><p>where子句中的or</p><p>在 WHERE 子句中，or 的前后条件中有一个列没有索引，涉及的索引都不会被使用到</p></li><li><p>数据量少，MySQL可能觉得全表扫描更快</p></li><li><p>其他</p><p>不等于（&lt;&gt;、!&#x3D;）不走； is not null &#x2F;is null可能不走索引，也可以走索引，取决与null值多少</p></li></ul><h4 id="为什么用B-树"><a href="#为什么用B-树" class="headerlink" title="为什么用B+树"></a>为什么用B+树</h4><p>设计一个适合索引的数据结构，至少满足以下要求：</p><ul><li>能在尽可能少的磁盘的 I&#x2F;O 操作中完成查询工作；</li><li>要能高效地查询某一个记录，也要能高效地执行范围查找；</li></ul><p><strong>二叉树会随着插入的元素增多，而导致树的高度变高，这就意味着磁盘 I&#x2F;O 操作次数多，会影响整体数据查询的效率</strong>。</p><p>B树和B+树：</p><ol><li>B+树非叶子节点上是不存储数据的，仅存储键值，而B树节点中不仅存储键值，也会存储数据。InnoDB存储引擎中，每个节点都是一个数据页，每个页的大小默认为16KB，意味着B+树每个非叶结点能存储更多的键值，树就会更矮更胖。而磁盘IO以块为单位，每个块一般4kb（8个扇区，每个扇区512byte），InnoDB有磁盘预读的机制，每次磁盘IO会读取一整个页（4块）到内存里，所以树的高度很大程度决定了磁盘IO次数。树高较低的话，我们查找数据进行磁盘的IO次数有会再次减少，数据查询的效率也会更快。</li><li>B+树索引的所有数据均存储在叶子节点（所有索引都会在叶结点出现），而且数据是按照顺序排列的，叶结点间构成一个链表。那么B+树使得<strong>范围查找，排序查找，分组查找以及去重查找变得异常简单</strong>。而B树因为数据分散在各个节点，要实现范围查询需要通过中序遍历。 </li><li>B+树因为数据都在叶结点，所以是稳定logn复杂度。B树离根节点越近查询速度越快，平均略优于B+树</li></ol><ul><li>为什么不用Hash：<ul><li>Hash 索引等值查询性能较好，但不支持排序和范围查询（Hash 索引是根据 hash 算法来定位的，范围内的数据不连续）；</li><li>由于元素无序，可能导致磁盘的随机访问。B+树叶结点是有序的，可以顺序访问。</li><li>只能使用整个键来搜索行。（对于 B 树索引，可以使用键的任何最左前缀来查找行。对于like可以右模糊匹配）</li></ul></li></ul><p>InnoDB叶结点间为什么用双向链表（结点内单向）：</p><p>​双向的好处是可以得心应手地处理倒序查询、&gt; &lt;，between and等’范围查询’的语法。</p><ul><li>为什么不用跳表？</li></ul><p>​B+树三层可存储2kw数据。存储相同数据，跳表高度要高得多，即磁盘IO次数更多。</p><p>​InnoDB一页16kb，假设非叶子节点掐头去尾可以存放15k的数据，而每一行有主键和页号组成，假设主键是bigint大小是8byte，，页号在源码叫FIL_PAGE_OFFSET，大小4byte(字节)，那么非叶子节点的一条数据就是12字节左右，15k&#x2F;12Byte &#x3D; 1280，也就是说x&#x3D;1280。</p><p>​在来算一下y的值，叶子节点和非叶子节点数据接口是一样的，所以假设掐头去尾剩15k可以存放数据，而叶子节点存放的是真正的数据，假设一行数据占1kb， 那一个数据页能存放15行，也就是y&#x3D;15。</p><p>​则三层B+树可以存1280 ^ (3 - 1) * 15 &#x3D; 24576000</p><p>为什么MongoDB用B-树？</p><p>MongoDB 从 3.2 开始就默认使用 WiredTiger 作为存储引擎，所以 MongoDB 内部存储的数据结构由 WiredTiger 决定。而 WiredTiger 官方文档明确说了底层用的 B+ 树，链接为 <a href="https://link.zhihu.com/?target=https://source.wiredtiger.com/10.0.0/tune_page_size_and_comp.html">WiredTiger: Tuning page size and compression</a></p><h4 id="MySQL优化器怎么选择索引"><a href="#MySQL优化器怎么选择索引" class="headerlink" title="MySQL优化器怎么选择索引"></a>MySQL优化器怎么选择索引</h4><ul><li><strong>索引选择性</strong>：索引选择性是指索引列的唯一值数量与记录总数的比率。优化器倾向于选择选择性高的索引，因为这样的索引可以更好地过滤出需要的数据，减少扫描的记录数量。</li><li><strong>覆盖索引</strong>：优化器会考虑是否可以使用覆盖索引来避免访问表的实际行数据。如果索引包含了查询所需的所有列，那么优化器可能会选择这个索引，因为它可以减少对表的访问次数。</li></ul><h3 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h3><h4 id="慢查询"><a href="#慢查询" class="headerlink" title="慢查询"></a>慢查询</h4><p><em>开启慢查询日志</em>：</p><p>MySQL中慢查询日志默认是关闭的，可以通过配置文件my.ini或者my.cnf中的log-slow-queries选项打开，也可以在MySQL服务启动的时候使用–log-slow-queries[&#x3D;file_name]启动慢查询日志。</p><p>启动慢查询日志时，需要在my.ini或者my.cnf文件中配置long_query_time选项指定记录阈值，如果某条查询语句的查询时间超过了这个值，这个查询过程将被记录到慢查询日志文件中。</p><p><em>分析慢查询日志</em>：</p><p>直接分析mysql慢查询日志，利用explain关键字可以模拟优化器执行SQL查询语句，来分析sql慢查询语句。</p><h4 id="MySQL执行计划"><a href="#MySQL执行计划" class="headerlink" title="MySQL执行计划"></a>MySQL执行计划</h4><p><strong>执行计划</strong> 是指一条 SQL 语句在经过 <strong>MySQL 查询优化器</strong> 的优化后，具体的执行方式。</p><p>MySQL 为我们提供了 <code>EXPLAIN</code> 命令，来获取执行计划的相关信息。</p><p>需要注意的是，<code>EXPLAIN</code> 语句并不会真的去执行相关的语句，而是通过查询优化器对语句进行分析，找出最优的查询方案，并显示对应的信息。<code>EXPLAIN</code> 执行计划支持 <code>SELECT</code>、<code>DELETE</code>、<code>INSERT</code>、<code>REPLACE</code> 以及 <code>UPDATE</code> 语句。</p><p>执行计划结果中共有 12 列，各列代表的含义总结如下表：</p><table><thead><tr><th><strong>列名</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>id</td><td>SELECT 查询的序列标识符</td></tr><tr><td>select_type</td><td>SELECT 关键字对应的查询类型</td></tr><tr><td>table</td><td>用到的表名</td></tr><tr><td>partitions</td><td>匹配的分区，对于未分区的表，值为 NULL</td></tr><tr><td>type</td><td>表的访问方法</td></tr><tr><td>possible_keys</td><td>可能用到的索引</td></tr><tr><td>key</td><td>实际用到的索引</td></tr><tr><td>key_len</td><td>所选索引的长度</td></tr><tr><td>ref</td><td>当使用索引等值查询时，与索引作比较的列或常量</td></tr><tr><td>rows</td><td>预计要读取的行数</td></tr><tr><td>filtered</td><td>按表条件过滤后，留存的记录数的百分比</td></tr><tr><td>Extra</td><td>附加信息</td></tr></tbody></table><ul><li><p>type</p><p>查询执行的类型，描述了查询是如何执行的。所有值的顺序从最优到最差排序为：system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL</p><p>常见的几种类型具体含义如下：</p><ul><li><strong>system</strong>：如果表使用的引擎对于表行数统计是精确的（如：MyISAM），且表中只有一行记录的情况下，访问方法是 system ，是 const 的一种特例。</li><li><strong>const</strong>：表中最多只有一行匹配的记录，一次查询就可以找到，常用于使用主键或唯一索引的所有字段作为查询条件。</li><li><strong>eq_ref</strong>：当连表查询时，前一张表的行在当前这张表中只有一行与之对应。是除了 system 与 const 之外最好的 join 方式，常用于使用主键或唯一索引的所有字段作为连表条件。</li><li><strong>ref</strong>：使用普通索引作为查询条件，查询结果可能找到多个符合条件的行。</li><li><strong>index_merge</strong>：当查询条件使用了多个索引时，表示开启了 Index Merge 优化，此时执行计划中的 key 列列出了使用到的索引。</li><li><strong>range</strong>：对索引列进行范围查询，执行计划中的 key 列表示哪个索引被使用了。</li><li><strong>index</strong>：查询遍历了整棵索引树，与 ALL 类似，只不过扫描的是索引，而索引一般在内存中，速度更快。</li><li><strong>ALL</strong>：全表扫描。</li></ul><p>SQL性能优化的目标：<strong>至少</strong>要达到 <strong>range</strong> 级别，要求是ref级别，如果可以是consts 最好。</p></li><li><p>extra</p><table><thead><tr><th>关键字</th><th>备注</th></tr></thead><tbody><tr><td>Using filesort</td><td>将用外部排序而不是按照索引顺序排列结果，数据较少时从内存排序，否则需要在磁盘完成排序，代价非常高，需要添加合适的索引。</td></tr><tr><td>Using temporary</td><td>需要创建一个临时表来存储结果，这通常发生在对没有索引的列进行GROUP BY时，或者ORDER BY里的列不都在索引里，需要添加合适的索引。</td></tr><tr><td>Using index</td><td>表示MySQL使用<strong>覆盖索引</strong>避免全表扫描，不需要再到表中进行二次查找数据，这是比较好的结果之一。注意不要和type中的index类型混淆。</td></tr><tr><td>Using where</td><td>通常是进行了全表&#x2F;全索引扫描后再用WHERE子句完成结果过滤，需要添加合适的索引。</td></tr><tr><td>Impossible WHERE</td><td>对Where子句判断的结果总是false而不能选择任何数据，例如where 1&#x3D;0，无需过多关注。</td></tr><tr><td>Select tables optimized away</td><td>使用某些聚合函数来访问存在索引的某个字段时，优化器会通过索引直接一次定位到所需要的数据行完成整个查询，例如MIN()\MAX()，这种也是比较好的结果之一。</td></tr><tr><td>Using index condition</td><td>在5.6版本后加入的新特性索引下推（Index Condition Pushdown）;来自MySQL文档：<a href="https://dev.mysql.com/doc/refman/8.0/en/explain.html"><code>EXPLAIN</code></a> output shows <code>Using index condition</code> in the <code>Extra</code> column when Index Condition Pushdown is used.</td></tr></tbody></table></li></ul><p>如何判断数据库的索引有没有生效？</p><p>可以使用<strong>EXPLAIN</strong>语句查看索引是否正在使用。<code>EXPLAIN</code> 并不会真的去执行相关的语句，而是通过 <strong>查询优化器</strong> 对语句进行分析，找出最优的查询方案，并显示对应的信息。如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> a <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th>possible_keys</th><th>可能用到的索引</th></tr></thead><tbody><tr><td>key</td><td>实际用到的索引</td></tr></tbody></table><h4 id="常用SQL优化"><a href="#常用SQL优化" class="headerlink" title="常用SQL优化"></a>常用SQL优化</h4><ul><li><p>禁止使用 SELECT * 必须使用 SELECT &lt;字段列表&gt; 查询</p><ul><li><code>SELECT *</code> 消耗更多的 CPU 和 IO 以网络带宽资源</li><li><code>SELECT *</code> 无法使用覆盖索引，除非你给所有列建一个联合索引（明显不可能）</li><li><code>SELECT &lt;字段列表&gt;</code> 可减少表结构变更带来的影响</li></ul></li><li><p>避免使用子查询，可以把子查询优化为 join 操作（相关：sql查询时走了主键索引，但跨度很大）</p><p>通常子查询在 in 子句中，且子查询中为简单 SQL(不包含 union、group by、order by、limit 从句) 时,才可以把子查询转化为关联查询进行优化。</p><p><em>注：</em>IN操作肯定会走索引。不过，当IN的取值范围较大时，可能会导致索引失效，这时会走全表扫描。</p><p><strong>子查询性能差的原因：</strong> 执行子查询时，MySQL 需要为内层查询语句的查询结果建立一个<strong>临时表</strong> ，然后外层查询语句从临时表中查询记录。查询完毕后，再撤销这些临时表 。这样会消耗过多的 CPU 和 IO 资源，产生大量的慢查询。子查询的结果集存储的临时表，不论是内存临时表还是磁盘临时表都 <strong>不会存在索引</strong> ，所以查询性能会受到一定的影响。对于返回结果集比较大的子查询，其对查询性能的影响也就越大。</p><p>在 MySQL 中，可以使用连接（JOIN）查询来替代子查询。连接可以走索引：驱动表是走全表扫描，而被驱动表是走树搜索。MySQL会选择小表（参与join的字段数据量小）做驱动表（left join强制左表为驱动表）。</p><p>1.当使用left join时，左表是驱动表，右表是被驱动表<br>2.当使用right join时，右表时驱动表，左表是驱动表<br>3.当使用join时，mysql会选择数据量比较小的表作为驱动表，大表作为被驱动表</p><p>注意：<strong>EXPLAIN语句分析出来的第一行的表即是驱动表</strong></p><p>例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM student stu1</span><br><span class="line">    WHERE stu1.`stuno` IN (</span><br><span class="line">    SELECT monitor</span><br><span class="line">    FROM class c</span><br><span class="line">    WHERE monitor IS NOT NULL</span><br><span class="line">);</span><br><span class="line">SELECT stu1.* FROM student stu1 JOIN class c </span><br><span class="line">ON stu1.`stuno` = c.`monitor`</span><br><span class="line">WHERE c.`monitor` IS NOT NULL;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>在明显不会有重复值时使用 UNION ALL 而不是 UNION</p><ul><li>UNION 会把两个结果集的所有数据放到临时表中后再进行去重操作</li><li>UNION ALL 不会再对结果集进行去重操作</li></ul></li><li><p>select * from table limit 100000,10; 很慢如何优化</p><p>MySQL并不是跳过offset行，而是取offset+N行，然后返回放弃前offset行，返回 N 行，那当offset特别大的时候，效率就非常的低下。要么控制返回的总页数，要么对超过 特定阈值的页数进行SQL改写。</p><p>利用延迟关联或者子查询优化：</p><ul><li><p>延迟关联：先通过覆盖索引快速查出主键，通过主键关联原表（回表）查。</p><p>SELECT a.* FROM a, (select id from 表1 where 条件 LIMIT 100000,10 ) b where a.id&#x3D;b.id</p><p>SELECT a.* FROM a join (select id from 表1 where 条件 LIMIT 100000,10 ) b on a.id&#x3D;b.id</p></li></ul></li></ul><ul><li><p>delete批量删除</p><p>delete语句的执行过程中，会对表中的所有数据行进行扫描，并对符合条件的数据行进行删除。在这个过程中，如果有其他事务正在对该表进行读取或修改操作，则当前事务将被阻塞，直到其他事务完成操作。</p><ol><li><p>delete from 表名where 条件limit 10000;</p><p>一次占用锁的时间比较长，可能导致其他客户端一致等待资源。</p></li><li><p>在一个连接中循环执行20次delete from表名limit 500;</p><p>分多次占用锁，串行化执行，不占有锁的间隙，其他客户端可以工作。</p></li></ol><ul><li>如果需要删除超大批量数据</li></ul><blockquote><p>1、先删除表中索引；<br>2、再删除需要删除的数据；<br>3、然后重新创建索引。</p></blockquote></li></ul><ul><li><p>超过三张表禁止join</p><p>三个表进行笛卡尔积计算会出现操作复杂度呈几何数增长，多个表JOIN时要确保被关联的字段有索引。</p><p>1、在内存中自己做关联，即先从数据库中把数据查出来之后，我们在代码中再进行二次查询，然后再进行关联。 </p><p>2、数据冗余，那就是把一些重要的数据在表中做冗余，这样就可以避免关联查询了。</p></li><li><p>如果有order by的场景，请注意利用索引的有序性。</p><p>order by 最后的字段是组合 索引的一部分，并且放在索引组合顺序的最后，避免出现file_sort的情况，影响查询性能。  </p><p>正例：where a&#x3D;? and b&#x3D;? order by c; 索引：a_b_c  </p><p>反例：索引中有范围查找，那么索引有序性无法利用，如：WHERE a&gt;10 ORDER BY b; 索引 a_b 无法排序。</p></li></ul><h5 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h5><p><a href="https://mp.weixin.qq.com/s/XC8e5iuQtfsrEOERffEZ-Q">https://mp.weixin.qq.com/s/XC8e5iuQtfsrEOERffEZ-Q</a></p><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><ul><li><p>数据库事务</p><p>一组操作构成的逻辑单元，这些操作要么都执行，要么都不执行。</p><p>事务的ACID四个特性：</p><p><strong>原子性</strong>（<code>Atomicity</code>）：事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</p><p><strong>一致性</strong>（<code>Consistency</code>）：事务应确保数据库的状态从一个一致状态转变为另一个一致状态。一致状态的含义是数据库中的数据应满足完整性约束。例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的（<strong>用户自定义完整性</strong>）；</p><p><strong>隔离性</strong>（<code>Isolation</code>）：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。</p><p><strong>持久性</strong>（<code>Durability</code>）：一个事务被提交之后，它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</p></li><li><p>并发事务带来哪些问题</p><ul><li><p>脏读（读未提交）</p><p>一个事务读取数据并且对数据进行了修改，这个修改对其他事务来说是可见的，即使当前事务没有提交。这时另外一个事务读取了这个还未提交的数据，但第一个事务由于某些原因回滚，导致数据并没有被提交到数据库，那第二个事务读取到的就是脏数据，即脏读。</p></li><li><p>（了解）丢失修改（Lost to modify）</p><p>在一个事务读取一个数据时，另外一个事务也访问了该数据，在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。</p></li></ul><ul><li><p>不可重复读（Unrepeatable read）</p><p>在一个事务内多次读取同一个数据，但前后两次读到的数据不一样的情况。在第一个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不一致。</p></li><li><p>幻读（Phantom read）</p><p> 幻读指的是一个事务在前后两次执行同一个查询，但两次查询到的记录的数量不一致。就好像发生了幻觉一样，所以称为幻读。</p></li></ul><p>严重性：脏读 &gt; 不可重读 &gt; 幻读</p></li><li><p>事务隔离级别</p><p>SQL 标准定义了四个隔离级别：</p><ul><li>**READ-UNCOMMITTED(读未提交)**：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、不可重复读或幻读。</li><li>**READ-COMMITTED(读已提交)**：允许读取并发事务已经提交的数据，可以阻止脏读，但是不可重复读或幻读仍有可能发生。</li><li>**REPEATABLE-READ(可重复读)**：事务对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</li><li>**SERIALIZABLE(串行化)**：所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。InnoDB中对每个SELECT语句后自动加上LOCK IN SHARE MODE，即为每个读取操作加一个共享锁。</li></ul></li><li><p>MySQL默认的隔离级别</p><p>InnoDB 引擎的默认隔离级别是<strong>可重复读</strong>，它能在很大程度上避免幻读现象（并不是完全解决了），解决的方案有两种：</p><ul><li><p>针对<strong>快照读</strong>（一致性非锁定读，普通 select 语句，读取的是ReadView中的历史数据），是<strong>通过 MVCC （Multi-Version Concurrency Control ，多版本并发控制）方式解决了幻读</strong>。</p><p>快照读的情况下，如果读取的记录正在执行 UPDATE&#x2F;DELETE 操作，读取操作不会因此去等待记录上 X 锁的释放，而是会去读取行的一个快照。</p><p>RR 隔离级别只会在事务开启后的第一次查询生成 <code>Read View</code> ，并使用至事务提交。所以在生成 <code>Read View</code> 之后其它事务所做的更新、插入记录版本对当前事务并不可见，实现了可重复读和防止快照读下的 “幻读”。</p></li><li><p>针对<strong>当前读</strong>（一致性锁定读，加X锁或S锁，<code>select ... for update</code>、<code>insert</code>、<code>update</code>、<code>delete</code>、<code>select ... lock in share mode</code>，读取的总是最新数据），是<strong>通过 Next-Key Lock（记录锁record lock+间隙锁gap lock）方式解决了幻读</strong>。（行锁包含Next-Key Lock、Record Lock和Gap Lock）</p><p>通过记录锁可以锁住已经存在的行，通过间隙锁可以锁定某个范围中的间隙（范围内不存在的行），从而避免插入新行。当执行上述语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，（删除也会阻塞）所以就很好了避免幻读问题。</p></li></ul><ul><li><p>RR级别下，<strong>不能解决的幻读情况</strong>：<br>1、事务1 先快照读，事务2新增了一条数据并提交事务，事务1再当前读。<br>2、事务1 先快照读，事务2新增了一条数据并提交事务，事务1对事务2提交的数据进行了修改，事务1再次快照读。</p><p>情况1不用说了吧，很好理解。对于情况2， 事务1的更新操作不属于快照读，因此事务1的更新操作是可以生效的，而当前数据会记录最新修改的记录，最新修改的记录为当前事务自己，所以是能看到的。</p></li></ul><blockquote><p>MySQL为什么默认采用可重复读（Oracle默认采用读已提交）？</p><p>MySQL使用可重复读（Repeatable-Read）作为默认的存储引擎主要是因为老版本的MySQL二进制文件的各种只支持statement这一种格式，这种格式的二进制文件如果使用提交读（Read-Committed）作为默认的隔离级别会导致丢失更新的问题，所以MySQL使用了可重复读（Repeatable-Read）作为默认的存储引擎。如果把二进制文件的格式改成row,那也可以使用提交读（Read-Committed）作为隔离级别，可以提高数据库的并发性能。</p><p>MySQL binlog的三种工作模式（在MySQL 8.0中，二进制日志记录默认启用，默认使用基于行的格式。binlog_format从MySQL 8.0.34开始就被弃用，并将在MySQL的未来版本中删除。这意味着对除基于Row之外的日志记录格式的支持也将在未来的版本中删除）： </p><p>Row  简介：日志中会记录每一行数据被修改的情况，然后在slave端对相同的数据进行修改。 优点：能清楚的记录每一行数据修改的细节 缺点：数据量太大</p><p>Statement 简介：每一条被修改数据的sql都会记录到master的bin-log中，slave在复制的时候sql进程会解析成和原来master端执行过的相同的sql再次执行。在主从同步中一般是不建议用statement模式的，因为会有些语句不支持，比如语句中包含UUID函数，以及LOAD DATA IN FILE语句等 优点：解决了 Row level下的缺点，不需要记录每一行的数据变化，减少bin-log日志量，节约磁盘IO，提高新能 缺点：容易出现主从复制不一致</p><p>Mixed（混合模式） 简介：结合了Row level和Statement level的优点，同时binlog结构也更复杂。</p><p>文档位置：<a href="https://dev.mysql.com/doc/refman/8.1/en/replication-options-binary-log.html#sysvar_binlog_format">https://dev.mysql.com/doc/refman/8.1/en/replication-options-binary-log.html#sysvar_binlog_format</a></p></blockquote></li><li><p>可重复读怎么实现？</p><blockquote><p>基于MVCC实现。</p></blockquote></li></ul><blockquote><p>MVCC就是多版本并发控制，其实说的是一条记录会有多个版本，每次修改记录都会增加一个新的版本，多个版本之间形成一条版本链。MVCC实现依赖于每行数据的隐藏列、基于undo log的版本链和ReadView。隐藏列中记录了最后一次修改数据行的事务id和指向undo log的指针，每条undo log又指向更早版本的undo log从而形成一条版本链。ReadView是数据库某个时刻的快照，记录了当时正在运行的事务相关的信息。</p><p>根据隐藏列中的事务id、ReadView中记录的信息以及可见性算法就可以得到对创建ReadView的事务可见的数据的版本。</p><p>在RR隔离级别下，只有事务中第一次查询前会创建一个ReadView，后面的查询都是基于这个ReadView，这就意味着事务中所有查询看到的数据版本都是一致的，除非事务本身修改了数据。这就实现了可重复读。</p><p>那么RC又如何实现？</p><p>RC隔离级别下，每次读取数据都会创建一个ReadView，所以可以看到最新的事务运行的情况，结合可见性算法就能看到其他事务提交的最新版本的数据。</p></blockquote><ul><li><p>InnoDB怎么实现MVCC</p><p>mvcc多版本并发控制，其实指的是一条记录会有多个版本，每次修改记录都会存储这条记录被修改之前的版本，多版本之间串联起来就形成了一条版本链。事务中有写操作只需增加一个新的版本，事务未提交前其他事务可以读取旧版本数据。这样不同时刻启动的事务<strong>不加锁</strong>就能读取数据，读写操作不会冲突。</p><p><code>MVCC</code> 的实现依赖于：<strong>隐藏列、undo log、Read View</strong>。在内部实现中，<code>InnoDB</code> 通过数据行的 <code>DB_TRX_ID</code> 和 <code>Read View</code> 来判断数据的可见性，如不可见，则通过数据行的 <code>DB_ROLL_PTR</code> 找到 <code>undo log</code> 中的历史版本。每个事务读到的数据版本可能是不一样的，在同一个事务中，用户只能看到该事务创建 <code>Read View</code> 之前已经提交的修改和该事务本身做的修改。</p><ul><li><p>隐藏列</p><p><code>InnoDB</code> 存储引擎为每行数据添加了三个隐藏列：</p><ul><li><code>DB_TRX_ID（6字节）</code>：表示最后一次插入或更新该行的<strong>事务 id</strong>。此外，<code>delete</code> 操作在内部被视为更新，只不过会在记录头 <code>Record header</code> 中的 <code>deleted_flag</code> 字段将其标记为已删除。</li><li><code>DB_ROLL_PTR（7字节）</code> <strong>回滚指针</strong>，指向该行的 <code>undo log</code> 。如果该行未被更新，则为空。</li><li><code>DB_ROW_ID（6字节）</code>：如果没有设置主键且该表没有唯一非空索引时，<code>InnoDB</code> 会使用该 id 来生成聚簇索引。</li></ul></li><li><p>基于undo log的版本链</p><p>每行数据的隐藏列中包含了指向undo log的指针，而每条undo log也会指向更早版本的undo log，从而形成一条版本链。</p></li><li><p>ReadView</p><p>在 <code>InnoDB</code> 存储引擎中，</p><ul><li>在 RC 隔离级别下的 <strong><code>每次select</code></strong> 查询前都生成一个<code>Read View</code> </li><li>在 RR 隔离级别下只在事务开始后 <strong><code>第一次select</code></strong> 数据前生成一个<code>Read View</code></li></ul><p><strong>快照中保存了当前数据库系统中正处于活跃（没有 commit）的事务的 ID 号</strong>，即当前不应该被本事务看到的其他事务 ID 列表（m_ids）。当用户在这个事务中要读取某个记录行的时候，<code>InnoDB</code> 会将该记录行的 <code>DB_TRX_ID</code> 与 <code>Read View</code> 中的一些变量及当前事务 ID 进行比较，判断这行记录对该事务是否可见。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">trx_id_t</span> m_low_limit_id;      <span class="comment">/* 大于等于这个 ID 的事务均不可见 */</span></span><br><span class="line"><span class="type">trx_id_t</span> m_up_limit_id;       <span class="comment">/* 小于这个 ID 的事务均可见 */</span></span><br><span class="line"><span class="type">trx_id_t</span> m_creator_trx_id;    <span class="comment">/* 创建该 Read View 的事务ID */</span></span><br><span class="line"><span class="type">ids_t</span> m_ids;                  <span class="comment">/* 创建 Read View 时的活跃事务列表 */</span></span><br></pre></td></tr></table></figure><ul><li>可见性算法</li></ul><ol><li>如果当前数据版本的 trx_id &#x3D;&#x3D; creator_trx_id 说明修改这条数据的事务就是当前事务，所以可见。</li><li>如果记录 DB_TRX_ID &lt; m_up_limit_id，那么表明最新修改该行的事务（DB_TRX_ID）在当前事务创建快照之前就提交了，所以该记录行的值对当前事务是可见的</li><li>如果 DB_TRX_ID &gt;&#x3D; m_low_limit_id，那么表明最新修改该行的事务（DB_TRX_ID）在当前事务创建快照之后才修改该行，所以该记录行的值对当前事务不可见。跳到步骤 5</li><li>如果 m_up_limit_id &lt;&#x3D; DB_TRX_ID &lt; m_low_limit_id，表明最新修改该行的事务（DB_TRX_ID）在当前事务创建快照的时候可能处于“活动状态”或者“已提交状态”；所以就要对活跃事务列表 m_ids 进行查找<ul><li>m_ids为空或在m_ids中找不到，则表明在当前事务创建快照之前，修改该行的事务已经提交了，所以记录行对当前事务可见。</li><li>如果在活跃事务列表 m_ids 中能找到 DB_TRX_ID，说明创建快照时修改这条数据的事务尚未提交，所以记录行对当前事务不可见。跳到步骤 5</li></ul></li><li>在该记录行的 DB_ROLL_PTR 指针所指向的 <code>undo log</code> 取出快照记录，用快照记录的 DB_TRX_ID 跳到步骤 1 重新开始判断，直到找到满足的快照版本或返回空</li></ol></li></ul></li><li><p>MySQL怎么实现ACID</p><blockquote><p>事务要从ACID四个特性说起，我就分别说一下MySQL怎么保证这四个特性。</p><p>先从原子性开始说，原子性就是事务内的操作，要么都执行成功，要么都失败。也就是说，只要其中一个操作失败，其他的已经执行成功的操作也必须回滚到操作执行之前的状态。这个主要通过undo log来实现。执行一条增删改的语句后，就会记录到undo log中。当事务回滚的时候，就去执行这些语句的反向操作，让数据回到事务执行前的状态。</p><p>再说一下持久性。持久性说的是一个事务被提交之后，它对数据库中数据的改变是持久的。我觉得就是事务提交之后，确保这些数据都能落到磁盘上。因为磁盘IO比较慢，如果每次读写数据都需要磁盘IO，性能就比较差。所以MySQL有一个Buffer Pool作为缓存，读写数据都是先操作Buffer Pool。然后把修改的数据定期刷到磁盘上。这就带来一个问题就是Buffer Pool是在内存里的，那么一旦MySQL宕机，可能有一部分数据没来得及写入磁盘。所以redo log就是用来解决这个问题。MySQL采用Write Ahead Logging  机制，就是先把日志写入磁盘，再更新到Buffer Pool。因为写日志是顺序写（连续，寻道时间短），要比直接把数据写入磁盘要快（随机写寻道时间长）。当MySQL宕机，就可以用redo log来恢复数据。这样就实现了持久性。</p><p>再说一下隔离性。隔离性就是多个事务并发执行时，一个事务的执行不应影响其他事务的执行。隔离性分为不同的隔离级别，但主要都是通过锁和MVCC来实现。锁主要用来保证写跟写之间的隔离，确保同一时刻只能有一个事务来写这个数据。MVCC主要用来解决读跟写之间的隔离，通过MVCC可以实现读已提交和可重复读这两个隔离级别，在不同隔离级别下事务能读到的数据是不一样的。。</p><p>最后就是一致性。一致性就是说事务应确保数据库的状态从一个一致状态转变为另一个一致状态。一致状态的含义是数据库中的数据应满足完整性约束。这个主要就是靠其他三个特性来保证。</p></blockquote><ul><li><p>原子性</p><p>实现原子性的关键，是当事务回滚时能够撤销所有已经成功执行的sql语句。InnoDB实现回滚靠的是undo log，当事务对数据库进行修改时，InnoDB会生成对应的undo log。如果事务执行失败或调用了rollback，导致事务需要回滚，便可以利用undo log中的信息将数据回滚到修改之前的样子。</p><p>undo log属于逻辑日志，它记录的是sql执行相关的信息。当发生回滚时，InnoDB会根据undo log的内容做与之前相反的工作。对于insert，回滚时会执行delete。对于delete，回滚时会执行insert。对于update，回滚时则会执行相反的update，把数据改回去。</p></li><li><p>持久性</p><p>InnoDB作为MySQL的存储引擎，数据是存放在磁盘中的，但如果每次读写数据都需要磁盘IO，效率会很低。为此，InnoDB提供了缓存(<strong>Buffer Pool</strong>)，Buffer Pool中包含了磁盘中部分数据页的映射，作为访问数据库的缓冲。当从数据库读取数据时，会首先从Buffer Pool中读取，如果Buffer Pool中没有，则从磁盘读取后放入Buffer Pool。当向数据库写入数据时，会首先写入Buffer Pool，Buffer Pool中修改的数据会<strong>定期刷新到磁盘</strong>中（这一过程称为刷脏）。</p><p>Buffer Pool的使用大大提高了读写数据的效率，但是也带了新的问题：如果<em>MySQL宕机</em>，而此时Buffer Pool中修改的数据还没有刷新到磁盘，就会导致<em>数据的丢失</em>，事务的持久性无法保证。</p><p>于是，redo log被引入来解决这个问题。当数据修改时，除了修改Buffer Pool中的数据，<em>还会在redo log记录这次操作</em>（记录到重做日志缓存<code>redo log buffer</code>里）。刷盘时机可自行设置，此外<code>InnoDB</code> 存储引擎有一个后台线程，每隔<code>1</code> 秒，就会把 <code>redo log buffer</code> 中的内容写到文件系统缓存（<code>page cache</code>），然后调用 <code>fsync</code>（系统调用） 刷盘。如果MySQL宕机，重启时可以读取redo log中的数据，对数据库进行恢复。redo log采用的是WAL（Write-ahead logging，预写式日志），所有修改<strong>先写入日志</strong>，<strong>再更新到Buffer Pool</strong>，保证了数据不会因MySQL宕机而丢失，从而满足了持久性要求。</p><p>在宕机后，重启 MySQL 时，InnoDB 会自动恢复 redo log 中 <code>checkpoint_lsn</code> 后的，且处于 commit 状态的事务。如果 redo log 中事务的状态为 prepare，则需要先查看 binlog 中该事务是否存在，是的话就恢复，否则就回滚（通过 undo log 回滚。脏页一直在刷，更新了脏页，但事务没提交就宕机了，所以需要回滚）。</p><p>（了解）既然redo log也需要在事务提交时将日志写入磁盘，为什么它比直接将Buffer Pool中修改的数据写入磁盘(即刷脏)要快呢？主要有以下两方面的原因：</p><ul><li>刷脏是随机IO，因为每次修改的数据位置随机，但写redo log是追加操作，属于<strong>顺序IO</strong>。</li><li>刷脏是以数据页（Page）为单位的，MySQL默认页大小是16KB，一个Page上一个小修改都要整页写入。而redo log中只包含真正需要写入的部分，无效IO大大减少。</li></ul></li><li><p>隔离性</p><p>第一方面，(一个事务)写操作对(另一个事务)写操作的影响：锁机制保证隔离性。</p><p>隔离性要求同一时刻只能有一个事务对数据进行写操作，InnoDB通过锁机制来保证这一点。锁机制的基本原理可以概括为：事务在修改数据之前，需要先获得相应的锁。获得锁之后，事务便可以修改数据。该事务操作期间，这部分数据是锁定的，其他事务如果需要修改数据，需要等待当前事务提交或回滚后释放锁。</p><p>按照粒度，锁可以分为表锁、行锁以及其他位于二者之间的锁。表锁在操作数据时会锁定整张表，并发性能较差。行锁则只锁定需要操作的数据，并发性能好。但是由于加锁本身需要消耗资源，因此在锁定数据较多情况下使用表锁可以节省大量资源。MySQL中不同的存储引擎支持的锁是不一样的，例如MyIsam只支持表锁，而InnoDB同时支持表锁和行锁，且出于性能考虑，绝大多数情况下使用的都是行锁。</p><p>第二方面，(一个事务)写操作对(另一个事务)读操作的影响：MVCC保证隔离性。</p><p>InnoDB默认的隔离级别是RR（REPEATABLE READ），RR解决脏读、不可重复读、幻读等问题，使用的是MVCC。MVCC全称Multi-Version Concurrency Control，即多版本的并发控制协议。它最大的优点是读不加锁，因此读写不冲突，并发性能好。</p></li><li><p>一致性</p><p>可以说，一致性是事务追求的最终目标。前面提到的原子性、持久性和隔离性，都是为了保证数据库状态的一致性。</p></li></ul></li></ul><h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><ul><li><p><strong>undo log（回滚日志）</strong>：是 Innodb 存储引擎层生成的日志，实现了事务中的<strong>原子性</strong>，主要<strong>用于事务回滚和 MVCC</strong>。</p><p>在事务没提交之前，MySQL 会先记录更新前的数据到 undo log 日志文件里面，在发生回滚时，就读取 undo log 里的数据，然后做与原先相反操作。</p><p><strong>在 <code>InnoDB</code> 存储引擎中 <code>undo log</code> 分为两种：<code>insert undo log</code> 和 <code>update undo log</code>：</strong></p><ol><li>**<code>insert undo log</code>**： 事务对insert新记录时产生的undo log, 只在事务回滚时需要, 并且在事务提交后就可以立即丢弃。</li><li>**<code>update undo log</code>**：事务对记录进行delete和update操作时产生的undo log，不仅在事务回滚时需要，快照读也需要，只有当其他事务快照读不涉及该日志记录，对应的回滚日志才会被删除。</li></ol></li><li><p><strong>redo log（重做日志）</strong>：是 Innodb 存储引擎层生成的日志，实现了事务中的<strong>持久性</strong>，主要<strong>用于掉电等故障恢复</strong>；<code>redo log</code> 是物理日志，记录内容是“在某个数据页上做了什么修改”。</p><p>redo log 文件是循环写，只记录未被刷入磁盘的数据的物理日志，已经刷入磁盘的数据都会从 redo log 文件里擦除。</p><p>详见MySQL怎么实现持久性。</p><ul><li><p>为什么canal不订阅redo log？</p><ul><li><p>redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。</p></li><li><p>redolog会记录未提交事务的数据，而binlog只会在事务提交后写入。</p></li><li><p>redo log 是物理日志，记录的是在某个数据页上做了什么修改；binlog 是逻辑日志，记录的是这个语句的原始逻辑。</p></li></ul></li><li><p>redo log什么时候删除？redo日志文件组是有限的，所以需要循环利用。当redo log日志的内容，已经由内存刷入到磁盘当中（也就是刷脏），那么对应的redo log就是可以被删除了，也就是可以被覆盖重写。具体而言，InnoDB 用检查点（<code>checkpoint_lsn</code>）指示未被刷脏页的 redo log 数据从这里开始，检查点前的数据就可以被覆盖了。</p></li></ul></li><li><p><strong>binlog （归档日志）</strong>：是 Server 层生成的日志，它记录了所有的查询语句以外的DML和DDL语句，主要<strong>用于数据备份和主从复制</strong>；MySQL 在完成一条更新操作后，Server 层还会生成一条 binlog，等之后事务提交的时候，会将该事务执行过程中产生的所有 binlog 统一写 入 binlog 文件。</p><p>binlog 是追加写，写满一个文件，就创建一个新的文件继续写，不会覆盖以前的日志，保存的是全量的日志。</p><blockquote><p>可以使用<code>mysqlbinlog  --base64-output=decode-rows -v path</code>命令查看mysql的binlog</p><p>binlog_rows_query_log_events &#x3D; 1  # 将原始的操作sql记录写入事件中</p></blockquote></li><li><p>（了解）两阶段提交</p><p><code>redo log</code>与<code>binlog</code>刷新到磁盘是两个独立的逻辑，可能发生一个刷盘成功，而另一个因MySQL宕机等还没来得及写入磁盘，这就造成两份日志之间的逻辑不一致。</p><p><strong>MySQL 为了避免出现两份日志之间的逻辑不一致的问题，使用了「两阶段提交」来解决</strong>，两阶段提交其实是分布式事务一致性协议，它可以保证多个逻辑操作要不全部成功，要不全部失败，不会出现半成功的状态。</p><p>为什么要两阶段提交？</p><ul><li>先写 redo log 直接提交，然后写 binlog，假设写完 redo log 后，机器挂了，binlog 日志没有被写入，那么机器重启后，这台机器会通过 redo log 恢复数据，但是这个时候 bingog 并没有记录该数据，后续进行机器备份的时候，就会丢失这一条数据，同时主从同步也会丢失这一条数据。</li><li>先写 binlog，然后写 redo log，假设写完了 binlog，机器异常重启了，由于没有 redo log，本机是无法恢复这一条记录的，但是 binlog 又有记录，那么和上面同样的道理，就会产生数据不一致的情况。</li></ul><p>如果采用 redo log 两阶段提交的方式就不一样了，写完 binglog 后，然后再提交 redo log 就会防止出现上述的问题，从而保证了数据的一致性。</p><p><a href="https://xiaolincoding.com/mysql/log/how_update.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4">https://xiaolincoding.com/mysql/log/how_update.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4</a></p><p><a href="https://javaguide.cn/database/mysql/mysql-logs.html#%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4">https://javaguide.cn/database/mysql/mysql-logs.html#%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4</a></p></li></ul><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><ul><li><p>全局锁、表级锁和行级锁</p><p>全局锁：一般用在整个库（包含非事务引擎表）做备份（mysqldump 或者 xtrabackup）时。<strong>整个数据库处于只读状态</strong></p><p>MyISAM 仅仅支持表级锁(table-level locking)，一锁就锁整张表，这在并发写的情况下性非常差。InnoDB 不光支持表级锁(table-level locking)，还支持行级锁(row-level locking)，默认为行级锁。</p><p>行级锁的粒度更小，仅对相关的记录上锁即可（对一行或者多行记录加锁），所以对于并发写入操作来说， InnoDB 的性能更高。</p><p><strong>表级锁和行级锁对比</strong>：</p><ul><li><p><strong>表级锁：</strong> MySQL 中锁定粒度最大的一种锁（全局锁除外），是针对非索引字段加的锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。不过，触发锁冲突的概率最高，高并发下效率极低。表级锁和存储引擎无关，MyISAM 和 InnoDB 引擎都支持表级锁。当执行 DDL 语句去修改表结构时，会使用表级锁。</p></li><li><p><strong>行级锁：</strong> MySQL 中锁定粒度最小的一种锁，是 <strong>针对索引字段加的锁</strong> ，只针对当前操作的行记录进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。行级锁和存储引擎有关，是在存储引擎层面实现的。</p></li></ul></li><li><p>行锁有哪些</p><p>InnoDB 行锁是通过对索引数据页上的记录加锁实现的，MySQL InnoDB 支持三种行锁定方式：</p><ul><li><p><strong>记录锁（Record Lock）</strong>：属于单个行记录上的锁。记录锁总是锁定索引记录，即使定义的表没有索引也是如此。对于这种情况，InnoDB会创建一个隐藏的聚集索引，并将该索引用于记录锁定。防止任何其他事务插入、更新或删除</p></li><li><p><strong>间隙锁（Gap Lock）</strong>：锁定一个范围，不包括记录本身。间隙锁是对索引记录之间间隙的锁定，或对第一个索引记录之前或最后一个索引记录之后间隙的锁定。例如，SELECT c1 FROM t WHERE c1 BETWEEN 10 and 20 For UPDATE；防止其他事务将值15插入到t.c1列中，无论该列中是否已经存在任何此类值，因为该范围中所有现有值之间的间隙都被锁定。</p><p>InnoDB中的Gap锁是“纯抑制性的”，这意味着它们的<strong>唯一目的是防止其他事务插入到Gap中</strong>。间隙锁可以共存。一个事务执行的间隙锁定不会阻止另一个事务对同一间隙执行间隙锁定。共享和独占间隙锁之间没有区别。它们彼此不冲突，并且执行相同的功能。</p><p>如果将事务隔离级别更改为READ COMMITTED，间隙锁定可以明确禁用。MySQL评估WHERE条件后，将释放不匹配行的记录锁。</p></li><li><p><strong>临键锁（Next-Key Lock）</strong>：Record Lock+Gap Lock，锁定一个范围，包含记录本身，主要目的是为了解决幻读问题（MySQL 事务部分提到过）。记录锁只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁。</p></li></ul><p><strong>在 InnoDB 默认的隔离级别 REPEATABLE-READ 下，行锁默认使用的是 Next-Key Lock。但是，如果操作的索引是唯一索引或主键，InnoDB 会对 Next-Key Lock 进行优化，将其降级为 Record Lock，即仅锁住索引本身，而不是范围。</strong></p></li><li><p>共享锁和排他锁呢？</p><p>不论是表级锁还是行级锁，都存在共享锁（Share Lock，S 锁）和排他锁（Exclusive Lock，X 锁）这两类：</p><ul><li><p><strong>共享锁（S 锁）</strong>：又称读锁，事务在读取记录的时候获取共享锁，允许多个事务同时获取（锁兼容）。</p></li><li><p><strong>排他锁（X 锁）</strong>：又称写锁&#x2F;独占锁，事务在修改记录的时候获取排他锁，不允许多个事务同时获取。如果一个记录已经被加了排他锁，那其他事务不能再对这条事务加任何类型的锁（锁不兼容）。</p></li></ul><p>由于 MVCC 的存在，对于一般的 <code>SELECT</code> 语句，InnoDB 不会加任何锁。不过， 你可以通过以下语句显式加共享锁或排他锁。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 共享锁</span><br><span class="line"><span class="keyword">SELECT</span> ... LOCK <span class="keyword">IN</span> SHARE MODE;</span><br><span class="line"># 排他锁</span><br><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure></li><li><p>意向锁有什么作用？</p><p>如果需要用到表锁的话，如何判断表中的记录没有行锁呢，一行一行遍历肯定是不行，性能太差。我们需要用到一个叫做意向锁的东东来快速判断是否可以对某个表使用表锁。</p><p>意向锁是表级锁，共有两种：</p><ul><li><strong>意向共享锁（Intention Shared Lock，IS 锁）</strong>：事务有意向对表中的某些记录加共享锁（S 锁），加共享锁前必须先取得该表的 IS 锁。</li><li><strong>意向排他锁（Intention Exclusive Lock，IX 锁）</strong>：事务有意向对表中的某些记录加排他锁（X 锁），加排他锁之前必须先取得该表的 IX 锁。</li></ul><p><strong>意向锁是由数据引擎自己维护的，用户无法手动操作意向锁，在为数据行加共享&#x2F;排他锁之前，InooDB 会先获取该数据行所在在数据表的对应意向锁</strong></p><p>插入意图锁是在行插入之前由insert操作设置的一种间隙锁。该锁定以这样一种方式发出插入意图的信号，即如果插入到同一索引间隙中的多个事务不在间隙内的同一位置插入，则它们不需要相互等待。假设存在值为4和7的索引记录。尝试分别插入值为5和6的单独事务，在获得插入行的独占锁之前，每个事务都使用插入意图锁来锁定4和7之间的间隙，但不会相互阻止，因为这些行不冲突。</p></li><li><p>什么情况加什么锁（翻译自官方文档<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-locks-set.html%EF%BC%89">https://dev.mysql.com/doc/refman/8.0/en/innodb-locks-set.html）</a></p><ul><li><p>如果没有适合语句的索引，MySQL必须扫描整个表来处理语句，则表中的每一行都会被锁定，从而阻止其他用户对表的所有插入</p></li><li><p>select…from是一致性读，读取数据库的快照。除非事务隔离级别设置为SERIALIZABLE，否则不设置锁。一致读取将忽略在readview中存在的记录上设置的任何锁定。</p></li><li><p>SELECT … FOR UPDATE 和 SELECT … FOR SHARE、update、delete，对于具有唯一搜索条件（结果只有一行）的唯一索引，InnoDB只对找到的索引记录加记录锁；对于其他条件和非唯一索引，InnoDB为扫描的范围加间隙锁或临键锁。</p></li><li><p>update…where &#x2F; delete … from … where在SQL语句处理过程中扫描的每个记录上（与where无关）设置一个<strong>独占的临键锁</strong>。但是，对于使用唯一索引搜索唯一行的语句，只需要index record lock。</p><blockquote><p>半一致性读（RC隔离级别下）</p></blockquote><ul><li>对于UPDATE或DELETE语句，InnoDB只对其更新或删除的行持有锁。在MySQL评估WHERE条件后，释放不匹配行的记录锁。这大大降低了死锁的概率，但它们仍然可能发生。</li></ul><ul><li><p>并发时，如果update的记录发生锁等待，那么返回该记录的prev 版本（在返回前会将锁等待的这个lock从trx中删除掉），到mysql层进行where判断，是否满足条件。如果满足where条件，那么再次进入innodb层，真正加锁或者发生锁等待。</p><p>这样做的好处是：减少同一行记录的锁冲突及锁等待；无并发冲突时，直接读取最新版本加锁，有冲突时，不加锁，读取prev版本不需要锁等待。</p></li></ul></li><li><p>insert对插入行加排他的<strong>记录锁</strong>，不会阻止其他会话插入插入行之前的间隙中。</p></li></ul></li></ul><ul><li><p>死锁</p><p>MySQL 会自动检测死锁并回滚事务。在并发环境下，当多个事务同时请求数据库资源时，可能会出现死锁，即多个事务相互等待对方释放资源，导致所有事务都无法继续执行的情况。</p><p>MySQL 会检测到这种情况，并采取一些策略来处理死锁，其中包括自动回滚事务。当发生死锁时，MySQL 会选择一个事务作为死锁牺牲者（通常是最后发起锁请求的事务），回滚该事务，使得其他事务可以继续执行。</p></li></ul><h3 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h3><h4 id="分库"><a href="#分库" class="headerlink" title="分库"></a>分库</h4><p>随着业务的发展，单库中的数据量不断增加，数据库的QPS会越来越高，对数据库的读写耗时也会相应地增长，这时单库的读写性能必然会成为系统的瓶颈点。这时可以通过将单个数据库拆分为多个数据库的方法，来分担数据库的压力,提升性能。同时多个数据库分布在不同的机器上也提高了数据库的可用性。</p><p><strong>垂直分库</strong> 就是把单一数据库按照业务进行划分，不同的业务表使用不同的数据库，进而将一个数据库的压力分担到多个数据库。</p><p><strong>水平分库</strong> 是把同一个表按一定规则拆分到不同的数据库中，每个库可以位于不同的服务器上，这样就实现了水平扩展，解决了单表的存储和性能瓶颈的问题。</p><h4 id="分表"><a href="#分表" class="headerlink" title="分表"></a>分表</h4><p>随着单表数据量的增加，对于数据的查询和更新，即使在数据库底层有一定的优化，但是随着量变必定会引起质变，导致性能急剧下降。这时可以通过分表的方法，将单表数据按一定规则水平拆分到多个表中，减小单表的数据量，提升系统性能。</p><p><strong>垂直分表</strong> 是对数据表列的拆分，把一张列比较多的表拆分为多张表。</p><p><strong>水平分表</strong> 是对数据表行的拆分，把一张行比较多的表拆分为多张表，可以解决单一表数据量过大的问题。</p><p><em>顺丰：其实企业中现在比较少进行分库分表了，都是用的比较新的数据库（如TiDB、PolarDB等），解决分库分表带来的查询等问题。</em></p><h3 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h3><p>以下是读写分离的几个主要用途：</p><ol><li>提高读取性能：在大多数应用程序中，读取操作比写入操作更频繁。通过将读操作分发到多个从服务器上，可以将读负载均衡到多个节点，从而提高读取性能。多个从服务器可以并行处理读请求，增加系统的并发处理能力。</li><li>减轻主服务器负载：将写操作集中在主服务器上，可以减轻主服务器的负载。由于写操作通常需要更多的计算和磁盘写入，将其与读操作分离可以避免读操作对主服务器的性能产生负面影响。</li><li>提高系统的可扩展性：通过读写分离，可以根据应用程序的需求，灵活地添加或删除从服务器来扩展系统的读取能力。当应用程序的读取需求增加时，可以简单地添加更多的从服务器来分担读取负载，而无需对主服务器进行修改。</li><li>提高系统的容错性：在读写分离架构中，如果主服务器发生故障，可以快速切换到其中一个从服务器作为新的主服务器，从而保证系统的高可用性。这种容错机制可以减少系统的停机时间，并提供持续的服务。</li></ol><p>注：从库可以写，但数据不会同步到主库</p><p>用Sharding-jdbc实现主从：</p><ul><li><p>mysql的主从复制环境</p><ol><li><p>配置主服务器（Master）：</p><ul><li><p>打开主服务器的配置文件（通常是 <code>my.cnf</code> 或 <code>my.ini</code>）。</p></li><li><p>在文件中找到<code>[mysqld]</code>部分，并添加以下配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">server-id = 1</span><br><span class="line">log-bin = mysql-bin</span><br><span class="line">binlog-format = ROW</span><br></pre></td></tr></table></figure><ul><li><code>server-id</code>：给主服务器分配一个唯一的标识符。每个服务器都必须有不同的 ID。</li><li><code>log-bin</code>：启用二进制日志，用于记录主服务器上的所有更改。</li><li><code>binlog-format</code>：设置二进制日志的格式。<code>ROW</code> 格式通常是推荐的选择，因为它可以提供更准确的复制。MySQL8以后默认为ROW，因此无需配置</li></ul></li></ul></li><li><p>重启主服务器：</p><ul><li>保存并关闭主服务器的配置文件。</li><li>重启主服务器，使配置更改生效。</li></ul></li><li><p>配置从服务器（Slave）：</p><ul><li><p>打开从服务器的配置文件。</p></li><li><p>在文件中找到<code>[mysqld]</code>部分，并添加以下配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">server-id = 2</span><br><span class="line">relay-log = mysql-relay-bin</span><br><span class="line">log-slave-updates = 1</span><br><span class="line">read-only = 1</span><br></pre></td></tr></table></figure><ul><li><code>server-id</code>：给从服务器分配一个唯一的标识符。每个服务器都必须有不同的 ID。</li><li><code>relay-log</code>：设置从服务器上的中继日志文件的名称。</li><li><code>log-slave-updates</code>：启用从服务器记录自己的二进制日志，以便其他从服务器可以复制它。</li><li><code>read-only</code>：将从服务器设置为只读模式，以防止在从服务器上进行写操作。</li></ul></li></ul></li><li><p>重启从服务器：</p><ul><li>保存并关闭从服务器的配置文件。</li><li>重启从服务器，使配置更改生效。</li></ul></li><li><p>在主服务器上创建用于复制的用户：</p><ul><li><p>在主服务器上登录 MySQL。</p></li><li><p>创建一个用于复制的用户，并为其授予复制相关的权限。例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;replication_user&#x27;</span>@<span class="string">&#x27;slave_ip&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;password&#x27;</span>;</span><br><span class="line"><span class="keyword">GRANT</span> REPLICATION SLAVE <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;replication_user&#x27;</span>@<span class="string">&#x27;slave_ip&#x27;</span>;</span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure><ul><li><code>&#39;replication_user&#39;@&#39;slave_ip&#39;</code>：替换为实际的从服务器 IP 地址和用户名。</li><li><code>&#39;password&#39;</code>：替换为实际的密码。</li></ul></li></ul></li><li><p>在从服务器上配置复制：</p><ul><li><p>在从服务器上登录 MySQL。</p></li><li><p>运行以下命令配置复制：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CHANGE MASTER <span class="keyword">TO</span></span><br><span class="line">  MASTER_HOST <span class="operator">=</span> <span class="string">&#x27;master_ip&#x27;</span>,</span><br><span class="line">  MASTER_USER <span class="operator">=</span> <span class="string">&#x27;replication_user&#x27;</span>,</span><br><span class="line">  MASTER_PASSWORD <span class="operator">=</span> <span class="string">&#x27;password&#x27;</span>,</span><br><span class="line">  MASTER_LOG_FILE <span class="operator">=</span> <span class="string">&#x27;mysql-bin.XXXXXX&#x27;</span>,</span><br><span class="line">  MASTER_LOG_POS <span class="operator">=</span> XXXXXX;</span><br></pre></td></tr></table></figure><ul><li><code>&#39;master_ip&#39;</code>：替换为实际的主服务器 IP 地址。</li><li><code>&#39;replication_user&#39;</code> 和 <code>&#39;password&#39;</code>：替换为在主服务器上创建的复制用户的凭据。</li><li><code>&#39;mysql-bin.XXXXXX&#39;</code> 和 <code>XXXXXX</code>：替换为主服务器上当前二进制日志文件的名称和位置，可以使用 <code>SHOW MASTER STATUS;</code> 命令在主服务器上获取。</li></ul></li></ul></li><li><p>启动复制：</p><ul><li><p>在从服务器上运行以下命令启动复制：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> SLAVE;</span><br></pre></td></tr></table></figure></li><li><p>可以使用 <code>SHOW SLAVE STATUS</code> 命令检查复制状态，并确保 <code>Slave_IO_Running</code> 和 <code>Slave_SQL_Running</code> 的值都为 <code>Yes</code>。</p></li></ul></li></ol></li><li><p>导入maven坐标</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.shardingsphere&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;sharding-jdbc-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p>在配置文件（application.yml）中配置读写分离规则</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">shardingsphere:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">names:</span> <span class="string">master,</span> <span class="string">slave</span></span><br><span class="line">    <span class="attr">master:</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">com.zaxxer.hikari.HikariDataSource</span></span><br><span class="line">      <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">      <span class="attr">jdbc-url:</span> <span class="string">jdbc:mysql://121.41.55.70:3306/test?useSSL=false&amp;useUnicode=true&amp;serverTimezone=Asia/Shanghai&amp;characterEncoding=utf8&amp;zeroDateTimeBehavior=convertToNull&amp;allowPublicKeyRetrieval=true&amp;allowMultiQueries=true&amp;rewriteBatchedStatements=true&amp;useAffectedRows=true</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">secretforSYP999</span></span><br><span class="line">      <span class="comment"># 从机数据源</span></span><br><span class="line">    <span class="attr">slave:</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">com.zaxxer.hikari.HikariDataSource</span></span><br><span class="line">      <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">      <span class="attr">jdbc-url:</span> <span class="string">jdbc:mysql://localhost:3306/test?useSSL=false&amp;useUnicode=true&amp;serverTimezone=Asia/Shanghai&amp;characterEncoding=utf8&amp;zeroDateTimeBehavior=convertToNull&amp;allowPublicKeyRetrieval=true&amp;allowMultiQueries=true&amp;rewriteBatchedStatements=true&amp;useAffectedRows=true</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">secretforSYP999</span></span><br><span class="line">  <span class="attr">masterslave:</span></span><br><span class="line">    <span class="attr">load-balance-algorithm-type:</span> <span class="string">round_robin</span> <span class="comment"># 轮询</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">dataSource</span></span><br><span class="line">    <span class="attr">master-data-source-name:</span> <span class="string">master</span></span><br><span class="line">    <span class="attr">slave-data-source-names:</span> <span class="string">slave</span></span><br><span class="line">  <span class="attr">props:</span></span><br><span class="line">    <span class="attr">sql:</span></span><br><span class="line">      <span class="attr">show:</span> <span class="literal">true</span> <span class="comment">#开启SQL显示，默认false</span></span><br></pre></td></tr></table></figure></li><li><p>在配置文件中配置允许bean定义覆盖配置项</p><p>作用是防止项目启动时，shardingJDBC和Druid创建dataSource的bean对象时冲突，导致项目启动失败。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">main:</span></span><br><span class="line">        <span class="attr">allow-bean-definition-overriding:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></li></ul><p>为了保证主从库间的事务一致性，避免跨服务的分布式事务，ShardingSphere-JDBC的主从模型中，事务中的数据读写均用主库。</p><p>即： 不添加@Transactional：insert对主库操作，select对从库操作<br>            添加@Transactional：则insert和select均对主库操作</p><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ul><li><p>useAffectedRows&#x3D;true</p><p>useAffectedRows&#x3D;true时, update返回值为实际更新行数; </p><p>useAffectedRows&#x3D;false时, update返回值为where条件匹配的行数</p></li><li><p>max_connections</p><p>最大并发数，默认151，最大16384（2^14）</p></li></ul><h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><p>Spring 是一款开源的轻量级 Java 开发框架，可以帮助我们简化应用开发、降低组件间的耦合性。</p><p>Spring框架包含众多模块，如Core、Testing、Data Access、Web Servlet（Spring MVC）等，其中Core是整个Spring框架的核心模块。Core模块提供了IoC容器、AOP功能、数据绑定、类型转换等一系列的基础功能，而这些功能以及其他模块的功能都是建立在IoC和AOP之上的，所以IoC和AOP是Spring框架的核心；Testing模块集成了Junit、Mockito等，让我们可以很方便的进行单元测试；Data Access模块可以简化对数据库的访问、事务管理等；</p><h3 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h3><p>IoC（Inversion of Control）是控制反转的意思，这是一种面向对象编程的设计思想。在不采用这种思想的情况下，当我们要使用对象时，需要手动new一个，自己去维护对象与对象之间的依赖关系，很容易造成对象之间的耦合度过高，在一个大型的项目中这十分的不利于代码的维护。控制反转就是把对象的实例化和管理交给IoC容器，让它帮我们维护对象与对象之间的依赖关系，降低对象之间的耦合度（对象间直接耦合变成都依赖于IOC容器）。</p><p>IoC是通过DI（Dependency Injection，即依赖注入，体现开闭原则）来实现的。而实现依赖注入的关键是IoC容器，它的本质就是一个工厂。</p><p>在具体的实现中，主要由三种注入方式：</p><ol><li><p>构造方法注入</p><p>就是被注入对象可以在它的构造方法中声明依赖对象的参数列表，让外部知道它需要哪些依赖对象。然后，IoC Service Provider会检查被注入的对象的构造方法，取得它所需要的依赖对象列表，进而为其注入相应的对象。构造方法注入方式比较直观，对象被构造完成后，即进入就绪状态，可以马上使用。</p></li><li><p>setter方法注入（注解加载setter方法上）</p><p>通过setter方法，可以更改相应的对象属性。所以，当前对象只要为其依赖对象所对应的属性添加setter方法，就可以通过setter方法将相应的依赖对象设置到被注入对象中。setter方法注入虽不像构造方法注入那样，让对象构造完成后即可使用，但相对来说更宽松一些， 可以在对象构造完成后再注入。</p></li><li><p>基于 field 注入</p><p>所谓基于 field 注入，就是在bean的变量上使用注解进行依赖注入。本质上是通过反射的方式直接注入到field。</p></li></ol><blockquote><p>为什么spring建议使用构造器注入来注入所有必需的依赖，使用 Setter 方法注入来注入其他属性。</p><ol><li>可以保证依赖不为空。如果依赖对象无法注入，启动（实例化）的时候就会发现错误，避免在对象使用时出现空指针异常等问题。字段注入只有在调用的时候才会发现为空。</li><li>可以注入 final 修饰的属性。字段注入不能注入 final 修饰的属性，因为 final 属性必须在声明时或构造函数或初始化块中被初始化，而字段注入是在实例化之后的属性赋值阶段进行的，因此无法满足 final 属性的初始化要求。</li></ol></blockquote><ul><li><p>IoC容器的种类</p><p>Spring主要提供了两种类型的容器：BeanFactory和ApplicationContext。</p><ul><li><p>BeanFactory：Spring <strong>Bean容器的顶级接口</strong>，它是一个工厂模式的实现，负责创建、配置和管理 bean 对象。它是 Spring IoC 容器的核心接口，提供了获取 bean 的方法，例如 <code>getBean()</code>。如果没有特殊指定，默认采用<strong>延迟初始化</strong>策略。只有当客户端对象需要访问容器中的某个受管对象的时候，才对该受管对象进行初始化以及依赖注入操作。所以，相对来说，容器启动初期速度较快，所需要的资源有限。对于资源有限，并且功能要求不是很严格的场景，BeanFactory是比较合适的IoC容器选择。</p><ul><li><p>FactoryBean</p><p>FactoryBean（工厂方法模式和装饰模式）是一个<strong>工厂Bean</strong>，它是一个接口，主要的功能是<strong>动态生成某一个类型的Bean的实例</strong>，也就是说，我们可以自定义一个Bean并且加载到IOC容器里面。</p><p>它里面有一个重要的方法叫<code>getObject()</code>，这个方法里面就是用来实现动态构建Bean的过程。</p></li></ul></li><li><p>ApplicationContext：它是在BeanFactory的基础上构建的，是相对比较高级的容器实现，除了拥有BeanFactory的所有支持，ApplicationContext还提供了其他高级特性，比如事件发布、国际化信息支持等。ApplicationContext所管理的对象，在该类型容器启动之后，默认全部初始化并绑定完成。所以，相对于BeanFactory来说，ApplicationContext要求更多的系统资源，同时，因为在启动时就完成所有初始化，容 器启动时间较之BeanFactory也会长一些。在那些系统资源充足，并且要求更多功能的场景中，ApplicationContext类型的容器是比较合适的选择。</p></li></ul></li><li><p>Spring是如何管理Bean的？</p><p>Bean 指的是那些被 IoC 容器所管理的对象。Spring通过IoC容器来管理Bean，我们可以通过XML配置或者注解配置，来指导IoC容器对Bean的管理。</p><p>以下是管理Bean时常用的一些注解：</p><ul><li><p>@ComponentScan用于声明扫描策略，通过它的声明，容器就知道要扫描哪些包下带有声明的类，也可以知道哪些特定的类是被排除在外的。</p></li><li><p>@Component、@Repository、@Service、@Controller用于声明Bean，它们的作用一样，但是语义不同。@Component用于声明通用的Bean，@Repository用于声明DAO层的Bean，@Service用于声明业务层的Bean，@Controller用于声明视图层的控制器Bean，被这些注解声明的类就可以被容器扫描并创建。本质上都是component，区分开结构更清晰</p></li><li><p>@Autowired、@Qualifier用于注入Bean，即告诉容器应该为当前属性注入哪个Bean。其中，@Autowired是按照Bean的类型进行匹配的，如果这个属性的类型具有多个Bean，就可以通过@Qualifier指定Bean的名称，以消除歧义。</p></li><li><p>@Scope用于声明Bean的作用域，默认情况下Bean是单例的，即在整个容器中这个类型只有一个实例。可以通过@Scope注解指定prototype值将其声明为多例的，也可以将Bean声明为session级作用域、request级作用域等等，但最常用的还是默认的单例模式。</p></li><li><p>@PostConstruct、@PreDestroy用于声明Bean的生命周期。其中，被@PostConstruct修饰的方法将在Bean实例化后被调用，@PreDestroy修饰的方法将在容器销毁前被调用。</p></li></ul></li><li><p>spring怎么知道要创建哪些bean对象？</p><p>xml和注解中定义了bean的信息</p></li><li><p>@Component 和 @Bean 的区别是什么？</p><ul><li><p><code>@Component</code> 注解作用于类。<code>@Component</code>通常是通过类路径扫描来自动侦测以及自动装配到 Spring 容器中（我们可以使用 <code>@ComponentScan</code> 注解定义要扫描的路径从中找出标识了需要装配的类自动装配到 Spring 的 bean 容器中）。</p></li><li><p><code>@Bean</code> 注解而作用于方法。我们在标有该注解的方法中定义产生这个bean的逻辑，告诉Spring这个方法将会返回一个对象，这个对象要注册为Spring IOC容器中的bean。</p></li><li><p><code>@Bean</code> 注解比 <code>@Component</code> 注解的自定义性更强，而且很多地方我们只能通过 <code>@Bean</code> 注解来注册 bean。比如当我们引用<strong>第三方库中的类需要装配到 <code>Spring</code>容器时</strong>，则只能通过 <code>@Bean</code>来实现。</p></li></ul></li><li><p>@Autowired和@Resource注解有什么区别？</p><p>都用来注入bean。</p><ol><li>@Autowired是Spring提供的注解，@Resource是JDK提供的注解。</li><li>@Autowired是只能按类型注入，默认情况下它要求依赖对象必须存在，如果允许null值，可以设置它required属性为false。如果我们想使用按名称装配，可以结合@Qualifier注解一起使用。（也可通过变量名，但不推荐）</li><li>@Resource默认按名称注入，也支持按类型注入。@Resource有两个中重要的属性：name和type。如果没有指定name属性，当注解标注在字段上，即默认取字段的名称作为bean名称寻找依赖对象；当注解标注在属性的setter方法上，即默认取属性名作为bean名称寻找依赖对象。如果按照默认的名称仍然找不到依赖对象时， @Resource注解会回退到按类型装配。但一旦指定了name属性，就只能按名称装配了。</li><li>作用范围：都可以作用于字段或setter方法；Resource不能作用于构造器</li></ol></li><li><p>Bean 的作用域有哪些?</p><p>Spring 中 Bean 的作用域通常有下面几种：</p><ul><li><p><strong>singleton</strong> : IoC 容器中只有唯一的 bean 实例。Spring 中的 bean 默认都是单例的，且不是线程安全的。</p><p>如果单例的Bean是一个无状态的Bean，即线程中的操作不会对Bean的成员执行查询以外的操作，那么这个单例的Bean是线程安全的。</p><p>实现线程安全：在类中定义一个 <code>ThreadLocal</code> 成员变量，将需要的可变成员变量保存在 <code>ThreadLocal</code> 中</p><p>使用单例模式可以减少对象的创建和销毁的开销。</p></li><li><p><strong>prototype</strong> : 原型模式。每次获取都会创建一个新的 bean 实例。需要注意的是，当容器创建了 Bean 的实例后，Bean 的实例就交给客户端代码管理，Spring 容器将不再跟踪其生命周期。</p></li><li><p><strong>request</strong> （仅 Web 应用可用）: 每一次 HTTP 请求都会产生一个新的 bean（请求 bean），该 bean 仅在当前 HTTP request 内有效。</p></li><li><p><strong>session</strong> （仅 Web 应用可用） : 每一次来自新 session 的 HTTP 请求都会产生一个新的 bean（会话 bean），该 bean 仅在当前 HTTP session 内有效。</p></li><li><p><strong>application&#x2F;global-session</strong> （仅 Web 应用可用）：每个 Web 应用在启动时创建一个 Bean（应用 Bean），该 bean 仅在当前应用启动时间内有效。</p></li><li><p><strong>websocket</strong> （仅 Web 应用可用）：每一次 WebSocket 会话产生一个新的 bean。</p></li></ul></li><li><p>bean的生命周期</p><p>大致分为实例化、属性赋值、初始化和销毁四个阶段：</p><ul><li>实例化：解析配置文件得到bean的定义，通过反射实例化对象</li><li>属性赋值：通过set方法设置对象的属性</li><li>初始化：<ol><li>如果实现了beanNameAware接口等aware接口，就调用对应的set方法；</li><li>调用实现了 BeanPostProcessor 接口的类 的<code>postProcessBeforeInitialization()</code> 方法（对所有bean）</li><li>如果有@PostConstruct标注的方法，就执行；</li><li>如果Bean 实现了<code>InitializingBean</code>接口，执行<code>afterPropertiesSet()</code>方法。</li><li>如果 配置了 initMethod ，执行指定的初始化方法。</li><li>如果有和加载这个 Bean 的 Spring 容器相关的 <code>BeanPostProcessor</code> 对象，执行<code>postProcessAfterInitialization()</code> 方法（对所有bean）</li></ol></li><li>销毁<ol><li>如果有@PreDestroy标注的方法，就执行</li><li>如果 Bean 实现了 <code>DisposableBean</code> 接口，执行 <code>destroy()</code> 方法。</li><li>如果配置了destroyMethod ，执行指定的方法。</li></ol></li></ul></li><li><p>怎么获取bean</p><ol><li><p>使用注解来自动装配Bean</p></li><li><p>使用ApplicationContext获取Bean</p><p>ApplicationContext是Spring Framework中的核心接口，其提供了访问Bean工厂的方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">public class Application &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ApplicationContext context = SpringApplication.run(Application.class, args) / ApplicationContextProvider.getApplicationContext();</span><br><span class="line">        UserService userService= context.getBean(UserService.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意事项：</p><ul><li>使用ApplicationContext获取Bean对象必须在SpringBoot启动类上添加@ComponentScan注解。</li><li>使用ApplicationContext获取Bean对象时，Bean的作用域必须为单例（Singleton）,否则会出现Bean创建多份的情况。</li></ul></li><li><p><strong>使用@Import注解</strong>：在配置类上使用@Import注解，将其他配置类（普通bean也行）导入当前配置类中，从而将其管理的 Bean 一起注册到 Spring 容器中。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import(&#123;OtherConfig.class, AnotherConfig.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="comment">// configuration</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>常用钩子接口</p><ol><li><strong>InitializingBean 和 DisposableBean</strong>：<ul><li>InitializingBean接口包含afterPropertiesSet()方法，当Bean的所有属性被设置之后，Spring容器会调用这个方法。</li><li>DisposableBean接口包含destroy()方法，当Bean被销毁之前，Spring容器会调用这个方法。</li></ul></li><li><strong>BeanPostProcessor</strong>：<ul><li>BeanPostProcessor接口允许在Bean初始化前后进行自定义处理。它包括postProcessBeforeInitialization()和postProcessAfterInitialization()两个方法，允许开发人员在Bean初始化前后执行自定义逻辑。</li></ul></li><li><strong>BeanFactoryPostProcessor</strong>：<ul><li>BeanFactoryPostProcessor接口允许在Bean工厂加载Bean定义之后，在实例化Bean之前对Bean定义进行修改。通过实现该接口，可以在Spring容器加载Bean定义后对其进行自定义处理。</li></ul></li></ol></li><li><p>配置参数怎么传递给bean</p><ul><li><p>@Value注解结合spel（${}）</p></li><li><p>以对象形式注入</p><p>假设有一个实体类<code>PoolProperties</code>，类上加了注解<code>@ConfigurationProperties(prefix = &quot;arcsoft.pool&quot;)</code></p><p>配置类（@Configuration）加上注解<code>@EnableConfigurationProperties(PoolProperties.class)</code></p></li></ul></li><li><p>怎么解决循环依赖？</p><p>先说一下循环依赖的问题。如果两个Bean A和B发生循环依赖，在属性赋值阶段A需要去注入B，就会先去创建B。B在属性赋值的时候也需要A已经创建完成。这就导致这两个Bean都无法完成属性赋值。</p><p>Spring用三级缓存解决循环依赖问题。</p><ul><li><p>第一级缓存 singletonObjects ，已完成初始化的Bean对象</p></li><li><p>第二级缓存 earlySingletonObjects ，已经实例化，但未完成属性赋值的Bean</p></li><li><p>第三级缓存 singletonFactories ，存放bean的工厂，getObject的时候会实例化一个bean对象</p></li></ul><p>假设A 和 B 产生循环依赖了。A实例化后，如果A是单例、允许循环依赖，就会在三级缓存里注册一个A的单例工厂。属性赋值阶段要去注入B，会依次去三级缓存里找B，没找到就去创建B。</p><p>B在属性赋值阶段的时候要注入A，他就会在三级缓存里找到A的单例工厂，通过工厂getObject方法，获取到A（此时的A仅仅创建出来，处于早期的状态，不是一个完整的Bean，但是可能被代理了），然后将获取到的A放入二级缓存 ，并且将A的工厂从三级缓存移除。然后把获取到的A注入B，然后B继续执行后面的属性赋值和初始化流程。B初始化完之后，就把自己放入一级缓存，然后返回给A，A就能完成对B的依赖注入。然后A继续执行，等A初始化完成之后，会把singletonFactories 和earlySingletonObjects 缓存清空，在singletonObjects 中放入自己成熟的bean。这样就解决了循环依赖的问题。</p><p>参考：<a href="https://www.zhihu.com/question/438247718">https://www.zhihu.com/question/438247718</a></p><p><img src="https://pics0.baidu.com/feed/64380cd7912397dd78d1dbc79c26e5bed2a287f3.jpeg@f_auto?token=3ceff5bb48ca543544496d0efcf3d4e8" alt="img"></p></li></ul><h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><p>AOP（Aspect Oriented Programming）是面向切面编程，它是一种编程思想，是面向对象编程（OOP）的一种补充。面向对象编程将对象的行为都封装在方法中，面向切面编程所做的就是将方法中一些跟对象行为无关的通用的业务流程（如事务处理、日志管理、权限控制）抽取出来，抽象成单独的模块，需要的时候再通过代理的方式将其织入到方法执行前后。这就减少了重复代码、降低了模块间的耦合度，使得模块中只需关注核心业务流程的实现。</p><p>Spring AOP基于代理模式中的动态代理。默认采用JDK 动态代理。JDK动态代理基于接口，会在程序运行期动态生成代理类，这个代理类会继承java.lang.reflect.Proxy类，同时实现被代理类的接口。如果要代理的类没有实现接口，则改为使用Cglib动态代理，让代理类去继承目标类（final类不能代理），然后重写其中目标类的方法</p><blockquote><p>注：SpringBoot2.x版本开始默认使用Cglib动态代理，但Spring用的还是JDK</p><p>好处：CGLib可以获取实际实现类中的注解，方便根据注解做对应处理。而JDK代理基于接口，无法获取实现类的注解。</p></blockquote><ul><li><p>Spring AOP不能对哪些类进行增强？</p><ol><li>Spring AOP<strong>只能对IoC容器中的Bean进行增强</strong>，对于不受容器管理的对象不能增强。</li><li>由于CGLib采用动态创建子类的方式生成代理对象，所以不能对final修饰的类进行代理。</li></ol></li><li><p>Spring AOP 和 AspectJ AOP 有什么区别？</p><p><strong>Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。</strong> Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。</p></li><li><p>多个切面的执行顺序？</p><p>1、通常使用<code>@Order</code> 注解直接定义切面顺序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 值越小优先级越高</span></span><br><span class="line"><span class="meta">@Order(3)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoggingAspect</span> <span class="keyword">implements</span> <span class="title class_">Ordered</span> &#123;</span><br></pre></td></tr></table></figure><p>2、实现<code>Ordered</code> 接口重写 <code>getOrder</code> 方法。</p></li></ul><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><ul><li><p>性能统计</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AOP + StopWatch统计方法执行时间</span></span><br><span class="line"><span class="meta">@Around(&quot;execution(* com.team.superStar.service.ArcFaceService.*(..))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">logAround</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">org.springframework.util.<span class="type">StopWatch</span> <span class="variable">stopWatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">org</span>.springframework.util.StopWatch();</span><br><span class="line">stopWatch.start();</span><br><span class="line"><span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> joinPoint.proceed();</span><br><span class="line">stopWatch.stop();</span><br><span class="line"><span class="type">String</span> <span class="variable">target</span> <span class="operator">=</span> joinPoint.getSignature().getDeclaringTypeName() + <span class="string">&quot;.&quot;</span> + joinPoint.getSignature().getName();</span><br><span class="line">System.out.println(target + <span class="string">&quot;执行时间：&quot;</span> + stopWatch.getTotalTimeMillis());</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li>日志记录</li><li>权限控制</li><li>声明式事务</li></ul><h3 id="事务-1"><a href="#事务-1" class="headerlink" title="事务"></a>事务</h3><ul><li><p>Spring 管理事务的方式有几种？</p><ul><li><p><strong>编程式事务</strong>：通过 <code>TransactionTemplate</code>或者 <code>TransactionManager</code> 手动编码管理事务。这种方式相对麻烦一些，但是好在更为灵活，我们可以将事务管理的范围控制的更为精确（声明式事务是方法级）。</p></li><li><p><strong>声明式事务</strong>：在 XML 配置文件中配置或者直接基于注解 : 实际是通过 AOP 实现（基于<code>@Transactional</code> 的全注解方式使用最多）给方法加上了<code>Transactional</code>注解的话，这个方法执行的所有<code>sql</code>会被放在一个事务中。如果不加<code>Transactional</code>，每条<code>sql</code>会开启一个单独的事务，中间被其它事务改了数据，都会实时读取到最新值。</p><p>原理：<a href="https://www.cnblogs.com/Xianhuii/p/17102828.html">https://www.cnblogs.com/Xianhuii/p/17102828.html</a></p></li></ul></li><li><p>@Transactional作用范围</p><ol><li><strong>方法</strong>：推荐将注解使用于方法上，不过需要注意的是：<strong>该注解只能应用到 public 方法上（动态代理的原因），否则不生效。</strong></li><li>类<strong>：如果这个注解使用在类上的话，表明该注解对该类中所有的 public 方法都生效。</strong></li><li>接口：不推荐在接口上使用。</li></ol></li><li><p><strong><code>@Transactional</code> 的常用配置参数</strong></p><table><thead><tr><th align="left">属性名</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">propagation</td><td align="left">事务的传播行为，默认值为 REQUIRED</td></tr><tr><td align="left">isolation</td><td align="left">事务的隔离级别，默认值采用 DEFAULT</td></tr><tr><td align="left">timeout</td><td align="left">事务的超时时间，默认值为-1（不会超时）。如果超过该时间限制但事务还没有完成，则自动回滚事务。</td></tr><tr><td align="left">readOnly</td><td align="left">指定事务是否为只读事务，默认值为 false。</td></tr><tr><td align="left">rollbackFor</td><td align="left">用于指定能够触发事务回滚的异常类型，并且可以指定多个异常类型。</td></tr></tbody></table></li><li><p>事务传播方式</p><p><strong>事务传播行为是为了解决业务层方法之间嵌套调用时当前事务如何传播到被嵌套调用的业务方法中</strong>。</p><table><thead><tr><th>事务传播类型</th><th>说明</th></tr></thead><tbody><tr><td>PROPAGATION_REQUIRED</td><td>如果当前没有事务，则新建一个事务；如果已存在一个事务，则加入到这个事务中。这是最常见的选择。</td></tr><tr><td>PROPAGATION_SUPPORTS</td><td>支持当前事务，如果当前没有事务，则以非事务方式执行。</td></tr><tr><td>PROPAGATION_MANDATORY</td><td>使用当前的事务，如果当前没有事务，则抛出异常。</td></tr><tr><td>PROPAGATION_REQUIRES_NEW</td><td>新建事务，如果当前存在事务，则把当前事务挂起。</td></tr><tr><td>PROPAGATION_NOT_SUPPORTED</td><td>以非事务方式执行操作，如果当前存在事务，则把当前事务挂起。</td></tr><tr><td>PROPAGATION_NEVER</td><td>以非事务方式执行操作，如果当前存在事务，则抛出异常。</td></tr><tr><td>PROPAGATION_NESTED</td><td>如果当前存在事务，则在嵌套事务内执行；如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。</td></tr></tbody></table></li><li><p>Spring事务隔离级别</p><p><strong><code>DEFAULT</code></strong> :使用后端数据库默认的隔离级别，MySQL 默认采用的 <code>REPEATABLE_READ</code> 隔离级别，Oracle 默认采用的 <code>READ_COMMITTED</code> 隔离级别。</p><p><strong>READ_UNCOMMITTED、READ_COMMITTED、REPEATABLE_READ、SERIALIZABLE</strong></p></li><li><p>@Transactional(rollbackFor &#x3D; Exception.class)注解了解吗？</p><p><code>Exception</code> 分为运行时异常 <code>RuntimeException</code> 和非运行时异常。</p><p>当 <code>@Transactional</code> 注解作用于类上时，该类的所有 public 方法将都具有该类型的事务属性，同时，我们也可以在方法级别使用该标注来覆盖类级别的定义。如果类或者方法加了这个注解，那么这个类里面的方法抛出异常，就会回滚，数据库里面的数据也会回滚。</p><p>在 <code>@Transactional</code> 注解中如果不配置<code>rollbackFor</code>属性,那么事务只会在遇到<code>RuntimeException</code>的时候才会回滚，加上 <code>rollbackFor=Exception.class</code>,可以让事务在遇到非运行时异常时也回滚</p></li><li><p>事务失效</p><ul><li><p>数据库底层不支持事务</p><p>Spring 事务是业务层的事务，其底层还是依赖于数据库本身的事务支持。如MyISAM引擎不支持。</p></li><li><p>类不受 Spring管理</p><p>被 <code>@Transactional</code> 注解的方法所在的类必须被 Spring 管理，否则不生效（基于Spring AOP）；</p></li><li><p>自调用：调用类内部的 @Transactional 方法，不会经过 Spring 的代理类。默认只有在外部调用事务才会生效。</p><p>解决：</p><ol><li>将两个方法合并为一个方法，用@Transactional修饰。</li><li>将被调用的方法放到另一个被Spring管理的类中，用实例对象调用，</li><li>用@Autowired在本类中注入本类实例，再用注入的实例对象调用该方法。</li></ol></li><li><p>异常被业务代码 catch，又没有手动抛出，则不会触发回滚</p></li><li><p>事务方法不是 public</p></li></ul></li></ul><h3 id="设计模式-1"><a href="#设计模式-1" class="headerlink" title="设计模式"></a>设计模式</h3><ul><li><strong>代理设计模式</strong> : Spring AOP 功能的实现。</li><li><strong>单例设计模式</strong> : Spring 中的 Bean 默认都是单例的（也可设置原型模式prototype）。</li><li><strong>观察者模式:</strong> Spring 事件驱动模型就是观察者模式很经典的一个应用。如ApplicationListener。</li><li><strong>模板方法模式</strong> : Spring 中 <code>jdbcTemplate</code>、<code>redisTemplate</code> 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。</li><li><strong>工厂设计模式</strong> : 简单工厂 <code>BeanFactory</code>、工厂方法<code>FactoryBean</code></li></ul><p>没有Spring怎么开发？</p><p>没有Spring框架之前，所有的javaWEB开发都是非常繁琐的，且十分冗余，哪里需要实例化对象，就直接new一个处理，同时还需要一个一个set属性值，或者不想满项目中都是new的话，自己实现一个单例工厂来创建获取，但是这种类太多了，那么就需要更多的单例工厂。通过Spring可以统一管理这些对象。</p><p>以前的Servlet开发需要手动实现javax.servlet.Servlet,一般项目都有很多功能，每一个功能类都对应一个servlet类，于是就有很多重复的代码，比如service,init,destroy等等.还要在配置文件中加入很多servletMapping。</p><h2 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h2><ul><li><p>拦截器和过滤器的区别？</p><ul><li><p><strong>出身不同</strong>：过滤器实现的是 <code>javax.servlet.Filter</code> 接口，是 Java Servlet 规范的一部分；要依赖于Tomcat等Servlet容器，导致它只能在web程序中使用；拦截器是一个Spring组件，并由Spring容器管理，不依赖于Tomcat等Servlet容器，是可以单独使用的。</p></li><li><p><strong>触发时机不同</strong>：<strong>请求的执行顺序是：请求进入容器 &gt; 进入过滤器 &gt; 进入 Servlet &gt; 进入拦截器 &gt; 执行控制器（Controller）</strong>。拦截器加载的时间点在springcontext之前</p></li><li><p><strong>实现方式不同</strong>：过滤器基于责任链模式，当前过滤器逻辑处理完成就通过调用 FilterChain 对象的 doFilter 方法将请求传递给下一个过滤器，所有过滤器都通过才会把请求交给servlet。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">【Filter】一般用于Servlet处理之前做一些前置的校验，每个Filter都有自己的职责和逻辑。</span><br><span class="line">调用filter时，需要传入当前filterChain的引用，来告诉filter当前执行的是哪一个filterChain。</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Filter</span> &#123;    </span><br><span class="line">    <span class="comment">//初始化方法    </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException;    </span><br><span class="line">    <span class="comment">//处理逻辑，    </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response,            FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException;    </span><br><span class="line">    <span class="comment">//生命周期销毁    </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line">【FilterChain】是由多个Filter组成的链条，如果在链上的filter校验通过或处理完成，那么调用<span class="string">&quot;chain.doFilter(request, response)&quot;</span>就可以让下一个filter继续执行逻辑直到filterChain结束</span><br></pre></td></tr></table></figure><p><strong>拦截器是基于动态代理（底层是反射）实现的</strong>，可以在Controller执行前后增加一些额外处理</p></li><li><p><strong>使用场景不同</strong>：因为拦截器更接近业务系统（Servlet执行后），所以<strong>拦截器主要用来实现项目中的业务判断的</strong>，比如：登录判断、权限判断、日志记录等业务。而<strong>过滤器通常是用来实现通用功能过滤的</strong>，比如：对请求URL做限制、敏感词过滤、对请求数据做字符转换、字符集编码设置、响应数据压缩等与详细业务不相关的请求处理都可以用过滤器来做。</p></li></ul></li></ul><ul><li><p>幂等性</p><p>幂等这个概念，是一个数学上的概念，即：f……(f(f(x))) &#x3D; f(x)。用在计算机领域，指的是系统里的接口或方法对外的一种承诺，使用相同参数对同一资源重复调用某个接口或方法的结果与调用一次的结果相同。</p><p><strong>业务上的一次或多次请求，最终的处理结果是一致的，即：在一定时间内，服务的幂等其实就是请求的幂等。</strong></p><p>实现方法：</p><ul><li><p>token（防止重复提交）</p><p>进入页面时，从服务器获取token，在服务器端把token进行存储（比如存入redis，注意过期时间），提交时把token带到服务器端进行验证；常见的处理流程如下：</p><p>后端验证token通过，将其删除。后面的相同请求发现没有token就不会再执行。</p><p><img src="https://s2.loli.net/2023/07/19/8Yo2mIhWSKiPce6.png" alt="token幂等"></p></li></ul></li></ul><h3 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h3><ul><li><p>什么是MVC？</p><p>MVC是一种设计模式，在这种模式下软件被分为三层，即Model（模型）、View（视图）、Controller（控制器）。Model代表的是数据，View代表的是用户界面，Controller代表的是数据的处理逻辑，它是Model和View这两层的桥梁。将软件分层的好处是，可以将对象之间的耦合度降低，便于代码的维护。</p><p>DAO是Data Access Object的缩写，即数据访问对象，在项目中它通常作为独立的一层，专门用于访问数据库。</p></li><li><p>Spring MVC 的核心组件有哪些？</p><ul><li><p><strong><code>DispatcherServlet</code><strong>：</strong>核心的中央处理器</strong>，负责接收请求、分发，并给予客户端响应。</p></li><li><p><strong><code>HandlerMapping</code><strong>：</strong>处理器映射器</strong>，根据 uri 去匹配查找能处理的 <code>Handler</code> ，并会将请求涉及到的拦截器和 <code>Handler</code> 一起封装。</p></li><li><p><strong><code>HandlerAdapter</code><strong>：</strong>处理器适配器</strong>，根据 <code>HandlerMapping</code> 找到的 <code>Handler</code> ，适配执行对应的 <code>Handler</code>；</p></li><li><p><strong><code>Handler</code><strong>：</strong>请求处理器</strong>，处理实际请求的处理器。</p></li><li><p><strong><code>ViewResolver</code><strong>：</strong>视图解析器</strong>，根据 <code>Handler</code> 返回的逻辑视图 &#x2F; 视图，解析并渲染真正的视图，并传递给 <code>DispatcherServlet</code> 响应客户端</p></li></ul></li><li><p>Spring MVC工作流程</p><ol><li>客户端发出一个HTTP请求，Web应用服务器接收到这个请求。如果匹配DispatcherServlet的请求映射路径，则Web容器将该<strong>请求转交给DispatcherServlet处理</strong>。</li><li>DispatcherServlet接收到这个请求后，将<strong>根据请求的信息（包括URL、HTTP方法、请求报文头、请求参数、Cookie等）及HandlerMapping的配置找到处理请求的处理器（Handler）</strong>。</li><li>当DispatcherServlet找到对应当前请求的Handler后，<strong>通过HandlerAdapter对Handler进行封装，再以统一的适配器接口调用Handler</strong>。HandlerAdapter是Spring MVC框架级接口，顾名思义，HandlerAdapter是一个适配器，它用统一的接口对各种Handler方法进行调用。</li><li>Handler完成业务逻辑的处理后，将<strong>返回一个ModelAndView给DispatcherServlet</strong>，ModelAndView包含了视图逻辑名和模型数据信息。</li><li>ModelAndView中包含的是“逻辑视图名”而非真正的视图对象，<strong>DispatcherServlet借由视图解析器ViewResolver完成逻辑视图名到真实视图对象View的解析工作</strong>。</li><li>当得到真实的视图对象View后，<strong>DispatcherServlet就把ModelAndView中的模型（Model）数据填充到视图中</strong>。</li><li>把 <code>View</code> 返回给请求者（浏览器）。最终客户端得到的响应消息可能是一个普通的HTML页面，也可能是一个XML或JSON串，甚至是一张图片或一个PDF文档等不同的媒体形式。</li></ol></li><li><p>说一说你知道的Spring MVC注解</p><ul><li><p>@RequestMapping（GetMapping、PostMapping）：</p><p>作用：处理请求地址映射的，也就是说将其中的处理器方法映射到url路径上。</p><p>属性：</p><ul><li><p>method：是让你指定请求的method的类型，比如常用的有get和post。</p></li><li><p>value：是指请求的实际地址，如果是多个地址就用{}来指定就可以啦。</p></li><li><p>params：指定request中一定要有的参数值，它才会使用该方法处理请求。</p></li></ul></li><li><p>@RequestParam：</p><p>作用：是将请求参数绑定到你的控制器的方法参数上，是Spring MVC中的接收普通参数的注解。</p><p>属性：</p><ul><li><p>value是请求参数中的名称。</p></li><li><p>required是请求参数是否必须提供参数，它的默认是true，意思是表示必须提供。</p></li></ul></li><li><p>@PathVaribale：</p><p>作用：该注解是用于绑定url中的占位符，但是注意，spring3.0以后，url才开始支持占位符的，它是Spring MVC支持的rest风格url的一个重要的标志。</p></li><li><p>@ResponseBody：</p><p>作用：如果作用在方法上，就表示该方法的返回结果是直接写入Http responsebody中，通常用来返回 JSON格式数据。</p></li><li><p>@RequestBody</p><p>@RequestBody 作用在形参列表上时，用于将前台发送过来固定格式的数据（xml 格式或者 json 等）封装到对应的实体对象。</p></li></ul></li><li><p>统一异常处理</p><p>@RestControllerAdvice加在类上，默认对所有Controller生效，也可以指定要织入的Controller类。当 <code>Controller</code> 中的方法抛出异常的时候，由被<code>@ExceptionHandler</code> 注解（可以指定要处理的异常类）修饰的方法进行处理。</p></li></ul><ul><li>接受参数三种方式<ul><li>用@RequestBody标注DTO</li><li>用@RequestParam标注参数，并指定name属性</li><li>用@PathVariable标注参数，并指定name属性</li></ul></li></ul><h3 id="Spring-Session"><a href="#Spring-Session" class="headerlink" title="Spring Session"></a>Spring Session</h3><p>在传统单机web应用中，一般使用tomcat&#x2F;jetty等web容器时，用户的session都是由容器管理。浏览器使用cookie中记录sessionId，容器根据sessionId判断用户是否存在会话session。这里的限制是，session存储在web容器中，被单台服务器容器管理。</p><p>但是网站主键演变，分布式应用和集群是趋势（提高性能）。此时用户的请求可能被负载分发至不同的服务器，此时传统的web容器管理用户会话session的方式即行不通。</p><p>spring-session的核心思想在于此：将session从web容器中剥离，存储在独立的存储服务器中。目前支持多种形式的session存储器：Redis、Database、MogonDB等。session的管理责任委托给spring-session承担。当request进入web容器，根据request获取session时，由spring-session负责存存储器中获取session，如果存在则返回，如果不存在则创建并持久化至存储器中。</p><blockquote><p>原理</p></blockquote><p>当请求进来的时候，SessionRepositoryFilter 会先拦截到请求，将 request 和 response 对象转换成 SessionRepositoryRequestWrapper 和SessionRepositoryResponseWrapper 。后续当第一次调用 request 的getSession方法时，会调用到 SessionRepositoryRequestWrapper 的getSession方法。</p><p>这个方法是被重写过的，逻辑是先从 request 的属性中查找，如果找不到；再查找一个key值是”SESSION”的 Cookie，通过这个 Cookie 拿到 SessionId 去 Redis 中查找，如果查不到，就直接创建一个RedisSession 对象，同步到 Redis 中。</p><p>说的简单点就是：拦截请求，将之前在服务器内存中进行 Session 创建销毁的动作，改成在 Redis 中创建。</p><h3 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h3><ul><li><p>Nginx负载均衡，其中一台挂了，还会代理过去吗</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream server_group &#123;</span><br><span class="line">    server backend1.example.com ;</span><br><span class="line">    server backend2.example.com  max_fails=3 fail_timeout=30s;</span><br><span class="line">    server backup1.example.com  backup;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="max-fails-number"><a href="#max-fails-number" class="headerlink" title="max_fails&#x3D;number"></a>max_fails&#x3D;number</h5><p>这个参数决定了多少次请求后端失败后会暂停这个业务节点，不再给它发新的请求，默认值是1。此参数需要配合fail_timeout一起用。</p><p>题外话：如何定义失败，有很多种类型，这里因为主要处理HTTP代理，所以更关注proxy_next_upstream。</p><p>proxy_next_upstream：主要定义了当服务节点出现状况时，会将请求发给其他节点，也就是定义了怎么算作业务节点失败。</p><h5 id="fail-timeout-time"><a href="#fail-timeout-time" class="headerlink" title="fail_timeout&#x3D;time"></a>fail_timeout&#x3D;time</h5><p>决定了当Nginx认定这个节点不可用时，暂停多久。不配置默认就是10s。</p><p>把上面两个参数联合起来考虑就是：当Nginx发现发送到这个节点上的请求失败了3次的时候，就会把这个节点摘除，摘除时间是30s，30s后才会再次发送请求到这个节点上。</p></li></ul><h3 id="幂等性"><a href="#幂等性" class="headerlink" title="幂等性"></a>幂等性</h3><p>常见幂等问题场景</p><ul><li><p>前端重复提交，多次点击，服务端收到多次请求</p></li><li><p>超时重试，调用下游服务或者依赖外部服务处理超时，或者因为网络原因导致超时</p></li><li><p>消息重复消费，使用消息中间件 pulsar、mq 等，重复消息发送，或者 ack 异常重复消费</p></li><li><p>高并发，唯一 ID 生成碰撞，重复写入，边界控制等</p></li></ul><p>解决方案：</p><ul><li><p>插入数据，可以借助唯一索引</p></li><li><p>通用、可靠策略：使用 UUID 或者 雪花算法生成全局唯一 ID，采用 防重表方式 实现幂等</p><p><img src="http://oss.ripplesu.top/blog/Typora/%E9%9D%A2%E8%AF%95%E9%A2%98/640" alt="幂等方案"></p></li></ul><h2 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h2><ul><li><p>Spring、SpringMVC、SpringBoot有什么区别</p><ol><li><p>Spring 是一款开源的轻量级 Java 开发框架，可以帮助我们简化应用开发、降低组件间的耦合性。它包含众多模块，如Core、Testing、Data Access、Web Servlet等，这些模块和功能都建立在IoC和AOP两大核心的基础之上。</p></li><li><p>SpringMVC是Spring Web Servlet模块中的一部分，给予了Spring快速构建 MVC 架构的 Web 程序的能力，主要处理web开发的路径映射和视图渲染等。<br> springMvc和springBoot:</p></li><li><p>SpringBoot本质上就是Spring，但它遵循“约定优于配置”的理念，可以帮助我们快速构建一个基于Spring的项目。使用 Spring Boot避免了繁琐的XML配置，只需要很少的配置或使用默认的配置。</p></li></ol><p>  另外，SpringBoot还有以下优点：</p><ol><li><p>内置了Tomcat等Web服务器，无需部署War文件，打成jar包就能启动。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">tomcat:</span></span><br><span class="line"><span class="comment"># 当所有可能的请求处理线程都在使用中时，传入连接请求的最大队列长度</span></span><br><span class="line"><span class="attr">accept-count:</span> <span class="number">100</span></span><br><span class="line"><span class="comment"># 服务器在任何给定时间接受和处理的最大连接数。一旦达到限制，操作系统仍然可以接受基于“acceptCount”属性的连接。</span></span><br><span class="line"><span class="attr">max-connections:</span> <span class="number">8192</span></span><br><span class="line"><span class="attr">threads:</span></span><br><span class="line"><span class="comment"># 工作线程的最小数量，初始化时创建的线程数</span></span><br><span class="line"><span class="attr">min-spare:</span> <span class="number">10</span></span><br><span class="line"><span class="comment"># 工作线程的最大数量 io密集型建议10倍的cpu数，cpu密集型建议cpu数+1，绝大部分应用都是io密集型</span></span><br><span class="line"><span class="attr">max:</span> <span class="number">200</span></span><br></pre></td></tr></table></figure></li><li><p>提供了Starter，聚合了模块运行所需的依赖以及可以自动进行初始化配置，做到开箱即用。</p></li></ol><p>缺点：</p><p>​集成度太高，屏蔽了很多细节，上手容易但难以了解底层原理</p></li><li><p>SpringBoot Starter原理</p><ul><li><p>起步依赖：其实就是将模块运行需要的依赖打包到一起（starter），可以简化依赖导入的过程。</p></li><li><p>自动配置：Starter中写@Configuration标记的配置类，类内用@Bean注解声明需要装配到IoC容器的对象，并用@Conditional注解指定生效条件；在类路径下<code>META-INF/spring.factories</code>中填写配置类的全类名。</p><p>自动配置过程：</p><ol><li>Spring Boot通过@EnableAutoConfiguration注解开启自动配置</li><li>加载所有jar包类路径下<code>META-INF/spring.factories</code>中注册的各种AutoConfiguration类</li><li>当某个AutoConfiguration类满足其注解@Conditional指定的生效条件（Starters提供的依赖、配置或Spring容器中是否存在某个Bean等）时，实例化该AutoConfiguration类中定义的Bean（组件等），并注入Spring容器，就可以完成依赖框架的自动配置。</li></ol></li><li><p>如何实现starter</p><ol><li>pom中引入相关依赖（Spring-boot-starter）</li><li>自动配置中流程</li><li>maven install安装到本地仓库</li></ol></li></ul></li><li><p>SpringBoot 核心注解<code>SpringBootApplication</code></p><p><code>@Configuration</code>、<code>@EnableAutoConfiguration</code>、<code>@ComponentScan</code> 注解的集合。</p><p>这三个注解的作用分别是：</p><ul><li><code>@EnableAutoConfiguration</code>：启用 SpringBoot 的自动配置机制</li><li><code>@Configuration</code>：允许在Spring上下文中注册额外的 bean或导入其他配置类。会将当前类内声明的一个或多个以**@Bean**注解标记的方法的实例纳入到Spring容器中，并且实例名就是方法名。</li><li><code>@ComponentScan</code>：注解默认会扫描启动类所在的包下所有的被<code>@Component</code> (<code>@Service</code>,<code>@Controller</code>、<code>@Repository</code>)注解标记的类，可以自定义不扫描某些 bean。</li></ul></li></ul><h4 id="自动装配"><a href="#自动装配" class="headerlink" title="自动装配"></a>自动装配</h4><p>自动装配指springBoot 在启动时会扫描外部引用 jar 包中的<code>META-INF/spring.factories</code>文件，将文件中配置的类型信息（Bean）加载到 Spring 的IoC容器。</p><p>SpringBoot 核心注解<code>SpringBootApplication</code>可以看做三个注解的集合，这三个注解中包括<code>@EnableAutoConfiguration</code>，用来启用 SpringBoot 的自动配置机制。</p><p>注解中通过import注解将 <code>AutoConfigurationImportSelector</code>类导入容器，类中有一个<code>selectImports</code>方法，该方法主要用于<strong>获取所有符合条件的类的全限定类名，这些类需要被加载到 IoC 容器中</strong>。</p><p><img src="https://s2.loli.net/2023/08/12/NZjdpQzwIqFx3G8.png" alt="selectImports"></p><p>selectImports方法调用getAutoConfigurationEntry方法，</p><p><strong>第 1 步</strong>:</p><p>判断是否启用自动装配。默认<code>spring.boot.enableautoconfiguration=true</code>，可在 <code>application.properties</code> 或 <code>application.yml</code> 中设置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span> <span class="comment">//作用：将main包下的所有组件注册到容器中</span></span><br><span class="line"><span class="meta">@Import(&#123;AutoConfigurationImportSelector.class&#125;)</span> <span class="comment">//加载自动装配类 xxxAutoconfiguration</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">ENABLED_OVERRIDE_PROPERTY</span> <span class="operator">=</span> <span class="string">&quot;spring.boot.enableautoconfiguration&quot;</span>;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt;[] exclude() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    String[] excludeName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第 2 步</strong>：</p><p>获取<code>EnableAutoConfiguration</code>注解中的属性，即不需要的配置类<code>exclude</code> 和 <code>excludeName</code>。</p><p><strong>第 3 步</strong></p><p><img src="https://s2.loli.net/2023/08/12/bcxkrteg5yaLPpB.png" alt="getAutoConfigurationEntry"></p><p><img src="https://s2.loli.net/2023/08/12/kGTJ2p9iXHgnPML.png" alt="loadFactoryNames"></p><p>通过SpringFactoriesLoader类的loadFactoryNames，读取所有starter的<code>META-INF/spring.factories</code>，获取所有需要自动装配的配置类，封装到list中</p><p><strong>第 4 步</strong>：</p><p>去除重复的配置类、排除<code>EnableAutoConfiguration</code>注解中声明的不需要的配置类、去除不符合条件（Conditional注解中声明的）的配置类，然后返回所有能够自动装配的类的全限定名。</p><p>最后就是实例化该AutoConfiguration类中定义的Bean（组件等），并注入Spring容器，就可以完成依赖框架的自动配置。</p><ul><li>其他问题<ul><li>如何集成spring：引入aop和web的starter</li></ul></li></ul><h4 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h4><p>1、在springboot启动的时候会创建一个SpringApplication对象，在对象的构造方法里面会进行一些参数的初始化工作，最主要的是判断当前应用程序的类型以及设置初始化器以及监听器，并在这个过程中会加载整个应用程序的spring.factories文件，将文件中的内容放到缓存当中，方便后续获取；</p><p>2、SpringApplication对象创建完成之后会执行run()方法来完成整个应用程序的启动，启动的过程中有两个最主要的方法prepareContext()和refreshContext()，在这两个方法中完成了自动装配的核心功能，在run()方法里还执行了一些包括上下文对象的创建，打印banner图，异常报告期的准备等各个准备工作，方便后续进行调用；</p><p>3、在prepareContext()中主要完成的是对上下文对象的初始化操作，包括属性的设置，比如设置环境变量。在整个过程中有一个load()方法，它主要是完成一件事，那就是将启动类作为一个beanDefinition注册到registry，方便后续在进行BeanFactoryPostProcessor调用执行的时候，可以找到对应执行的主类，来完成对@SpringBootApplication、@EnableAutoConfiguration等注解的解析工作；</p><p>4、在refreshContext()方法中会进行整个容器的刷新过程，会调用spring中的refresh()方法，refresh()方法中有13个非常关键的方法，来完成整个应用程序的启动。而在自动装配过程中，会调用的关键的一个方法就是invokeBeanFactoryPostProcessors()方法，在这个方法中主要是对ConfigurationClassPostProcessor类的处理，这个类是BFPP（BeanFactoryPostProcessor）的子类，因为实现了BDRPP（BeanDefinitionRegistryPostProcessor）接口，在调用的时候会先调用BDRPP中的postProcessBeanDefinitionRegistry()方法，然后再调用BFPP中的postProcessBeanFactory()方法，在执行postProcessBeanDefinitionRegistry()方法的时候会解析处理各种的注解，包含@PropertySource、@ComponentScan、@Bean、@Import等注解，最主要的是对@Import注解的解析；</p><p>5、在解析@Import注解的时候，会有一个getImport()方法，从主类开始递归解析注解，把所有包含@Import的注解都解析到，然后在processImport()方法中对import的类进行分类，例如AutoConfigurationImportSelect归属于ImportSelect的子类，在后续的过程中会调用DeferredImportSelectorHandler类里面的process方法，来完成整个EnableAutoConfiguration的加载。</p><h4 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h4><p>Spring Boot 常用注解汇总</p><p>一、启动注解 @SpringBootApplication</p><ul><li><p>@SpringBootConfiguration 注解，继承@Configuration注解，主要用于加载配置文件</p></li><li><p>@EnableAutoConfiguration 注解，开启自动配置功能</p></li><li><p>@ComponentScan 注解，主要用于组件扫描和自动装配</p></li></ul><p>二、Controller 相关注解</p><ul><li><p>@Controller</p></li><li><p>@RestController 复合注解</p></li><li><p>@ResponseBody</p></li><li><p>@RequestBody</p></li><li><p>@RequestMapping</p></li><li><p>@GetMapping用于将HTTP get请求映射到特定处理程序的方法注解</p></li><li><p>@PostMapping用于将HTTP post请求映射到特定处理程序的方法注解</p></li></ul><p>三、取请求参数值</p><ul><li>@PathVariable:获取url中的数据</li><li>@RequestParam:获取请求参数的值</li><li>@RequestHeader 把Request请求header部分的值绑定到方法的参数上</li><li>@CookieValue 把Request header中关于cookie的值绑定到方法的参数上</li></ul><p>四、注入bean相关</p><ul><li>@Repository（DAO）</li><li>@Service（本质是component）</li><li>@Scope作用域注解</li><li>@Entity实体类注解</li><li>@Bean产生一个bean的方法</li><li>@Autowired 自动导入</li><li>@Component</li><li>@Lazy延迟加载bean</li></ul><p>五、导入配置文件</p><ul><li>@PropertySource注解</li><li>@ImportResource导入xml配置文件</li><li>@Import 导入额外的配置信息</li></ul><p>六、事务注解 </p><ul><li>@Transactional</li></ul><p>七、全局异常处理</p><ul><li>@ControllerAdvice 统一处理异常</li><li>@ExceptionHandler 注解声明异常处理方法</li></ul><h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><p>properties（键值对，&#x3D;）和yaml（key:(空格)value）优先级？properties高</p><p>Bootstrap 配置文件是 Spring 应用程序的<strong>启动配置</strong>文件，用于配置 Spring 环境和初始化 Spring 容器。Bootstrap 配置文件的名称通常为 bootstrap.yml 或 bootstrap.properties。Bootstrap 配置文件中可以配置一些与应用程序无关的配置项，例如数据源、缓存、消息队列等等。这些配置项可以在应用程序的任何地方使用，因为它们是在<strong>应用程序启动之前</strong>就加载和初始化好的。</p><p>Application 配置文件是 Spring 应用程序的业务逻辑配置文件，用于配置应用程序的各种组件和服务。Application 配置文件的名称通常为 application.yml 或 application.properties。</p><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><ul><li><p>跨域：主要原因是浏览器的同源策略</p><p>实现WebMvcConfiger接口，重写addCorsMappings方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> &#123;</span><br><span class="line">    registry.addMapping(<span class="string">&quot;/**&quot;</span>)</span><br><span class="line">            .allowCredentials(<span class="literal">true</span>)</span><br><span class="line">            .allowedMethods(<span class="string">&quot;*&quot;</span>)</span><br><span class="line">            .allowedOrigins(<span class="string">&quot;*&quot;</span>)</span><br><span class="line">            .allowedHeaders(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">    <span class="built_in">super</span>.addCorsMappings(registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Spring-Security"><a href="#Spring-Security" class="headerlink" title="Spring Security"></a>Spring Security</h2><p>Spring Security 应用级别的安全主要包含两个主要部分，即登录<strong>认证</strong>（Authentication）和访问<strong>授权</strong>（Authorization），首先用户登录的时候传入登录信息，登录验证器完成登录认证并将登录认证好的信息存储到请求上下文，然后在进行其他操作，如接口访问、方法调用时，权限认证器从上下文中获取登录认证信息，然后根据认证信息获取权限信息，通过权限信息和特定的授权策略决定是否授权。</p><ul><li><code>认证</code>：验证当前访问系统的是不是本系统的用户，并且要确认具体是哪个用户</li><li><code>授权</code>：经过认证后判断当前用户是否有权限进行某个操作</li></ul><h3 id="RBAC"><a href="#RBAC" class="headerlink" title="RBAC"></a>RBAC</h3><p>RBAC 即基于角色的权限访问控制（Role-Based Access Control）。这是一种通过角色关联权限，角色同时又关联用户的授权的方式。</p><p>简单地说：<strong>一个用户可以拥有若干角色，每一个角色又可以被分配若干权限</strong>，这样就构造成“用户-角色-权限” 的授权模型。在这种模型中，用户与角色、角色与权限之间构成了多对多的关系</p><h2 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h2><p>MyBatis 是一个 半自动的ORM（Object Relation Mapping）框架。</p><p>MyBatis 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。</p><p><img src="https://s2.loli.net/2023/07/08/wuQobYRXCPJqpAK.png" alt="mybatis层次结构"></p><ul><li><p>JDBC</p><p>JDBC（Java DataBase Connectivity，Java数据库链接）就是使用JAVA语言操作关系型数据库的一套API。</p><p><strong>本质</strong></p><ol><li>官方（sun）定义的一套<strong>操作所有关系型数据库的规则</strong>，即接口（没有提供实现类）。</li><li>各个数据库厂商自行去实现这套接口，所以有了数据库驱动jar包。</li><li>我们使用接口（JDBC）来编写通用的代码，真正执行的是驱动jar包中的实现类。</li></ol><p><img src="https://s2.loli.net/2023/07/16/2Yq1yumj3SwCeGi.png" alt="JDBC"></p></li><li><p>MyBatis中的$和#有什么区别？</p><p>使用#设置参数时，MyBatis会创建预编译的SQL语句，即JDBC中的PreparedStatement。执行前会将<code>#&#123;&#125;</code>替换为占位符‘?’，然后在执行时依次为占位符（?）赋值，传入的参数自动加上双引号，即当成普通字符串。预编译的SQL语句执行效率高，并且可以防止注入攻击。</p><p>使用$设置参数时，MyBatis只是创建普通的SQL语句，即JDBC中的Statement。然后在执行SQL语句时MyBatis将参数直接拼入到SQL里。有sql注入风险。一般用于传入数据库对象，可以解决一些特殊情况下的问题。例如，有时需要根据某些列进行排序，<strong>但参与排序的字段并不确定，而是要通过前端参数传递过来，</strong>这就无法使用预编译的方式了。</p><ul><li><p>sql注入</p><p>现在假设我们后台的SQL语句如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from user where username=&#x27;$&#123;username&#125;&#x27; and password=&#x27;$&#123;password&#125;&#x27;</span><br></pre></td></tr></table></figure><p>前端网页有两个输入框，一个是用户名输入框，另一个是密码输入框。假设用户老老实实地输入用户名为zhangsan，密码为123，那么最终生成的SQL语句如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from user where username=&#x27;zhangsan&#x27; and password=&#x27;123&#x27;</span><br></pre></td></tr></table></figure><p>假设用户输入的用户名是 <code>zhangsan&#39; or 1=1 #</code>，密码则随意给了个值 111，那么最终生成的 SQL语句可能就是下面这样了：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from user where username=&#x27;zhangsan&#x27; or 1=1 #&#x27; and password=&#x27;123&#x27;</span><br></pre></td></tr></table></figure><p>大家知道，# 在 SQL语句中的含义是注释，#后面的SQL内容是不执行的。所以这个SQL无论怎么执行，最终都会返回true。这就是所谓的SQL注入了。</p></li></ul></li><li><p>为啥<code>mapper</code>接口能执行？</p><p>基于JDK动态代理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">newInstance</span><span class="params">(SqlSession sqlSession)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> MapperProxy&lt;T&gt; mapperProxy = <span class="keyword">new</span> <span class="title class_">MapperProxy</span>&lt;T&gt;(sqlSession, mapperInterface, methodCache);</span><br><span class="line">    <span class="keyword">return</span> newInstance(mapperProxy);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">protected</span> T <span class="title function_">newInstance</span><span class="params">(MapperProxy&lt;T&gt; mapperProxy)</span> &#123;</span><br><span class="line">    <span class="comment">//用JDK自带的动态代理生成映射器</span></span><br><span class="line">    <span class="keyword">return</span> (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; mapperInterface &#125;, mapperProxy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/ygy162/article/details/106459395/">https://blog.csdn.net/ygy162/article/details/106459395/</a></p></li><li><p>分页</p><ul><li><p>MyBatis的分页是内存分页还是物理分页</p><ul><li><p>Mybatis使用RowBounds对象进行分页<br>RowBounds 表面是在“所有”数据中检索数据，其实并非是一次性查询出所有数据，因为 MyBatis 是对 jdbc 的封装，在 jdbc 驱动中有一个 Fetch Size 的配置，它规定了每次最多从数据库查询多少条数据。它是针对 ResultSet 结果集执行的<strong>内存分页</strong>而非物理分页。</p></li><li><p>可以在 SQL 内直接书写带有物理分页的参数来完成物理分页功能</p><p>也可以使用分页插件来完成物理分页</p></li></ul></li><li><p>分页插件：PageHelper（物理分页）</p><p>原理：Mybatis中真正用来执行Sql语句的对象是Executor；它在初始化完成之后，会调用interceptorChain的pluginAll方法，pluginAll方法遍历所有Interceptor对象并调用其plugin方法；plugin方法其实就是调用Plugin类的静态方法wrap()基于JDK动态代理得到executor的代理对象；plugin类（实现了InvocationHandler）的invoke方法中判断是否执行的方法是否是要拦截的方法，如果是就执行Interceptor中的intercept方法，否则调用原方法。</p><ol><li>先使用PageHelper.startPage传入分页参数，该方法将分页参数放到一个ThreadLocal变量中；</li><li>再利用PageInterceptor这个分页拦截器拦截executor的query方法，从ThreadLocal中拿到分页的信息，如果需要分页就拼装分页SQL（limit语句等）进行分页查询；</li><li>执行完查询（doSelect）最后再把ThreadLocal中的东西清除掉。</li></ol></li></ul></li><li><p>动态sql</p><ul><li><code>&lt;if test = &quot;&quot;&gt;&lt;/if&gt;</code>满足条件拼上标签中的语句<ul><li>注意：test中参数不用加#{}或${}</li></ul></li><li><code>&lt;where&gt;&lt;/where&gt;</code> 有条件自动加上where子句</li><li><code>trim </code>用于insert，拼接上前后缀</li><li><code>set </code>用于update</li><li><code>&lt;choose&gt;&lt;/choose&gt;（when, otherwise）</code></li><li><code>&lt;foreach&gt;&lt;/foreach&gt;</code></li><li><code>&lt;bind/&gt;</code></li></ul></li><li><p>怎么把数据库中的数据映射到实体对象</p><p>查询结果中字段名与对象（resultType）属性名一般是一致的，或使用resultMap指定字段与属性的映射关系。</p><p>有了列名与属性名的映射关系后，MyBatis 通过反射创建实体对象，同时使用反射给对象的属性逐一赋值并返回。</p></li></ul><ul><li><p>怎么返回自增主键</p><p>xml中设置useGeneratedKeys&#x3D;”true” keyProperty&#x3D;”id（实体类表示id字段）”</p></li></ul><ul><li><p>二级缓存</p><p>一级缓存：</p><p>一级缓存存在于SqlSession的生命周期中，它默认会启用，并且不能关闭。在同一个 SqlSession（同一个事务） 中查询时，MyBatis 会把执行的方法和参数通过算法生成缓存的键值，将键值和查询结果存入一个Map对象中。如果同一个SqlSession 中执行的方法和参数完全一致，那么通过算法会生成相同的键值，当Map 缓存对象中己经存在该键值时，则会返回缓存中的对象。</p><p>二级缓存：</p><p>在MyBatis 的全局配置settings 中有一个参数cacheEnabled，这个参数是二级缓存的全局开关，默认值是true，初始状态为开启状态。</p><p>MyBatis 的二级缓存是和命名空间绑定的，可以被多个SQLSession共享，不同的SQLSession只要执行相同 namespace 下的 相同的sql 语句，数据查询出来先缓存在一级缓存，当事务提交后(sqlSession.commit())再缓存到二级缓存，第二次会先查二级再查一级。</p><p>在保证二级缓存的全局配置开启的情况下，给Mapper.xml 开启二级缓存只需要在Mapper. xml 中添加如下代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span> /&gt;</span></span><br></pre></td></tr></table></figure><ul><li>映射语句文件中的所有select语句将会被缓存。</li><li>映射语句文件中的所有insert、update和delete语句会清空缓存。</li><li>MyBatis要求返回的POJO必须是可序列化的（ 要求实现Serializable接口）</li></ul><p>适用条件：</p><ol><li>namespace中查询的数据没有其他namespace会修改，否则两个namespace的缓存可能不一致</li><li>增删改不频繁，否则频繁清空缓存</li></ol><p>回收策略：LRU</p></li><li><p>一对一、一对多。多对多</p><p>联合查询：SQL 语句直接关联查询到关系表的字段，resultMap 中关系对象的映射使用 association 标签，标签中 javaType 属性指定关系对象的 java 类型，子标签配置该关系对象的属性映射。</p><p>嵌套查询：SQL 只查主表字段，resultMap 中关系对象的映射使用 association 标签，配置 select 属性引用嵌套查询标签，关系对象使用嵌套查询标签中的 resultMap 进行映射。</p><p>association 指的就是一对一，collection 指的就是一对多查询</p></li><li><p>Mapper接口怎么和xml中的sql关联</p><p>xml文件中，<mapper> 根标签的namespace属性需要配置成接口的全类名。</p><p>select等标签的id与接口中的方法绑定、parameterType绑定参数类型</p></li><li><p>why mybatis</p><ol><li>灵活性：MyBatis允许您直接编写原生的SQL语句，提供了很高的灵活性。您可以根据需要编写任何复杂的SQL，从而满足各种业务需求。</li><li>易于使用：MyBatis通过XML配置文件和注解，让您可以轻松地将SQL语句与Java代码分离，使得代码结构更清晰、易于维护。</li><li>映射简单：MyBatis提供了简单的映射方式，可以将数据库表中的字段自动映射到Java对象的属性上，降低了数据转换的复杂性。</li><li>良好的扩展性：MyBatis提供了丰富的插件接口，您可以通过编写自定义插件来扩展MyBatis的功能，以满足特定需求。</li><li>与其他框架集成：MyBatis可以与Spring、Spring Boot等流行框架无缝集成，提供更加完整的解决方案。</li><li>社区支持：MyBatis有一个活跃的开发者社区，为使用者提供了丰富的文档、教程和支持。这有助于在遇到问题时快速找到解决方案。</li></ol></li></ul><h3 id="批量提交的若干问题"><a href="#批量提交的若干问题" class="headerlink" title="批量提交的若干问题"></a>批量提交的若干问题</h3><p><a href="https://so.csdn.net/so/search?q=Mybatis&spm=1001.2101.3001.7020">Mybatis</a>中有两种批量插入的方式：</p><ol><li><p>动态SQL使用foreach标签进行批量插入</p></li><li><p>使用Mybatis的batch模式进行批量插入</p><p>注意：</p><ul><li>方法需要被spring事务管理（@Transactional）</li></ul></li></ol><p><a href="https://blog.csdn.net/a82514921/article/details/129370033?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-129370033-blog-127187599.235%5Ev38%5Epc_relevant_sort_base3&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-129370033-blog-127187599.235%5Ev38%5Epc_relevant_sort_base3&utm_relevant_index=1">https://blog.csdn.net/a82514921/article/details/129370033?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-129370033-blog-127187599.235%5Ev38%5Epc_relevant_sort_base3&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-129370033-blog-127187599.235%5Ev38%5Epc_relevant_sort_base3&amp;utm_relevant_index=1</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(rollbackFor = Exception.class)</span> <span class="comment">// 这里回滚可以生效</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">batchInsertOrUpdateLikeRecord</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionTemplate.getSqlSessionFactory().openSession(ExecutorType.BATCH, <span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 需要rewriteBatchedStatements=true，效果是将</span></span><br><span class="line">    <span class="comment">// insert into t values();insert into t values();转换成insert into t values(),();。</span></span><br><span class="line">    <span class="type">LikeMapper</span> <span class="variable">likeMapper</span> <span class="operator">=</span> sqlSession.getMapper(LikeMapper.class);</span><br><span class="line">    <span class="comment">// 批量写数据库</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)&#123;</span><br><span class="line">        <span class="comment">// 这里不会实际执行</span></span><br><span class="line">        likeMapper.test(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        sqlSession.commit();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        <span class="comment">// 这里回滚不会生效</span></span><br><span class="line">        <span class="comment">//            sqlSession.rollback();</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常见BUG"><a href="#常见BUG" class="headerlink" title="常见BUG"></a>常见BUG</h3><ul><li><p>数据库字段名和属性名对不上</p></li><li><p>元素内容必须由格式正确的字符数据或标记组成。</p><p>@Update等注解中，小于号（&lt;）、大于号（&gt;）需要转义，否则会视为括号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&amp;lt; &lt;  小于号</span><br><span class="line">&amp;gt; &gt; 大于号 </span><br><span class="line">&amp;amp; &amp; 和</span><br><span class="line">&amp;apos;  ‘’单引号</span><br><span class="line">&amp;quot; “”  双引号</span><br></pre></td></tr></table></figure></li><li><p>nested exception is org.apache.ibatis.binding.BindingException: Parameter ‘xxx‘ not found。Available parameters are [arg2, arg1, arg0, param3, param1, param2]（相关问题：Mybatis多个参数怎么处理？）</p><p>原因：Mybatis参数映射出现问题，#{xxx}找不到对应的参数，这是因为编译器在编译时对形参变量名进行了转化，改变了形参。<br>传递JavaBean对象和单个参数不会出错，因此除了这两种情况外，传递多个非JavaBean对象或基本数据类型时要用**@Param标注形参**。</p><blockquote><p>mybatis 框架会自动创建一个 map 集合用于存储实际参数，而每个实参都会用 两个键值对进行存储.</p><p>如果有多个参数，依次对应arg0、arg1、arg2···，param1，param2···</p><p>需要注意的是，使用了 @Param 注解之后，arg0 和 arg1 失效了，但 param1 和 param2 还可以使用。</p><p>如果只有一个参数，MyBatis 会<strong>自动的使用唯一的那一个参数</strong>，所以，在配置SQL映射时，使用的 #{} 占位符中的占位参数名称根本就不重要！在开发时，推荐使用规范的名称，但是，从代码是否可以运行的角度来说，这个占位符中写什么都不重要！</p><p><strong>如果只有一个参数,并且在<if>里使用,则必须加别名.</strong></p></blockquote></li></ul><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p>Redis是基于内存的数据库，按键值对存储。Redis 内置了多种数据类型实现（比如 String、Hash、Sorted Set、Bitmap、HyperLogLog、GEO），并且对数据类型的操作都是<strong>原子性</strong>的，因为执行命令由单线程负责的。另外，Redis 还支持持久化、多种开箱即用的集群方案、Lua 脚本、发布&#x2F;订阅模式，内存淘汰机制、过期删除机制、事务（不支持原子性、回滚）等等。</p><ul><li>Redis可以用来做什么？&#x2F; 为什么用redis<ol><li>Redis最常用来做缓存，高性能、承载并发请求数量是MySQL的数倍，是实现分布式缓存的首先中间件；</li><li>Redis可以作为数据库，实现诸如点赞、关注、排行等对性能要求极高的互联网需求；</li><li>Redis可以作为计算工具，能用很小的代价，统计诸如PV&#x2F;UV、用户在线天数等数据；</li><li>Redis还有很多其他的使用场景，例如：可以实现分布式锁、限流、可以作为消息队列使用。</li></ol></li></ul><ul><li><p>Redis 与 Memcached <strong>共同点</strong>：</p><ol><li>都是基于内存的数据库，一般都用来当做缓存使用。</li><li>都有过期策略。</li><li>两者的性能都非常高。</li></ol><p>Redis 与 Memcached <strong>区别</strong>：</p><ul><li>Redis 支持的数据类型更丰富（String、Hash、List、Set、ZSet），而 Memcached 只支持最简单的 key-value 数据类型；</li><li>Redis 支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用，而 Memcached 没有持久化功能，数据全部存在内存之中，Memcached 重启或者挂掉后，数据就没了；</li><li>Redis 原生支持集群模式，Memcached 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；</li><li>Redis 支持发布订阅模型、Lua 脚本、事务等功能，而 Memcached 不支持；</li><li>Redis执行命令是单线程，所以非常适合做分布式锁。最佳实践：单机多实例以充分利用cpu。Memcached，是多线程，适合极高并发场景（微博说性能更高，微博内大量用了Memcached）</li></ul></li></ul><h3 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h3><ul><li><p>Redis如何找出大量以某一个前缀开头的key</p><p>scan cursor [MATCH pattern] [COUNT count]</p><ol><li>基于游标的迭代器，需要基于上一次的游标延续之前的迭代过程；</li><li>以0作为游标开始一次新的迭代，知道命令返回游标0完成一次遍历；</li><li>不保证每次执行都返回某个给定数量的元素，支持模糊查询；</li><li>一次返回的数量不可控，只能是大概率符合count参数；</li></ol><p>scan 0 match k1* count 10 其含义是从0开始迭代返回前缀为k1的key，并且希望一次返回10个</p></li></ul><ul><li><p>查看key的过期时间</p><p>redisTemplate.getExpire()、原生TTL命令</p></li><li><p>memory usage [key] 查看key的内存占用</p></li><li><p>Redis提供了多个原子性命令，用于在单个操作中执行多个操作，确保它们在执行过程中不会被其他命令中断。以下是几个常见的原子性命令：</p><p>SETNX：如果指定的键不存在，则设置键的值为指定值。该操作是原子性的，只在键不存在时执行。</p><p>GETSET：设置指定键的新值，并返回键之前的旧值。该操作是原子性的，确保其他命令在SET和GET操作中间不会干扰。</p><p>INCR、DECR：对指定键的整数值进行递增或递减。这两个命令都是原子性的，保证在执行过程中不会有其他命令干扰。</p><p>MSET、MSETNX：分别用于设置多个键值对和多个不存在的键值对。这两个命令都是原子性的，确保设置操作在执行过程中不会被其他命令中断。</p><p>HSET、HSETNX：用于设置哈希表中指定字段的值，并返回是否成功设置。这两个命令都是原子性的，确保设置操作在执行过程中不会被其他命令中断。</p><p>LPUSH、RPUSH：分别在列表的头部和尾部插入一个或多个元素。这两个命令都是原子性的，确保在执行过程中不会有其他命令干扰。</p></li></ul><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p>时间复杂度 <a href="https://coldsmog.cn/project-4/doc-117/">https://coldsmog.cn/project-4/doc-117/</a></p><p>基本数据类型：<strong>String（字符串），Hash（哈希），List（列表），Set（集合）、Zset（有序集合）</strong>。</p><p><img src="https://s2.loli.net/2023/05/26/9m5QI18Grl2BuLV.png" alt="img"></p><ul><li><p>String ：SDS（Simple Dynamic String，简单动态字符串）</p><ul><li><p>常规文本或二进制数据（比如 session、token、序列化后的对象、图片的路径）的缓存；</p></li><li><p>计数比如用户单位时间的请求数（简单限流可以用到）、页面单位时间的访问数；</p></li><li><p>分布式锁(利用 <code>SETNX key value</code> 命令可以实现一个最简易的分布式锁)；</p><ul><li>如果 key 不存在，则显示插入成功，可以用来表示加锁成功；</li><li>如果 key 存在，则会显示插入失败，可以用来表示加锁失败。</li></ul></li><li><p>分布式session</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">（M）SET、（M）GET </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">判断某个 key 是否存在</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">EXISTS name</span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除某个 key 对应的值</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">DEL name</span></span><br><span class="line">(integer) 1</span><br><span class="line">INCR、DECR；INCRBY</span><br><span class="line">EXPIRE、TTL</span><br><span class="line">SETNX（不存在才设置）、SETEX（同时设置过期时间）</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>hash：哈希表(dict)+listpack</p><ul><li>如果哈希类型元素个数小于 512 个（默认值，可由 hash-max-ziplist-entries 配置），所有值小于 64 字节（默认值，可由 hash-max-ziplist-value 配置）的话，Redis 会使用<strong>压缩列表</strong>（listpack）作为 Hash 类型的底层数据结构；</li><li>如果哈希类型元素不满足上面条件，Redis 会使用<strong>哈希表</strong>作为 Hash 类型的底层数据结构。</li></ul><p>场景：</p><ul><li>缓存对象，hash的field与对象的属性对应</li><li>购物车：以用户 id 为 key，商品 id 为 field，商品数量为 value，恰好构成了购物车的3个要素</li></ul><p>String 还是 Hash 存储对象数据更好呢？</p><ul><li>String 存储的是序列化后的对象数据，存放的是整个对象。Hash 是对对象的每个字段单独存储，可以获取部分字段的信息，也可以修改或者添加部分字段，节省网络流量。如果对象中某些字段需要经常变动或者经常需要单独查询对象中的个别字段信息，Hash 就非常适合。</li><li>String 存储相对来说更加节省内存，缓存相同数量的对象数据，String 消耗的内存约是 Hash 的一半。并且，存储具有多层嵌套的对象时也方便很多。如果系统对性能和资源消耗非常敏感的话，String 就非常适合。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">存储一个哈希表key的键值</span></span><br><span class="line">HSET key field value   </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取哈希表key对应的field键值</span></span><br><span class="line">HGET key field</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在一个哈希表key中存储多个键值对</span></span><br><span class="line">HMSET key field value [field value...] </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">批量获取哈希表key中多个field键值</span></span><br><span class="line">HMGET key field [field ...]       </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除哈希表key中的field键值</span></span><br><span class="line">HDEL key field [field ...]    </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">返回哈希表key中field的数量</span></span><br><span class="line">HLEN key       </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">返回哈希表key中所有的键值</span></span><br><span class="line">HGETALL key </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">为哈希表key中field键的值加上增量n</span></span><br><span class="line">HINCRBY key field n      </span><br></pre></td></tr></table></figure></li></ul><ul><li><p>list：quickList，一个quickList是一个双向链表，每个节点是一个压缩列表（ziplist）</p><ul><li>显示最新的项目列表<br>比如说，当我们想要在网页上列出用户的最新20条评论，在最新的评论边上我们有一个“显示全部”的链接，点击后就可以获得更多的评论。<br>Redis列表结构，LPUSH可以在列表头部插入一个内容ID作为关键字，LTRIM可用来限制列表的数量，这样列表永远为N个ID，无需查询最新的列表，直接根据ID去到对应的内容页即可。<br>即每次新评论发表时，我们会将它的ID添加到一个Redis列表。可以限定列表的长度为1000</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将一个或多个值value插入到key列表的表头(最左边)，最后的值在最前面</span></span><br><span class="line">LPUSH key value [value ...] </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将一个或多个值value插入到key列表的表尾(最右边)</span></span><br><span class="line">RPUSH key value [value ...]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">移除并返回key列表的头元素</span></span><br><span class="line">LPOP key     </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">移除并返回key列表的尾元素</span></span><br><span class="line">RPOP key </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">返回列表key中指定区间内的元素，区间以偏移量start和stop指定，从0开始</span></span><br><span class="line">LRANGE key start stop</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从key列表表头弹出一个元素，没有就阻塞<span class="built_in">timeout</span>秒，如果<span class="built_in">timeout</span>=0则一直阻塞</span></span><br><span class="line">BLPOP key [key ...] timeout</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从key列表表尾弹出一个元素，没有就阻塞<span class="built_in">timeout</span>秒，如果<span class="built_in">timeout</span>=0则一直阻塞</span></span><br><span class="line">BRPOP key [key ...] timeout</span><br></pre></td></tr></table></figure><p>Set 类型和 List 类型的区别如下：</p><ul><li>List 可以存储重复元素，Set 只能存储非重复元素；</li><li>List 是按照元素的先后顺序存储元素的，而 Set 则是无序方式存储元素的。</li></ul></li><li><p>set：哈希表+整数集合</p><ul><li>如果集合中的元素都是整数且元素个数小于 <code>512</code> （默认值，<code>set-maxintset-entries</code>配置）个，Redis 会使用<strong>整数集合（inset）</strong>作为 Set 类型的底层数据结构；</li><li>如果集合中的元素不满足上面条件，则 Redis 使用<strong>哈希表</strong>作为 Set 类型的底层数据结构。</li></ul><p>无序并唯一的键值集合，支持多个集合取交集、并集、差集。</p><p>应用场景：</p><ul><li>点赞：保证一个用户只能点一个赞</li><li>支持交集运算，所以可以用来计算共同关注的好友、公众号等</li><li>抽奖：SrandomMember或SRandomPop</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">往集合key中存入元素，元素存在则忽略，若key不存在则新建 O(1)</span></span><br><span class="line">SADD key member [member ...] </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从集合key中删除元素 O(1)</span></span><br><span class="line">SREM key member [member ...] </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取集合key中所有元素</span></span><br><span class="line">SMEMBERS key</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">判断member元素是否存在于集合key中 O(1)</span></span><br><span class="line">SISMEMBER key member</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从集合key中随机选出count个元素，元素不从key中删除</span></span><br><span class="line">SRANDMEMBER key [count]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从集合key中随机选出count个元素，元素从key中删除</span></span><br><span class="line">SPOP key [count]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">交集运算</span></span><br><span class="line">SINTER key [key ...]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将交集结果存入新集合destination中</span></span><br><span class="line">SINTERSTORE destination key [key ...]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">并集运算</span></span><br><span class="line">SUNION key [key ...]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将并集结果存入新集合destination中</span></span><br><span class="line">SUNIONSTORE destination key [key ...]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">差集运算</span></span><br><span class="line">SDIFF key [key ...]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将差集结果存入新集合destination中</span></span><br><span class="line">SDIFFSTORE destination key [key ...]</span><br></pre></td></tr></table></figure></li><li><p>zset：listpack+跳表</p><ul><li>如果有序集合的元素个数小于 <code>128</code> 个，并且每个元素的值小于 <code>64</code> 字节时，Redis 会使用<strong>压缩列表</strong>（listpack）作为 Zset 类型的底层数据结构；</li><li>如果有序集合的元素不满足上面的条件，Redis 会使用<strong>跳表</strong>作为 Zset 类型的底层数据结构；</li></ul><p>Zset 类型（有序集合类型）相比于 Set 类型多了一个排序属性 score（分值），对于有序集合 ZSet 来说，每个存储元素相当于有两个值组成的，一个是有序集合的元素值，一个是排序值。</p><ul><li>排行榜</li><li>姓名、电话号码排序等</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">https://blog.csdn.net/qq_43842093/article/details/122905910</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">往有序集合key中加入带分值元素 复杂度O（logn）</span></span><br><span class="line">ZADD key score member [[score member]...]   </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">往有序集合key中删除元素 O（logn）</span></span><br><span class="line">ZREM key member [member...]                 </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">返回有序集合key中元素member的分值 复杂度O（1）</span></span><br><span class="line">ZSCORE key member</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">为有序集合key中元素member的分值加上increment</span></span><br><span class="line">ZINCRBY key increment member </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">正序获取有序集合key从start下标到stop下标的元素 复杂度<span class="built_in">log</span>(n)+k</span></span><br><span class="line">ZRANGE key start stop [WITHSCORES]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">倒序获取有序集合key从start下标到stop下标的元素</span></span><br><span class="line">ZREVRANGE key start stop [WITHSCORES]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">返回有序集合中指定分数区间内的成员，分数由低到高排序。</span></span><br><span class="line">ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">返回指定成员区间内的成员，按字典正序排列, 分数必须相同。</span></span><br><span class="line">ZRANGEBYLEX key min max [LIMIT offset count]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">返回指定成员区间内的成员，按字典倒序排列, 分数必须相同</span></span><br><span class="line">ZREVRANGEBYLEX key max min [LIMIT offset count]</span><br></pre></td></tr></table></figure></li></ul><h3 id="特殊数据类型"><a href="#特殊数据类型" class="headerlink" title="特殊数据类型"></a>特殊数据类型</h3><ul><li><p>BitMap</p><p>Bitmap，即位图，是一串连续的二进制数组（0和1），可以通过偏移量（offset）定位元素。BitMap通过最小的单位bit来进行<code>0|1</code>的设置，表示某个元素的值或者状态，时间复杂度为O(1)。</p><p>Bitmap 本身是用 String 类型作为底层数据结构实现的一种统计二值状态的数据类型。</p><p>String 类型是会保存为二进制的字节数组，所以，Redis 就把字节数组的每个 bit 位利用起来，用来表示一个元素的二值状态，你可以把 Bitmap 看作是一个 bit 数组。</p><p>两种状态的统计都可以使用bitmaps，例如：统计用户活跃与非活跃数量、登录与非登录、上班打卡等等。</p><ul><li>签到</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置值，其中value只能是 0 和 1</span></span><br><span class="line">SETBIT key offset value</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取值</span></span><br><span class="line">GETBIT key offset</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取指定范围内值为 1 的个数</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">start 和 end 以字节为单位</span></span><br><span class="line">BITCOUNT key start end</span><br></pre></td></tr></table></figure></li><li><p>HyperLoglog</p><p>是一种用于「统计基数」的数据集合类型，基数统计就是指统计一个集合中不重复的元素个数。但要注意，HyperLogLog 是统计规则是基于概率完成的，不是非常准确，标准误算率是 0.81%。</p><p>在 Redis 里面，<strong>每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 <code>2^64</code> 个不同元素的基数</strong>。</p><ul><li>UV统计（浏览用户数量）</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加指定元素到 HyperLogLog 中</span></span><br><span class="line">PFADD key element [element ...]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">返回给定 HyperLogLog 的基数估算值。</span></span><br><span class="line">PFCOUNT key [key ...]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将多个 HyperLogLog 合并为一个 HyperLogLog</span></span><br><span class="line">PFMERGE destkey sourcekey [sourcekey ...]</span><br></pre></td></tr></table></figure></li><li><p>GEO</p><p>底层为sorted set。应用场景：按经纬度查看附近的人</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">存储指定的地理空间位置，可以将一个或多个经度(longitude)、纬度(latitude)、位置名称(member)添加到指定的 key 中。</span></span><br><span class="line">GEOADD key longitude latitude member [longitude latitude member ...]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从给定的 key 里返回所有指定名称(member)的位置（经度和纬度），不存在的返回 nil。</span></span><br><span class="line">GEOPOS key member [member ...]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">返回两个给定位置之间的距离。</span></span><br><span class="line">GEODIST key member1 member2 [m|km|ft|mi]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">根据用户给定的经纬度坐标来获取指定范围内的地理位置集合。</span></span><br><span class="line">GEORADIUS key longitude latitude radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count] [ASC|DESC] [STORE key] [STOREDIST key]</span><br></pre></td></tr></table></figure></li><li><p>Stream</p><ul><li>如果你的业务场景足够简单，对于<strong>数据丢失</strong>不敏感，而且<strong>消息积压</strong>概率比较小的情况下，把 Redis 当作队列是完全可以的。</li><li>如果你的业务有海量消息，消息积压的概率比较大，并且不能接受数据丢失，那么还是用专业的消息队列中间件吧。</li></ul></li></ul><blockquote><p>介绍一下Redis数据结构？</p><p>先说说Redis数据类型，主要包括5种基本数据类型和3种特殊类型。</p><p>基本数据类型包括String、List、Set、Sorted Set和Hash。</p><p>String就是字符串，应用场景：作为缓存、计数器</p><p>String底层基于SDS（简单动态字符串）实现，解决了C语言字符串存在的一些问题。比如C语言的字符串用‘\0’表示结束，最先遇到的‘\0’会被视为字符串结尾，所以不能保存二进制数据。SDS用一个字节数组存放数据，另外用一个len成员记录字符串长度，所以不需要用‘\0’结尾（为了兼容实际还是用了）,可以存文本也可以存二进制数据。</p><p>List就是链表，它的元素是有序的，而且列表内的元素是可以重复的。可以用来做数据分页展示</p><p>底层基于quicklist实现。quicklist就是一个双向链表，链表的每个节点指向一个压缩列表ziplist（ziplist所存储的内容都是在连续的内存区域当中的，可以通过数据元素的类型和大小来分配内存空间，所以更省内存。插入的时间复杂化度为O(n)，而且每当插入新的元素需要realloc做内存扩展）。</p><p>Set是字符串集合，它不允许存放重复元素，并且元素是无序的。适用于一些需要去重的场景如项目中评论的点赞，也可以借助SrandomMember来做抽奖。</p><p>Set在存放元素都是整数且元素个数少于512的时候采用inset结构，它是一个有序的整数集合。不满足这个条件就采用hashtable。</p><p>Sorted Set是有序集合，它保留了集合中元素不能重复的特性，但是有序集合给每个元素多设置了一个分数用来排序。应用场景就是用来做排行榜，比如项目中帖子的点赞用zset按点赞时间来排。</p><p>在zset元素比较少（&lt;128）并且每个元素都比较小（&lt;64字节）时采用压缩列表，每个集合元素使用两个紧挨在一起的压缩列表节点来保存，第一个节点保存元素的成员（member），而第二个元素则保存元素的分值（score）。其他情况用的是skiplist和哈希表。跳表是多层的有序列表，增删复杂度o(logn)，通过跳表能进行高效的范围查询，通过哈希表能进行高效单点查询。</p><p>Hash就是一个键值对（key-value）集合。可以用来存对象，比如用户信息，不同信息分别对应一个field，这样就可以按需要获取用户的信息，不用每次去数据库查。</p><p>在hash元素比较少（&lt;512）并且每个元素都比较小（&lt;64字节）时采用压缩列表，其他情况用的是哈希表。</p></blockquote><h3 id="数据结构-Redis7-0-listpack取代了压缩列表ziplist"><a href="#数据结构-Redis7-0-listpack取代了压缩列表ziplist" class="headerlink" title="数据结构(Redis7.0,listpack取代了压缩列表ziplist)"></a>数据结构(Redis7.0,listpack取代了压缩列表ziplist)</h3><p><img src="https://s2.loli.net/2023/06/24/qcaeEJTOIwht15o.png" alt="Redis数据结构"></p><ul><li><p>SDS</p><p>Redis基于C语言实现，但C语言的字符串有如下缺点：</p><ul><li>获取字符串长度的时间复杂度为 O（N）；</li><li>字符串的结尾是以 “\0” 字符标识，字符串里面不能包含有 “\0” 字符，因此不能保存二进制数据；</li><li>字符串操作函数不高效且不安全，比如有缓冲区溢出的风险，有可能会造成程序运行终止；</li></ul><p><img src="https://s2.loli.net/2023/06/24/GVFE3OvQ7nUWrTt.png" alt="Redis-SDS"></p><ul><li><strong>len，记录了字符串长度</strong>。这样获取字符串长度的时候，只需要返回这个成员变量值就行，时间复杂度只需要 O（1）。（C 语言的字符串长度获取 strlen 函数，需要通过遍历的方式来统计字符串长度，时间复杂度是 O（N）。）</li><li><strong>alloc，分配给字符数组的空间长度</strong>。这样在修改字符串的时候，可以通过 <code>alloc - len</code> 计算出剩余的空间大小，可以用来判断空间是否满足修改需求，如果不满足的话，就会自动将 SDS 的空间扩展至执行修改所需的大小，然后才执行实际的修改操作，所以使用 SDS 既不需要手动修改 SDS 的空间大小，也不会出现前面所说的缓冲区溢出的问题。</li><li><strong>flags，用来表示不同类型的 SDS</strong>。一共设计了 5 种类型，分别是 sdshdr5、sdshdr8、sdshdr16、sdshdr32 和 sdshdr64，可以灵活保存不同大小字符串。比如，sdshdr16 类型的 SDS，默认情况下，编译器会按照 2 字节对齐的方式给变量分配内存，这意味着，即使一个变量的大小不到 2 个字节，编译器也会给它分配 2 个字节。</li><li><strong>buf[]，字符数组，用来保存实际数据</strong>。不仅可以保存字符串，也可以保存二进制数据。因为 SDS 不需要用 “\0” 字符来标识字符串结尾了，而是<strong>有个专门的 len 成员变量来记录长度，所以可存储包含 “\0” 的数据</strong>。但是 SDS 为了兼容部分 C 语言标准库的函数， SDS 字符串结尾还是会加上 “\0” 字符。</li></ul></li></ul><h5 id="skiplist跳表"><a href="#skiplist跳表" class="headerlink" title="skiplist跳表"></a>skiplist跳表</h5><p>Redis 只有 Zset 对象的底层实现用到了跳表，跳表的优势是能支持平均 O(logN) 复杂度的节点查找。</p><p>zset 结构体里有两个数据结构：一个是跳表，一个是哈希表。这样的好处是既能进行高效的范围查询，也能进行高效单点查询。</p><p>Zset 对象在执行数据插入或是数据更新的过程中，会依次在跳表和哈希表中插入或更新相应的数据，从而保证了跳表和哈希表中记录的信息一致。</p><p>Zset 对象能支持范围查询（如 ZRANGEBYSCORE 操作），这是因为它的数据结构设计采用了跳表，而又能以常数复杂度获取元素权重（如 ZSCORE 操作），这是因为它同时采用了哈希表进行索引。</p><p>链表在查找元素的时候，因为需要逐一查找，所以查询效率非常低，时间复杂度是O(N)，于是就出现了跳表。<strong>跳表是在链表基础上改进过来的，实现了一种「多层」的有序链表</strong>（空间换时间），这样的好处是能快读定位数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">    <span class="comment">//Zset 对象的元素值</span></span><br><span class="line">    sds ele;</span><br><span class="line">    <span class="comment">//元素权重值</span></span><br><span class="line">    <span class="type">double</span> score;</span><br><span class="line">    <span class="comment">//后向指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">//节点的level数组，保存每层上的前向指针和跨度</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> span;</span><br><span class="line">    &#125; level[];</span><br><span class="line">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/06/29/GqD3fFx8uCOHzPL.png" alt="跳表"></p><ul><li><p>查询过程</p><p>查找一个跳表节点的过程时，跳表会从头节点的最高层开始，逐一遍历每一层。在遍历某一层的跳表节点时，会用跳表节点中的 SDS 类型的元素和元素的权重来进行判断，共有两个判断条件：</p><ul><li>如果当前节点的权重「小于」要查找的权重时，跳表就会访问该层上的下一个节点。</li><li>如果当前节点的权重「等于」要查找的权重时，并且当前节点的 SDS 类型数据「小于」要查找的数据时，跳表就会访问该层上的下一个节点。</li></ul><p>如果上面两个条件都不满足，或者下一个节点为空时，跳表就会使用目前遍历到的节点的 level 数组里的下一层指针，然后沿着下一层指针继续查找，这就相当于跳到了下一层接着查找。</p></li><li><p>结点层数的设置</p><p><strong>跳表在创建节点的时候，随机生成每个节点的层数</strong>，并没有严格维持相邻两层的节点数量比例为 2 : 1 的情况。</p><p>具体的做法是，<strong>跳表在创建节点时候，会生成范围为[0-1]的一个随机数，如果这个随机数小于 0.25（相当于概率 25%），那么层数就增加 1 层，然后继续生成下一个随机数，直到随机数的结果大于 0.25 结束，最终确定该节点的层数</strong>。</p><p>这样的做法，相当于每增加一层的概率不超过 25%，层数越高，概率越低，层高最大限制是 32。</p></li></ul><ul><li><p>为什么用跳表不用红黑树？</p><ul><li><strong>从内存占用上来比较，跳表比平衡树更灵活一些</strong>。平衡树每个节点包含 2 个指针（分别指向左右子树），而跳表每个节点包含的指针数目平均为 1&#x2F;(1-p)，具体取决于参数 p 的大小。如果像 Redis里的实现一样，取 p&#x3D;1&#x2F;4，那么平均每个节点包含 1.33 个指针，比平衡树更有优势。</li><li><strong>在做范围查找的时候，跳表比平衡树操作要简单</strong>。在平衡树上，我们找到指定范围的小值之后，还需要以中序遍历的顺序继续寻找其它不超过大值的节点。如果不对平衡树进行一定的改造，这里的中序遍历并不容易实现。而在跳表上进行范围查找就非常简单，只需要在找到小值之后，对第 1 层链表进行若干步的遍历就可以实现。</li><li><strong>从算法实现难度上来比较，跳表比平衡树要简单得多</strong>。平衡树的插入和删除操作可能引发子树的调整，逻辑复杂，而跳表的插入和删除只需要修改相邻节点的指针，操作简单又快速。</li></ul></li><li><p>为什么不用B+树？</p><ul><li><p><strong>简单实现</strong></p><p>跳跃表的实现相对简单，相比B+ Tree而言，代码实现难度要小很多。在实际应用中，简单的实现通常能够提高代码的可读性和可维护性，因此跳跃表比B+ Tree更适合Redis这种注重性能和易用性的应用。</p></li><li><p><strong>更好的内存效率</strong></p><p>在存储相同数量的元素时，跳跃表通常需要更少的内存。这是因为跳跃表在实现过程中，节点的层数是随机的，并且每个节点只需要记录下一层节点的指针，而不是像B+ Tree那样需要记录所有子节点的指针。这样一来，跳跃表在存储相同数量的元素时，所需的内存通常比B+ Tree要少。</p></li><li><p><strong>更高的写入性能</strong></p><p>在写入操作方面，跳跃表比B+ Tree具有更高的性能。这是因为在跳跃表中，每个节点都是独立的，当需要进行插入或删除操作时，只需要修改少量节点即可，而B+ Tree需要从根节点开始遍历到叶子节点，才能找到正确的位置进行插入或删除操作。而且B+树需要考虑平衡性、页分裂等问题，跳表不需要考虑。因此，在频繁进行写入操作的场景中，跳跃表比B+ Tree更加高效。</p></li></ul></li></ul><h5 id="ziplist压缩列表"><a href="#ziplist压缩列表" class="headerlink" title="ziplist压缩列表"></a>ziplist压缩列表</h5><p>简言之，有点类似于数组，用一块连续的内存空间，但是根据每个节点存放的具体元素的不同采用不同的编码以节省内存（按实际存放元素分配内存）。查首尾O（1），其他位置O（n）</p><p>压缩列表的最大特点，就是它被设计成一种内存紧凑型的数据结构，占用一块连续的内存空间，不仅可以利用 CPU 缓存，而且会针对不同长度的数据，进行相应编码，这种方法可以有效地节省内存开销。</p><p><img src="https://s2.loli.net/2023/06/29/m53FSzEICUfcBZA.png" alt="ziplist"></p><p>压缩列表在表头有三个字段：</p><ul><li><em><strong>zlbytes</strong></em>，记录整个压缩列表占用对内存字节数；</li><li><em><strong>zltail</strong></em>，记录压缩列表「尾部」节点距离起始地址由多少字节，也就是列表尾的偏移量；</li><li><em><strong>zllen</strong></em>，记录压缩列表包含的节点数量；</li><li><em><strong>zlend</strong></em>，标记压缩列表的结束点，固定值 0xFF（十进制255）。</li></ul><p>在压缩列表中，如果我们要查找定位第一个元素和最后一个元素，可以通过表头三个字段（zllen）的长度直接定位，复杂度是 O(1)。而<strong>查找其他元素时，就没有这么高效了，只能逐个查找，此时的复杂度就是 O(N) 了，因此压缩列表不适合保存过多的元素</strong>。</p><p>压缩列表节点包含三部分内容：</p><ul><li><em><strong>prevlen</strong></em>，记录了「前一个节点」的长度，目的是为了实现从后向前遍历；</li><li><em><strong>encoding</strong></em>，记录了当前节点实际数据的「类型和长度」，类型主要有两种：字符串和整数。</li><li><em><strong>data</strong></em>，记录了当前节点的实际数据，类型和长度都由 <code>encoding</code> 决定；</li></ul><p>当我们往压缩列表中插入数据时，压缩列表就会根据数据类型是字符串还是整数，以及数据的大小，会使用不同空间大小的 prevlen 和 encoding 这两个元素里保存的信息，<strong>这种根据数据大小和类型进行不同的空间大小分配的设计思想，正是 Redis 为了节省内存而采用的</strong>。</p><h5 id="quicklist"><a href="#quicklist" class="headerlink" title="quicklist"></a>quicklist</h5><p>quicklistNode 结构体里包含了前一个节点和下一个节点指针，这样每个 quicklistNode 形成了一个双向链表。但是链表节点的元素不再是单纯保存元素值，而是保存了一个压缩列表，所以 quicklistNode 结构体里有个指向压缩列表的指针 *zl。</p><p><img src="https://s2.loli.net/2023/06/29/d2Rv7IzSq4X9tWn.png" alt="quicklist"></p><p>在向 quicklist 添加一个元素的时候，不会像普通的链表那样，直接新建一个链表节点。而是会检查插入位置的压缩列表是否能容纳该元素，如果能容纳就直接保存到 quicklistNode 结构里的压缩列表，如果不能容纳，才会新建一个新的 quicklistNode 结构。</p><p>quicklist 会控制 quicklistNode 结构里的压缩列表的大小或者元素个数，来规避潜在的连锁更新的风险，但是这并没有完全解决连锁更新的问题。</p><h5 id="listpack"><a href="#listpack" class="headerlink" title="listpack"></a>listpack</h5><p>listpack 采用了压缩列表的很多优秀的设计，比如还是用一块连续的内存空间来紧凑地保存数据，并且为了节省内存的开销，listpack 节点会采用不同的编码方式保存不同大小的数据。</p><p><img src="https://s2.loli.net/2023/06/29/Rkv8LfdaOsbeEYT.png" alt="listpack"></p><p>主要包含三个方面内容：</p><ul><li>encoding，定义该元素的编码类型，会对不同长度的整数和字符串进行编码；</li><li>data，实际存放的数据；</li><li>len，encoding+data的总长度；</li></ul><p>可以看到，<strong>listpack 没有压缩列表中记录前一个节点长度的字段了，listpack 只记录当前节点的长度，当我们向 listpack 加入一个新元素的时候，不会影响其他节点的长度字段的变化，从而避免了压缩列表的连锁更新问题</strong>。</p><h5 id="Dict-两个Hashtable"><a href="#Dict-两个Hashtable" class="headerlink" title="Dict(两个Hashtable)"></a>Dict(两个Hashtable)</h5><p>采用<strong>拉链法</strong>解决Hash冲突。链式哈希局限性也很明显，随着链表长度的增加，在查询这一位置上的数据的耗时就会增加，毕竟链表的查询的时间复杂度是 O(n)。</p><p>要想解决这一问题，就需要进行 rehash，也就是对哈希表的大小进行扩展。Redis采用渐进式rehash。</p><p><strong>所谓渐进式rehash是指我们的大字典的扩容是比较消耗时间的，需要重新申请新的数组，然后将旧字典所有链表的元素重新挂接到新的数组下面，是一个O(n)的操作。但是因为我们的redis是单线程的，无法承受这样的耗时过程，所以采用了渐进式rehash小步搬迁，虽然慢一点，但是可以搬迁完毕</strong>。</p><p>扩容条件</p><p>我们的扩容一般会在Hash表中的元素个数等于第一维数组的长度的时候，就会开始扩容。扩容的大小是原数组的两倍。不过在redis在做bgsave（RDB持久化操作的过程），为了减少内存页的过多分离（Copy On Write），redis不会去扩容。但是如果hash表的元素个数已经到达了第一维数组长度的5倍的时候，就会强制扩容，不管你是否在持久化。</p><p>不扩容主要是为了尽可能减少内存页过多分离，系统需要更多的开销去回收内存。</p><p>缩容条件</p><p>当我们的hash表元素逐渐删除的越来越少的时候。redis于是就会对hash表进行缩容来减少第一维数组长度的空间占用。缩容的条件是元素个数低于数组长度的10%，并且缩容不考虑是否在做redis持久化。</p><p>不用考虑bgsave主要是因为我们的缩容的内存都是已经使用过的，缩容的时候可以直接置空，而且由于申请的内存比较小，同时会释放掉一些已经使用的内存，不会增大系统的压力。</p><p>rehash步骤</p><p>1、为ht[1] 分配空间，让字典同时持有ht[0]和ht[1]两个哈希表；</p><p>2、定时维持一个索引计数器变量rehashidx，并将它的值设置为0，表示rehash 开始；</p><p>3、在rehash进行期间，每次对字典执行CRUD操作时，程序除了执行指定的操作以外，还会将ht[0]中的数据rehash 到ht[1]表中，并且将rehashidx加一；</p><p>4、当ht[0]中所有数据转移到ht[1]中时，将rehashidx 设置成-1，表示rehash 结束；</p><p>（采用渐进式rehash 的好处在于它采取分而治之的方式，避免了集中式rehash 带来的庞大计算量。特别的在进行rehash时只能对h[0]元素减少的操作，如查询和删除；而查询是在两个哈希表中查找的，而插入只能在ht[1]中进行，ht[1]也可以查询和删除。）</p><p>5、将ht[0]释放，然后将ht[1]设置成ht[0]，最后为ht[1]分配一个空白哈希表。</p><p><a href="https://www.xiaolincoding.com/redis/data_struct/command.html#string">https://www.xiaolincoding.com/redis/data_struct/command.html#string</a></p><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><h4 id="RedisBloom"><a href="#RedisBloom" class="headerlink" title="RedisBloom"></a>RedisBloom</h4><p><a href="https://bugwz.com/2022/01/01/redismodule-redisbloom/">https://bugwz.com/2022/01/01/redismodule-redisbloom/</a></p><h3 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h3><p><a href="https://mp.weixin.qq.com/s/-op5WR1wSkgAuP7JYZWP8g">https://mp.weixin.qq.com/s/-op5WR1wSkgAuP7JYZWP8g</a></p><ul><li><p>redis为什么快</p><ul><li><p>Redis <strong>基于内存</strong>，内存的访问速度是磁盘的上千倍；</p></li><li><p>Redis 是键值数据库，底层是全局哈希表，可以用O(1)的时间复杂度定位到元素；内置了多种<strong>高效的数据结构</strong>实现，不同场景下都能有较高的性能。</p></li><li><p>Redis处理主要业务逻辑是单线程的，单线程模型可以避免了多线程之间的竞争，<strong>规避进程内频繁的线程上下文切换开销</strong>，避免同步机制（比如锁）的开销</p><p><strong>CPU 并不是制约 Redis 性能表现的瓶颈所在</strong>，更多情况下是受到内存大小和网络I&#x2F;O的限制。网络 I&#x2F;O 在 Redis 整个执行期间占用了大部分的 CPU 时间，所以 <strong>Redis 6.0 版本之后，也采用了多个 I&#x2F;O 线程（默认3个）来处理网络请求</strong>，性能提升一倍以上。</p></li></ul><ul><li><p>Redis 基于 Reactor 模式设计开发了一套高效的事件处理模型，主要是单线程事件循环和<strong>IO 多路复用</strong>；</p><p> <strong>I&#x2F;O 多路复用机制</strong>处理大量的客户端 Socket 请求，IO 多路复用机制是指一个线程处理多个 IO 流，就是我们经常听到的 select&#x2F;epoll 机制。简单来说，在 Redis 只运行单线程的情况下，该机制允许内核中，同时存在多个监听 Socket 和已连接 Socket。内核会一直监听这些 Socket 上的连接请求或数据请求。一旦有请求到达，就会交给 Redis 线程处理，这就实现了一个 Redis 线程处理多个 IO 流的效果。</p></li></ul></li></ul><p><strong>Redis 单线程指的是「接收客户端请求-&gt;解析请求 -&gt;进行数据读写等操作-&gt;发送数据给客户端」这个过程是由一个线程（主线程）来完成的</strong>。</p><p>Redis有一些后台线程用于执行一些比较耗时（关闭文件、AOF 刷盘、释放内存，如果由主线程执行会<strong>阻塞主线程</strong>）的操作：</p><ul><li>通过 <code>bio_close_file</code> 后台线程来<strong>释放</strong>AOF &#x2F; RDB 等过程中产生的临时<strong>文件资源</strong>。</li><li>通过 <code>bio_aof_fsync</code> 后台线程调用 <code>fsync</code> 函数将系统内核缓冲区还未同步到到磁盘的数据强制<strong>刷</strong>到磁<strong>盘</strong>（ AOF 文件）。</li><li>通过 <code>bio_lazy_free</code>后台线程<strong>释放大对象</strong>（已删除）占用的内存空间.</li></ul><h3 id="事务、pipeline、Lua脚本"><a href="#事务、pipeline、Lua脚本" class="headerlink" title="事务、pipeline、Lua脚本"></a>事务、pipeline、Lua脚本</h3><p><code>Redis</code>事务在发送每个指令到事务缓存队列时都要经过一次网络读写，当一个事务内部的指令较多时，需要的网络 IO 时间也会线性增长。所以通常 <code>Redis</code>的客户端在执行事务时都会结合 <code>pipeline</code>一起使用，这样可以**将多次 IO 操作压缩为单次 IO **操作。</p><p>需要注意的是：一个<code>pipeline</code>包含的命令不应太多，因为在使用流水线操作时，<code>Redis</code>在将所有响应批量返回给客户端之前会<strong>将所有响应缓存在内存</strong>中，因此对数千个查询（特别是那些返回大量数据的查询）进行流水线操作可能会对服务器和客户端都造成负担。</p><p>Lua脚本：</p><ul><li><p>原子性<br> 脚本会将多个命令和操作当成一个命令在redis中执行，在执行脚本的时候不会被其他的命令插入，具有原子性，因此更适合于处理事务；<br> 而管道虽然也会将多个命令一次性传输到服务端，但在服务端执行的时候仍然是多个命令，如在执行CMD1的时候，外部另一个客户端提交了CMD9，会先执行完CMD9再执行管道中的CMD2，因此事实上<strong>管道是不具有原子性的</strong>。</p></li><li><p>redis本身是不支持事务回滚的，那也就是说如果 在执行lua脚本过程中，有一部分命令成功了，有一部分失败了，也不会出现回滚的操作。</p></li><li><p>优点</p><ul><li>原子性操作：Redis使用单线程执行Lua脚本，保证了脚本的原子性操作，避免了多个操作之间的竞态条件。</li><li>减少网络开销：通过执行Lua脚本，可以将多个Redis操作合并为一个网络请求，减少了网络开销。Redis将Lua脚本编译成一个SHA1哈希值，并将其存储在一个键名为SCRIPTS的Redis哈希集中。在脚本第一次运行后，这个哈希值将被存储在Redis缓存中。后续只需发送这个SHA1值和脚本的参数即可（RedisTemplate可以帮我们实现）</li><li>复杂操作的封装：Lua脚本可以将多个操作封装成一个原子性的命令，提高了代码的简洁性和可读性。</li><li>高效：Lua语言是快速轻量级的脚本语言，它具有快速的解释能力。</li></ul></li></ul><p>redis事务可以原子性的执行一组命令，但是每条命令实际上是不是马上执行的：先发到server端队列里攒着一起exec，这样的话如果命令之间有依赖就没法搞定了。</p><blockquote><p>注意事项：java参数类型一定要跟lua脚本类型匹配！</p></blockquote><h3 id="过期删除与内存淘汰"><a href="#过期删除与内存淘汰" class="headerlink" title="过期删除与内存淘汰"></a>过期删除与内存淘汰</h3><h4 id="过期删除策略"><a href="#过期删除策略" class="headerlink" title="过期删除策略"></a>过期删除策略</h4><p><strong>Redis 中除了字符串类型有自己独有设置过期时间的命令 <code>setex</code> 外，其他方法都需要依靠 <code>expire</code> 命令来设置过期时间 （通过expire可以续期）。另外， <code>persist</code> 命令可以移除一个键的过期时间。</strong></p><p>每当我们对一个 key 设置了过期时间时，Redis 会把该 key 带上过期时间（值是一个 long long 类型的整数）存储到一个<strong>过期字典</strong>（expires dict）中，也就是说过期字典保存了数据库中所有 key 的过期时间。</p><p>当我们查询一个 key 时，Redis 首先检查该 key 是否存在于过期字典中：</p><ul><li>如果不在，则正常读取键值；</li><li>如果存在，则会获取该 key 的过期时间，然后与当前系统时间进行比对，如果比系统时间大，那就没有过期，否则判定该 key 已过期。</li></ul><p>常用的过期数据的删除策略就两个：</p><ol><li><strong>惰性删除</strong>：<strong>不主动删除过期键，每次从访问 key 时，才检测 key 是否过期，如果过期则删除该 key</strong>。这样对 CPU 最友好，但是可能会造成太多过期 key 没有被删除。</li><li><strong>定期删除</strong>：<strong>每隔一段时间「随机」从数据库中取出一定数量的 key 进行检查，并删除其中的过期key。</strong>并且，Redis 底层会通过限制删除操作执行的时长和频率来减少删除操作对 CPU 时间的影响。</li></ol><p>定期删除对内存更加友好，惰性删除对 CPU 更加友好。两者各有千秋，所以 Redis 采用的是 <strong>定期删除+惰性&#x2F;懒汉式删除</strong> 。</p><p>Redis 的定期删除的流程：</p><ol><li>从过期字典中随机抽取 20 个 key；</li><li>检查这 20 个 key 是否过期，并删除已过期的 key；</li><li>如果本轮检查的已过期 key 的数量，超过 5 个（4分之一），也就是「已过期 key 的数量」占比「随机抽取 key 的数量」大于 25%，则继续重复步骤 1；如果已过期的 key 比例小于 25%，则停止继续删除过期 key，然后等待下一轮再检查。</li></ol><p>可以看到，定期删除是一个循环的流程。那 Redis 为了保证定期删除不会出现循环过度，导致线程卡死现象，为此增加了定期删除循环流程的时间上限，默认不会超过 25ms。</p><h4 id="内存淘汰"><a href="#内存淘汰" class="headerlink" title="内存淘汰"></a>内存淘汰</h4><p><strong>no eviction</strong>（Redis3.0之后，默认的内存淘汰策略） ：它表示当运行内存超过最大设置内存时，不淘汰任何数据，而是不再提供服务，直接返回错误。</p><p><strong>allkeys-lru（least recently used）</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）。</p><p><strong>volatile-lru（least recently used）</strong>：从已设置过期时间的数据集（<code>server.db[i].expires</code>）中挑选最近最少使用的数据淘汰。</p><p><strong>volatile-random &#x2F; allkeys-random</strong>：从<em>已设置过期时间的数据集</em> &#x2F; <em>所有数据</em> 中任意选择数据淘汰。</p><p><strong>volatile-lfu &#x2F; allkeys-lfu（least frequently used）</strong>：从<em>已设置过期时间的数据集</em> &#x2F; <em>所有数据</em>中挑选最不经常使用的数据淘汰。</p><p><strong>volatile-ttl</strong>：从已设置过期时间的数据集中挑选将要过期的数据淘汰。</p><ul><li><p>lru 最近最少使用</p><p>传统 LRU 算法的实现是基于「链表」结构，链表中的元素按照操作顺序从前往后排列，最新操作的键会被移动到表头，当需要内存淘汰时，只需要删除链表尾部的元素即可，因为链表尾部的元素就代表最久未被使用的元素。</p><p>Redis 实现的是一种<strong>近似 LRU 算法</strong>，目的是为了更好的节约内存，它的<strong>实现方式是在 Redis 的对象结构体中添加一个额外的字段，用于记录此数据的最后一次访问时间</strong>。</p><p>当 Redis 进行内存淘汰时，会使用<strong>随机采样的方式来淘汰数据</strong>，它是随机取 5 个值（此值可配置），然后<strong>淘汰最久没有使用的那个</strong>。</p><p>LRU算法的不足之处在于，若一个key很少被访问，只是刚刚偶尔被访问了一次，则它就被认为是热点数据，短时间内不会被淘汰。</p></li><li><p>lfu 最近最不常用</p><p>它根据key的最近访问频率进行淘汰。LFU在LRU的基础上，为每个数据增加了一个计数器，来统计这个数据的访问次数。当使用LFU策略淘汰数据时，首先会根据数据的访问次数进行筛选，把访问次数最低的数据淘汰出内存。如果两个数据的访问次数相同，LFU再比较这两个数据的访问时间，把访问时间更早的数据淘汰出内存。</p></li></ul><h3 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h3><p>Redis 的读写操作都是在内存中，所以 Redis 性能才会高，但是当 Redis 重启后，内存中的数据就会丢失，那为了保证内存中的数据不会丢失，Redis 实现了数据持久化的机制，这个机制会把数据存储到磁盘，这样在 Redis 重启就能够从磁盘中恢复原有的数据。</p><p>Redis 共有三种数据持久化的方式：</p><h4 id="AOF-日志"><a href="#AOF-日志" class="headerlink" title="AOF 日志"></a><strong>AOF 日志</strong></h4><p>类似于MySQL的binlog，每执行一条写操作命令，就把该命令以追加的方式写入到一个文件里；然后 Redis 重启时，会读取该文件记录的命令，然后逐一执行命令的方式来进行数据恢复。</p><ul><li><p>AOF过程</p><p>先执行写操作命令后，才将该命令记录到 AOF 日志里；AOF 日志是在主线程中执行</p><ul><li>避免额外的检查开销，AOF 记录日志不会对命令进行语法检查；</li><li>在命令执行完之后再记录，不会阻塞当前的命令执行。</li></ul><p>AOF 持久化功能的实现可以简单分为 5 步：</p><ol><li><strong>命令追加（append）</strong>：所有的写命令会追加到 AOF 缓冲区中。</li><li><strong>文件写入（write）</strong>：调用系统调用write将 AOF 缓冲区的数据写入到 系统内核缓冲区，等待系统写入AOF 文件中。</li><li><strong>文件同步（fsync）</strong>：AOF 缓冲区根据对应的持久化方式（ <code>fsync</code> 策略）向硬盘做同步操作。这一步需要调用 <code>fsync</code> 函数（系统调用）， <code>fsync</code> 针对单个文件操作，对其进行强制硬盘同步，<code>fsync</code> 将阻塞直到写入磁盘完成后返回，保证了数据持久化。</li><li><strong>文件重写（rewrite）</strong>：随着 AOF 文件越来越大，需要定期对 AOF 文件进行重写，达到压缩的目的。</li><li><strong>重启加载（load）</strong>：当 Redis 重启时，可以加载 AOF 文件进行数据恢复。</li></ol></li><li><p>写回磁盘策略</p><p>Redis 提供了 3 种写回硬盘的策略，控制的就是上面说的第三步的过程。 在 Redis.conf 配置文件中的 appendfsync 配置项可以有以下 3 种参数可填：</p><ul><li><p><strong>Always</strong>，这个单词的意思是「总是」，所以它的意思是每次写操作命令执行完后，同步将 AOF 日志数据写回硬盘；</p></li><li><p><strong>Everysec</strong>，这个单词的意思是「每秒」，所以它的意思是每次写操作命令执行完后，先将命令写入到 AOF 文件的内核缓冲区，然后每隔一秒将缓冲区里的内容写回到硬盘；</p></li><li><p><strong>No</strong>，意味着不由 Redis 控制写回硬盘的时机，转交给操作系统控制写回的时机，也就是每次写操作命令执行完后，先将命令写入到 AOF 文件的内核缓冲区，再由操作系统决定何时将缓冲区内容写回硬盘。</p></li></ul></li><li><p>AOF重写：由后台线程执行</p><p>Redis 为了避免 AOF 文件越写越大，提供了 <strong>AOF 重写机制</strong>，当 AOF 文件的大小超过所设定的阈值后，Redis 就会启用 AOF 重写机制，来压缩 AOF 文件。</p><p>AOF 重写机制是在重写时，读取当前数据库中的所有键值对，然后将每一个键值对用一条命令记录到「新的 AOF 文件」。</p><p>AOF 文件重写期间，Redis 还会维护一个 <strong>AOF 重写缓冲区</strong>，该缓冲区会在子进程创建新 AOF 文件期间，记录服务器执行的所有写命令。当子进程完成创建新 AOF 文件的工作之后，服务器会将重写缓冲区中的所有内容追加到新 AOF 文件的末尾，使得新的 AOF 文件保存的数据库状态与现有的数据库状态一致。最后，服务器用新的 AOF 文件替换旧的 AOF 文件，以此来完成 AOF 文件重写操作。</p></li></ul><h4 id="RDB-快照"><a href="#RDB-快照" class="headerlink" title="RDB 快照"></a><strong>RDB 快照</strong></h4><p>Redis 可以通过创建快照来获得存储在内存里面的数据在 <strong>某个时间点</strong> 上的副本，以二进制的方式写入磁盘；</p><p>恢复数据时， RDB 恢复数据的效率会比 AOF 高些，因为直接将 RDB 文件读入内存就可以。</p><ul><li><p>RDB 做快照时会阻塞线程吗？</p><p>Redis 提供了两个命令来生成 RDB 文件，分别是 save 和 bgsave，他们的区别就在于是否在「主线程」里执行：</p><ul><li><p>执行了 save 命令，就会在主线程生成 RDB 文件，由于和执行操作命令在同一个线程，所以如果写入 RDB 文件的时间太长，<strong>会阻塞主线程</strong>；</p></li><li><p>执行了 bgsave 命令，<strong>会创建一个子进程来生成 RDB 文件</strong>，这样可以<strong>避免主线程的阻塞</strong>；</p></li></ul></li></ul><p>Redis 还可以通过配置文件的选项来实现每隔一段时间自动执行一次 bgsave 命令，默认会提供以下配置:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">save <span class="number">900</span> <span class="number">1</span> <span class="comment">// 900s之内至少1次修改</span></span><br><span class="line">save <span class="number">300</span> <span class="number">10</span></span><br><span class="line">save <span class="number">60</span> <span class="number">10000</span></span><br></pre></td></tr></table></figure><p>执行 bgsave 过程中，Redis 依然<strong>可以继续处理操作命令</strong>的，也就是数据是能被修改的，关键的技术就在于<strong>写时复制技术（Copy-On-Write, COW）。</strong></p><p>执行 bgsave 命令的时候，会通过 fork() 创建子进程，此时子进程和父进程是共享同一片内存数据的，因为创建子进程的时候，会复制父进程的页表，但是页表指向的物理内存还是一个，此时如果主线程执行读操作，则主线程和 bgsave 子进程互相不影响；如果主线程执行写操作，则被修改的数据会复制一份副本，然后 bgsave 子进程会把该副本数据写入 RDB 文件，在这个过程中，主线程仍然可以直接修改原来的数据。</p><h4 id="混合持久化方式"><a href="#混合持久化方式" class="headerlink" title="混合持久化方式"></a><strong>混合持久化方式</strong></h4><p>Redis 4.0 新增的方式，集成了 AOF 和 RBD 的优点；</p><p>RDB 优点是数据恢复速度快，但是快照的频率不好把握。频率太低，丢失的数据就会比较多，频率太高，就会影响性能。</p><p>AOF 优点是丢失数据少，但是文件体积大且数据恢复不快。</p><p>混合持久化工作在 <strong>AOF 日志重写过程</strong>，当开启了混合持久化时，在 AOF 重写日志时，fork 出来的重写子进程会先将与主线程共享的内存数据以 RDB 方式写入到 AOF 文件，然后主线程处理的操作命令会被记录在重写缓冲区里，<strong>重写缓冲区里的增量命令会以 AOF 方式写入到 AOF 文件</strong>，写入完成后通知主进程将新的含有 RDB 格式和 AOF 格式的 AOF 文件替换旧的的 AOF 文件。</p><p>也就是说，使用了混合持久化，AOF 文件的<strong>前半部分是 RDB 格式的全量数据，后半部分是 AOF 格式的增量数据</strong>。这样的好处在于，重启 Redis 加载数据的时候，由于前半部分是 RDB 内容，这样<strong>加载的时候速度会很快</strong>。加载完 RDB 的内容后，才会加载后半部分的 AOF 内容，这里的内容是 Redis 后台子进程重写 AOF 期间，主线程处理的操作命令，可以使得<strong>数据更少的丢失</strong>。</p><p><strong>混合持久化优点：</strong></p><ul><li>混合持久化结合了 RDB 和 AOF 持久化的优点，开头为 RDB 的格式，使得 Redis 可以更快的启动，同时结合 AOF 的优点，减低了大量数据丢失的风险。</li></ul><h4 id="RDB与AOF对比"><a href="#RDB与AOF对比" class="headerlink" title="RDB与AOF对比"></a>RDB与AOF对比</h4><p><strong>RDB 比 AOF 优秀的地方</strong>：</p><ul><li>RDB 文件存储的内容是经过压缩的二进制数据， 保存着某个时间点的数据集，文件很小，适合做数据的备份，灾难恢复。AOF 文件存储的是每一次写命令，类似于 MySQL 的 binlog 日志，通常会比 RDB 文件大很多。当 AOF 变得太大时，Redis 能够在后台自动重写 AOF。新的 AOF 文件和原有的 AOF 文件所保存的数据库状态一样，但体积更小。</li><li>使用 RDB 文件恢复数据，直接解析还原数据即可，不需要一条一条地执行命令，速度非常快。而 AOF 则需要依次执行每个写命令，速度非常慢。也就是说，与 AOF 相比，恢复大数据集的时候，RDB 速度更快。</li></ul><p><strong>AOF 比 RDB 优秀的地方</strong>：</p><ul><li>RDB 的数据安全性不如 AOF，没有办法实时或者秒级持久化数据。生成 RDB 文件的过程是比较繁重的， 虽然 BGSAVE 子进程写入 RDB 文件的工作不会阻塞主线程，但会对机器的 CPU 资源和内存资源产生影响，严重的情况下甚至会直接把 Redis 服务干宕机。AOF 支持秒级数据丢失（取决 fsync 策略，如果是 everysec，最多丢失 1 秒的数据），仅仅是追加命令到 AOF 文件，操作轻量。</li></ul><p><strong>综上</strong>：</p><ul><li>Redis 保存的数据丢失一些也没什么影响的话，可以选择使用 RDB。</li><li>不建议单独使用 AOF，因为时不时地创建一个 RDB 快照可以进行数据库备份、更快的重启以及解决 AOF 引擎错误。</li><li>如果保存的数据要求安全性比较高的话，建议同时开启 RDB 和 AOF 持久化或者开启 RDB 和 AOF 混合持久化。</li></ul><h3 id="缓存设计"><a href="#缓存设计" class="headerlink" title="缓存设计"></a>缓存设计</h3><p>key的设计：[业务名]:[数据名]:[主键]</p><h4 id="常见问题-1"><a href="#常见问题-1" class="headerlink" title="常见问题"></a>常见问题</h4><ul><li><p>缓存穿透</p><p>查询的数据既不在缓存中，也不在数据库中。故请求直达数据库，一般为恶意攻击。</p><p>解决方案：</p><ol><li><p>缓存空对象：存储层未命中后，仍然将空值存入缓存层，并设置一个<strong>较短</strong>的过期时间。客户端再次访问数据时，缓存层会直接返回空值。</p><blockquote><p>为什么要较短的过期时间？如果这个时候数据库突然又有了对应数据，就会存在不一致问题。</p></blockquote></li><li><p>布隆过滤器：把所有可能存在的请求的值都存放在布隆过滤器中，当用户请求过来，先判断用户发来的请求的值是否存在于布隆过滤器中，若请求的数据不存在则直接返回空值。</p><p>缺点：</p><ul><li>布隆过滤器可能会存在误判的情况。总结来说就是：<strong>布隆过滤器说某个元素存在，小概率会误判（随着里面内容的增加，误判率就会随之上升）。布隆过滤器说某个元素不在，那么这个元素一定不在。</strong></li><li>不允许有删除操作。会导致其中的无效元素可能会越来越多，即实际已经在磁盘删除中的元素，但在bloomfilter中还认为可能存在，这会造成越来越多的false positive（假阳性）。</li></ul><p>底层：bitmap + k个hash函数</p><p>当一个元素加入位图时，通过k个hash函数将元素映射到位图的k个点，并把它们置1；当检索时，再通过k个hash函数运算检查位图的k个点是否都为1；如果有不为1的点，那么认为该key不存在；如果全部为1，则可能存在（<strong>不同的字符串可能哈希出来的位置相同</strong>）。</p><blockquote><p>“我们提到了布隆过滤器清除状态比较困难，但有些缓存数据是有生命周期的，比如一周或者一个月之后就大概率过期了，你有没有什么好办法可以帮助我们更好地清理过期数据呢？”</p><p>解决：每过一定的周期就建立一个新的布隆过滤器B，和原有的布隆过滤器A保持双写，再过一段时间后，A与B的指代交换，然后删除A。</p><p>注：Redis Bloom 的布隆当容量超出设定值，会创建一个2倍大小的<em>子过滤器</em>，查询时依次检索</p><p>布隆过滤器及其变种对比</p><p>Cuckoo（ [ˈkʊku:]） Filter相比Bloom Filter优点：</p><ol><li><p>支持删除数据。布隆过滤器因为多个元素可能映射到同一个点位，因此不能删除。而布谷鸟过滤器每个元素只对应一个位置。</p></li><li><p>比 Bloom filters 具有更好的<strong>查询</strong>性能（默认2个bucket，最多两次访存。布隆有k个hash函数，需要k次访存。写性能布隆更优）。</p></li><li><p>论文里说在误判率小于 3% 的情况下，大概能比 Bloom filters 节省 40% 多空间。（布谷鸟过滤器误判的情况：元素不存在，但是它的两个bucket中对应位置都被其他元素占了）。我看了一下Redisbloom的这两个过滤器，误判率为1.56%的情况下，cuckooFilter大概省20%+</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">error_rate = (buckets * hash_functions)/2^fingerprint_size = (buckets*2)/256，即默认为1.56%</span><br><span class="line">https://redis.io/docs/data-types/probabilistic/cuckoo-filter/#sizing-cuckoo-filters</span><br></pre></td></tr></table></figure></li></ol><p>缺点：</p><ol><li><p>长度必须是2的幂次</p></li><li><p>插入数据性能比布隆差，负载越大插入越慢（因为可能踢来踢去）</p><p>实测：差不多，因为瓶颈主要是网络</p></li><li><p>Cuckoo误判率较高，redis的Cuckoo最低貌似只能达到1&#x2F;128的误判率</p></li></ol><p>原理：<a href="https://www.zhihu.com/question/429437541/answer/3015446209">https://www.zhihu.com/question/429437541/answer/3015446209</a></p><p>cuckoo hash 使用 2 个 hash 函数得到 2 个 bucket 的位置，但是 cuckoo filter 中首先利用 hash 函数得到 bucket1， 然后利用下面公式得到 bucket2 的位置。<code>bucket2 = bucket1 ⊕ hash(fingerprint)</code><br>这样就可以利用异或 hash(fingerprint) 通过一个 bucket 的位置来获取另外一个 bucket 的位置。</p><ol><li>它的哈希函数是成对的（具体的实现可以根据需求设计），每一个元素都是两个哈希函数，分别映射到两个位置，一个是记录的位置，另一个是备用位置。这个备用位置是处理碰撞时用的。</li><li>cuckoo hash 处理碰撞的方法，主要把原来占用位置的这个元素踢走; 被踢出去的元素插入到它的备用位置。如果备用位置上还有人，再把它踢走，如此往复。直到被踢的次数达到一个上限，才确认哈希表已满，并执行 rehash 操作（默认2倍扩容，生成一个2倍大小的子过滤器）。</li></ol><p>它有两个 hash 表，记为 T1，T2。两个 hash 函数，记为 h1，h2。</p><p>当一个<em>不存在的元素</em>插入的时候，会先根据 h1 计算出其在 T1 表的位置，如果该位置为空则可以放进去。</p><p>如果该位置不为空，则根据 h2 计算出其在 T2 表的位置，如果该位置为空则可以放进去。</p><p>如果该位置不为空，就把当前位置上的元素踢出去，然后把当前元素放进去就行了。</p><p>也可以随机踢出两个位置中的一个，总之会有一个元素被踢出去。</p><p>举个例子：</p><p>我想要插入元素 x，经过两个 hash 函数计算后，它的两个位置分别为 T1 表的 2 号位置和 T2 表的 1 号位置。</p><p><img src="http://oss.ripplesu.top/blog/Typora/%E9%9D%A2%E8%AF%95%E9%A2%98/v2-827d8877490a14c1427f71594ee52570_720w.webp" alt="布谷鸟过滤器插入示例1"></p><p>两个位置都被占了，那就随机把 T1 表 2 号位置上的 y 踢出去吧。</p><p>而 y 的另一个位置被 z 元素占领了。</p><p>于是 y 毫不留情把 z 也踢了出去。</p><p>z 发现自己的备用位置还空着（虽然这个备用位置也是元素 v 的备用位置），赶紧就位。</p><p>所以，当 x 插入之后，图就变成了这样：</p><p><img src="http://oss.ripplesu.top/blog/Typora/%E9%9D%A2%E8%AF%95%E9%A2%98/v2-cc7f200ac26f61e2a183a9705a8510b9_720w.webp" alt="布谷鸟过滤器插入示例2"></p></blockquote><p><a href="https://www.modb.pro/db/32203">https://www.modb.pro/db/32203</a></p><p><img src="http://oss.ripplesu.top/blog/Typora/%E9%9D%A2%E8%AF%95%E9%A2%98/modb_019e53dc-f634-11ea-9c9b-5254001c05fe.png" alt="布隆过滤器及其变种对比"></p></li><li><p><strong>非法请求的限制</strong>：做好参数校验，过滤非法请求；限制ip</p></li></ol></li><li><p>缓存击穿</p><p>热点数据（在数据库中）突然失效，大量请求直达数据库，瞬间对数据库造成巨大压力。</p><p>解决思路主要有两种：</p><ol><li><p>永不过期：热点数据不设置过期时间，所以不会出现上述问题，这是“物理”上的永不过期。</p><p>或者为每个数据设置<strong>逻辑过期</strong>时间。命中缓存后，将value取出，判断value中的逻辑过期时间，如果没有过期，则直接返回redis中的旧数据；如果过期，则在开启独立线程去重构缓存，然后直接返回之前的数据。（或访问时续期，但每次访问都多一次写操作，性能差）</p><p>对于时间确定，可以预知是一个热点key的情况，比如秒杀场景（或项目中的考试场景），可以提前预热数据到缓存中，并保证在活动时间内缓存不会过期。</p></li><li><p>加互斥锁：对数据的访问加互斥锁（如用setnx），当一个线程访问该数据时，获取到了锁的线程前往查询数据库，查询后将数据写入redis，再释放锁；其他线程只能休眠一段时间后重试。</p></li></ol></li><li><p>缓存雪崩</p><p>缓存中有大量数据同时过期，或是Redis宕机，导致大量请求直达数据库。</p><ol><li>避免数据同时过期：设置过期时间时，附加一个随机数，使过期时间分布尽量均匀，避免大量的key同时过期。</li><li>多级缓存（二级缓存失效，一级缓存可能还命中，不会直达数据库）</li><li>构建高可用的Redis服务：采用哨兵或集群模式，部署多个Redis实例，个别节点宕机，依然可以保持服务的整体可用。</li><li>启用限流、降级和熔断措施：在发生雪崩时，若应用访问的不是核心数据，则直接返回预定义信息&#x2F;空值&#x2F;错误信息。或者在发生雪崩时，对于访问缓存接口的请求，客户端并不会把请求发给Redis，而是直接返回。</li></ol></li></ul><h5 id="大key与热key"><a href="#大key与热key" class="headerlink" title="大key与热key"></a>大key与热key</h5><ul><li><p>大key</p><p>简单来说，如果一个 key 对应的 value 所占用的内存比较大，那这个 key 就可以看作是 bigkey。具体多大才算大呢？有一个不是特别精确的参考标准：string 类型的 value 超过 10 kb，复合类型的 value 包含的元素超过 5000 个（对于复合类型的 value 来说，不一定包含的元素越多，占用的内存就越多）。</p><ul><li><p><strong>客户端超时阻塞</strong>。由于 Redis 执行命令是单线程处理，然后在操作大 key 时会比较耗时，那么就会阻塞 Redis，从客户端这一视角看，就是很久很久都没有响应。</p></li><li><p><strong>引发网络阻塞</strong>。每次获取大 key 产生的网络流量较大，如果一个 key 的大小是 1 MB，每秒访问量为 1000，那么每秒会产生 1000MB 的流量，这对于普通千兆网卡的服务器来说是灾难性的。</p></li><li><p><strong>阻塞工作线程</strong>。如果使用 del 删除大 key 时，会阻塞工作线程，这样就没办法处理后续的命令。</p></li><li><p><strong>内存分布不均</strong>。集群模型在 slot 分片均匀情况下，会出现数据和查询倾斜情况，部分有大 key 的 Redis 节点占用内存多，QPS 也会比较大。</p><ul><li><p>注：</p><p>TPS：即每秒处理事务数，QPS：每秒查询率。</p><p>对于一个页面的一次访问，形成一个Tps；但一次<a href="https://www.zhihu.com/search?q=%E9%A1%B5%E9%9D%A2%E8%AF%B7%E6%B1%82&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2429686279%7D">页面请求</a>，可能产生多次对服务器的请求，服务器对这些请求，就可计入“Qps”之中。</p><p>例如：访问一个页面会请求服务器3次，产生一个“T”，产生3个“Q”</p></li></ul></li></ul><ul><li><strong>使用 Redis 自带的 <code>--bigkeys</code> 参数来查找</strong></li></ul><p>如何处理 bigkey？</p><p>bigkey 的常见处理以及优化办法如下（这些方法可以配合起来使用）：</p><ul><li><strong>分割 bigkey</strong>：将一个 bigkey 分割为多个小 key。这种方式需要修改业务层的代码，一般不推荐这样做。</li><li><strong>手动清理</strong>：Redis 4.0+ 可以使用 <code>UNLINK</code> 命令来<strong>异步删除</strong>一个或多个指定的 key。Redis 4.0 以下可以考虑使用 <code>SCAN</code> 命令结合 <code>DEL</code> 命令来分批次删除。</li><li><strong>开启 lazy-free（惰性删除&#x2F;延迟释放）</strong> ：lazy-free 特性是 Redis 4.0 开始引入的，指的是让 Redis 采用异步方式延迟释放 key 使用的内存，将该操作交给单独的子线程处理，避免阻塞主线程。</li></ul></li></ul><ul><li><h4 id="什么是-hotkey？"><a href="#什么是-hotkey？" class="headerlink" title="什么是 hotkey？"></a>什么是 hotkey？</h4><p>简单来说，如果一个 key 的访问次数比较多且明显多于其他 key 的话，那这个 key 就可以看作是 hotkey。例如在 Redis 实例的每秒处理请求达到 5000 次，而其中某个 key 的每秒访问量就高达 2000 次，那这个 key 就可以看作是 hotkey。hotkey 出现的原因主要是某个热点数据访问量暴增，如重大的热搜事件、参与秒杀的商品。</p><p>处理 hotkey 会占用大量的 CPU 和带宽，可能会影响 Redis 实例对其他请求的正常处理。</p><ul><li><strong>使用 Redis 自带的 <code>--hotkeys</code> 参数来查找。</strong>前提是内存淘汰策略选择<strong>LFU</strong></li></ul><h4 id="如何解决-hotkey？"><a href="#如何解决-hotkey？" class="headerlink" title="如何解决 hotkey？"></a>如何解决 hotkey？</h4><p>hotkey 的常见处理以及优化办法如下（这些方法可以配合起来使用）：</p><ul><li><strong>读写分离</strong>：主节点处理写请求，从节点处理读请求。</li><li><strong>使用 Redis Cluster</strong>：将热点数据分散存储在多个 Redis 节点上。</li><li><strong>二级缓存</strong>：hotkey 采用二级缓存的方式进行处理，将 hotkey 存放一份到 JVM 本地内存中（可以用 Caffeine）。</li></ul></li></ul><h5 id="慢查询-1"><a href="#慢查询-1" class="headerlink" title="慢查询"></a>慢查询</h5><p>慢查询日志主要用于记录Redis实例中<strong>执行时间</strong>超过指定阈值的命令。</p><ul><li><p><code>config set slowlog-log-slower-than n</code>设置慢查询阈值</p><ul><li>值为正数，执行时间大于该值设置的微秒时才记录到慢日志中。默认 10000 微秒。</li><li>值为负数，禁用慢查询日志。</li><li>值为 0，所有命令都记录到慢日志中</li></ul></li><li><p><code>slowlog-max-len</code></p><ul><li>慢查询日志长度，最小值为零。默认 128</li><li>当记录新命令并且当前慢日志已达到最大长度时，最旧的一条记录将被删除。</li></ul></li><li><p><code>slowlog reset</code>清空日志</p></li><li><p>慢查询日志输出格式</p><p>1）每条日志唯一标识符</p><p>2）命令执行时的<a href="https://so.csdn.net/so/search?q=%E6%97%B6%E9%97%B4%E6%88%B3&spm=1001.2101.3001.7020">时间戳</a></p><p>3）命令执行消耗的时间，单位微秒</p><p>4）执行的命令数组</p><p>5）客户端地址和端口 （仅 4.0 以上版本支持）</p><p>6）客户端名称 （仅 4.0 以上版本支持，默认名称为空，需要通过 client setname 命令进行设置）</p></li></ul><h5 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h5><p><a href="https://mp.weixin.qq.com/s/nNEuYw0NlYGhuKKKKoWfcQ">https://mp.weixin.qq.com/s/nNEuYw0NlYGhuKKKKoWfcQ</a></p><h4 id="缓存更新策略"><a href="#缓存更新策略" class="headerlink" title="缓存更新策略"></a>缓存更新策略</h4><p>腾讯云：<a href="https://mp.weixin.qq.com/s/uex9zkf2uPeTp56cfv4dHA">https://mp.weixin.qq.com/s/uex9zkf2uPeTp56cfv4dHA</a></p><ul><li><p>Cache Aside（旁路缓存）策略；</p></li><li><p>Read&#x2F;Write Through（读穿 &#x2F; 写穿）策略：<strong>同步更新 cache 和 db</strong>。</p><p>Read-Through意为读穿透模式，它的流程和Cache-Aside类似，不同点在于Read-Through中多了一个访问控制层，读请求只和该访问控制层进行交互，而背后缓存命中与否的逻辑则由访问控制层与数据源进行交互，业务层的实现会更加简洁，并且对于缓存层及持久化层交互的封装程度更高，更易于移植。</p><p>Write-Through意为直写模式，对于Write-Through直写模式来说，它也增加了访问控制层来提供更高程度的封装。不同于Cache-Aside的是，Write-Through直写模式在写请求更新数据库之后，并不会删除缓存，而是更新缓存。缺点：更新效率低，并且两个写操作任何一次写失败都会造成数据不一致。</p></li><li><p>Write Behind Caching（<strong>Write-back</strong>）：Write behind意为异步回写模式，它也具有类似Read-Through&#x2F;Write-Through的访问控制层，不同的是，Write behind在处理写请求时，只更新缓存而不更新数据库，对于数据库的更新，则是通过<strong>批量异步更新</strong>的方式进行的，批量写入的时间点可以选在数据库负载较低的时间进行。</p><p>在Write-Behind模式下，写请求延迟较低，减轻了数据库的压力，具有较好的吞吐性。但数据库和缓存的一致性较弱，比如当更新的数据还未被写入数据库时，直接从数据库中查询数据是落后于缓存的。同时，缓存的负载较大，如果缓存宕机会导致数据丢失，所以需要做好缓存的高可用。显然，Write behind模式下适合大量写操作的场景，常用于电商秒杀场景中库存的扣减。</p><p><img src="https://s2.loli.net/2023/07/11/SmT9BQE3fCq4bc7.png" alt="Write-Behind"></p></li></ul><h5 id="Cache-Aside（旁路缓存）策略"><a href="#Cache-Aside（旁路缓存）策略" class="headerlink" title="Cache Aside（旁路缓存）策略"></a>Cache Aside（旁路缓存）策略</h5><p>携程：<a href="https://mp.weixin.qq.com/s/E-chAZyHtaZOdA19mW59-Q">https://mp.weixin.qq.com/s/E-chAZyHtaZOdA19mW59-Q</a></p><p>旁路缓存策略是比较常用的方法，它需要由缓存的调用者同时维护数据库与缓存。具体又可以细分为读和写两种策略。<br>读策略较为简单，只需要先从缓存中读取数据，缓存命中则直接将对应数据返回；缓存未命中，则从数据库中读出对应的数据返回，同时将数据放入缓存中。<br>而写策略就需要考虑如下两个问题：</p><h5 id="数据写入数据库时，是删除缓存还是更新缓存？"><a href="#数据写入数据库时，是删除缓存还是更新缓存？" class="headerlink" title="数据写入数据库时，是删除缓存还是更新缓存？"></a>数据写入数据库时，是删除缓存还是更新缓存？</h5><ul><li><p>更新缓存：更新缓存的<strong>消耗比较大</strong>。如果数据需要经过复杂的计算再写入缓存，那么频繁的更新缓存，就会影响服务器的性能。如果是写入数据频繁的业务场景，那么可能频繁的更新缓存时，却没有业务读取该数据。</p><p>另外，如果同时有请求A和请求B进行更新操作，那么会出现</p><ol><li>线程A更新了数据库</li><li>线程B更新了数据库</li><li>线程B更新了缓存</li><li>线程A更新了缓存</li></ol><p>这就出现请求A更新缓存应该比请求B更新缓存早才对，但是因为网络等原因，B却比A更早更新了缓存。这就导致了<strong>脏数据</strong>，因此不考虑。</p></li><li><p>删除缓存：更新数据库时让缓存失效，查询时再更新缓存。减少了无效操作，一般采用这种策略。</p></li></ul><h5 id="先操作缓存还是数据库？"><a href="#先操作缓存还是数据库？" class="headerlink" title="先操作缓存还是数据库？"></a>先操作缓存还是数据库？</h5><h6 id="先删缓存，再操作数据库"><a href="#先删缓存，再操作数据库" class="headerlink" title="先删缓存，再操作数据库"></a>先删缓存，再操作数据库</h6><ul><li><p>异常情况<br>异常情况下，线程1删除缓存后，在执行更新数据库操作完成前，线程2查询缓存但未命中，故前往查询数据库。而此时线程1的更新操作尚未完成，于是线程2得到了旧数据，并将其写入缓存。这样就产生了缓存与数据库不一致的现象。由于更新缓存的速度远高于更新数据库，因此异常情况发生概率较高。<img src="https://s2.loli.net/2023/05/27/5nUyRw2Z1gY8obz.png" alt="image.png"></p><p>3和4可以交换顺序。</p><p>为什么要延时？如果3和4交换顺序，更新了数据库后马上删缓存，而此时线程2还未写入缓存，则无效删除。</p><blockquote><p>延时双删</p></blockquote><p>上面我们提到，如果是先删缓存、再更新数据库，在没有出现失败时可能会导致数据的不一致。如果在实际的应用中，出于某些考虑我们需要选择这种方式，那有办法解决这个问题吗？答案是有的，那就是采用延时双删的策略，延时双删的基本思路如下：</p><ol><li>删除缓存；</li><li>更新数据库；</li><li>sleep N毫秒（将失效指令放入延时队列，另一个线程轮询队列获取指令并执行。）；</li><li>再次删除缓存。</li></ol><p>延迟的实现可以在代码中sleep或采用延迟队列。显而易见的是，无论这个值如何预估，都很难和读请求的完成时间点准确衔接，这也是延时双删被诟病的主要原因。</p></li></ul><h6 id="先操作数据库，再删除缓存"><a href="#先操作数据库，再删除缓存" class="headerlink" title="先操作数据库，再删除缓存"></a>先操作数据库，再删除缓存</h6><ul><li><p>异常情况<br>线程1查询缓存前恰好缓存失效，故前往查询数据库；而此时线程2更新完数据库执行删除缓存操作；此后线程1将从数据库中查出的数据放入缓存，故产生了不一致现象。但这种情况出现的可能性较低，因为线程2要在线程1查询完数据库后写入缓存的极短时间内完成更新数据库的操作。<img src="https://s2.loli.net/2023/05/27/8gtIaZKSpFMUf1C.png" alt="image.png"></p><p>这种场景的出现，不仅需要缓存失效且读写并发执行，而且还需要读请求查询数据库的执行早于写请求更新数据库，同时读请求的执行完成晚于写请求。足以见得，这种不一致场景产生的条件非常严格，在实际的生产中出现的可能性较小。</p><p>除此之外，在并发环境下，Cache-Aside中也存在读请求命中缓存的时间点在写请求更新数据库之后，删除缓存之前，这样也会导致读请求查询到的缓存落后于数据库的情况。</p><p>虽然在下一次读请求中，缓存会被更新，但如果业务层面对这种情况的容忍度较低，为了避免并发带来的缓存不一致问题，需要将**”更新DB”+”删除缓存”、”查询DB”+”更新缓存”两个流程都进行加锁，两处对应的锁key是相同的**。此处需要加的是分布式锁。加锁势必会导致吞吐量的下降，故采取加锁的方案应该对性能的损耗有所预期。</p><p><img src="https://s2.loli.net/2023/07/11/mlXJWCf37jgreiv.png" alt="缓存更新与DB更新并发控制"></p><p>（1）缓存查询和DB更新的并发控制</p><p>查询操作流程中，先判断lock是否存在，若存在，则表示当前DB或缓存正在更新，不能直接查询缓存，在查询DB后返回数据。之所以这么做，还是由场景决定的，如前文所述，我们场景下的基本处理思路是，缓存仅作为“DB降压”的辅助手段，在不确定缓存数据是否最新的情况下，宁可多查询几次DB，也不要查询到缓存中的不一致数据。此外，更新操作相对于查询操作是很少的，在我们贷前服务中，读写比例约为8:1。</p><p>此处另外的一个可行方案是可在检测到有锁后可进行短暂的等待和重试，好处是可进一步增加缓存的命中率，但是多一次锁等待，可能会影响到查询接口的性能。可根据自身场景进行抉择。</p><p>此外，为了进行降级，在锁判断前也增加了降级开关判断，若降级开关开启，也会直接查询DB。而降级主要是由于redis故障引起的，下文详述。若检测是否有锁时发生了异常同样也会直接查询DB。</p><p>（2）缓存更新和DB更新的并发控制</p><p>查询操作流程中，若缓存不存在，则进行缓存的更新，在更新时候先尝试进行加锁，若当前有锁说明当前有DB或缓存正在更新，则进行等待和重试，从而可避免查询到DB中的老数据更新到缓存中。</p><p>其中lock2的流程（load cache），我们是同步进行的。另外一个可行的方案是，异步发起缓存的加载，可减少锁等待时间，但是若出现瞬时的高并发查询，可能缓存无法及时加载产生从而频繁产生瞬时压力。可根据自身场景进行抉择。</p></li></ul><p>综上所述，执行写操作时应先更新数据库，再删除缓存。<br>不过，这种方案还存在一个问题：万一<strong>缓存删除失败</strong>，那么缓存中的数据仍然是旧的数据。为了尽可能减小删除缓存失败带来的影响，应该为数据设置一个过期时间。</p><blockquote><p>如果必须保证更新数据库与删除缓存这两个操作都成功，可以考虑如下解决策略：</p></blockquote><ul><li><p>将删除缓存的操作加入到消息队列，利用其<strong>重试机制</strong>确保删除缓存操作成功。</p></li><li><p>通过Canal等中间件订阅Mysql的binlog，只要数据库更新成功，canal都会自动将消息投递给下游的消息队列。</p><blockquote><p>为什么要canal？删缓存可能失败，需要通过重试保证删除成功。不用canal，需要手动重试或发到消息队列。</p><p>用canal的好处：解耦和异步处理。通过将数据库的数据变更事件发送到消息队列中，可以实现数据库与应用程序之间的解耦。应用程序可以异步地从消息队列中消费数据变更事件，并根据需要进行处理，而不需要直接依赖数据库。</p></blockquote></li></ul><h4 id="强一致性策略"><a href="#强一致性策略" class="headerlink" title="强一致性策略"></a>强一致性策略</h4><p>上述策略只能保证数据的最终一致性。要想做到强一致，最常见的方案是 2PC、3PC、Paxos、Raft 这类一致性协议，但它们的性能往往比较差，而且这些方案也比较复杂，还要考虑各种容错问题。如果业务层要求必须读取数据的强一致性，可以采取以下策略：</p><p><strong>（1）暂存并发读请求</strong></p><p>在更新数据库时，先在 Redis 缓存客户端暂存并发读请求，等数据库更新完、缓存值删除后，再读取数据，从而保证数据一致性。</p><p><strong>（2）串行化</strong></p><p>读写请求入队列，工作线程从队列中取任务来依次执行</p><ol><li>修改服务 Service 连接池，id 取模选取服务连接，能够保证同一个数据的读写都落在同一个后端服务上</li><li>修改数据库 DB 连接池，id 取模选取 DB 连接，能够保证同一个数据的读写在数据库层面是串行的</li></ol><p><strong>（3）使用 Redis 分布式读写锁</strong></p><p>将淘汰缓存与更新库表放入同一把写锁中，与其它读请求互斥，防止其间产生旧数据。读写互斥、写写互斥、读读共享，可满足读多写少的场景数据一致，也保证了并发性。并根据逻辑平均运行时间、响应超时时间来确定过期时间。</p><h4 id="Redis分布式锁"><a href="#Redis分布式锁" class="headerlink" title="Redis分布式锁"></a>Redis分布式锁</h4><p><a href="https://mp.weixin.qq.com/s/hvTx6_WSZ82ok3na7L1IiA">https://mp.weixin.qq.com/s/hvTx6_WSZ82ok3na7L1IiA</a></p><p>目前分布式锁的实现方式有3种主流方法，即：</p><ul><li><p>基于数据库实现分布式锁，此处的数据库指的是MySQL关系型数据库</p></li><li><ul><li><p>基于MySQL锁表</p><p>其实现原理是：创建一张锁表，对临界资源做唯一性约束，通过增加一条记录对某一资源上锁，释放锁时删除记录；一般不推荐此种用法。</p></li><li><p>数据库版本号乐观锁</p><p>在数据库的表中需要包含一个数字类型的字段version，读取数据时把version字段读出来，更新数据时判断当前version是否等于读取出来的version，并对当前version+1；如果等于就更新成功，不等于表示数据已过期更新失败。例如以积分体系为例，存在多种场景增加积分，通过乐观锁来保证数据的正确性。</p><p>乐观锁CR注意点:</p></li></ul></li><li><ul><li>where 条件一定要命中索引(最好是主键或者唯一索引)，否则会锁表；</li></ul></li><li><p>update table set 中必须要包含version &#x3D; version + 1；</p><ul><li>update 返回结果为0时，一定要根据业务场景进行相应的处理，自主重试或者抛异常；</li></ul></li><li><p>基于缓存实现分布式锁，此处的缓存指的是Redis</p></li><li><p>基于zookeeper&#x2F;etcd实现分布式锁</p></li></ul><table><thead><tr><th>实现方式</th><th>优点</th><th>缺点</th><th>应用场景</th></tr></thead><tbody><tr><td>MySQL数据库表</td><td>易于理解&#x2F;易于实现</td><td>容易出现单点故障、死锁性能低&#x2F;可靠性低</td><td>适用于并发量低、性能要求低的场景</td></tr><tr><td>Redis分布式锁</td><td>性能高&#x2F;易于实现可跨集群部署，无单点故障</td><td>锁失效时间的控制不稳定稳定性低于ZooKeeper</td><td>适用于高并发、高性能场景</td></tr><tr><td>ZooKeeper分布式锁</td><td>无单点故障&#x2F;可靠性高不可重入&#x2F;无死锁问题</td><td>实现复杂性能低于缓存分布式锁</td><td>适用于大部分分布式场景，除对性能要求极高的场景</td></tr></tbody></table><h5 id="用setnx实现简单分布式锁"><a href="#用setnx实现简单分布式锁" class="headerlink" title="用setnx实现简单分布式锁"></a>用setnx实现简单分布式锁</h5><p>首先加锁的逻辑可以通过<code>setnx key value</code>来实现，第一个进入的线程执行成功，返回1，表示它抢到了锁。那么在线程执行完业务后，就把锁删除，表示释放锁。在此期间，没有抢到锁的线程需等待一段时间后重试。<br>如果客户端<strong>忘记解锁或解锁失败</strong>,那么这种情况就很有可能造成<strong>死锁</strong>。但如果直接给锁增加过期时间（减少死锁影响）即新增<code>expire key seconds</code>又会发生其他问题,即这两个命令并<strong>不是原子性</strong>的。那么如果第二步失败,依然无法避免死锁问题。考虑到如上问题,我们最终可以通过<code>set...nx...</code>命令,<strong>将加锁、过期命令编排到一起</strong>,把他们变成原子操作,这样就可以避免死锁。写法为**<code>set key value nx ex seconds</code>**。java中可以用如下方法实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String KEY_PREFIX=<span class="string">&quot;lock:&quot;</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> timeoutSec)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取线程标示</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">threadId</span> <span class="operator">=</span> Thread.currentThread().getId()</span><br><span class="line">    <span class="comment">// 获取锁</span></span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">success</span> <span class="operator">=</span> stringRedisTemplate.opsForValue()</span><br><span class="line">            .setIfAbsent(KEY_PREFIX + name, threadId + <span class="string">&quot;&quot;</span>, timeoutSec, TimeUnit.SECONDS);</span><br><span class="line">    <span class="keyword">return</span> Boolean.TRUE.equals(success);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//通过del删除锁</span></span><br><span class="line">    stringRedisTemplate.delete(KEY_PREFIX + name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="直接删除锁时可能导致误删问题"><a href="#直接删除锁时可能导致误删问题" class="headerlink" title="直接删除锁时可能导致误删问题"></a>直接删除锁时可能导致误删问题</h5><p>释放锁时，如果直接将锁删除，又会出现新的问题： <strong>持有锁的线程1</strong>在锁的内部出现了阻塞等情况，导致他的<strong>锁过期自动释放</strong>。这时<strong>线程2来尝试获得锁，就拿到了这把锁</strong>。然后线程2在持有锁执行过程中，<strong>线程1</strong>反应过来，<strong>继续执行</strong>，在任务完成后依然会尝试释放锁,因为它的代码逻辑规定它在任务结束后释放锁,但是它的锁早已经被释放了,此时就会<strong>把本应该属于线程2的锁进行删除</strong>。<br>解决方案：我们可以在加锁时为key的值赋一个随机且不重复的字符串,作为锁的<strong>标识</strong>，线程要记住这个标识（线程号？存在threadLocal中？）。在每个线程释放锁的时候，去判断一下当前这把锁是否属于自己，如果不属于自己，则不进行锁的删除。</p><p>具体实现代码如下，用UUID与线程id拼接作为锁的标识：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ID_PREFIX</span> <span class="operator">=</span> UUID.randomUUID().toString(<span class="literal">true</span>) + <span class="string">&quot;-&quot;</span>;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> timeoutSec)</span> &#123;</span><br><span class="line">   <span class="comment">// 获取线程标示</span></span><br><span class="line">   <span class="type">String</span> <span class="variable">threadId</span> <span class="operator">=</span> ID_PREFIX + Thread.currentThread().getId();</span><br><span class="line">   <span class="comment">// 获取锁</span></span><br><span class="line">   <span class="type">Boolean</span> <span class="variable">success</span> <span class="operator">=</span> stringRedisTemplate.opsForValue()</span><br><span class="line">                .setIfAbsent(KEY_PREFIX + name, threadId, timeoutSec, TimeUnit.SECONDS);</span><br><span class="line">   <span class="keyword">return</span> Boolean.TRUE.equals(success);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 获取线程标示</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">threadId</span> <span class="operator">=</span> ID_PREFIX + Thread.currentThread().getId();</span><br><span class="line">    <span class="comment">// 获取锁中的标示</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(KEY_PREFIX + name);</span><br><span class="line">    <span class="comment">// 判断标示是否一致</span></span><br><span class="line">    <span class="keyword">if</span>(threadId.equals(id)) &#123;</span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">        stringRedisTemplate.delete(KEY_PREFIX + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="锁的判断与删除的原子性问题"><a href="#锁的判断与删除的原子性问题" class="headerlink" title="锁的判断与删除的原子性问题"></a>锁的判断与删除的原子性问题</h5><p>如果锁的<strong>判断与释放</strong>这两步不是<strong>原子</strong>的，仍会导致误删。<br>例如：线程1现在持有锁之后，在执行业务逻辑过程中，他正准备删除锁，而且已经走到了条件判断的过程中，比如他已经拿到了当前这把<strong>锁确实是属于他自己的，正准备删除锁，但是此时他的锁到期了（或删除失败）</strong>。此时线程2进来并获得了锁，而线程1会接着往后执行，直接就会执行删除锁那行代码，相当于条件判断并没有起到作用。<br>要防止上述情况发生,就需要采用Lua脚本,<strong>通过Lua脚本将两个命令编排在一起,而整个Lua脚本的执行是原子的</strong>。<br>Redis提供的调用函数，语法如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis.call(<span class="string">&#x27;命令名称&#x27;</span>, <span class="string">&#x27;key&#x27;</span>, <span class="string">&#x27;其它参数&#x27;</span>, ...)</span><br></pre></td></tr></table></figure><p>实现判断并删除锁的lua脚本如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 这里的 KEYS[1] 就是锁的key，这里的ARGV[1] 就是当前线程标示</span></span><br><span class="line"><span class="comment">-- 获取锁中的标示，判断是否与当前线程标示一致</span></span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;GET&#x27;</span>, KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>]) <span class="keyword">then</span></span><br><span class="line">  <span class="comment">-- 一致，则删除锁</span></span><br><span class="line">  <span class="keyword">return</span> redis.call(<span class="string">&#x27;DEL&#x27;</span>, KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 不一致，则直接返回</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p>java调用lua脚本实现锁的释放的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DefaultRedisScript&lt;Long&gt; UNLOCK_SCRIPT;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        UNLOCK_SCRIPT = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;();</span><br><span class="line">        UNLOCK_SCRIPT.setLocation(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;unlock.lua&quot;</span>));</span><br><span class="line">        UNLOCK_SCRIPT.setResultType(Long.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 调用lua脚本</span></span><br><span class="line">    stringRedisTemplate.execute(</span><br><span class="line">            UNLOCK_SCRIPT,</span><br><span class="line">            Collections.singletonList(KEY_PREFIX + name),</span><br><span class="line">            ID_PREFIX + Thread.currentThread().getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>基于Redis的分布式锁实现思路：</p><ul><li>利用set nx ex获取锁，并设置过期时间，保存线程标示</li><li>释放锁时先判断线程标示是否与自己一致，一致则删除锁</li><li>基于lua脚本，保证锁的判断与删除是原子的</li><li>特性：<ul><li>利用set nx满足互斥性</li><li>利用set ex保证故障时锁依然能释放，避免死锁，提高安全性</li><li>利用Redis集群保证高可用和高并发特性</li></ul></li></ul><h5 id="存在的问题（了解）"><a href="#存在的问题（了解）" class="headerlink" title="存在的问题（了解）"></a>存在的问题（了解）</h5><p>基于setnx实现的分布式锁存在下面的问题：</p><p><strong>重入问题</strong>：重入问题是指 获得锁的线程可以再次进入到相同的锁的代码块中，可重入锁的意义在于防止死锁，比如HashTable这样的代码中，他的方法都是使用synchronized修饰的，假如他在一个方法内，调用另一个方法，那么此时如果是不可重入的，不就死锁了吗？所以可重入锁他的主要意义是防止死锁，我们的synchronized和Lock锁都是可重入的。</p><p><strong>不可重试</strong>：是指目前的分布式只能尝试一次，我们认为合理的情况是：当线程在获得锁失败后，他应该能再次尝试获得锁。</p><p><strong>超时释放：</strong>我们在加锁时增加了过期时间，这样的我们可以防止死锁，但是如果卡顿的时间超长，虽然我们采用了lua表达式防止删锁的时候，误删别人的锁，但是毕竟没有锁住，有安全隐患</p><p><strong>主从一致性：</strong> 如果Redis提供了主从集群，当我们向集群写数据时，主机需要异步的将数据同步给从机，而万一在同步过去之前，主机宕机了，就会出现死锁问题。</p><p>解决：RedLock（Redisson）</p><p>RedLock算法思想，意思是不能只在一个redis实例上创建锁，应该是在多个redis实例上创建锁，<strong>n &#x2F; 2 + 1</strong>，必须在大多数redis节点上都成功创建锁，才能算这个整体的RedLock加锁成功</p><h5 id="Redisson分布式锁"><a href="#Redisson分布式锁" class="headerlink" title="Redisson分布式锁"></a>Redisson分布式锁</h5><p>在分布式锁中，他采用hash结构用来存储锁，其中大key表示表示这把锁是否存在，用小key表示当前这把锁被哪个线程持有。</p><p>lua脚本中一共有3个参数：</p><ul><li><p><strong>KEYS[1] ： 锁名称</strong></p></li><li><p><strong>ARGV[1]：  锁失效时间</strong></p></li><li><p><strong>ARGV[2]：  id + “:” + threadId; 锁的小key</strong></p></li></ul><p>源码中判断当前这个方法的返回值是否为null，如果是null，则对应则前两个if对应的条件，退出抢锁逻辑，如果返回的不是null，即走了第三个分支，在源码处会进行while(true)的自旋抢锁。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 锁是否存在，== <span class="number">0</span> 表示不存在</span><br><span class="line"><span class="string">&quot;if (redis.call(&#x27;exists&#x27;, KEYS[1]) == 0) then &quot;</span> +</span><br><span class="line">// hash中写入 id + <span class="string">&quot;:&quot;</span> + threadId :  <span class="number">1</span></span><br><span class="line"><span class="string">&quot;redis.call(&#x27;hset&#x27;, KEYS[1], ARGV[2], 1); &quot;</span> +</span><br><span class="line">// 设置锁的过期时间</span><br><span class="line"><span class="string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;</span> +</span><br><span class="line"><span class="string">&quot;return nil; &quot;</span> +</span><br><span class="line"><span class="string">&quot;end; &quot;</span> +</span><br><span class="line">// 锁存在，判断锁是否是自己的</span><br><span class="line"><span class="string">&quot;if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[2]) == 1) then &quot;</span> +</span><br><span class="line">// 如果是，则将计数值 + <span class="number">1</span></span><br><span class="line"><span class="string">&quot;redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[2], 1); &quot;</span> +</span><br><span class="line">// 设置过期时间</span><br><span class="line"><span class="string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;</span> +</span><br><span class="line"><span class="string">&quot;return nil; &quot;</span> +</span><br><span class="line"><span class="string">&quot;end; &quot;</span> +</span><br><span class="line">// 加锁失败，返回锁的过期时间</span><br><span class="line"><span class="string">&quot;return redis.call(&#x27;pttl&#x27;, KEYS[1]);&quot;</span></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/08/02/5faFUR6Wtpod1yD.png" alt="Redisson分布式锁"></p><p><strong>watch dog自动延期机制</strong></p><p>客户端1加锁的锁key默认生存时间才30秒，如果超过了30秒，客户端1还想一直持有这把锁，怎么办呢？</p><p>简单！只要客户端1一旦加锁成功，就会启动一个watch dog看门狗，**他是一个后台线程，会每隔**10秒**检查一下**，如果客户端1还持有锁key（计数值&gt;0），那么就会重置锁key的过期时间。</p><p><strong>MultiLock</strong></p><p>为了提高redis的可用性，我们会搭建集群或者主从，现在以主从为例</p><p>此时我们去写命令，写在主机上， 主机会将数据同步给从机，但是假设在主机还没有来得及把数据写入到从机去的时候，此时主机宕机，哨兵会发现主机宕机，并且选举一个slave变成master，而此时新的master中实际上并没有锁信息，此时锁信息就已经丢掉了。</p><p>为了解决这个问题，redission提出来了MutiLock锁，使用这把锁咱们就不使用主从了，每个节点的地位都是一样的， 这把锁加锁的逻辑需要写入到每一个主丛节点上，只有所有的服务器都写入成功，此时才是加锁成功，假设现在某个节点挂了，那么他去获得锁的时候，只要有一个节点拿不到，都不能算是加锁成功，就保证了加锁的可靠性。</p><h3 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h3><p>Redis 提供了基于“发布&#x2F;订阅”模式的消息机制，此种模式下，消息发布者和订阅者不进行直接通信，发布者客户端向指定的频道（channel）发布消 息，订阅该频道的每个客户端都可以收到该消息。</p><p>主要对应的 Redis 命令为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">subscribe channel [channel ...] # 订阅一个或多个频道</span><br><span class="line">unsubscribe channel # 退订指定频道</span><br><span class="line">publish channel message # 发送消息</span><br><span class="line">psubscribe pattern # 订阅指定模式</span><br><span class="line">punsubscribe pattern # 退订指定模式</span><br></pre></td></tr></table></figure><p>使用案例：</p><p>打开一个 Redis 客户端，如向 TestChanne 说一声 hello:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; publish TestChanne hello</span><br><span class="line">(integer) 1 # 返回的是接收这条消息的订阅者数量</span><br></pre></td></tr></table></figure><p>这样消息就发出去了。发出去的消息不会被持久化，也就是有客户端订阅 TestChanne 后只能接收到后续发布到该频道的消息，之前的就接收不到了。</p><p>打开另一 Redis 个客户端，这里假设发送消息之前就打开并且订阅了 TestChanne 频道：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; subscribe TestChanne # 执行上面命令客户端会进入订阅状态</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) &quot;subscribe&quot; // 消息类型</span><br><span class="line">2) &quot;TestChanne&quot; // 频道</span><br><span class="line">3) &quot;hello&quot; // 消息内容</span><br></pre></td></tr></table></figure><p>我们可以利用 Redis 发布订阅功能，实现的简单 MQ 功能，实现上下游的解耦。不过需要注意了，由于 Redis 发布的消息<strong>不会被持久化</strong>，这就会导致新订阅的客户端将不会收到历史消息。所以，如果当前的业务场景不能容忍这些缺点，那还是用专业 MQ 吧。</p><p>优势</p><ul><li><p>消息具备广播能力</p></li><li><p>psubscribe能按字符串通配符匹配，给予了业务逻辑的灵活性</p></li><li><p>能订阅特定key或特定命令的系统消息</p></li></ul><p>不足</p><ul><li><p>Redis异常、客户端断连都会导致消息丢失</p></li><li><p>消息缺乏堆积能力，不能削峰填谷。推送的方式缺乏背压机制，没有考虑消费者处理能力，推送的消息超过消费者处理能力后可能导致消息丢失或服务异常</p></li></ul><p>可见，Pub&#x2F;Sub 模式不适合做消息存储，消息积压类的业务，而是擅长处理广播，即时通讯，即时反馈的业务。</p><h3 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h3><p><a href="https://blog.csdn.net/qq_45076180/article/details/109532216">https://blog.csdn.net/qq_45076180/article/details/109532216</a></p><h4 id="主从"><a href="#主从" class="headerlink" title="主从"></a>主从</h4><h4 id="哨兵"><a href="#哨兵" class="headerlink" title="哨兵"></a>哨兵</h4><h4 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h4><h3 id="Caffeine"><a href="#Caffeine" class="headerlink" title="Caffeine"></a>Caffeine</h3><p>本地缓存基于本地环境的内存，访问速度非常快，对于一些变更频率低、实时性要求低的数据，可以放在本地缓存中，提升访问速度<br>使用本地缓存能够减少和Redis类的远程缓存间的数据交互，减少网络I&#x2F;O开销，降低这一过程中在网络通信上的耗时</p><p><a href="https://zhuanlan.zhihu.com/p/348695568">https://zhuanlan.zhihu.com/p/348695568</a></p><p>优点：性能非常高</p><p>缺点：服务器内存有限，不能存大量数据；集群部署需要考虑本地缓存一致性问题</p><h4 id="淘汰算法"><a href="#淘汰算法" class="headerlink" title="淘汰算法"></a>淘汰算法</h4><h5 id="常见算法"><a href="#常见算法" class="headerlink" title="常见算法"></a>常见算法</h5><p><strong>FIFO(First In First Out)：先进先出。</strong></p><p>它是优先淘汰掉最先缓存的数据、是最简单的淘汰算法。缺点是如果先缓存的数据使用频率比较高的话，那么该数据就不停地进进出出，因此它的缓存命中率比较低。</p><p><strong>LRU(Least Recently Used)：最近最久未使用。</strong></p><p>它是优先淘汰掉最久未访问到的数据。缺点是不能很好地应对偶然的突发流量。比如一个数据在一分钟内的前59秒访问很多次，而在最后1秒没有访问，但是有一批冷门数据在最后一秒进入缓存，那么热点数据就会被冲刷掉。</p><p><strong>LFU(Least Frequently Used)：</strong></p><p>最近最少频率使用。它是优先淘汰掉最不经常使用的数据，需要维护一个表示使用频率的字段。</p><p>主要有两个缺点：</p><p>一、如果访问频率比较高的话，频率字段会占据一定的空间；</p><p>二、无法合理更新新上的热点数据，比如某个歌手的老歌播放历史较多，新出的歌如果和老歌一起排序的话，就永无出头之日。</p><p><strong>W-TinyLFU 算法</strong></p><p>Caffeine 使用了 W-TinyLFU 算法，解决了 LRU 和LFU上述的缺点。W-TinyLFU 算法由论文《TinyLFU: A Highly Efficient Cache Admission Policy》提出。</p><p>它主要干了两件事：</p><p>一、采用 Count–Min Sketch 算法降低频率信息带来的内存消耗；</p><p>二、维护一个PK机制保障新上的热点数据能够缓存。</p><h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>消息队列是一个存放消息的容器，用于在不同的应用程序之间传递消息。生产者将消息放到队列中，消费者按顺序从队列中取出消息进行处理。</p><p>消息队列选型：<a href="https://mp.weixin.qq.com/s/WuIjtx1PjICG4gFZE5X6-g">https://mp.weixin.qq.com/s/WuIjtx1PjICG4gFZE5X6-g</a></p><p><img src="https://s2.loli.net/2023/08/21/TNEQW9qYusPfeo1.png" alt="消息队列对比"></p><p>注：RocketMQ可以做到消息0丢失，kafka可以做到最小概率丢失</p><p>Kafka 一开始的目的就是用于日志收集和传输，适合有大量数据产生的互联网业务，特别是<strong>大数据领域的实时计算、日志采集</strong>等场景，用 Kafka 绝对没错，社区活跃度高，业内标准。</p><p>RocketMQ 特别适用于金融互联网领域这类对于可靠性要求很高的场景，比如订单交易等，而且 RocketMQ 是阿里出品的，经历过那么多次淘宝双十一的考验，大品牌，在稳定性值得信赖。目前社区也比RabbitMQ活跃。因此如果公司对自己的技术实力有自信，基础架构研发实力较强，推荐用 RocketMQ。</p><p>RabbitMQ 适用于公司对外提供能力，可能会有很多主题接入的中台业务场景，毕竟它是百万级主题数的。它的时效性是毫秒级的，但实际毫秒级和微秒级在感知上没有什么太大的区别，所以它的这一大优点并不太会作为考量标准。同时，它的功能是比较完善的，开源社区活跃度高（目前低于RocketMQ），能解决开发中遇到的bug，所以万级别数据量业务场景的小公司可以优先选择功能完善的RabbitMQ。它的缺点就是用 Erlang 语言编写，所以很多开发人员很难去看懂源码并进行二次开发和维护，也就是说对于公司来说可能处于不可控的状态。</p><h3 id="消息队列作用"><a href="#消息队列作用" class="headerlink" title="消息队列作用"></a>消息队列作用</h3><ul><li><p>解耦</p><p>传统的软件开发模式，各个模块之间相互调用，每个模块都要时刻关注所调用的模块的是否更改或者是否执行成功等等。使用消息队列，可以避免模块之间直接调用，将所需共享的数据放在消息队列中，消息接受者对消息进行处理或包装后，构造成一个新的消息类型，将消息继续发送出去。对于新增业务模块，只要对该类消息感兴趣，即可订阅该类消息，对原有系统和业务没有任何影响，降低了系统各个模块的耦合度，提高了系统的可扩展性。</p></li><li><p>异步</p><p>很多时候应用不想或不需要立即处理消息，就可以将用户的请求数据存储到消息队列之后就立即返回结果，从而降低系统响应时间。随后，系统再慢慢对消息进行消费。</p><ul><li><p>不用MQ怎么实现异步？</p><ul><li>直接创建一个新线程去执行异步任务</li><li>提交任务到线程池</li><li>复杂一点可以用CompletableFuture结合线程池</li></ul><p>优点：实现简单，不需要考虑消息丢失、重复消费等问题。MQ需要引入消息中间件，增加了系统的复杂度和维护成本</p></li><li><p>MQ异步与多线程异步有何区别？</p><ul><li>处理任务的维度不同。多线程是在一个进程中可以有多个线程并发处理任务，MQ是把消息发送到不同节点的不同进程来处理任务。</li><li>数据可靠性不同。多线程数据基于内存来交互，消息队列可以将消息持久化。</li><li>分布式能力。MQ具备分布式能力，多线程只能在一个进程中去处理任务。</li></ul></li><li><p>另一种实现：Spring事件监听ApplicationEventPublisher</p><p>缺点：</p><ol><li>有限的可靠性：<code>ApplicationEventPublisher</code> 是在应用程序内部实现的，因此它依赖于应用程序的运行状态。如果应用程序崩溃或重启，那些未被处理的事件可能会丢失。与消息队列相比，消息队列通常具有持久化和可靠性保证，可以在应用程序故障后保留未处理的消息。</li><li>性能开销：尽管 <code>ApplicationEventPublisher</code> 是应用程序内部的实现，但它仍然需要遍历所有的事件监听器并调用它们的处理方法。如果事件监听器过多或处理逻辑复杂，可能会导致性能开销。</li><li>难以追踪和调试：由于事件的传播过程是通过接口和抽象类型进行定义的，它们的调用和处理过程可能比较难以跟踪和调试。相比之下，使用消息队列可以更容易地追踪和监控消息的传递和处理过程。</li></ol></li></ul></li><li><p>削峰</p><p>先将短时间产生的大量消息存储在消息队列中，然后后端服务再慢慢根据自己的能力去消费这些消息。高峰期的消息可以被积压起来，在随后的时间内进行平滑的处理完成，而不至于让系统短时间内无法承载而导致崩溃。常见场景：秒杀</p></li></ul><h3 id="使用消息队列会带来哪些问题？"><a href="#使用消息队列会带来哪些问题？" class="headerlink" title="使用消息队列会带来哪些问题？"></a>使用消息队列会带来哪些问题？</h3><ul><li><strong>系统可用性降低：</strong>消息丢失、重复消费、消费失败等</li><li><strong>系统复杂性提高：</strong> 加入 MQ 之后，你需要保证消息没有被重复消费、处理消息丢失的情况、保证消息传递的顺序性等</li><li><strong>一致性问题：</strong> 消息没有被正确消费导致数据不一致的情况</li></ul><h3 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h3><h4 id="发布-订阅模型-Kafka-消息模型"><a href="#发布-订阅模型-Kafka-消息模型" class="headerlink" title="发布-订阅模型:Kafka 消息模型"></a>发布-订阅模型:Kafka 消息模型</h4><p>队列模型<strong>使用队列（Queue）作为消息通信载体，满足生产者与消费者模式，一条消息只能被一个消费者使用，未被消费的消息在队列中保留直到被消费或超时。</strong> 比如：我们生产者发送 100 条消息的话，两个消费者来消费一般情况下两个消费者会按照消息发送的顺序各自消费一半（也就是你一个我一个的消费。）</p><p>发布-订阅模型主要是为了解决队列模型存在的问题，即单个消息分发给多个消费者处理。</p><p>发布订阅模型（Pub-Sub） 使用<strong>主题（Topic）</strong> 作为消息通信载体，类似于<strong>广播模式</strong>；发布者发布一条消息，该消息通过主题传递给所有的订阅者，<strong>在一条消息广播之后才订阅的用户则是收不到该条消息的</strong>。</p><p><strong>在发布 - 订阅模型中，如果只有一个订阅者，那它和队列模型就基本是一样的了。所以说，发布 - 订阅模型在功能层面上是可以兼容队列模型的。</strong></p><h4 id="为什么选择Kafka？"><a href="#为什么选择Kafka？" class="headerlink" title="为什么选择Kafka？"></a>为什么选择Kafka？</h4><p>这里就需要先了解Kakfa的特性。</p><ul><li>高吞吐、低延迟：kakfa 最大的特点就是收发消息非常快，kafka 每秒可以处理几十万条消息，它的最低延迟只有几毫秒（批量收发，其实时延相对高）。</li><li>伸缩性：每个主题(topic) 包含多个分区(partition)，主题中的分区可以分布在不同的主机(broker)中。</li><li>持久性、可靠性：Kafka能够允许数据的持久化存储，消息被持久化到磁盘，并支持数据备份防止数据丢失，Kafka底层的数据存储是基于Zookeeper存储的，Zookeeper我们知道它的数据能够持久存储。</li><li>容错性：允许集群中的节点失败，某个节点宕机，Kafka集群能够正常工作。</li><li>高并发：支持数千个客户端同时读写。</li></ul><p>吞吐量高，生态兼容性很好，可以方便地与其他大数据组件集成，如 Hadoop、Spark，在日志采集、大数据实时计算方面应用广泛，大数据领域的标准。但是功能相对少。</p><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a><strong>缺点</strong></h5><p><strong>分区有序</strong>：仅在同一分区内保证有序，无法实现全局有序；</p><p><strong>无延时消息</strong>：消费顺序是按照写入时的顺序，不支持延时消息</p><p><strong>重复消费</strong>：消费系统宕机、重启导致 offset 未提交；</p><p><strong>Rebalance</strong>：Rebalance 的过程中 consumer group 下的所有消费者实例都会停止工作，等待 Rebalance 过程完成。</p><p>topic数量不能太大：<a href="https://mp.weixin.qq.com/s/1BOriPt5j4UvwIZ3Qs8F9A%EF%BC%88%E8%B7%9F%E9%A1%BA%E5%BA%8F%E5%86%99%E7%9B%98%E6%9C%89%E5%85%B3%EF%BC%89">https://mp.weixin.qq.com/s/1BOriPt5j4UvwIZ3Qs8F9A（跟顺序写盘有关）</a></p><h5 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a><strong>使用场景</strong></h5><p><strong>日志收集</strong>：大量的日志消息先写入 kafka，数据服务通过消费 kafka 消息将数据落地；</p><p><strong>消息系统</strong>：解耦生产者和消费者、缓存消息等；</p><p><strong>用户活动跟踪</strong>：kafka 经常被用来记录 web 用户或者 app 用户的各种活动，如浏览网页、搜索、点击等活动，这些活动信息被各个服务器发布到 kafka 的 topic 中，然后消费者通过订阅这些 topic 来做实时的监控分析，亦可保存到数据库；</p><p><strong>运营指标</strong>：记录运营、监控数据，包括收集各种分布式应用的数据，生产各种操作的集中反馈，比如报警和报告；</p><p><strong>流式处理</strong>、大数据实时计算：比如 spark streaming。</p><h4 id="Kafka为什么这么快？"><a href="#Kafka为什么这么快？" class="headerlink" title="Kafka为什么这么快？"></a>Kafka为什么这么快？</h4><p>Kafka 高可靠高性能原理探究<a href="https://mp.weixin.qq.com/s/_g11mmmQse6KrkUE8x4abQ">https://mp.weixin.qq.com/s/_g11mmmQse6KrkUE8x4abQ</a></p><ol><li><p>Kafka通过<strong>零拷贝</strong>原理来快速移动数据（零拷贝并不是不需要拷贝，而是减少不必要的拷贝次数）。</p><ul><li><p>网络数据持久化到磁盘 (Producer 到 Broker)</p><p>通过<strong>mmap</strong>（Memory Mapped Files） 将内核中读缓冲区（read buffer）的地址与用户空间的缓冲区（user buffer）进行映射，从而实现内核缓冲区与应用程序内存的共享，<strong>省去了将数据从内核读缓冲区（read buffer）拷贝到用户缓冲区（user buffer）的过程</strong></p></li><li><p>磁盘文件通过网络发送（Broker 到 Consumer）</p><p>Kafka 在 Consumer 从 Broker 读数据过程中使用了 sendfile 技术。具体在这里采用的方案是通过 NIO 的 <code>transferTo/transferFrom</code> 调用操作系统的 sendfile 实现零拷贝，消除了 CPU 数据拷贝。</p></li></ul></li><li><p>Kafka 支持<strong>批量发送消息</strong>，将多个消息打包成一个批次进行发送，从而减少网络传输的开销，提高网络传输的效率和吞吐量。Kafka 的批量发送消息是通过以下两个参数来控制的：</p><ul><li><p>batch.size：控制批量发送消息的大小，默认值为 16KB，可适当增加 batch.size 参数值提升吞吐。但是，需要注意的是，<strong>如果批量发送的大小设置得过大，可能会导致消息发送的延迟增加，因此需要根据实际情况进行调整</strong>。</p></li><li><p>linger.ms：控制消息在批量发送前的等待时间，默认值为 0。当 linger.ms 大于 0 时，如果有消息发送，Kafka 会等待指定的时间，如果等待时间到达或者批量大小达到 batch.size，就会将消息打包成一个批次进行发送。可适当增加 linger.ms 参数值提升吞吐，比如 10 ～ 100。</p></li></ul><p>在 Kafka 的生产者客户端中，当发送消息时，如果启用了批量发送，Kafka 会将消息缓存到缓冲区中。当缓冲区中的消息大小达到 batch.size 或者等待时间到达 linger.ms 时，Kafka 会将缓冲区中的消息打包成一个批次进行发送。如果在等待时间内没有达到 batch.size，Kafka 也会将缓冲区中的消息发送出去，从而避免消息积压。</p></li><li><p>Kafka采取<strong>顺序写入磁盘</strong>的方式，避免了随机磁盘寻址的浪费（寻址开销小）。</p><p>kafka 为了提升系统吞吐、降低时延，Broker 接收到消息后只是将数据写入<strong>PageCache</strong>后便认为消息已写入成功，而 PageCache 中的数据通过 linux 的 flusher 程序进行异步刷盘（避免了同步刷盘的巨大系统开销），将数据<strong>顺序追加写</strong>到磁盘日志文件中。由于 pagecache 是在内存中进行缓存，因此读写速度非常快，可以大大提高读写效率。顺序追加写充分利用顺序 I&#x2F;O 写操作，避免了缓慢的随机 I&#x2F;O 操作，可有效提升 Kafka 吞吐。</p></li><li><p>Kafka 支持<strong>压缩</strong>技术，通过将消息进行压缩后再进行传输，从而减少网络传输的开销（压缩和解压缩的过程会消耗一定的 CPU 资源，因此需要根据实际情况进行调整）。</p></li></ol><h4 id="什么是-Producer、Consumer、Broker、Topic、Partition？"><a href="#什么是-Producer、Consumer、Broker、Topic、Partition？" class="headerlink" title="什么是 Producer、Consumer、Broker、Topic、Partition？"></a>什么是 Producer、Consumer、Broker、Topic、Partition？</h4><p>Kafka 将生产者发布的消息发送到 <strong>Topic（主题）</strong> 中，需要这些消息的消费者可以订阅这些 <strong>Topic（主题）</strong>，如下图所示：</p><p><img src="https://s2.loli.net/2023/07/06/iU1FVNEksKjpo6Y.png" alt="img"></p><p>上面这张图也为我们引出了，Kafka 比较重要的几个概念：</p><ol><li><strong>Producer（生产者）</strong> : 生产者，负责消息的创建并通过一定的路由策略发送消息到合适的 Broker；</li><li><strong>Consumer（消费者）</strong> : 消费者，负责从 Broker 中拉取（Pull）订阅的消息并进行消费，通常多个消费者构成一个分组，消息只能被同组中的一个消费者消费；</li><li><strong>Broker（代理）</strong> : 可以看作是一个独立的 Kafka 实例，负责消息的持久化、中转等功能。多个 Kafka Broker 组成一个 Kafka Cluster。</li><li><strong>ZooKeeper</strong>：ZooKeeper 是一个分布式的协调服务，可以用于解决分布式系统中的一些常见问题，例如协调分布式进程、配置管理。负责 broker、consumer 集群元数据的管理等；（<strong>注意：Producer 端直接连接 broker，不在 zk 上存任何数据，只是通过 ZK 监听 broker 和 topic 等信息</strong></li></ol><p>同时，你一定也注意到每个 Broker 中又包含了 Topic 以及 Partition 这两个重要的概念：</p><ul><li><strong>Topic（主题）</strong> : Kafka 按 topic 对消息进行分类，Producer 将消息发送到特定的主题，Consumer 通过订阅特定的 Topic(主题) 来消费消息。</li><li><strong>Partition（分区）</strong> : Partition 属于 Topic 的一部分。一个 Topic 可以有多个 Partition ，并且同一 Topic 下的 Partition 可以分布在不同的 Broker 上，这也就表明一个 Topic 可以横跨多个 Broker 。</li></ul><blockquote><p>划重点：<strong>Kafka 中的 Partition（分区） 实际上可以对应成为消息队列中的队列。每个分区都是一个日志文件，消息以只追加的方式写入其中。⼀个分区只能被⼀个消费组下⾯的⼀个消费者消费（不同消费者组可以消费同一个topic的所有消息）。通常情况下，在一个 Kafka 集群中，<code>partition</code>的数量越多，意味着可以到达的吞吐量越大</strong>。</p><p>分区数配置：server.properties配置文件 num.partitions</p></blockquote><ul><li><strong>segment</strong>：分段。宏观上看，一个 partition 对应一个日志（Log）。由于生产者生产的消息会不断<strong>追加到 log 文件末尾</strong>，为防止 log 文件过大导致数据检索效率低下，<strong>Kafka 采取了分段和索引机制，将每个 partition 分为多个 segment，同时也便于消息的维护和清理</strong>。每个 segment 包含一个.log 日志文件、两个索引(.index、timeindex)文件以及其他可能的文件。每个 Segment 的数据文件以该段中最小的 offset 为文件名，当查找 offset 的 Message 的时候，通过二分查找快找到 Message 所处于的 Segment 中。</li><li><strong>offset</strong>：消息在日志中的位置，消息在被追加到分区日志文件的时候都会分配一个特定的偏移量。Kafka 服务器会将偏移量保存在内部的 __consumer_offsets 主题中。offset 是消息在分区中的唯一标识，是一个单调递增且不变的值。Kafka 通过它来保证消息在分区内的顺序性，不过 offset 并不跨越分区，也就是说，<strong>Kafka 保证的是分区有序而不是主题有序</strong>。<ol><li>自动提交：消费者可以通过设置 enable.auto.commit 参数为 true 来启用自动提交偏移量功能。当消费者消费完一批消息后，会自动将偏移量提交到 Kafka 服务器中。自动提交偏移量的缺点是可能会出现消息<strong>重复消费或漏消费</strong>的情况。</li><li>手动提交：消费者可以通过调用 commitSync() 或 commitAsync() 方法手动提交偏移量。手动提交偏移量的优点是可以控制偏移量的提交时机，避免出现消息重复消费或漏消费的情况。</li></ol></li></ul><h4 id="Kafka-的多副本机制了解吗？带来了什么好处？"><a href="#Kafka-的多副本机制了解吗？带来了什么好处？" class="headerlink" title="Kafka 的多副本机制了解吗？带来了什么好处？"></a>Kafka 的多副本机制了解吗？带来了什么好处？</h4><p>Kafka 为分区（Partition）引入了多副本（Replica）机制。分区（Partition）中的多个副本之间会有一个叫做 leader 的家伙，其他副本称为 follower。我们发送的消息会被发送到 leader 副本，然后 follower 副本才能从 leader 副本中拉取消息进行同步。</p><blockquote><p>生产者和消费者只与 leader 副本交互。你可以理解为其他副本只是 leader 副本的拷贝，它们的存在只是为了保证消息存储的安全性。当 leader 副本发生故障时会从 follower 中选举出一个 leader,但是 follower 中如果有和 leader 同步程度达不到要求的参加不了 leader 的竞选。</p></blockquote><p><strong>Kafka 的多分区（Partition）以及多副本（Replica）机制有什么好处呢？</strong></p><ol><li>Kafka 通过给特定 Topic 指定多个 Partition, 而各个 Partition 可以分布在不同的 Broker 上, 这样便能提供比较好的并发能力（负载均衡）。</li><li>Partition 可以指定对应的 Replica 数, 这也极大地提高了消息存储的安全性, 提高了容灾能力，不过也相应的增加了所需要的存储空间。</li></ol><p>注：分区可以增加，但不能减少。Kafka 分区增加后，Kafka 集群会立即重新平衡，使 Kafka 的消费者组(consumer group)重新分配消费者(consumer)的分区(partition)，但原来分区已有的消息是不会拆分迁移的。</p><h4 id="Kafka-如何保证消息的消费顺序？"><a href="#Kafka-如何保证消息的消费顺序？" class="headerlink" title="Kafka 如何保证消息的消费顺序？"></a>Kafka 如何保证消息的消费顺序？</h4><p>我们在使用消息队列的过程中经常有业务场景需要严格保证消息的消费顺序，比如我们同时发了 2 个消息，这 2 个消息对应的操作分别对应的数据库操作是：</p><ol><li>更改用户会员等级。</li><li>根据会员等级计算订单价格。</li></ol><p>假如这两条消息的消费顺序不一样造成的最终结果就会截然不同。</p><p>我们知道 Kafka 中 Partition(分区)是真正保存消息的地方，我们发送的消息都被放在了这里。而我们的 Partition(分区) 又存在于 Topic(主题) 这个概念中，并且我们可以给特定 Topic 指定多个 Partition。</p><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/KafkaTopicPartionsLayout.png" alt="img"></p><p>每次添加消息到 Partition(分区) 的时候都会采用尾加法，如上图所示。 <strong>Kafka 只能为我们保证 Partition(分区) 中的消息有序。</strong></p><blockquote><p>消息在被追加到 Partition(分区)的时候都会分配一个特定的偏移量（offset）。Kafka 通过偏移量（offset）来保证消息在分区内的顺序性。</p></blockquote><p>Kafka 中发送 1 条消息的时候，可以指定 topic, partition, key,data（数据） 4 个参数。如果你发送消息的时候指定了 Partition 的话，所有消息都会被发送到指定的 Partition。并且，<strong>同一个 key 的消息可以保证只发送到同一个 partition（通过hash）</strong>，这个我们可以采用表&#x2F;对象的 id 来作为 key 。</p><ul><li><strong>如果 key 不为 null</strong>：对 Key 值进行 Hash 计算，从<strong>所有分区</strong>中根据 Key 的 Hash 值计算出一个分区号；拥有相同 Key 值的消息被写入同一个分区，<strong>顺序消息实现的关键</strong>；</li><li><strong>如果 key 为 null</strong>：消息将以<strong>轮询</strong>的方式，在<strong>所有可用分区</strong>中分别写入消息。如果不想使用 Kafka 默认的分区器，用户可以实现 Partitioner 接口，自行实现分区方法。</li></ul><p>总结一下，对于如何保证 Kafka 中消息消费的顺序，有了下面两种方法：</p><ol><li><strong>1 个 Topic 只对应一个 Partition（并发性能差）。</strong></li><li><strong>（推荐）发送消息的时候指定 key&#x2F;Partition。</strong></li></ol><p>当然不仅仅只有上面两种方法，上面两种方法是我觉得比较好理解的，</p><p>对于 Kafka 来说，一个 topic 下同一个 partition 中的消息肯定是有序的，生产者在写的时候可以指定一个 key，通过我们会用订单号作为 key，这个 key 对应的消息都会发送到同一个 partition 中，所以消费者消费到的消息也一定是有序的。</p><p>那么为什么 Kafka 还会存在消息错乱的问题呢？问题就出在消费者身上。通常我们消费到同一个 key 的多条消息后，会使用多线程技术去并发处理来提高消息处理速度，否则一条消息的处理需要耗时几十 毫秒，1 秒也就只能处理几十条消息，吞吐量就太低了。而多线程并发处理的话，binlog 执行到数据库的时候就不一定还是原来的顺序了。</p><p>Kafka 从生产者到消费者消费消息这一整个过程其实都是可以保证有序的，<strong>导致最终乱序是由于消费者端需要使用多线程并发处理消息来提高吞吐量</strong>，比如消费者消费到了消息以后，开启 32 个线程处理消息，每个线程线程处理消息的快慢是不一致的，所以才会导致最终消息有可能不一致。</p><p>所以对于 Kafka 的消息顺序性保证，其实我们只需要保证同一个订单号的消息只被同一个线程处理的就可以了。由此我们可以在线程处理前增加个内存队列，每个线程只负责处理其中一个内存队列的消息，同一个订单号的消息发送到同一个内存队列中即可。</p><h4 id="Kafka-如何保证消息不丢失"><a href="#Kafka-如何保证消息不丢失" class="headerlink" title="Kafka 如何保证消息不丢失"></a>Kafka 如何保证消息不丢失</h4><p><a href="https://mp.weixin.qq.com/s/kQRBSaGls7-a7VAUMepyBA">https://mp.weixin.qq.com/s/kQRBSaGls7-a7VAUMepyBA</a></p><h5 id="生产者丢失消息的情况"><a href="#生产者丢失消息的情况" class="headerlink" title="生产者丢失消息的情况"></a>生产者丢失消息的情况</h5><p>生产者(Producer) 调用<code>send</code>方法发送消息之后，消息可能因为网络问题并没有发送过去。</p><p>所以，我们不能默认在调用<code>send</code>方法发送消息之后消息发送成功了。为了确定消息是发送成功，我们要判断消息发送的结果。但是要注意的是 Kafka 生产者(Producer) 使用 <code>send</code> 方法发送消息实际上是<strong>异步</strong>的操作，我们可以通过 <code>get()</code>方法获取调用结果，但是这样也让它变为了同步操作，示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SendResult&lt;String, Object&gt; sendResult = kafkaTemplate.send(topic, o).get();</span><br><span class="line"><span class="keyword">if</span> (sendResult.getRecordMetadata() != <span class="literal">null</span>) &#123;</span><br><span class="line">  logger.info(<span class="string">&quot;生产者成功发送消息到&quot;</span> + sendResult.getProducerRecord().topic() + </span><br><span class="line">              <span class="string">&quot;-&gt; &quot;</span> + sendResult.getProducerRecord().value().toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是一般不推荐这么做！可以采用为其添加回调函数的形式，示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ListenableFuture&lt;SendResult&lt;String, Object&gt;&gt; future = kafkaTemplate.send(topic, o);</span><br><span class="line">future.addCallback(result -&gt; logger.info(<span class="string">&quot;生产者成功发送消息到topic:&#123;&#125; partition:&#123;&#125;的消息&quot;</span>, result.getRecordMetadata().topic(), result.getRecordMetadata().partition()),</span><br><span class="line">                ex -&gt; logger.error(<span class="string">&quot;生产者发送消失败，原因：&#123;&#125;&quot;</span>, ex.getMessage()));</span><br></pre></td></tr></table></figure><p>如果消息发送失败的话，我们检查失败的原因之后重新发送即可！</p><p><strong>设置 acks &#x3D; all（-1）</strong></p><p>acks 是 Producer 的参数，如果设置成 all，需要所有副本 Broker 都要接收到消息，该消息才算是“已提交”。这是最高等级的“已提交”定义。</p><p><strong>设置 retries 为一个较大的值。</strong></p><p>一般是 3 ，但是为了保证消息不丢失的话一般会设置比较大一点。设置完成之后，当出现网络问题之后能够自动重试消息发送，避免消息丢失。另外，建议还要设置重试间隔，因为间隔太小的话重试的效果就不明显了，网络波动一次你 3 次一下子就重试完了</p><p>message.send.max.retries 默认值：3，消息发送最大尝试次数。</p><p>retry.backoff.ms 默认值：300，每次尝试增加的额外的间隔时间。</p><h5 id="消费者丢失消息的情况"><a href="#消费者丢失消息的情况" class="headerlink" title="消费者丢失消息的情况"></a>消费者丢失消息的情况</h5><p>我们知道消息在被追加到 Partition(分区)的时候都会分配一个特定的偏移量（offset）。偏移量（offset)表示 Consumer 当前消费到的 Partition(分区)的所在的位置。Kafka 通过偏移量（offset）可以保证消息在分区内的顺序性。</p><p><strong>当消费者拉取到了分区的某个消息之后，消费者会自动提交 offset</strong>。自动提交的话会有一个问题，试想一下，当消费者刚拿到这个消息准备进行真正消费的时候，突然挂掉了，消息实际上并没有被消费，但是 offset 却被自动提交了；多线程消费消息，某个线程处理消息出现异常，还是会出现自动提交offset。</p><p>解决办法也比较粗暴，我们手动关闭自动提交 offset，每次在真正消费完消息之后再自己<strong>手动提交 offset</strong> 。 但是，这样会带来消息被重新消费的问题。比如你刚刚消费完消息之后，还没提交 offset，结果自己挂掉了（或重启），那么这个消息理论上就会被消费两次（如果没挂，那么这条消息不会重复消费）。</p><p> 1.如果在消费kafka的数据过程中，一直没有提交offset，那么在此程序运行的过程中它不会重复消费。但是如果重启之后，就会重复消费之前没有提交offset的数据。</p><p> 2.如果在消费的过程中有几条或者一批数据数据没有提交offset，后面其他的消息消费后正常提交offset，那么服务端会更新为消费后最新的offset，不会重新消费，就算重启程序也不会重新消费。</p><blockquote><p>注：修改enable-auto-commit: false后，必须手动提交</p><p>ACK模式描述<br>MANUALpoll()拉取一批消息，处理完业务后，手动调用Acknowledgment.acknowledge()先将offset存放到map本地缓存，在下一次poll之前从缓存拿出来批量提交<br>MANUAL_IMMEDIATE每处理完业务手动调用Acknowledgment.acknowledge()后立即提交<br>RECORD当每一条记录被消费者监听器（ListenerConsumer）处理之后提交<br>BATCH当每一批poll()的数据被消费者监听器（ListenerConsumer）处理之后提交<br>TIME当每一批poll()的数据被消费者监听器（ListenerConsumer）处理之后，距离上次提交时间大于TIME时提交<br>COUNT当每一批poll()的数据被消费者监听器（ListenerConsumer）处理之后，被处理record数量大于等于COUNT时提交<br>COUNT_TIMETIME或COUNT满足其中一个时提交</p></blockquote><h5 id="Kafka-（Broker）弄丢了消息"><a href="#Kafka-（Broker）弄丢了消息" class="headerlink" title="Kafka （Broker）弄丢了消息"></a>Kafka （Broker）弄丢了消息</h5><p>我们知道 Kafka 为分区（Partition）引入了多副本（Replica）机制。分区（Partition）中的多个副本之间会有一个叫做 leader 的家伙，其他副本称为 follower。我们发送的消息会被发送到 leader 副本，然后 follower 副本才能从 leader 副本中拉取消息进行同步。生产者和消费者只与 leader 副本交互。你可以理解为其他副本只是 leader 副本的拷贝，它们的存在只是为了保证消息存储的安全性。</p><p><strong>试想一种情况：假如 leader 副本所在的 broker 突然挂掉，那么就要从 follower 副本重新选出一个 leader ，但是 leader 的数据还有一些没有被 follower 副本的同步的话，就会造成消息丢失。</strong></p><p><strong>设置 acks &#x3D; all（-1）</strong></p><p>acks 的默认值即为 1，代表我们的消息被 leader 副本接收之后就算被成功发送。当我们配置 <strong>acks &#x3D; all</strong> 表示只有所有 ISR 列表的副本全部收到消息时，生产者才会接收到来自服务器的响应. 这种模式是最高级别的，也是最安全的，可以确保不止一个 Broker 接收到了消息. 该模式的延迟会很高.</p><p><strong>设置 min.insync.replicas &gt; 1</strong></p><p>一般情况下我们还需要设置 <strong>min.insync.replicas&gt; 1</strong> ，这样配置代表消息至少要被写入到 2 个副本才算是被成功发送。<strong>min.insync.replicas</strong> 的默认值为 1 ，在实际生产中应尽量避免默认值 1。</p><p><strong>设置 replication.factor &gt;&#x3D; 3</strong></p><p>为了保证 leader 副本能有 follower 副本能同步消息，我们一般会为 topic 设置 <strong>replication.factor &gt;&#x3D; 3</strong>。这样就可以保证每个 分区(partition) 至少有 3 个副本。虽然造成了数据冗余，但是带来了数据的安全性。</p><p>但是，为了保证整个 Kafka 服务的高可用性，你需要确保 <strong>replication.factor &gt; min.insync.replicas</strong> 。为什么呢？设想一下假如两者相等的话，只要是有一个副本挂掉，整个分区就无法正常工作了。这明显违反高可用性！一般推荐设置成 <strong>replication.factor &#x3D; min.insync.replicas + 1</strong>。</p><p><strong>设置 unclean.leader.election.enable &#x3D; false</strong></p><p>它控制的是哪些 Broker 有资格竞选分区的 Leader。如果一个 Broker 落后原先的 Leader 太多，那么它一旦成为新的 Leader，必然会造成消息的丢失。故一般都要将该参数设置成 false，即不允许这种情况的发生。</p><h4 id="Kafka-如何保证消息不重复消费（幂等性）"><a href="#Kafka-如何保证消息不重复消费（幂等性）" class="headerlink" title="Kafka 如何保证消息不重复消费（幂等性）"></a>Kafka 如何保证消息不重复消费（幂等性）</h4><p><strong>kafka 出现消息重复消费的原因：</strong></p><ul><li>服务端侧<strong>已经消费的数据没有成功提交 offset</strong>（根本原因）。</li><li>当一个消费者加入或退出消费者组时（或主题的分区数量发生变化），或由于服务端处理业务时间长或者网络链接等等原因让 Kafka 认为服务假死，会触发分区 <strong>rebalance</strong>。在 Rebalance 过程中，Kafka 会将所有分区重新分配给消费者，以确保每个消费者都能够处理一定数量的分区。</li></ul><p><strong>解决方案：</strong></p><ul><li><p>消费消息服务做幂等校验，比如 Redis 的 set、MySQL 的主键（防重表）等天然的幂等功能。这种方法最有效。</p></li><li><p>将 <code>enable.auto.commit</code>参数设置为 false，关闭自动提交，开发者在代码中手动提交 offset。那么这里会有个问题：</p><p>什么时候提交 offset 合适？</p><ul><li>处理完消息再提交：依旧有消息重复消费的风险，和自动提交一样</li><li>拉取到消息即提交：会有消息丢失的风险。允许消息延时的场景，一般会采用这种方式。然后，通过定时任务在业务不繁忙（比如凌晨）的时候做数据兜底。</li></ul><p>京东：幂等设计详解<a href="https://mp.weixin.qq.com/s/_Nn5F98PvoWk_xjVrIpFNQ">https://mp.weixin.qq.com/s/_Nn5F98PvoWk_xjVrIpFNQ</a></p><p><a href="https://mp.weixin.qq.com/s/p_khlkMFQsuK2w56tDrsOg">https://mp.weixin.qq.com/s/p_khlkMFQsuK2w56tDrsOg</a></p></li></ul><h4 id="当消费者在消费过程突然宕机了，重新恢复后是从哪里消费，会有什么问题"><a href="#当消费者在消费过程突然宕机了，重新恢复后是从哪里消费，会有什么问题" class="headerlink" title="当消费者在消费过程突然宕机了，重新恢复后是从哪里消费，会有什么问题?"></a>当消费者在消费过程突然宕机了，重新恢复后是从哪里消费，会有什么问题?</h4><p>消费者会记录offset，故障恢复后会从这里继续消费，那么这个offset记录在哪里呢?记录在zookeeper和本地，新版的默认将offset保证在kafka的内置topic中，名称为_consumer_offsets。在这个topic默认会有50个Partition，每一个Partition都有3个副本，分区数量就是由参数offset.topic.num.partition配置的。通过groupid的哈希值和该参数的取模方式来确定某个消费者组已消费的offset保存到_consumer_offsets主题的哪个分区中。这个由消费者组名+主题+分区，来确定唯一的offset的key，从而获取对应的值。</p><h4 id="事务消息"><a href="#事务消息" class="headerlink" title="事务消息"></a>事务消息</h4><p>Kafka的事务消息和RocketMQ有所不同。RocketMQ保证的是<strong>发消息和本地事务</strong>这两个操作的原子性，kafka的事务消息保证<strong>多条消息</strong>同时发送成功或失败。</p><p>如果Kafka发消息失败，会直接抛出异常，让用户自行处理。我们可以在业务代码中反复重试提交，直到提交成功。RocketMQ通过消息回查解决特殊情况下发送消息失败的问题。</p><h4 id="监控-运维"><a href="#监控-运维" class="headerlink" title="监控&#x2F;运维"></a>监控&#x2F;运维</h4><p><a href="https://github.com/didi/KnowStreaming">https://github.com/didi/KnowStreaming</a></p><h4 id="Spring-Kafka"><a href="#Spring-Kafka" class="headerlink" title="Spring-Kafka"></a>Spring-Kafka</h4><p><a href="https://docs.spring.io/spring-kafka/docs/2.9.10/reference/html">https://docs.spring.io/spring-kafka/docs/2.9.10/reference/html</a></p><h5 id="Retryable-topic"><a href="#Retryable-topic" class="headerlink" title="Retryable-topic"></a>Retryable-topic</h5><p><a href="https://zhuanlan.zhihu.com/p/554967177">https://zhuanlan.zhihu.com/p/554967177</a></p><p>kafka本身并没有延迟消息功能</p><h5 id="Listener"><a href="#Listener" class="headerlink" title="Listener"></a>Listener</h5><ul><li><p>concurrency</p><p>举个例子 ： ****如果设置 <code>concurrency=2</code> 时，Spring-Kafka 就会为该 <code>@KafkaListener</code>标注的方法消费的消息 创建 2个线程，进行并发消费****。 当然了，这是有前置条件的。 <strong>不要超过 partitions 的大小</strong></p><ul><li><p>当concurrency &lt; partition 的数量，会出现消费不均的情况，一个消费者的线程可能消费多个partition 的数据</p></li><li><p>当concurrency &#x3D; partition 的数量，最佳状态，一个消费者的线程消费一个 partition 的数据</p></li><li><p>当concurrency &gt; partition 的数量，会出现有的消费者的线程没有可消费的partition， 造成资源的浪费</p><p><em><strong>*分布式情况：总consumer线程数&#x3D;concurrency*机器数量;*</strong></em></p></li></ul></li></ul><h4 id="Kafka-Stream"><a href="#Kafka-Stream" class="headerlink" title="Kafka Stream"></a>Kafka Stream</h4><p><a href="https://blog.csdn.net/u010349629/article/details/130931817">https://blog.csdn.net/u010349629/article/details/130931817</a></p><h3 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h3><p><a href="https://rocketmq.apache.org/zh/docs/">https://rocketmq.apache.org/zh/docs/</a></p><h4 id="事务消息-1"><a href="#事务消息-1" class="headerlink" title="事务消息"></a>事务消息</h4><p>如果使用@Transactional + 发送普通消息，极端情况下，可能存在问题：</p><ol><li>发消息成功，但事务提交前突然宕机，下游收到消息就会误以为本地事务已经成功</li><li>发消息成功，但由于网络原因导致消息发送超时了，这种情况下你不知道到底消息有没有发出去，这样的话你接下来是要提交本地事务、还是回滚、还是重发，这个不确定。RocketMQ的事务消息提供了消息回查的机制，可以解决这个问题。</li></ol><p>事务消息可以保证本地事务和消息投递是原子操作，也就是说本地事务执行成功，消息一定能可靠投递。</p><ol><li>生产者将消息发送至Apache RocketMQ服务端。</li><li>Apache RocketMQ服务端将消息持久化成功之后，向生产者返回Ack确认消息已经发送成功，此时消息被标记为”暂不能投递”，这种状态下的消息即为半事务消息。</li><li>生产者开始执行本地事务逻辑。</li><li>生产者根据本地事务执行结果向服务端提交二次确认结果（Commit或是Rollback），服务端收到确认结果后处理逻辑如下：<ul><li>二次确认结果为Commit：服务端将半事务消息标记为可投递，并投递给消费者。</li><li>二次确认结果为Rollback：服务端将回滚事务，不会将半事务消息投递给消费者。</li></ul></li><li>在断网或者是生产者应用重启的特殊情况下，若服务端未收到发送者提交的二次确认结果，或服务端收到的二次确认结果为Unknown未知状态，经过固定时间后，服务端将对消息生产者即生产者集群中任一生产者实例发起<strong>消息回查</strong>。 服务端回查的间隔时间和最大回查次数，请参见<a href="https://rocketmq.apache.org/zh/docs/introduction/03limits">参数限制</a>。</li><li>生产者收到消息回查后，需要检查对应消息的本地事务执行的最终结果。</li><li>生产者根据检查到的本地事务的最终状态再次提交二次确认，服务端仍按照步骤4对半事务消息进行处理。</li></ol><h3 id="Rabbitmq"><a href="#Rabbitmq" class="headerlink" title="Rabbitmq"></a>Rabbitmq</h3><ul><li>Producer(生产者)： 将消息发送到Exchange</li><li>Exchange(交换器)：将从生产者接收到的消息路由到Queue</li><li>Queue(队列)：存放供消费者消费的消息</li><li>BindingKey(绑定键)：建立Exchange与Queue之间的关系（个人看作是一种规则，也就是Exchange将什么样的消息路由到Queue）</li><li>RoutingKey(路由键)：Producer发送消息与路由键给Exchange，Exchange将判断RoutingKey是否符合BindingKey，如何则将该消息路由到绑定的Queue</li><li>Consumer(消费者)：从Queue中获取消息</li></ul><table><thead><tr><th>交换机类型</th><th>匹配RoutingKey</th><th>特点</th></tr></thead><tbody><tr><td>扇出 Fanout</td><td>不需要匹配；广播转发，可以发送到所有队列</td><td>不需要匹配</td></tr><tr><td>直接 Direct</td><td>完全匹配；只发到特定的队列</td><td>完全匹配</td></tr><tr><td>主题 Topic</td><td>选择匹配；按通配符发送到特定的队列</td><td>选择匹配</td></tr></tbody></table><h3 id="延时消息"><a href="#延时消息" class="headerlink" title="延时消息"></a>延时消息</h3><p><a href="https://mp.weixin.qq.com/s/OmbyxkufVm-XzwIv_A514w">https://mp.weixin.qq.com/s/OmbyxkufVm-XzwIv_A514w</a></p><p><strong>Java Timer类</strong></p><p>Java中的Timer类是一个定时器，它可以用来实现延时消息的功能。Timer类提供了schedule()方法，可以用来安排任务在一定时间后执行。下面是一个简单的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Timer</span> <span class="variable">timer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timer</span>();</span><br><span class="line">timer.schedule(<span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="number">5000</span>);</span><br></pre></td></tr></table></figure><p>在上面的示例中，我们创建了一个Timer对象，并使用schedule()方法安排了一个任务在5秒后执行。任务的具体实现是一个匿名内部类，它继承了TimerTask类，并重写了run()方法。当定时器到达指定的时间时，run()方法会被执行。</p><p>Timer类的使用非常简单，但是它存在一些问题。Timer类是单线程的，如果有多个任务需要执行，它们会被放到同一个队列中，按照先后顺序依次执行。如果某个任务的执行时间过长，会影响后续任务的执行。</p><p><strong>DelayQueue</strong></p><p>DelayQueue 是一个无界阻塞队列，队列中的元素只有在延迟期满后才能被取出。队列的头部存储的是最先到期的元素。添加进该队列的元素必须实现 Delayed 接口，指定延迟时间，元素过期的判断是根据 getDelay(TimeUnit unit) 方法的返回值，返回值小于等于 0，则认为元素过期。队列不允许存储空元素。</p><p><strong>RabbitMQ</strong></p><p><strong>1） TTL+ 死信队列</strong></p><p>RabbitMQ 是基于 TTL+ 死信队列的方式来实现的。具体来说，通过设置消息的 TTL，当达到 TTL 时消息还没有被消费，此时会投递到死信队列。TTL 分两种：</p><ul><li>Queue 级别的 TTL：所有消息统一的 TTL</li><li>Message 级别的 TTL：每条消息可以是不同的 TTL，但是存在队头阻塞问题</li></ul><p>该方案的优点是实现简单，但是延迟误差不确定。</p><p><strong>2） 插件</strong></p><p>Rabbitmq实现了一个插件x-delay-message来实现延时队列</p><p><strong>RocketMQ</strong></p><ul><li><p>4.x版本</p><p>基于定时调度+延迟等级的方式来实现的。具体来说，将延时消息发送到指定的延时等级队列（一共有 18 个等级，1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h），然后通过一个定时器进行轮询这些 ConsumeQueue 实现延时的效果。具体实现如下：</p><ul><li><p>修改消息 topic 名称和队列信息投递到对应等级的延时消息的 ConsumeQueue 中</p></li><li><p>ScheduleMessageService消费ConsumeQueue中的消息再重新投递到 CommitLog 中</p></li><li><p>将 CommitLog 中的消息投递到目标 topic 中，消费者消费目标 topic 中的消息</p></li></ul></li><li><p>5.x版本</p><p><a href="https://rocketmq.apache.org/zh/docs/featureBehavior/02delaymessage">https://rocketmq.apache.org/zh/docs/featureBehavior/02delaymessage</a></p><p>定时消息的定时时长参数<strong>精确到毫秒级</strong>，但是默认精度为1000ms，即定时消息为秒级精度。定时时长最大值默认为24小时，不支持自定义修改，超过范围则服务端会立即投递消息。</p></li></ul><p><strong>Redis</strong></p><p>基于 Redis 实现延迟队列的方式有很多，在这里简单描述两种：</p><p><strong>1）定时轮询</strong></p><p>该方案的大致步骤如下：</p><ul><li>将消息的延时时间戳作为 zset 的 key，消息的 ID 作为 zset 的 value</li><li>消息 ID 作为 key，消息体序列化成 String 作为 value 存储在 Redis 中</li><li>定时轮询 zset，大于当前时间则投递到 Redis 的 List 中供消费者消费</li></ul><p><strong>2）Key 过期监听器</strong></p><p>每条消息设置一个过期时间，监听过期事件然后将消息投递到 target topic。</p><p>基于 Redis 实现延时队列的优点是实现简单，但是都可能存在丢消息的情况，并且存储成本高。</p><h2 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h2><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><h4 id="一致性Hash"><a href="#一致性Hash" class="headerlink" title="一致性Hash"></a>一致性Hash</h4><p>在移除或者添加一个服务器时，能够尽可能小地改变已存在的服务请求与处理请求的服务器之间的映射关系；</p><p><a href="https://zhuanlan.zhihu.com/p/484756425">https://zhuanlan.zhihu.com/p/484756425</a></p><h3 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h3><p>微服务架构是一种将应用程序拆分成一组小型、独立的服务的架构风格，每个服务都运行在自己的进程中，通过轻量级的通信机制相互协作，以实现业务功能。相对于传统的单体应用架构，微服务架构有以下几个优点：</p><ol><li>高可用性：微服务架构将一个大型应用拆分成多个小型服务，每个服务都运行在自己的进程中，因此可以通过水平扩展来提高可用性。当某个服务出现故障时，只会影响到该服务，而不会影响整个应用的可用性。</li><li>易于维护和升级：由于每个服务都是独立的，因此可以<strong>单独对某个服务进行维护和升级，而不会影响到其他服务</strong>。同时，由于服务之间采用轻量级的通信机制，因此可以方便地添加、删除或替换服务，以满足不同的业务需求。</li><li>更快的开发和部署：微服务架构将应用程序拆分成多个小型服务，每个服务都负责一个特定的业务功能，因此可以通过团队之间的协作来加速开发和部署。同时，由于每个服务都是独立的，因此可以快速地进行部署和测试。</li><li>更好的可扩展性：由于<strong>每个服务都是独立的，因此可以根据业务需求来进行水平扩展</strong>。例如，当某个服务的负载增加时，可以通过添加更多的实例来提高性能。</li><li>更好的技术选型：由于每个服务都是独立的，因此可以<strong>根据业务需求来选择最合适的技术栈</strong>。例如，某个服务需要处理大量的数据时，可以选择使用分布式计算框架来提高性能。</li></ol><p>需要注意的是，微服务架构也存在一些挑战和复杂性，如<strong>服务之间的通信、服务发现和治理、分布式事务</strong>等。因此，在实践中需要根据具体的业务需求和技术能力来选择合适的架构风格。</p><p><strong>微服务架构的优点</strong></p><p>与传统单体应用架构相比，微服务架构有很多优点，具体表现如下：</p><ul><li><p>高可用</p><p>当架构中的某一组件发生故障时，在单一进程的传统架构下，故障很有可能在进程内扩散，导致整个应用不可用。在微服务架构下，故障会被隔离在单个服务中。若设计良好，其他服务可通过重试、平稳退化等机制实现应用层面的容错。</p></li><li><p>可扩展</p><p>单个服务应用也可以实现横向扩展，这种扩展可以通过将整个应用完整的复制到不同的节点中实现。当应用的不同组件在扩展需求上存在差异时，微服务架构便体现出其灵活性，因为每个服务可以根据实际需求独立进行扩展。</p></li></ul><p><strong>微服务的缺点</strong></p><ul><li><p>复杂度高</p><p>与单体式架构相比，微服务会导致复杂性上升，因为多个团队会在更多地方创建更多服务。若管理不当，则会导致开发速度和效率降低。</p></li><li><p>基础设施成本呈指数级增长</p><p>每个新的微服务都有自己的成本，例如测试工具、托管基础架构和监控工具等方面。</p></li><li><p>性能下降</p><p>微服务之间通过REST、RPC等形式进行交互，通信的时延会受到较大的影响。</p></li></ul><h4 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h4><ul><li>Dubbo</li><li>Feign：基于Http传输协议，短连接。性能略差，不适合高并发访问，但使用方便</li><li>gRPC</li></ul><h4 id="服务注册-配置"><a href="#服务注册-配置" class="headerlink" title="服务注册&amp;配置"></a>服务注册&amp;配置</h4><ul><li><p>Nacos</p><p>服务注册中心：也叫服务发现中心，微服务将自己注册到服务注册中心，服务间远程调用通过服务注册中心获取目标服务的地址，从而进行远程调用。</p><p>市面上的服务注册中心有：Zookeeper、Eureka、Nacos、Consul。</p><p>配置中心：统一管理微服务的配置文件。</p><p>市面上的配置中心有：Spring Cloud config、Apollo、Nacos。</p></li></ul><h4 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h4><ul><li><p>Spring Cloud Gateway</p><p>网关的作用是负载均衡、路由转发。前端请求到Nginx，通过负载均衡到Gateway网关，通过网关将请求转发至各个微服务。网关进行路由时需要知道每个微服务实例的地址，网关从nacos读取服务地址。</p><p>流程如下：</p><p>1、微服务启动，将自己注册到Nacos，Nacos记录了各微服务实例的地址。</p><p>2、网关从Nacos读取服务列表，包括服务名称、服务地址等。</p><p>3、请求到达网关，网关将请求路由到具体的微服务。</p><p>本项目网关还具有统一鉴权功能：</p><p>1、网站白名单</p><p>在白名单的中的地址不进行身份校验直接放行。</p><p>2、身份校验</p><p>校验请求合法性，令牌合法则继续访问，否则拒绝访问。</p></li></ul><h4 id="熔断降级"><a href="#熔断降级" class="headerlink" title="熔断降级"></a>熔断降级</h4><p>熔断：当下游服务异常而断开与上游服务的交互，它就相当于保险丝，下游服务异常触发了熔断，从而保证上游服务不受影响。</p><p>降级：当下游服务异常触发熔断后，上游服务就不再去调用异常的微服务而是执行了降级处理逻辑，这个降级处理逻辑可以是本地一个单独的方法。</p><h5 id="Hystrix与Sentinel"><a href="#Hystrix与Sentinel" class="headerlink" title="Hystrix与Sentinel"></a>Hystrix与Sentinel</h5><p><img src="http://oss.ripplesu.top/blog/Typora/%E9%9D%A2%E8%AF%95%E9%A2%98/bVcXSr2" alt="Hystrix与Sentinel"></p><ul><li><p>Hystrix 最核心的一项功能就是资源隔离，支持线程池隔离和信号量隔离；Sentinel支持信号量隔离。</p></li><li><p>Sentinel与Hystrix都支持基于失败比率的熔断降级，在调用超过指定的数量并且失败比率达到设定阀值时触发熔断，并在下个时间窗口自动恢复。Sentinel也支持按失败总数熔断降级，但按失败总数的熔断降级固定时间窗口为1分钟，当1分钟内调用失败总数达到设定的阀值就会触发熔断。此外，Sentinel还支持基于平均响应时间的熔断降级，平均响应时间越长，说明服务的性能在持续下降，在响应时间持续飙高时自动熔断，可以防止调用慢造成级联阻塞。</p></li><li><p>Sentinel 和旧版本 Hystrix 的实时指标数据统计实现都是基于滑动窗口，指标数据统计指的是统计每个资源的当前窗口时间内的请求总数、处理成功总数、失败总数、总耗时、平均耗时、最大耗时、最小耗时、被降级总数等。</p></li><li><p>Sentinel 提供数据源接口可实现动态加载规则配置，结合 loadRules API 可灵活的运行时修改规则配置，并且随时修改随时生效。Hystrix 的资源模型设计上采用了命令模式，在创建 Command 时就需要指定隔离策略是线程池隔离还是信号量隔离，一但指定了隔离策略，运行期间便不能修改隔离策略，而在 Sentinel 中资源定义和规则配置是分离的，因此在配置的灵活性上 Sentinel 更具有优势。</p></li><li><p>Sentinel 支持系统自适应限流，Hystrix 所不支持的。当系统负载较高的时候，如果仍持续让请求进入，可能会导致系统崩溃，无法响应。在集群环境下，负载均衡把本应这台机器承载的流量转发到其它的机器上去，如果这个时候其它的机器也处在一个边缘状态的时候，这个增加的流量就会导致这台机器崩溃，最后导致整个集群不可用。针对这个情况，Sentinel 提供了对应的保护机制，让系统的入口流量和系统的负载达到一个平衡，保证系统在能力范围之内处理最多的请求。</p></li><li><p>在 QPS 过高的情况下，直接拒绝超出限制的请求是最常见的实现方式，但有些场景我们可能并不想直接拒绝请求，而是让请求排队等待处理，例如某一秒突增请求过多，但下一秒可能又没有请求或者请求很少的情况。Sentinel 的流量控制支持多种模式，例如直接拒绝模式、慢启动预热模式、匀速器模式。而慢启动预热模式和匀速器模式也是 Hystrix 所不支持的。介绍下Sentinel流量整形的三种模式：</p><blockquote><p><strong>直接拒绝</strong>：即超出的请求直接拒绝<br><strong>慢启动模式</strong>：当流量激增的时候控制流量通过的速率，让通过的流量缓慢增加，在一定时间内逐渐增加到阀值上限，给冷系统一个预热时间，避免冷系统被压跨。<br><strong>匀速器模式</strong>：利用Leaky Bucket算法实现的匀速模式，严格控制了请求通过的时间间隔，同时堆积的请求将会排队，超过超时时长的请求会被拒绝</p></blockquote></li><li><p>Sentinel 在框架的设计上使用了责任链模式和 SPI 机制提供扩展功能。使用SPI我们可以自定义降级功能ProcessorSlot。</p></li><li><p>Sentinel 还支持集群限流。除了轮询负载均衡算法外，其它的算法都会导致流量到集群的每个节点都不一样，有的多有的少。集群流控可以精确地控制整个集群的调用总量，结合单机限流兜底，可以更好地发挥流量控制的效果。Sentinel集群分嵌入模式（Embedded）与独立模式（Alone）。</p><blockquote><p><strong>嵌入模式</strong>：集群限流服务端作为应用的内置服务同应用一起启动，与应用在同一个进程，可动态的挑选其中一个节点作为集群限流服务端<br><strong>独立模式</strong>：集群限流服务端作为一个独立的应用部署</p></blockquote></li><li><p>黑白名单限流和热点参数限流也是 Sentinel 的一大特色，黑白名单限流，可根据请求来源判断来源是否在黑名单中，如果在黑名单中则拒绝请求，否则放行，结合 Sentinel 的灵活动态配置，黑白名单可用于高峰期间对某些服务限流。</p></li></ul><h3 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h3><h4 id="基于XA协议（强一致性）的两阶段提交-2PC-2-phase-commit-protocol"><a href="#基于XA协议（强一致性）的两阶段提交-2PC-2-phase-commit-protocol" class="headerlink" title="基于XA协议（强一致性）的两阶段提交 2PC(2-phase commit protocol)"></a>基于XA协议（强一致性）的两阶段提交 2PC(2-phase commit protocol)</h4><h4 id="事务补偿TCC模式（弱一致性）"><a href="#事务补偿TCC模式（弱一致性）" class="headerlink" title="事务补偿TCC模式（弱一致性）"></a>事务补偿TCC模式（弱一致性）</h4><h4 id="最终一致性方案-Eventual-cnsisteney"><a href="#最终一致性方案-Eventual-cnsisteney" class="headerlink" title="最终一致性方案(Eventual cnsisteney)"></a>最终一致性方案(Eventual cnsisteney)</h4><p>最终一致性是一种通过异步方式解决数据一致性问题的方案。</p><h5 id="本地消息表-定时任务轮询"><a href="#本地消息表-定时任务轮询" class="headerlink" title="本地消息表 + 定时任务轮询"></a>本地消息表 + 定时任务轮询</h5><h5 id="MQ事务消息"><a href="#MQ事务消息" class="headerlink" title="MQ事务消息"></a>MQ事务消息</h5><p>以下来自<a href="https://rocketmq.apache.org/zh/docs/featureBehavior/04transactionmessage">https://rocketmq.apache.org/zh/docs/featureBehavior/04transactionmessage</a></p><p>分布式系统调用的特点为一个核心业务逻辑的执行，同时需要调用多个下游业务进行处理。因此，如何保证核心业务和多个下游业务的执行结果完全一致，是分布式事务需要解决的主要问题。</p><p>以电商交易场景为例，用户支付订单这一核心操作的同时会涉及到下游物流发货、积分变更、购物车状态清空等多个子系统的变更。当前业务的处理分支包括：</p><ul><li>主分支订单系统状态更新：由未支付变更为支付成功。</li><li>物流系统状态新增：新增待发货物流记录，创建订单物流记录。</li><li>积分系统状态变更：变更用户积分，更新用户积分表。</li><li>购物车系统状态变更：清空购物车，更新用户购物车记录。</li></ul><p><strong>传统XA事务方案：性能不足</strong></p><p>为了保证上述四个分支的执行结果一致性，典型方案是基于XA协议的分布式事务系统来实现。将四个调用分支封装成包含四个独立事务分支的大事务。基于XA分布式事务的方案可以满足业务处理结果的正确性，但最大的缺点是多分支环境下资源锁定范围大，并发度低，随着下游分支的增加，系统性能会越来越差。</p><p><strong>基于普通消息方案：一致性保障困难</strong></p><p>将上述基于XA事务的方案进行简化，将订单系统变更作为本地事务，剩下的系统变更作为普通消息的下游来执行，事务分支简化成普通消息+订单表事务，充分利用消息异步化的能力缩短链路，提高并发度。</p><p>该方案中消息下游分支和订单系统变更的主分支很容易出现不一致的现象，例如：</p><ul><li>消息发送成功，订单没有执行成功，需要回滚整个事务。</li><li>订单执行成功，消息没有发送成功，需要额外补偿才能发现不一致。</li><li>消息发送超时未知，此时无法判断需要回滚订单还是提交订单变更。</li></ul><p><strong>基于Apache RocketMQ分布式事务消息：支持最终一致性</strong></p><p>上述普通消息方案中，普通消息和订单事务无法保证一致的原因，本质上是由于普通消息无法像单机数据库事务一样，具备提交、回滚和统一协调的能力。</p><p>而基于Apache RocketMQ实现的分布式事务消息功能，在普通消息基础上，支持二阶段的提交能力。将二阶段提交和本地事务绑定，实现全局提交结果的一致性。</p><h2 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h2><h3 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h3><p><code>java.util.Timer</code>是 JDK 1.3 开始就已经支持的一种定时任务的实现方式。</p><p><code>Timer</code> 内部使用一个叫做 <code>TaskQueue</code> 的类存放定时任务，它是一个基于最小堆实现的优先级队列。<code>TaskQueue</code> 会按照任务距离下一次执行时间的大小将任务排序，保证在堆顶的任务最先执行。这样在需要执行任务时，每次只需要取出堆顶的任务运行即可。</p><p>不过其缺陷较多，比如一个 <code>Timer</code> 一个线程，这就导致 <code>Timer</code> 的任务的执行只能串行执行，一个任务执行时间过长的话会影响其他任务（性能非常差），再比如发生异常时任务直接停止（<code>Timer</code> 只捕获了 <code>InterruptedException</code> ）。</p><h3 id="ScheduledExecutorService"><a href="#ScheduledExecutorService" class="headerlink" title="ScheduledExecutorService"></a>ScheduledExecutorService</h3><p><code>ScheduledExecutorService</code> 是一个接口，有多个实现类，比较常用的是 <code>ScheduledThreadPoolExecutor</code> 。<code>ScheduledThreadPoolExecutor</code> 本身就是一个线程池，支持任务并发执行。并且，其内部使用 <code>DelayedWorkQueue</code> 作为任务队列。</p><p>JDK自带的不论是使用 <code>Timer</code> 还是 <code>ScheduledExecutorService</code> 都仅支持按照指定频率，无法使用 Cron 表达式指定任务执行的具体时间。</p><blockquote><p>Cron表达式在线生成<a href="http://cron.qqe2.com/">http://cron.qqe2.com/</a> </p></blockquote><h3 id="Spring-Task"><a href="#Spring-Task" class="headerlink" title="Spring Task"></a>Spring Task</h3><p>直接通过 Spring 提供的 <code>@Scheduled</code> 注解即可定义定时任务。支持 <strong>Cron 表达式</strong> 。Cron 表达式主要用于定时作业(定时任务)系统定义执行时间或执行频率的表达式。</p><p>但是，Spring 自带的定时调度只支持单机，并且提供的功能比较单一，不够灵活。</p><p>​1.单线程执行，多个定时任务不能同时执行</p><p>​    2.如果当前定时任务还没有结束，那么下一次定时任务的时间到了也不会触发。</p><p>Spring Task 底层是基于 JDK 的 <code>ScheduledThreadPoolExecutor</code> 线程池来实现的。</p><p>上面提到的一些定时任务的解决方案都是在单机下执行的，适用于比较简单的定时任务场景比如每天凌晨备份一次数据。如果我们需要一些高级特性比如支持任务在分布式场景下的分片和高可用的话，我们就需要用到分布式任务调度框架了。</p><h3 id="Quartz"><a href="#Quartz" class="headerlink" title="Quartz"></a>Quartz</h3><p>通常情况下，一个定时任务的执行往往涉及到下面这些角色：</p><ul><li><strong>任务</strong>：首先肯定是要执行的任务，这个任务就是具体的业务逻辑比如定时发送文章。</li><li><strong>调度器</strong>：其次是调度中心，调度中心主要负责任务管理，会分配任务给执行器。</li><li><strong>执行器</strong>：最后就是执行器，执行器接收调度器分派的任务并执行。</li></ul><h4 id="Quartz集群如何分派任务"><a href="#Quartz集群如何分派任务" class="headerlink" title="Quartz集群如何分派任务"></a>Quartz集群如何分派任务</h4><p>在通常情况下，我们都是希望任务<strong>仅在集群中某一台机器中执行</strong>，而非并发执行带来难以预期的后果，这种情况下，就存在着如何分派任务的问题。</p><p>Quartz中存在两种行锁STATE_ACCESS和TRIGGER_ACCESS，分别代表着状态访问锁和触发器访问锁。</p><p>我们需要明确的一点是，集群中的Quartz都是同构的。在这个前提下，任务会在各个集群服务器同一时刻被唤起（当然，需要保证服务器之间的时间同步），<strong>抢占共享数据库中触发器访问锁</strong>，抢到锁的服务器拥有本次任务的执行权限，为获取到锁的服务器退出本次任务的执行。</p><h4 id="Quartz与XXL-job对比"><a href="#Quartz与XXL-job对比" class="headerlink" title="Quartz与XXL-job对比"></a>Quartz与XXL-job对比</h4><p>quartz是一款开源的使用非常广泛的定时任务框架。其可以说是定时任务的鼻祖，很多理念都与xxl-job类似。</p><p><img src="http://oss.ripplesu.top/blog/Typora/%E9%9D%A2%E8%AF%95%E9%A2%98/v2-d65c823532738779d19c92d70588e0df_r.jpg" alt="Quartz与XXL-JOB对比"></p><p>整体来说，xxl-job就是quartz的一个增强版，其弥补了quartz不支持并行调度，不支持失败处理策略和动态分片的策略等诸多不足，同时其有管理界面，上手比较容易，支持分布式，适用于分布式场景下的使用。两者相同的是都是通过数据库锁来控制任务不能重复执行。</p><h3 id="XXL-job"><a href="#XXL-job" class="headerlink" title="XXL-job"></a>XXL-job</h3><p>优点：</p><ul><li>社区活跃：GitHub20+kstar，1000+issue；相较quartz和elasticjob活跃的多</li><li>开箱即用（学习成本比较低）、与 Spring 集成。</li><li>分布式支持：XXL-Job 可以支持分布式部署，可以在多台机器上运行任务，并且可以通过注册中心进行任务调度和监控。只依赖数据库作为集群注册中心，不需要ZK</li><li>高可靠性和容错性：XXL-Job 支持任务的失败重试和任务的失效转移（系统会自动将该节点上的任务转移到其他节点上执行），可以保证任务的高可靠性和容错性。</li><li>可视化管理界面：XXL-Job 提供了一个可视化的管理界面，可以方便地进行任务管理、任务调度和任务监控。</li><li>执行日志记录：XXL-Job 可以记录任务的执行日志，方便用户进行问题排查和分析。</li></ul><h3 id="Elastic-job"><a href="#Elastic-job" class="headerlink" title="Elastic-job"></a>Elastic-job</h3><p>当当网开源的一个面向互联网生态和海量任务的分布式调度解决方案，由两个相互独立的子项目 ElasticJob-Lite 和 ElasticJob-Cloud 组成。</p><p>使用 ZooKeeper 作为注册中心，注册中心负责协调分配任务到不同的节点上。</p><p>Elastic-Job 中的定时调度都是由执行器自行触发，这种设计也被称为去中心化设计（调度和处理都是执行器单独完成）。</p><ul><li>优点：可以与 Spring集成、支持分布式、支持集群、性能不错</li><li>缺点：依赖了额外的中间件比如 Zookeeper（复杂度增加，可靠性降低、维护成本变高）</li></ul><h2 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a>计算机基础</h2><h3 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h3><h4 id="网络体系结构"><a href="#网络体系结构" class="headerlink" title="网络体系结构"></a>网络体系结构</h4><h5 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h5><p>从下到上分别是<strong>物理层、数据链路层、网络层、传输层、会话层、表示层和应用层</strong>。</p><ul><li><p>物理层</p><ul><li><p>任务：<strong>透明（透明传输指的是，无论上层交付给数据链路层什么数据，数据链路层都好像是看不见这个数据一样将这个数据传输出去。）地传输比特流</strong>。尽可能屏蔽掉具体传输介质和物理设备的差异。使其上面的数据链路层不必考虑网络的具体传输介质是什么。</p></li><li><p>功能：为数据段设备提供传送数据通路</p></li><li><p>传输单位：比特</p></li><li><p>所实现的硬件：集线器，中继器</p></li></ul></li><li><p>数据链路层</p><ul><li><p>任务：<strong>将网络层传输下来的IP数据报组装成帧</strong>，通过差错控制、流量控制方法，使有差错的物理线路变为无差错的数据链路，即提供可靠的通过物理介质传输数据的方法。</p></li><li><p>功能：a. 链路连接的建立、拆除和分离</p><p>​            b. 帧定界和帧同步</p><p>​            c.差错检测</p></li><li><p>传输单位：帧</p></li><li><p>所实现的硬件：交换机、网桥</p></li><li><p>协议：PPP,HDLC、SDLC、STP、ARQ</p></li></ul></li><li><p>网络层</p><ul><li><p>任务：a. 将传输层传下来的报文段封装成分组</p><p>​            b.选择合适的路由，使得传输层传下来的分组能够交付到目的主机</p></li><li><p>功能：a. 为传输层提供服务</p><p>​            b. 组包和拆包</p><p>​            c. 路由选择</p><p>​            d.拥塞控制</p></li><li><p>传输单位：数据段</p></li><li><p>所实现的硬件：路由器</p></li><li><p>协议：ICMP、ARP、RARP、IP、IGMP、OSPF</p></li></ul></li><li><p>传输层</p><ul><li><p>任务：<strong>负责主机中两个进程之间的通信</strong></p></li><li><p>功能：</p><p>​      a. 为端到端连接提供可靠的服务</p><p>​      b. 为端到端连接提供流量控制、差错控制、服务质量等管理服务</p></li><li><p>传输单位：报文段（TCP）或用户数据报（UDP）</p></li><li><p><strong>协议：TCP、UDP</strong></p></li></ul></li><li><p>会话层</p><ul><li><p>任务：<strong>不同主机上各进程间的对话</strong></p></li><li><p>功能：管理主机间的会话进程，包括建立、管理以及终止进程间的会话。是一种端到端的服务</p></li></ul></li><li><p>表示层</p><p><strong>负责处理在两个内部数据表示结构不同的通信系统之间交换信息的表示格式</strong>（把应用层提供的信息变换为能够共同理解的形式），为数据<em>加密和解密</em>以及为提高传输效率提供必需的数据<em>压缩以及解压</em>等功能。</p><p> ①数据格式处理：协商和建立数据交换的格式，解决各应用程序之间在数据格式表示上的差异。   </p><p>②数据的编码：处理字符集和数字的转换。   </p><p>③压缩和解压缩：为了减少数据的传输量，这一层还负责数据的压缩与恢复。   </p><p>④数据的加密和解密：可以提高网络的安全性。</p></li><li><p>应用层</p><ul><li><p>任务：<strong>提供系统与用户程序的接口</strong>，使用户程序能够使用网络服务</p></li><li><p>功能：</p><p>​      a.文件传输</p><p>​      b. 访问和管理</p><p>​      c. 电子邮件服务</p></li><li><p>协议：FTP（20）、SMTP（25）、POP3、HTTP（80）、DNS（53）、TELnet</p></li></ul></li></ul><h5 id="TCP-IP协议簇四层模型"><a href="#TCP-IP协议簇四层模型" class="headerlink" title="TCP&#x2F;IP协议簇四层模型"></a>TCP&#x2F;IP协议簇四层模型</h5><p><img src="https://s2.loli.net/2023/06/08/Udx5HGbC64lT3cg.png" alt="image-20230608152155503"></p><ol><li><p><strong>应用层</strong>(application layer)</p><p>(1) 应用层(application layer)：是体系结构中的最高。<strong>直接为用户的应用进程提供服务</strong>。应用层是不用去关心数据是如何传输的，当两个不同设备的应用需要通信的时候，应用就把应用数据传给下一层，也就是传输层。</p><p>(2) 在因特网中的应用层协议很多，如支持万维网应用的<strong>HTTP</strong>协议，支持电子邮件的<strong>SMTP</strong>协议，支持文件传送的<strong>FTP</strong>协议等等。</p></li><li><p><strong>传输层</strong>(transport layer)</p><ul><li><p><strong>传输控制协议TCP(Transmission Control Protocol)：</strong>面向连接的，数据传输的单位是报文段，能够提供可靠的交付（流量控制、超时重传、拥塞控制等）。   </p></li><li><p><strong>用户数据包协议UDP(User Datagram Protocol)：</strong>无连接的，数据传输的单位是用户数据报，不保证提供可靠的交付，只能提供“尽最大努力交付”。实时性相对更好，传输效率也高。</p></li></ul></li><li><p><strong>网络层</strong>(network layer)</p><p>对于 IPv4 协议， IP 地址共 32 位，每段是 8 位。只有一个单纯的 IP 地址虽然做到了区分设备，但是寻址起来就特别麻烦，全世界那么多台设备，难道一个一个去匹配？这显然不科学。</p><p>因此，需要将 IP 地址分成两种意义：</p><ul><li>一个是<strong>网络号</strong>，负责标识该 IP 地址是属于哪个「子网」的；</li><li>一个是<strong>主机号</strong>，负责标识同一「子网」下的不同主机；</li></ul><p>怎么分的呢？这需要配合<strong>子网掩码</strong>才能算出 IP 地址 的网络号和主机号。</p></li><li><p>网络接口层</p><p>生成了 IP 头部之后，接下来要交给<strong>网络接口层</strong>（<em>Link Layer</em>）在 IP 头部的前面加上 MAC 头部，并封装成数据帧（Data frame）发送到网络上。</p></li></ol><h5 id="五层模型"><a href="#五层模型" class="headerlink" title="五层模型"></a>五层模型</h5><p>五层网络体系结构分分别为：<strong>应用层、运输层、网络层、数据链路层、物理层</strong>。各层功能分别如下：</p><ol><li><p>第五层——<strong>应用层</strong>(application layer)</p><p>(1) 应用层(application layer)：是体系结构中的最高。直接为用户的应用进程提供服务。</p><p>(2) 在因特网中的应用层协议很多，如支持万维网应用的HTTP协议，支持电子邮件的SMTP协议，支持文件传送的FTP协议等等。</p></li><li><p>第四层——<strong>运输层</strong>(transport layer)</p><p>(1) 运输层(transport layer)：负责向两个主机中进程之间的通信提供服务。由于一个主机可同时运行多个进程，因此运输层有<strong>复用</strong>和<strong>分用</strong>的功能。</p><p>  a. 复用，就是多个应用层进程可同时使用下面运输层的服务。</p><p>  b. 分用，就是把收到的信息分别交付给上面应用层中相应的进程。</p><p>(2) <strong>运输层主要使用以下两种协议：</strong>   <strong>(1) 传输控制协议TCP(Transmission Control Protocol)：</strong>面向连接的，数据传输的单位是报文段，能够提供可靠的交付。   <strong>(2) 用户数据包协议UDP(User Datagram Protocol)：</strong>无连接的，数据传输的单位是用户数据报，不保证提供可靠的交付，只能提供“尽最大努力交付”。</p></li><li><p>第三层——<strong>网络层</strong>(network layer)</p><p>网络层(network layer)主要包括以下两个任务：</p><p>(1) 负责为分组交换网上的不同主机提供通信服务。在发送数据时，网络层把运输层残生的报文段或用户数据报封装成分组或包进行传送。在TCP&#x2F;IP体系中，由于网络层使用IP协议，因此分组也叫做IP数据报，或简称为数据报。</p><p>(2) 选中合适的路由，使源主机运输层所传下来的分组，能够通过网络中的路由器找到目的主机。</p></li><li><p>第二层——<strong>数据链路层</strong>(data link layer)</p><p><strong>数据链路层(data link layer)：</strong>常简称为链路层，我们知道，两个主机之间的数据传输，总是在一段一段的链路上传送的，也就是说，在两个相邻结点之间传送数据是直接传送的(点对点)，这时就需要使用专门的链路层的协议。</p><p>在两个相邻结点之间传送数据时，数据链路层将网络层交下来的IP数据报组装成帧(framing)，在两个相邻结点之间的链路上“透明”地传送帧中的数据。</p><p>每一帧包括数据和必要的控制信息(如同步信息、地址信息、差错控制等)。典型的帧长是几百字节到一千多字节。</p><p><strong>注意</strong>：”透明”是一个很重要的术语。它表示，某一个实际存在的事物看起来却好像不存在一样。”在数据链路层透明传送数据”表示无力什么样的比特组合的数据都能够通过这个数据链路层。因此，对所传送的数据来说，这些数据就“看不见”数据链路层。或者说，数据链路层对这些数据来说是透明的。   (1) 在接收数据时，控制信息使接收端能知道一个帧从哪个比特开始和到哪个比特结束。这样，数据链路层在收到一个帧后，就可从中提取出数据部分，上交给网络层。   (2) 控制信息还使接收端能检测到所收到的帧中有无差错。如发现有差错，数据链路层就简单地丢弃这个出了差错的帧，以免继续传送下去白白浪费网络资源。如需改正错误，就由运输层的TCP协议来完成。</p><p>相关题目：数据链路层采用后退N帧（GBN）协议，发送方已经发送了编号为0～7的帧。当计时器超时时，若发送方只收到0、2、3号帧的确认，则发送方需要重发的帧数是多少？分别是那几个帧？</p><p>根据GBN协议工作原理，GBN协议的确认是累积确认，不会管中间所丢的数据包，所以，此时发送端需要重发的帧数是4个，依次分别是4、5、6、7号帧</p></li><li><p>第一层——<strong>物理层</strong>(physical layer)</p><p><strong>物理层(physical layer)：</strong>在物理层上所传数据的单位是比特。物理层的任务就是透明地传送比特流。</p></li></ol><h4 id="TCP与UDP"><a href="#TCP与UDP" class="headerlink" title="TCP与UDP"></a>TCP与UDP</h4><h5 id="TCP与UDP区别"><a href="#TCP与UDP区别" class="headerlink" title="TCP与UDP区别"></a>TCP与UDP区别</h5><p><strong>是否面向连接</strong>：UDP 在传送数据之前不需要先建立连接。而 TCP 提供面向连接的服务，在传送数据之前必须先建立连接，数据传送结束后要释放连接。</p><p><strong>是否是可靠传输</strong>：远地主机在收到 UDP 报文后，不需要给出任何确认，并且不保证数据不丢失，不保证是否顺序到达（尽最大努力交付）。TCP 提供可靠的传输服务，TCP 在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、超时重传、拥塞控制等机制。通过 TCP 连接传输的数据，无差错、不丢失、不重复、并且按序到达。</p><p><strong>是否有状态</strong>：这个和上面的“是否可靠传输”相对应。TCP 传输是有状态的，这个有状态说的是 TCP 会去记录自己发送消息的状态比如消息是否发送了、是否被接收了等等。为此 ，TCP 需要维持复杂的连接状态表。而 UDP 是无状态服务，简单来说就是不管发出去之后的事情了。</p><p><strong>传输效率</strong>：由于使用 TCP 进行传输的时候多了连接、确认、重传等机制，所以 TCP 的传输效率要比 UDP 低很多。</p><p><strong>传输形式</strong>：TCP 是面向字节流的：TCP与应用程序的交互是一次一个数据块,但是TCP把应用程序交下来的数据看成仅仅是一连串的无结构的字节流。TCP不保证接收方应用程序所收到的数据块和发送方应用程序所发出的数据块具有对应大小的关系,但是接收方应用程序收到的字节流必须和发送方应用程序发出的字节流完全一样</p><p>UDP 是面向报文的：发送方 UDP 对应用程序交下来的报文,在添加首部后就向下交付 IP 层。UDP 对应用层交下来的报文,既不合并,也不拆分,而是保留这些报文的边界。接收方 UDP 对 IP 层交上来的 UDP 用户数据报,在去除首部后就原封不动地交付上层的应用进程,一次交付一个完整的报文。 </p><p><strong>首部开销</strong>：TCP 首部开销（20 ～ 60 字节）比 UDP 首部开销（8 字节）要大。</p><p><strong>是否提供广播或多播服务</strong>：TCP 只支持点对点通信，UDP 支持一对一、一对多、多对一、多对多；</p><h5 id="什么时候选择-TCP，什么时候选-UDP"><a href="#什么时候选择-TCP，什么时候选-UDP" class="headerlink" title="什么时候选择 TCP，什么时候选 UDP?"></a>什么时候选择 TCP，什么时候选 UDP?</h5><ul><li><strong>UDP 一般用于即时通信</strong>，比如：语音、 视频、直播等等。这些场景对传输数据的准确性要求不是特别高，比如你看视频即使少个一两帧，实际给人的感觉区别也不大。</li><li><strong>TCP 用于对传输准确性要求特别高的场景</strong>，比如文件传输、发送和接收邮件、远程登录等等</li></ul><h5 id="TCP格式"><a href="#TCP格式" class="headerlink" title="TCP格式"></a>TCP格式</h5><p><img src="https://s2.loli.net/2023/06/10/kgJKHqFNV3fxci5.png" alt="TCP 头格式"></p><p><strong>序列号</strong>：在建立连接时由计算机生成的随机数作为其初始值，通过 SYN 包传给接收端主机，每发送一次数据，就「累加」一次该「数据字节数」的大小。<strong>用来解决网络包乱序问题。</strong></p><p><strong>确认应答号</strong>：指<strong>下一次「期望」收到的数据的序列号</strong>，发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。<strong>用来解决丢包的问题。</strong></p><p><strong>控制位：</strong></p><ul><li><em>ACK</em>：该位为 <code>1</code> 时，「确认应答」的字段变为有效，TCP 规定除了最初建立连接时的 <code>SYN</code> 包之外该位必须设置为 <code>1</code> 。</li><li><em>RST</em>：该位为 <code>1</code> 时，表示 TCP 连接中出现异常必须强制断开连接。</li><li><em>SYN</em>：该位为 <code>1</code> 时，表示希望建立连接，并在其「序列号」的字段进行序列号初始值的设定。</li><li><em>FIN</em>：该位为 <code>1</code> 时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换 <code>FIN</code> 位为 1 的 TCP 段。</li></ul><h5 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h5><p><img src="https://s2.loli.net/2023/06/10/UVHMpqJlN46RISd.png" alt="TCP 三次握手"></p><ul><li>一开始，客户端和服务端都处于 <code>CLOSE</code> 状态。先是服务端主动监听某个端口，处于 <code>LISTEN</code> 状态</li><li>客户端会随机初始化序号（<code>client_isn</code>），将此序号置于 TCP 首部的「序号」字段中，同时把 <code>SYN</code> 标志位置为 <code>1</code>，表示 <code>SYN</code> 报文。接着把第一个 SYN 报文发送给服务端，表示向服务端发起连接，该报文不包含应用层数据，之后客户端处于 <code>SYN-SENT</code> 状态。</li><li>服务端收到客户端的 <code>SYN</code> 报文后，首先服务端也随机初始化自己的序号（<code>server_isn</code>），将此序号填入 TCP 首部的「序号」字段中，其次把 TCP 首部的「确认应答号」字段填入 <code>client_isn + 1</code>, 接着把 <code>SYN</code> 和 <code>ACK</code> 标志位置为 <code>1</code>。最后把该报文发给客户端，该报文也不包含应用层数据，之后服务端处于 <code>SYN-RCVD</code> 状态。</li><li>客户端收到服务端报文后，还要向服务端回应最后一个应答报文，首先该应答报文 TCP 首部 <code>ACK</code> 标志位置为 <code>1</code> ，其次「确认应答号」字段填入 <code>server_isn + 1</code> ，最后把报文发送给服务端，这次报文可以携带客户到服务端的数据，之后客户端处于 <code>ESTABLISHED</code> 状态。</li><li>服务端收到客户端的应答报文后，也进入 <code>ESTABLISHED</code> 状态。</li></ul><h6 id="（了解）为什么是三次？"><a href="#（了解）为什么是三次？" class="headerlink" title="（了解）为什么是三次？"></a>（了解）为什么是三次？</h6><p>RFC 793 指出的 TCP 连接使用三次握手的<strong>首要原因</strong>：</p><blockquote><p><em>The principle reason for the three-way handshake is to prevent old duplicate connection initiations from causing confusion.</em></p></blockquote><p>简单来说，三次握手的<strong>首要原因是为了防止旧的重复连接初始化造成混乱。</strong></p><p>我们考虑一个场景，客户端先发送了 SYN（seq &#x3D; 90）报文，然后客户端宕机了，而且这个 SYN 报文还被网络阻塞了，服务端并没有收到，接着客户端重启后，又重新向服务端建立连接，发送了 SYN（seq &#x3D; 100）报文（<em>注意！不是重传 SYN，重传的 SYN 的序列号是一样的</em>）。</p><p><img src="https://s2.loli.net/2023/06/10/uCQoa1Xs3Zm92rI.png" alt="三次握手避免历史连接"></p><p>客户端连续发送多次 SYN（都是同一个四元组）建立连接的报文，在<strong>网络拥堵</strong>情况下：</p><ul><li>一个「旧 SYN 报文」比「最新的 SYN」 报文早到达了服务端，那么此时服务端就会回一个 <code>SYN + ACK</code> 报文给客户端，此报文中的确认号是 91（90+1）。</li><li>客户端收到后，发现自己期望收到的确认号应该是 100 + 1，而不是 90 + 1，于是就会回 RST 报文。</li><li>服务端收到 RST 报文后，就会释放连接。</li><li>后续最新的 SYN 抵达了服务端后，客户端与服务端就可以正常的完成三次握手了。</li></ul><p>上述中的「旧 SYN 报文」称为历史连接，TCP 使用三次握手建立连接的<strong>最主要原因就是防止「历史连接」初始化了连接</strong>。</p><p><a href="https://www.xiaolincoding.com/network/3_tcp/tcp_interview.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B-%E4%B8%8D%E6%98%AF%E4%B8%A4%E6%AC%A1%E3%80%81%E5%9B%9B%E6%AC%A1">https://www.xiaolincoding.com/network/3_tcp/tcp_interview.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B-%E4%B8%8D%E6%98%AF%E4%B8%A4%E6%AC%A1%E3%80%81%E5%9B%9B%E6%AC%A1</a></p><h6 id="握手丢失了会发生什么"><a href="#握手丢失了会发生什么" class="headerlink" title="握手丢失了会发生什么"></a>握手丢失了会发生什么</h6><ul><li><p>第一次握手丢失</p><p>当客户端想和服务端建立 TCP 连接的时候，首先第一个发的就是 SYN 报文，然后进入到 <code>SYN_SENT</code> 状态。</p><p>在这之后，如果客户端迟迟收不到服务端的 SYN-ACK 报文（第二次握手），就会触发「<strong>超时重传</strong>」机制，重传 SYN 报文，而且<strong>重传的 SYN 报文的序列号都是一样的</strong>。</p><p><strong>每次超时的时间是上一次的 2 倍，有次数限制（Linux中默认为5）。</strong></p><p>达到最大重传次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到服务端的第二次握手（SYN-ACK 报文），那么客户端就会断开连接。</p></li><li><p>第二次握手丢失</p><p>当服务端收到客户端的第一次握手后，就会回 SYN-ACK 报文给客户端，这个就是第二次握手，此时服务端会进入 <code>SYN_RCVD</code> 状态。</p><p>第二次握手的 <code>SYN-ACK</code> 报文其实有两个目的 ：</p><ul><li>第二次握手里的 ACK， 是对第一次握手的确认报文；</li><li>第二次握手里的 SYN，是服务端发起建立 TCP 连接的报文；</li></ul><p>因为第二次握手报文里是包含对客户端的第一次握手的 ACK 确认报文，所以，如果客户端迟迟没有收到第二次握手，那么<em>客户端就觉得可能自己的 SYN 报文（第一次握手）丢失了</em>，于是<strong>客户端就会触发超时重传机制，重传 SYN 报文</strong>。</p><p>然后，因为第二次握手中包含服务端的 SYN 报文，所以当客户端收到后，需要给服务端发送 ACK 确认报文（第三次握手），服务端才会认为该 SYN 报文被客户端收到了。</p><p>那么，如果第二次握手丢失了，服务端就收不到第三次握手，于是<strong>服务端这边会触发超时重传机制，重传 SYN-ACK 报文</strong>。</p></li><li><p>第三次握手丢失了，会发生什么？</p><p>客户端收到服务端的 SYN-ACK 报文后，就会给服务端回一个 ACK 报文，也就是第三次握手，此时客户端状态进入到 <code>ESTABLISH</code> 状态。</p><p>因为这个第三次握手的 ACK 是对第二次握手的 SYN 的确认报文，所以当第三次握手丢失了，如果服务端那一方迟迟收不到这个确认报文，就会触发超时重传机制，<strong>重传 SYN-ACK 报文</strong>，直到收到第三次握手，或者达到最大重传次数。</p><p>注意，<strong>ACK 报文是不会有重传的，当 ACK 丢失了，就由对方重传对应的报文</strong>。</p></li></ul><h5 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h5><p>双方都可以主动断开连接，断开连接后主机中的资源将被释放，四次挥手的过程如下图：</p><p><img src="https://s2.loli.net/2023/06/10/3vrqMIiLT2khS4J.png" alt="客户端主动关闭连接 —— TCP 四次挥手"></p><ul><li>第一次：客户端打算关闭连接，此时会发送一个 TCP 首部 <code>FIN</code> 标志位被置为 <code>1</code> 的报文，也即 <code>FIN</code> 报文，之后客户端进入 <code>FIN_WAIT_1</code> 状态。</li><li>第二次：服务端收到该报文后，就向客户端发送 <code>ACK</code> 应答报文，接着服务端进入 <code>CLOSE_WAIT</code> 状态。</li><li>客户端收到服务端的 <code>ACK</code> 应答报文后，之后进入 <code>FIN_WAIT_2</code> 状态。</li><li>第三次：等待服务端处理完数据后，也向客户端发送 <code>FIN</code> 报文，之后服务端进入 <code>LAST_ACK</code> 状态。</li><li>第四次：客户端收到服务端的 <code>FIN</code> 报文后，回一个 <code>ACK</code> 应答报文，之后进入 <code>TIME_WAIT</code> 状态</li><li>服务端收到了 <code>ACK</code> 应答报文后，就进入了 <code>CLOSE</code> 状态，至此服务端已经完成连接的关闭。</li><li>客户端在经过 <code>2MSL</code> 一段时间后，自动进入 <code>CLOSE</code> 状态，至此客户端也完成连接的关闭</li></ul><h6 id="为什么是四次？"><a href="#为什么是四次？" class="headerlink" title="为什么是四次？"></a>为什么是四次？</h6><ul><li>关闭连接时，客户端向服务端发送 <code>FIN</code> 时，仅仅表示客户端不再发送数据了但是还能接收数据。</li><li>服务端收到客户端的 <code>FIN</code> 报文时，先回一个 <code>ACK</code> 应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 <code>FIN</code> 报文给客户端来表示同意现在关闭连接。</li></ul><p>从上面过程可知，服务端通常需要等待完成数据的发送和处理，所以服务端的 <code>ACK</code> 和 <code>FIN</code> 一般都会分开发送，因此是需要四次挥手。</p><blockquote><p>什么情况会出现三次挥手？</p><p>当被动关闭方（上图的服务端）在 TCP 挥手过程中，「<strong>没有数据要发送」并且「开启了 TCP 延迟确认机制」（默认开启），那么第二和第三次挥手就会合并传输，这样就出现了三次挥手。</strong></p><p>当发送没有携带数据的 ACK，它的网络效率也是很低的，因为它也有 40 个字节的 IP 头 和 TCP 头，但却没有携带数据报文。 为了解决 ACK 传输效率低问题，所以就衍生出了 <strong>TCP 延迟确认</strong>。 TCP 延迟确认的策略：</p><ul><li>当有响应数据要发送时，ACK 会随着响应数据一起立刻发送给对方</li><li>当没有响应数据要发送时，ACK 将会延迟一段时间，以等待是否有响应数据可以一起发送</li><li>如果在延迟等待发送 ACK 期间，对方的第二个数据报文又到达了，这时就会立刻发送 ACK</li></ul></blockquote><h6 id="握手丢失"><a href="#握手丢失" class="headerlink" title="握手丢失"></a>握手丢失</h6><ul><li><p>第一次丢失：客户端（发送方）重传，每次重传间隔时间是上次2倍，有次数限制</p></li><li><p>第二次丢失：ACK不会重传，故与第一次一致</p></li><li><p>第三次丢失：重传FIN</p></li><li><p>第四次丢失：重传FIN</p><p>具体过程：</p><ul><li>当服务端重传第三次挥手报文达到 2 时，由于 tcp_orphan_retries 为 2（假设）， 达到了最大重传次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到客户端的第四次挥手（ACK 报文），那么服务端就会断开连接。</li><li>客户端在收到第三次挥手后，就会进入 TIME_WAIT 状态，开启时长为 2MSL 的定时器，如果途中再次收到第三次挥手（FIN 报文）后，就会重置定时器，当等待 2MSL 时长后，客户端就会断开连接。</li></ul></li></ul><h6 id="为什么TIME-WAIT等待2MSL"><a href="#为什么TIME-WAIT等待2MSL" class="headerlink" title="为什么TIME_WAIT等待2MSL"></a>为什么TIME_WAIT等待2MSL</h6><p><strong>等待足够的时间以确保最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭。</strong></p><p>如果客户端（主动关闭方）最后一次 ACK 报文（第四次挥手）在网络中丢失了，那么按照 TCP 可靠性原则，服务端（被动关闭方）会重发 FIN 报文。</p><p>假设客户端没有 TIME_WAIT 状态，而是在发完最后一次回 ACK 报文就直接进入 CLOSE 状态，如果该 ACK 报文丢失了，服务端则重传的 FIN 报文，而这时客户端已经进入到关闭状态了，在收到服务端重传的 FIN 报文后，就会回 RST 报文。</p><p>服务端收到这个 RST 就会异常关闭连接。</p><p>为了防止这种情况出现，客户端必须等待足够长的时间，确保服务端能够收到 ACK，如果服务端没有收到 ACK，那么就会触发 TCP 重传机制，服务端会重新发送一个 FIN，这样一去一来刚好两个 MSL 的时间。</p><p>客户端在收到服务端重传的 FIN 报文时，TIME_WAIT 状态的等待时间，会重置回 2MSL。</p><p><strong>防止历史连接中的数据，被后面相同四元组的连接错误的接收</strong></p><p>TCP使用四元组区分一个连接（源端口、目的端口、源IP、目的IP），如果新、旧连接的IP与端口号完全一致，则内核协议栈无法区分这两条连接。</p><p>如果旧链接发送的报文由于某些原因被网络延迟了，服务端以相同的四元组打开了新连接，就可能接收前面被延迟的报文，这就会导致数据错乱的问题。</p><p>为了防止这个问题， TCP 设计了 TIME_WAIT 状态，状态会持续 <code>2MSL</code> 时长，这个时间<strong>足以让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都自然消失，再出现的数据包一定都是新建立连接所产生的。</strong></p><h6 id="TIME-WAIT太多？"><a href="#TIME-WAIT太多？" class="headerlink" title="TIME_WAIT太多？"></a>TIME_WAIT太多？</h6><p>当连接处于TIME_WAIT状态时仍会占用系统资源（fd（文件描述符，单文件最大1024个）、端口、内存），TIME_WAIT太多就会占用大量的系统资源</p><h4 id="访问一个页面的过程？"><a href="#访问一个页面的过程？" class="headerlink" title="访问一个页面的过程？"></a>访问一个页面的过程？</h4><h4 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h4><h5 id="HTTP（超文本传输协议）简介"><a href="#HTTP（超文本传输协议）简介" class="headerlink" title="HTTP（超文本传输协议）简介"></a>HTTP（超文本传输协议）简介</h5><p>（1）HTTP协议的特性</p><p>  HTTP 协议一共有<strong>五大特点</strong>：a. 支持客户&#x2F;服务器模式；b. 简单快速；c. 灵活；d. 无连接；e. 无状态。</p><p>  <strong>无连接含义：</strong>限制每次连接只处理一个请求。服务器<strong>处理完客户的请求，并收到客户的应答后，即断开连接</strong>。采用这种方式可以节省传输时间。</p><p>  <strong>无状态含义：</strong>指协议对于事务处理没有记忆能力，<strong>服务器不知道客户端是什么状态</strong>。即我们给服务器发送 HTTP 请求之后，服务器根据请求，会给我们发送数据过来，但是，发送完，不会记录任何信息。</p><p>（2）HTTP 客户机及服务器</p><p>  HTTP 客户机：web 浏览器</p><p>  HTTP 服务器：web 服务器，包含 web 对象（HTML 文件、JPEG 文件、java 小程序、视频片段等）</p><p>（3）HTTP 方法字段：</p><p>  <strong>GET</strong>：绝大部分 HTTP 请求报文使用 GET 方法</p><p>  <strong>POST</strong>：用户提交表单时（如向搜索引擎提供关键字），但提交表单不一定要用 POST 方法</p><p>  <strong>HEAD</strong>：类似于 GET，区别在于服务器返回的响应报文中不包含请求对象（常用于故障跟踪）</p><p>  <strong>PUT</strong>：用于向服务器上传对象</p><p>  <strong>DELETE</strong>：用于删除服务器上的对象</p><p>（4）HTTP 状态信息</p><p><img src="/../../../ProgramData/Typora/Blog/%E9%9D%A2%E8%AF%95%E9%A2%98/6-%E4%BA%94%E5%A4%A7%E7%B1%BBHTTP%E7%8A%B6%E6%80%81%E7%A0%81.png" alt=" 五大类 HTTP 状态码 "></p><p>  <strong>200 OK</strong> 表示从客户端发来的请求在服务器端被正确处理  </p><p>  <strong>301 Permanently Moved</strong> 被请求的资源已永久移动到新位置，新的URL在Location头中给出，浏览器应该自动地访问新的URL。</p><p>  <strong>302 Found</strong> 请求的资源现在临时从不同的URL响应请求。301是永久重定向，而302是临时重定向。</p><p>  <strong>304 Not Modified</strong> 304状态码是告诉浏览器可以从缓存中获取所请求的资源。</p><p>  <strong>400 bad request</strong> 请求报文存在语法错误</p><p>  <strong>403 forbidden</strong> 表示对请求资源的访问被服务器拒绝</p><p>  <strong>404 not found</strong> 表示在服务器上没有找到请求的资源</p><p>  <strong>500 internal sever error</strong> 表示服务器端在执行请求时发生了错误</p><p>  <strong>503 service unavailable</strong> 表明服务器暂时处于超负载或正在停机维护，无法处理请求</p><p>（4）HTTP中常见的文件格式</p><p>  text&#x2F;html： HTML格式</p><p>  text&#x2F;plain：纯文本格式</p><p>  image&#x2F;jpeg：jpg图片格式</p><p>  application&#x2F;json： JSON数据格式</p><p>  application&#x2F;x-www-form-urlencoded： form表单数据被编码为key&#x2F;value格式发送到服务器（表单默认的提交数据格式）</p><p>  multipart&#x2F;form-data： 在表单中进行文件上传时使用</p><ul><li><p>get请求与post请求有什么区别？</p><ul><li><p>一般<strong>get是幂等的，post不是</strong>。幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。</p><p>GET 只是查询数据，所以不会影响服务器的资源，所以<strong>GET是幂等性的</strong>。</p><p>POST因为每次调用都会生在后台新建资源，所以<strong>POST不是幂等性的。</strong></p><p>相关问题：一个用户下单点外卖，此时进入了高铁隧道没信号了，于是多点了几下，如何处理这种重复的请求？</p><p>用 Token 的机制实现防止重复提交。</p><p>简单的说就是调用方在调用接口的时候先向后端请求一个全局 ID（Token），请求的时候携带这个全局 ID 一起请求（Token 最好将其放到 Headers 中），后端把 Token 作为 Key存入redis；服务端接收到请求后根据 Token 到 Redis 中查找该 key 是否存在，如果 Key 存在就执行删除命令，然后正常执行后面的业务逻辑；不存在就是重复提交。</p></li></ul><ul><li><p>GET请求会被浏览器主动cache，而且在浏览器中 GET 请求可以保存为书签（因为幂等），而POST不会，除非手动设置（cache）。</p></li><li><p>对参数的数据类型，GET只接受ASCII字符，而POST没有限制。</p></li><li><p>GET参数通过URL传递，传送的参数是有长度限制的，POST放在Request body中，无长度限制。</p></li><li><p>get请求产生一个TCP数据包；post请求产生两个TCP数据包（get请求，浏览器会把http header和data一并发送出去，服务器响应200返回数据；post请求，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 返回数据）</p></li></ul></li></ul><h5 id="HTTP和HTTPS"><a href="#HTTP和HTTPS" class="headerlink" title="HTTP和HTTPS"></a>HTTP和HTTPS</h5><ul><li>HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL&#x2F;TLS 安全协议，使得报文能够加密传输。</li><li>HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL&#x2F;TLS 的握手过程，才可进入加密报文传输。</li><li>两者的默认端口不一样，HTTP 默认端口号是 80，HTTPS 默认端口号是 443。</li><li>HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。</li></ul><h4 id="Cookie和Session"><a href="#Cookie和Session" class="headerlink" title="Cookie和Session"></a>Cookie和Session</h4><ul><li><p>cookie和session的区别是什么？</p><ol><li>存储位置不同：cookie存放于客户端；session存放于服务端，占用服务器内存。</li><li>存储容量不同：单个cookie保存的数据&lt;&#x3D;4KB，一个站点最多保存20个cookie；而session并没有上限。</li><li>隐私策略不同：cookie对客户端是可见的，别有用心的人可以分析存放在本地的cookie并进行cookie欺骗，所以它是不安全的；session存储在服务器上，对客户端是透明的，不存在敏感信息泄露的风险。</li><li>生命周期不同：可以通过设置cookie的属性，达到cookie长期有效的效果；session依赖于名为JSESSIONID的cookie，而该cookie的默认过期时间为-1，只需关闭窗口该session就会失效，因此session不能长期有效。</li><li>浏览器支持不同：cookie是需要浏览器支持的，如果客户端禁用了cookie，则会话跟踪就会失效；运用session就需要使用URL重写的方式，所有用到session的URL都要进行重写，否则session会话跟踪也会失效。</li><li>跨域支持不同：cookie支持跨域访问，session不支持跨域访问。</li></ol></li><li><p>session的工作原理</p><p>session依赖于cookie。</p><p>当客户端首次访问服务器时，服务器会为其创建一个session对象，该对象具有一个唯一标识SESSIONID。并且在响应阶段，服务器会创建一个cookie，并将SESSIONID存入其中。</p><p>客户端通过响应的cookie而持有SESSIONID，所以当它再次访问服务器时，会通过cookie携带这个SESSIONID。服务器获取到SESSIONID后，就可以找到与之对应的session对象，进而从这个session中获取该客户端的状态。</p></li></ul><h4 id="消息推送"><a href="#消息推送" class="headerlink" title="消息推送"></a>消息推送</h4><h5 id="短轮询"><a href="#短轮询" class="headerlink" title="短轮询"></a>短轮询</h5><p><strong>轮询(polling)</strong> 应该是实现消息推送方案中最简单的一种，这里我们暂且将轮询分为短轮询和长轮询。</p><p>短轮询很好理解，指定的时间间隔，由浏览器向服务器发出 HTTP 请求，服务器实时返回未读消息数据给客户端，浏览器再做渲染显示。</p><p>一个简单的 JS 定时器就可以搞定，每秒钟请求一次未读消息数接口，返回的数据展示即可。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 方法请求</span></span><br><span class="line">  <span class="title function_">messageCount</span>().<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (res.<span class="property">code</span> === <span class="number">200</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">messageCount</span> = res.<span class="property">data</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>效果还是可以的，短轮询实现固然简单，缺点也是显而易见，由于推送数据并不会频繁变更，无论后端此时是否有新的消息产生，客户端都会进行请求，势必会对服务端造成很大压力，浪费带宽和服务器资源。</p><h5 id="长轮询"><a href="#长轮询" class="headerlink" title="长轮询"></a>长轮询</h5><p>长轮询是对上边短轮询的一种改进版本，在尽可能减少对服务器资源浪费的同时，保证消息的相对实时性。长轮询在中间件中应用的很广泛，比如 Nacos 和 Apollo 配置中心，消息队列 Kafka、RocketMQ 中都有用到长轮询。</p><p>长轮询其实原理跟轮询差不多，都是采用轮询的方式。不过，如果服务端的数据没有发生变更，会 <strong>一直 hold 住请求</strong>，直到服务端的数据发生变化，或者等待一定时间超时才会返回。返回后，客户端又会立即再次发起下一次长轮询。</p><p>缺点：</p><p>1、保持连接会消耗资源。</p><p>2、服务器没有返回有效数据，程序超时</p><h5 id="SSE-Server-Send-Events"><a href="#SSE-Server-Send-Events" class="headerlink" title="SSE(Server-Send Events)"></a>SSE(Server-Send Events)</h5><p><a href="https://html.spec.whatwg.org/multipage/server-sent-events.html#server-sent-events">HTML Standard (whatwg.org)</a></p><p>SSE 是 HTML5 遵循 W3C 标准提出的客户端和服务端之间进行实时通信的协议。与 WebSocket 作用相似，都可以建立服务端与浏览器之间的通信，实现服务端向客户端推送消息，但还是有些许不同：</p><ul><li>SSE 是<strong>基于 HTTP 协议</strong>的，它们不需要特殊的协议或服务器实现即可工作（不需要额外部署）；WebSocket <strong>需单独服务器</strong>来处理协议。</li><li>SSE 单向通信，<strong>只能由服务端向客户端单向通信</strong>；WebSocket 全双工通信，即通信的双方可以同时发送和接受信息。</li><li>SSE <strong>实现简单</strong>开发成本低，无需引入其他组件；WebSocket 传输数据需做二次解析，开发门槛高一些。</li><li>SSE 默认<strong>支持断线重连</strong>，如果连接断开，浏览器会尝试重新连接；WebSocket 则需要自己实现。</li><li>SSE <strong>只能传送文本消息</strong>，二进制数据需要经过编码后传送；WebSocket 默认支持传送二进制数据。</li><li>SSE单个浏览器单个域名只能打开6个链接</li></ul><p>SSE 好像一直不被大家所熟知，一部分原因是出现了 WebSocket，这个提供了更丰富的协议来执行双向、全双工通信。对于游戏、即时通信以及需要双向近乎实时更新的场景，拥有双向通道更具吸引力。</p><p>但是，在某些情况下，不需要从客户端发送数据。而你只需要一些服务器操作的更新。比如：站内信、未读消息数、状态更新、股票行情、监控数量等场景（Chat-GPT网页端流式数据推送、百度的文心一言也是用SSE实现），SSE 不管是从实现的难易(Spring MVC内置支持，<strong>轻量级</strong>)和成本上都更加有优势。此外，SSE 具有 WebSocket 在设计上缺乏的多种功能，例如：<strong>自动重新连接</strong>、事件 ID 和发送任意事件的能力。</p><p>SSE 在服务器和客户端之间打开一个单向通道，本质其实就是一个HTTP的长连接，但服务端响应的不再是一次性的数据包而是<code>Content-Type: text/event-stream</code>类型的数据流信息，在有数据变更时从服务器流式传输到客户端。客户端可以在不同的页面上使用同一个连接来接收事件流。这意味着无论客户端打开了多少个页面，<strong>只需要维护一个连接</strong>即可。</p><p>轮询是 请求-响应-请求-响应</p><p>SSE是 请求-响应-响应-响应</p><p><a href="https://cloud.tencent.com/developer/article/2280164?areaSource=102001.9&traceId=uLgnP3DiUuqDeR9Jnubjz">https://cloud.tencent.com/developer/article/2280164?areaSource=102001.9&amp;traceId=uLgnP3DiUuqDeR9Jnubjz</a></p><blockquote><p>SSE（Server-Sent Events）连接在客户端关闭连接或者服务器关闭连接时会自动释放。</p><p>当客户端关闭连接时，浏览器会发送一个 <code>close</code> 事件给服务器，服务器在收到该事件后会关闭连接并释放资源。</p><p>当服务器关闭连接时，服务器会发送一个 <code>close</code> 事件给客户端，客户端在收到该事件后会关闭连接并释放资源。</p><p>需要注意的是，SSE 连接是一种长连接，它可以持续地向客户端推送数据。因此，在使用 SSE 连接时需要注意定时发送心跳包，以保持连接的稳定性。如果长时间没有数据传输，可能会导致连接被关闭。</p></blockquote><h5 id="Websocket"><a href="#Websocket" class="headerlink" title="Websocket"></a>Websocket</h5><p>Websocket是一种在 TCP 连接上进行全双工通信的协议，建立客户端和服务器之间的通信渠道。浏览器和服务器仅需一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。</p><p>SpringBoot 整合 Websocket，先引入 Websocket 相关的工具包，和 SSE 相比额外的开发成本。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引入websocket --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-websocket<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Websocket与SSE性能对比：很接近，体现不出差距，ws要略微好一点</p><p><a href="https://www.timeplus.com/post/websocket-vs-sse">https://www.timeplus.com/post/websocket-vs-sse</a></p><h3 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h3><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><ul><li><strong>内部排序</strong>：数据记录在内存中进行排序。</li><li>**<a href="https://zh.wikipedia.org/wiki/%E5%A4%96%E6%8E%92%E5%BA%8F">外部排序open in new window</a>**：因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。</li><li><strong>稳定性</strong>：排序前后两个大小相同的元素的相对位置不变</li></ul><p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/sorting-algorithms/sort1.png" alt="十大排序算法"></p><ol><li>插入排序的最好时间复杂度为 O(n) 而不是 O(n^2) 。</li><li>希尔排序的平均时间复杂度为 O(nlogn)</li></ol><h5 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h5><p>简言之，两重循环，不断比较相邻两个元素，让这两个元素相对有序。</p><ol><li><p>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</p></li><li><p>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</p></li><li><p>针对所有的元素重复以上的步骤，除了最后一个；</p></li><li><p>重复步骤 1~3，直到排序完成。</p></li></ol><ul><li><strong>稳定性</strong>：稳定</li><li><strong>时间复杂度</strong>：最佳：O(n) ，最差：O(n2)， 平均：O(n2)</li><li><strong>空间复杂度</strong>：O(1)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 升序排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 当数组已经有序，无需二重循环</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                swap(arr, j, j + <span class="number">1</span>);</span><br><span class="line">                <span class="comment">// Change flag</span></span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h5><p>简言之，不断选择最小&#x2F;最大的元素，交换到已排序序列的末尾</p><ol><li>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置</li><li>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</li><li>重复第 2 步，直到所有元素均排序完毕。</li></ol><ul><li><strong>稳定性</strong>：稳定</li><li><strong>时间复杂度</strong>：最佳：O(n) ，最差：O(n2)， 平均：O(n2)</li><li><strong>空间复杂度</strong>：O(1)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 升序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">selectionSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">minIndex</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[minIndex]) &#123;</span><br><span class="line">                minIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (minIndex != i) &#123;</span><br><span class="line">            swap(arr, minIndex, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h5><p>简言之，不断选择下一个元素，插入到已排序序列中合乎顺序的指定位置</p><ol><li><p>从第一个元素开始，该元素可以认为已经被排序；</p></li><li><p>取出下一个元素，在已经排序的元素序列中从后向前扫描；</p></li><li><p>如果该元素（已排序）大于新元素，将该元素移到下一位置；</p></li><li><p>重复步骤 3，直到找到已排序的元素小于或者等于新元素的位置；</p></li><li><p>将新元素插入到该位置后；</p></li><li><p>重复步骤 2~5。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">insertionSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">preIndex</span> <span class="operator">=</span> i - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        <span class="keyword">while</span> (preIndex &gt;= <span class="number">0</span> &amp;&amp; current &lt; arr[preIndex]) &#123;</span><br><span class="line">            arr[preIndex + <span class="number">1</span>] = arr[preIndex];</span><br><span class="line">            preIndex -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[preIndex + <span class="number">1</span>] = current;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h5><p>快速排序用到了分治思想，同样的还有归并排序。乍看起来快速排序和归并排序非常相似，都是将问题变小，先排序子串，最后合并。不同的是快速排序在划分子问题的时候经过多一步处理，将划分的两组数据划分为一大一小，这样在最后合并的时候就不必像归并排序那样再进行比较。但也正因为如此，划分的不定性使得快速排序的时间复杂度并不稳定。</p><p>快速排序的基本思想：通过一趟排序将待排序列分隔成独立的两部分，其中一部分记录的元素均比另一部分的元素小，则可分别对这两部分子序列继续进行排序，以达到整个序列有序。</p><p><strong>算法步骤</strong></p><p>快速排序使用<a href="https://zh.wikipedia.org/wiki/%E5%88%86%E6%B2%BB%E6%B3%95">分治法open in new window</a>（Divide and conquer）策略来把一个序列分为较小和较大的 2 个子序列，然后递回地排序两个子序列。具体算法描述如下：</p><ol><li>从序列中<strong>随机</strong>挑出一个元素，做为 “基准”(<code>pivot</code>)；</li><li>重新排列序列，将所有比基准值小的元素摆放在基准前面，所有比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个操作结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li><li>递归地把小于基准值元素的子序列和大于基准值元素的子序列进行快速排序.</li></ol><ul><li><strong>稳定性</strong>：不稳定（意义：初始顺序有意义，比如按多个字段排序）</li><li><strong>时间复杂度</strong>：最佳：O(nlogn)， 最差：O(nlogn)，平均：O(nlogn)（每次划分代价n，递归深度nlogn）</li><li><strong>空间复杂度</strong>：O(logn)（主要的空间消耗来自于递归调用和分区操作。每次递归调用都需要在栈上保存一些信息，包括递归函数的参数、返回地址等。而分区操作需要使用额外的空间来存储左右子数组的临时数据。递归树高度logn）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> low, <span class="type">int</span> high)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> partition(arr, low, high);</span><br><span class="line">        quickSort(arr, low, pivot-<span class="number">1</span>);</span><br><span class="line">        quickSort(arr, pivot+<span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 左边比pivot小，右边比pivot大，返回pivot位置</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> low, <span class="type">int</span> high)</span>&#123;</span><br><span class="line">    <span class="comment">// 取最左元素为基准</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> arr[low];</span><br><span class="line">    <span class="keyword">while</span> (low &lt; high)&#123;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; arr[high] &gt;= pivot) &#123;</span><br><span class="line">            --high;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[low] = arr[high];</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; arr[low] &lt;= pivot) &#123;</span><br><span class="line">            ++low;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[high] = arr[low];</span><br><span class="line">    &#125;</span><br><span class="line">    arr[low] = pivot;</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>在数据基本有序的情况下，快排的时间复杂度会退化为O(n^2)，如何优化？</p><ul><li>三数取中法：在选择枢轴元素时，不是简单地选择第一个或最后一个元素，而是选择中间的元素。具体做法是，从待排序数组的头、尾、中间三个位置分别取出一个元素，然后选择这三个元素的中位数作为枢轴元素。这样可以尽可能地避免选择到极端的元素，从而提高快排的效率。</li></ul><ul><li>插入排序：在快排的递归过程中，当待排序数组的大小小于一个阈值时（比如10），可以采用插入排序来代替快排。因为在数据规模较小的情况下，快排可能还要递归好几次，相比之下插入排序的时间复杂度更低，而且插入排序对于基本有序的数据排序效果更好。这样可以避免递归深度过深，提高快排的效率。</li></ul></li><li><p>第k小 <a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/">https://leetcode.cn/problems/kth-largest-element-in-an-array/</a></p><p>我们对数组 <code>a[l⋯r] </code>做快速排序的过程是：</p><ul><li>分解： 将数组<code>a[l⋯r]</code>「划分」成两个子数组<code> a[l⋯q−1]、a[q+1⋯r]</code>，使得 <code>a[l⋯q−1] </code>中的每个元素小于等于 <code>a[q]</code>，且<code>a[q]</code>小于等于 <code>a[q+1⋯r] </code>中的每个元素。其中，计算下标 q 也是「划分」过程的一部分。</li><li>解决： 通过递归调用快速排序，对子数组 <code>a[l⋯q−1] </code>和<code>a[q+1⋯r]</code>进行排序。</li><li>合并： 因为子数组都是原址排序的，所以不需要进行合并操作，<code>a[l⋯r]</code> 已经有序。</li><li>上文中提到的 「划分」 过程是：从子数组 <code>a[l⋯r] </code>中选择任意一个元素 x 作为主元，调整子数组的元素使得左边的元素都小于等于它，右边的元素都大于等于它， x 的最终位置就是 q。</li></ul><p>由此可以发现每次经过「划分」操作后，我们一定可以确定一个元素的最终位置，即 x 的最终位置为 q，并且保证<code>a[l⋯q−1]</code>中的每个元素小于等于 <code>a[q]</code>，且 <code>a[q]</code> 小于等于 <code>a[q+1⋯r]</code> 中的每个元素。所以只要某次划分的 q 为倒数第 k 个下标的时候，我们就已经找到了答案。 我们只关心这一点，至于 <code>a[l⋯q−1] </code>和 ⋯<code>a[q+1⋯r] </code>是否是有序的，我们不关心。</p><p>因此我们可以改进快速排序算法来解决这个问题：在分解的过程当中，我们会对子数组进行划分，如果划分得到的 q 正好就是我们需要的下标，就直接返回 a[q]；否则，如果 q 比目标下标小，就递归右子区间，否则递归左子区间。这样就可以把原来递归两个区间变成只递归一个区间，提高了时间效率。这就是「快速选择」算法。</p><p>我们知道快速排序的性能和「划分」出的子数组的长度密切相关。直观地理解如果每次规模为 n 的问题我们都划分成 1 和 n−1，每次递归的时候又向 n−1 的集合中递归，这种情况是最坏的，时间代价是 O(n^2)。我们可以引入随机化来加速这个过程，它的时间代价的期望是 O(n)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">kthSmall</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> low, <span class="type">int</span> high, <span class="type">int</span> k)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> partition(arr, low, high);</span><br><span class="line">    <span class="keyword">if</span>(pivot == k)&#123;</span><br><span class="line">        <span class="keyword">return</span> arr[pivot];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pivot &gt; k)&#123;</span><br><span class="line">        <span class="keyword">return</span> kthSmall(arr, low, pivot - <span class="number">1</span>, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> kthSmall(arr, pivot + <span class="number">1</span>, high, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> low, <span class="type">int</span> high)</span>&#123;</span><br><span class="line">    <span class="comment">// 取最左元素为基准</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> arr[low];</span><br><span class="line">    <span class="keyword">while</span> (low &lt; high)&#123;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; arr[high] &gt;= pivot) &#123;</span><br><span class="line">            --high;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[low] = arr[high];</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; arr[low] &lt;= pivot) &#123;</span><br><span class="line">            ++low;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[high] = arr[low];</span><br><span class="line">    &#125;</span><br><span class="line">    arr[low] = pivot;</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><h5 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h5><p>完全二叉树的数组表示。</p><ul><li>所有的节点都大于（或小于）等于它的子节点</li><li>左侧子节点的位置是 2 * index + 1</li><li>右侧子节点的位置是 2 * index + 2 （也就是在左子节点的基础上 + 1）</li><li>父节点的位置是 (index - 1) &#x2F; 2</li></ul><h4 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h4><h5 id="如何判断某-URL-是否存在于-100-亿条数据中"><a href="#如何判断某-URL-是否存在于-100-亿条数据中" class="headerlink" title="如何判断某 URL 是否存在于 100 亿条数据中"></a>如何判断某 URL 是否存在于 100 亿条数据中</h5><p>现在想要实现一个网页过滤系统，利用该系统可以根据网页的 URL 判断该网页是否在黑名单上，黑名单现在已经包含 100 亿个不安全网页的 URL，每个网页的 URL 最多占用 64B（字节） 大小。</p><p>请设计该系统， 要求：</p><ol><li>该系统允许有万分之一以下的判断失误率 </li><li>使用的额外空间不要超过 30GB</li></ol><p><strong>布隆过滤器</strong>。</p><p>布隆过滤器的基本构造，其实就是一个 BitMap（更简单点来说其实就是一个数组），BitMap 中每个位上的元素由若干个哈希函数进行赋值。布隆过滤器的优势在于<strong>使用很少的空间就可以将准确率做到很高的程度</strong>（但想做到完全正确是不可能的）。</p><p>那么假设这时又来了一个新值，如何判断这个新值之前是否已经存在呢？（如何判断某个网页的 URL 是否在黑名单上呢？）</p><p>记这个网页的 URL 为 <code>input</code>，想检查它是否是存在于黑名单（BitMap）中，就把 <code>input</code> 通过同样的 k 个哈希函数，得到 k 个值，然后继续同样地把 k 个值取余（%m），就得到在 [0, m-1] 范围上的 k 个值，接下来在 BitMap 上看这些位置是不是都为黑：</p><ul><li>如果有一个<strong>不为</strong>黑，说明 <code>input</code> <strong>一定不在</strong>这个 BitMap 里 </li><li>如果都<strong>为</strong>黑，说明 a <strong>可能</strong>在这个 BitMap 里，也就是说存在误判的可能性</li></ul><p>解释具体一点，如果 <code>input</code> 的确是之前已经处理过的 URL，那么在生成布隆过滤器时，BitMap 中相应的 k 个位置一定已经涂黑了，所以在检查阶段，<code>input</code> 执行一遍相同的操作，肯定不会产生误判的。</p><p>会产生误判的是，<code>input</code> 明明<strong>不是</strong>之前已经处理过的输入对象，但由于哈希冲突的存在，可能就那么巧，两个不同的输入得到的 k 个哈希输出都是一样的（当然概率会非常小），那么在检查 <code>input</code> 时，可能 <code>input</code> 对应的 k 个位置都是黑的，从而错误地认为 <code>input</code> 是输入对象。</p><p>所以用布隆过滤器设计的系统，总结来说就是：<strong>黑名单中存在的 URL，一定能够检查出来，黑名单中不存在的 URL，有比较小的可能性被误判</strong>。</p><p>对于这种误判，其实也有解决方案，那就是白名单，<strong>对已经发现的误报数据我们可以通过建立白名单来防止再次误报</strong>。</p><p>比如，已经发现 <code>www.baidu.com</code> 这个样本不在布隆过滤器（黑名单）中，但是每次计算后的结果都显示其在布隆过滤器中，那么就可以把这个样本加入白名单中，以后这个样本再次输入的时候，就不会进入布隆过滤器的逻辑进行判断了。</p><h5 id="只用2GB内存在20亿个整数中找到出现次数top100的数"><a href="#只用2GB内存在20亿个整数中找到出现次数top100的数" class="headerlink" title="只用2GB内存在20亿个整数中找到出现次数top100的数"></a>只用2GB内存在20亿个整数中找到出现次数top100的数</h5><p>想要在很多整数中找到出现次数最多的数，通常的做法是使用哈希表对出现的每一个数做词频统计。</p><p>哈希表的key需要占用4B，value也是4B。</p><p>本题共有20亿个数，用32位的整数就可以表示其出现的次数，而不会产生溢出，但哈希表的一条记录(key, value)需要占用8B，当哈希表记录数为2亿个时需要至少1.6GB的内存。极端情况下20亿个数都不同，这样内存可能会不够用。</p><p>解决办法是把包含20亿个数的大文件用<strong>足够好的哈希函数分成21个小文件，根据哈希函数的性质，相同的数一定会在同一个文件中，我们这个时候就可以统计每个文件中出现次数最多的数，然后再从这些数中再次选出最多的数</strong>。</p><ol><li>最开始还是用哈希分流的思路来处理，把包含百亿数据量的词汇文件分流到不同的机器上；</li><li>如果对每一台机器来说分到的数据量依然很大，可以再用哈希函数把每台机器的分流文件拆成更小的文件处理；</li><li>处理每一个小文件的时候，哈希表统计每种词及其词频后再遍历。在遍历的过程中使用大小为100的小根堆来选出每一个小文件的top100，再将小根堆里的词按照词频排序，就得到了每个小文件的排序后top100；</li><li>然后把各个小文件排序后的top100进行外排序或者继续利用小根堆，选出每台机器上的top100；</li><li>不同机器之间的top100再进行外排序或者继续利用小根堆，最终求出整个百亿数据量中的top100。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> test200亿URL() <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\inputFilePath.txt&quot;</span>);</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(file));</span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">while</span> ((line = reader.readLine()) != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 按hash分为20个文件</span></span><br><span class="line">            <span class="type">FileWriter</span> <span class="variable">fileWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(file.getParent() + <span class="string">&quot;\\&quot;</span> +</span><br><span class="line">                    <span class="comment">// String 的Hashcode可能是负数</span></span><br><span class="line">                    (line.hashCode() &amp; Integer.MAX_VALUE % <span class="number">20</span>) + <span class="string">&quot;.txt&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">            <span class="comment">// \r\n表示回车换行</span></span><br><span class="line">            fileWriter.write(line + <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">            fileWriter.flush();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 小顶堆,TreeMap按key排序，所以这里用优先队列</span></span><br><span class="line">        PriorityQueue&lt;Map.Entry&lt;String, Integer&gt;&gt; priorityQueue =</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; a.getValue() - b.getValue());</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i++ &lt; <span class="number">20</span>)&#123;</span><br><span class="line">            <span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(file.getParent() + <span class="string">&quot;\\&quot;</span> + i + <span class="string">&quot;.txt&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>(!file1.exists())&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">FileReader</span> <span class="variable">fileReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(file1);</span><br><span class="line">            <span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(fileReader);</span><br><span class="line">            String line1;</span><br><span class="line">            Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">            <span class="comment">// 用hashmap统计当前文件的词频</span></span><br><span class="line">            <span class="keyword">while</span> ((line1 = bufferedReader.readLine()) != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(map.containsKey(line1))&#123;</span><br><span class="line">                    map.put(line1, map.get(line1) + <span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    map.put(line1, <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            map.entrySet().stream().forEach(entry -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (priorityQueue.size() &lt; <span class="number">100</span>)&#123;</span><br><span class="line">                    priorityQueue.add(entry);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span>(entry.getValue() &gt; priorityQueue.element().getValue())&#123;</span><br><span class="line">                        priorityQueue.remove();</span><br><span class="line">                        priorityQueue.add(entry);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(file.getParent() + <span class="string">&quot;\\&quot;</span> + <span class="string">&quot;result.txt&quot;</span>,<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : priorityQueue) &#123;</span><br><span class="line">            System.out.println();</span><br><span class="line">            fw.write(entry.getKey() + <span class="string">&quot; &quot;</span> + entry.getValue() + <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        fw.flush();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="两个栈模拟队列"><a href="#两个栈模拟队列" class="headerlink" title="两个栈模拟队列"></a>两个栈模拟队列</h5><p>从栈的数据结构出发，元素item1和元素item2分别进入inStack再出栈进入outStack，因为栈后进先出的特点，两次入栈出栈操作刚好能满足队列的先出先出，但很重要的一个点在于，每次元素item入队和出队时，都需考虑到inStack和outStack的情况：入队时确保outStack为空，所有元素再inStack栈中，出队时确保inStack为空，所有元素再outStack中，以保证队列的结构正确。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span>&lt;E&gt;&#123;</span><br><span class="line"><span class="comment">//定义两个栈，分别用于入队和出队</span></span><br><span class="line"><span class="keyword">private</span> Stack&lt;E&gt; inStack;</span><br><span class="line"><span class="keyword">private</span> Stack&lt;E&gt; outStack;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">MyQueue</span><span class="params">()</span> &#123;</span><br><span class="line">inStack =<span class="keyword">new</span> <span class="title class_">Stack</span>&lt;E&gt;();</span><br><span class="line">outStack =<span class="keyword">new</span> <span class="title class_">Stack</span>&lt;E&gt;();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//入队</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">offer</span><span class="params">(E item)</span> &#123;</span><br><span class="line"><span class="keyword">while</span>(!outStack.isEmpty()) &#123;</span><br><span class="line">inStack.push(outStack.pop());</span><br><span class="line">&#125;</span><br><span class="line">inStack.push(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//出队</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">poll</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">while</span>(!inStack.isEmpty()) &#123;</span><br><span class="line">outStack.push(inStack.pop());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> outStack.pop();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判空</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> inStack.size()==outStack.size();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h5><p>Java中可以用<code>Arrays.binarySearch</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="comment">// 或者(left + right) &gt;&gt;&gt; 1无符号右移，防止溢出。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid; <span class="comment">// 找到目标元素，返回索引</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>; <span class="comment">// 目标元素在右半部分，更新左边界</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>; <span class="comment">// 目标元素在左半部分，更新右边界</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// 目标元素不存在，返回 -1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><ul><li><p>CPU 占用高怎么排查？（以下来自Chat-GPT）</p><p>可能是由于系统负载高、进程<strong>死循环</strong>、进程阻塞等原因引起的。下面是一些排查高 CPU 占用的方法：</p><ol><li>查看系统负载：使用 <code>top</code> 命令可以查看系统的负载情况，如果系统负载较高，说明系统资源已经达到极限，需要考虑优化或升级硬件。</li><li>查看进程占用情况：使用 <code>top</code> 命令或者 <code>ps</code> 命令可以查看进程的 CPU 占用情况，如果某个进程的 CPU 占用较高，说明该进程可能存在问题，需要进一步排查。</li><li>查看进程调用栈：用jps查看java进程，使用 <code>jstack</code> 命令可以查看 Java 进程的调用栈信息，如果发现某个线程在死循环或者阻塞等情况，可以定位到具体的代码位置进行排查</li><li>使用性能分析工具：使用性能分析工具，如 <code>jstat</code>、<code>jprofiler</code>、<code>perf</code> 、<code>Arthas</code>等，可以对进程的性能进行详细分析，找出性能瓶颈所在。</li></ol><ul><li><p>CPU飙升？</p><p>可能是死循环。可以用Arthas的thread命令查看每个线程cpu占用，例如：</p><p><img src="http://oss.ripplesu.top/blog/Typora/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20231101155757756.png" alt="Arthas排查thread"></p><p><img src="http://oss.ripplesu.top/blog/Typora/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20231101160152955.png" alt="image-20231101160152955"></p></li></ul></li></ul><h4 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h4><ul><li><p>统计文件中某个单词出现的次数</p><p>grep -o ‘单词’ 文件路径 | wc -w</p><p>注：’|’为管道，前者命令的输出将作为后者的输入</p><p>查看大日志某个关键词的上下五行</p><p>grep -A 5 -B 5 “关键词” 文件名</p></li></ul><ul><li><p>目录</p><ul><li><p><code>ls</code>：显示目录中的文件和子目录的列表。</p></li><li><p><code>mkdir [选项] 目录名</code>：创建新目录（增）。</p></li><li><p><code>find [路径] [表达式]</code>：在指定目录及其子目录中搜索文件或目录（查），非常强大灵活。</p><p>例如：① 列出当前目录及子目录下所有文件和文件夹: <code>find .</code>；</p><p>② 在<code>/home</code>目录下查找以 <code>.txt</code> 结尾的文件名:<code>find /home -name &quot;*.txt&quot;</code> ,忽略大小写: <code>find /home -i name &quot;*.txt&quot;</code> ；</p><p>③ 当前目录及子目录下查找所有以 <code>.txt</code> 和 <code>.pdf</code> 结尾的文件:<code>find . \( -name &quot;*.txt&quot; -o -name &quot;*.pdf&quot; \)</code>或<code>find . -name &quot;*.txt&quot; -o -name &quot;*.pdf&quot;</code>。</p></li><li><p><code>pwd</code>：显示当前工作目录的路径。</p></li><li><p><code>rmdir [选项] 目录名</code>：删除空目录（删）。例如：<code>rmdir -p my_directory</code>，删除名为 <code>my_directory</code> 的空目录，并且会递归删除<code>my_directory</code>的空父目录，直到遇到非空目录或根目录。</p></li><li><p><code>rm [选项] 文件或目录名</code>：删除文件&#x2F;目录（删）。例如：<code>rm -r my_directory</code>，删除名为 <code>my_directory</code> 的目录，<code>-r</code>(recursive,递归) 表示会递归删除指定目录及其所有子目录和文件。</p></li><li><p><code>cp [选项] 源文件/目录 目标文件/目录</code>：复制文件或目录（移）。</p></li><li><p><code>mv [选项] 源文件/目录 目标文件/目录</code>：移动文件或目录（移），也可以用于重命名文件或目录。</p></li></ul></li><li><p>文件操作</p><ul><li><p><code>touch [选项] 文件名..</code>：创建新文件或更新已存在文件（增）。</p></li><li><p><code>ln [选项] &lt;源文件&gt; &lt;硬链接/软链接文件&gt;</code>：创建硬链接&#x2F;软链接。</p></li><li><p><code>cat/more/less/tail 文件名</code>：文件的查看（查） 。命令 <code>tail -f 文件</code> 可以对某个文件进行动态监控，例如 Tomcat 的日志文件， 会随着程序的运行，日志会变化，可以使用 <code>tail -f catalina-2016-11-11.log</code> 监控 文 件的变化 ；tail -n 指定行数，默认为10</p></li><li><p><code>vim 文件名</code>：修改文件的内容（改）。在实际开发中，使用 vim 编辑器主要作用就是修改配置文件，下面是一般步骤：<code>vim 文件------&gt;进入文件-----&gt;命令模式------&gt;按i进入编辑模式-----&gt;编辑文件 -------&gt;按Esc进入底行模式-----&gt;输入：wq/q!</code> （输入 wq 代表写入内容并退出，即保存；输入 q!代表强制退出不保存）。</p></li><li><p><code>tar -czvf 打包压缩后的文件名 要打包压缩的文件</code> ：压缩。其中：</p><ul><li>z：调用 gzip 压缩命令</li><li>c：打包文件</li><li>v：显示运行过程</li><li>f：指定文件名</li></ul><p><code>tar [-xzvf] 压缩文件</code></p></li></ul></li></ul><ul><li><p>系统状态</p><p><code>top [选项]</code>：用于实时查看系统的 <strong>CPU 使用率、内存使用率、进程信息</strong>等。</p><ul><li>-Hp Pid 查看某个进程的线程资源占用</li></ul><p><code>uptime [选项]</code>：用于查看系统总共运行了多长时间、系统的平均负载等信息。</p><p><code>vmstat [间隔时间] [重复次数]</code>：vmstat （Virtual Memory Statistics） 的含义为显示虚拟内存状态，但是它可以报告关于进程、内存、I&#x2F;O 等系统整体运行状态。</p><p><code>free [选项]</code>：用于查看系统的<strong>内存使用情况</strong>，包括已用内存、可用内存、缓冲区和缓存等。</p><p><code>df [选项] [文件系统]</code>：用于查看系统的<strong>磁盘空间使用情况</strong>，包括磁盘空间的总量、已使用量和可用量等，可以指定文件系统上。例如：<code>df -a</code>，查看全部文件系统。</p><p><code>du [选项] [文件]</code>：用于查看指定目录或文件的磁盘空间使用情况，可以指定不同的选项来控制输出格式和单位。</p><p><code>ps [选项]</code>：用于查看系统中的进程信息，包括进程的 ID、状态、资源使用情况等。<code>ps -ef</code>（“-e ”参数代表显示所有进程，“-f”参数代表全格式。）&#x2F;<code>ps -aux</code>：这两个命令都是查看当前系统正在运行进程，两者的区别是展示格式不同。如果想要查看特定的进程可以使用这样的格式：<code>ps aux|grep redis</code> （查看包括 redis 字符串的进程），也可使用 <code>pgrep redis -a</code>。</p><p><code>systemctl [命令] [服务名称]</code>：用于管理系统的服务和单元，可以查看系统服务的状态、启动、停止、重启等。</p></li><li><p>网络</p><p><code>ifconfig</code> 或 <code>ip</code>：用于查看系统的网络接口信息，包括网络接口的 IP 地址、MAC 地址、状态等。</p><p><code>netstat [选项]</code>：用于查看系统的网络连接状态和网络统计信息，可以查看当前的网络连接情况、监听端口、网络协议等</p><p><code>telnet</code>命令用于远端登入。执行telnet指令开启终端机阶段作业，并登入远端主机。</p><p><code>curl</code>命令: curl [ -O ] url   发送http网络请求。可以下载文件，获取信息（网页源码）</p><p>​-O 用于下载文件，当url是下载链接时，可以使用选项保存文件</p></li><li><p>权限</p><p><strong>修改文件&#x2F;目录的权限的命令：<code>chmod</code></strong></p><p>示例：修改&#x2F;test 下的 aaa.txt 的权限为文件所有者有全部权限，文件所有者所在的组有读写权限，其他用户只有读的权限。</p><p><strong><code>chmod u=rwx,g=rw,o=r aaa.txt</code></strong> 或者 <strong><code>chmod 764 aaa.txt</code></strong></p><p><strong>Linux 用户管理相关命令:</strong></p><ul><li><code>useradd [选项] 用户名</code>:创建用户账号。使用<code>useradd</code>指令所建立的帐号，实际上是保存在 <code>/etc/passwd</code>文本文件中。</li><li><code>userdel [选项] 用户名</code>:删除用户帐号。</li><li><code>usermod [选项] 用户名</code>:修改用户账号的属性和配置比如用户名、用户 ID、家目录。</li><li><code>passwd [选项] 用户名</code>: 设置用户的认证信息，包括用户密码、密码过期时间等。。例如：<code>passwd -S 用户名</code> ，显示用户账号密码信息。<code>passwd -d 用户名</code>: 清除用户密码，会导致用户无法登录。<code>passwd 用户名</code>，修改用户密码，随后系统会提示输入新密码并确认密码。</li><li><code>su [选项] 用户名</code>（su 即 Switch User，切换用户）：在当前登录的用户和其他用户之间切换身份。</li></ul></li><li><p>其他</p><ul><li><p>nohup ： 不挂断的运行，注意并没有后台运行的功能。：终端会话关闭时，会发送挂起信号（SIGHUP）给与终端相关联的进程。而使用 <code>nohup</code> 命令后，程序会忽略挂起信号，从而保证程序的持续运行。&amp;才是后台运行</p></li><li><p>配置文件 &#x2F;etc&#x2F;profile 重新加载：source &#x2F;etc&#x2F;profile</p></li><li><p>kill </p><p>默认-15 优雅关闭线程；有些时候，进程可能无法正常退出，此时使用kill命令可能无法终止进程。-9强制终止。</p></li></ul></li></ul><h5 id="相关面试题-1"><a href="#相关面试题-1" class="headerlink" title="相关面试题"></a>相关面试题</h5><ul><li><p>你应该常看日志吧，如何从Linux日志里面取出userId&#x3D;xxx，把xxx信息取出来</p><p><code>cat log | grep userId=xxx</code></p></li></ul><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><p>见博客</p><h3 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h3><p><a href="https://javaguide.cn/tools/maven/maven-core-concepts.html">https://javaguide.cn/tools/maven/maven-core-concepts.html</a></p><p><a href="http://www.mvnbook.com/maven-dependency-conflict.html">http://www.mvnbook.com/maven-dependency-conflict.html</a></p><p>clean 命令可以清除 Maven 构建生成的目录和文件，以便重新构建项目。执行 clean 命令将删除 target 目录和其他 Maven 生成的文件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean</span><br></pre></td></tr></table></figure><p>compile 命令可以编译 Maven 项目中的源代码，生成编译后的类文件，并将其输出到 target 目录下的 classes 目录中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn compile</span><br></pre></td></tr></table></figure><p>package 命令可以将 Maven 项目打包为一个可分发的格式，如 JAR、WAR 或 EAR 文件，并将其输出到 target 目录中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn package</span><br></pre></td></tr></table></figure><p>install 命令可以将 Maven 项目打包并安装到本地 Maven 仓库中。安装到本地仓库后，其他 Maven 项目可以引用该项目作为依赖项。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn install</span><br></pre></td></tr></table></figure><p>test 命令可以执行 Maven 项目中的单元测试，确保代码的正确性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn test</span><br></pre></td></tr></table></figure><p>dependency:tree 命令可以显示 Maven 项目的依赖关系树，以便开发人员更好地了解项目中使用的依赖项。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn <span class="attr">dependency</span>:tree</span><br></pre></td></tr></table></figure><h4 id="版本冲突"><a href="#版本冲突" class="headerlink" title="版本冲突"></a>版本冲突</h4><p>多个jar包依赖同一个jar包的不同版本。解决：留一个都可以用的版本，把其他版本排除掉</p><h4 id="依赖传递性"><a href="#依赖传递性" class="headerlink" title="依赖传递性"></a>依赖传递性</h4><p>Maven 依赖传递性是指，当一个 Maven 项目依赖于其他的 Maven 项目或者第三方库时，这些依赖的传递关系会被自动处理。</p><p>具体来说，当一个 Maven 项目依赖于其他的 Maven 项目或者第三方库时，Maven 会自动下载这些依赖，并将它们加入到项目的 classpath 中。如果这些依赖本身还依赖于其他的项目或者库，那么这些依赖的传递关系也会被自动处理。</p><p>例如，假设项目 A 依赖于项目 B，而项目 B 又依赖于项目 C 和 D，那么当你在项目 A 中引入项目 B 的依赖时，Maven 会自动下载并加入项目 B、C 和 D 的依赖，从而构建出一个完整的 classpath。</p><p>Maven 依赖传递性的优点在于，它可以自动处理依赖关系，避免手动管理依赖关系的繁琐和错误。但是，如果依赖传递关系过于复杂，可能会导致依赖冲突或者版本不一致的问题，需要进行手动调整。此外，由于 Maven 依赖传递性是自动处理的，可能会导致一些依赖没有被显式地声明，从而增加了项目的不确定性和维护难度。</p><h3 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h3><p>Docker 是一种开源的容器化平台，用于构建、部署和运行应用程序。它允许开发者将应用程序及其依赖项打包到一个称为容器的独立运行环境中，以便在不同的计算机上进行部署。每个容器都是一个轻量级、可移植和自包含的单元，具有自己的文件系统、运行时环境和资源。</p><p><strong>容器虚拟化的是操作系统而不是硬件，容器之间是共享同一套操作系统资源的。虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统。因此容器的隔离级别会稍低一些。</strong></p><ol><li><p>镜像（Image）：镜像是应用程序及其依赖项的打包格式。它包含了运行应用程序所需的一切，如操作系统、应用程序代码、运行时环境、库和其他依赖项。镜像是只读的，可以被多个容器使用。镜像可以从 Docker Hub 或其他镜像仓库获取，也可以通过 Dockerfile 来定义和构建。</p></li><li><p>容器（Container）：容器是从镜像创建的运行实例。每个容器都是一个隔离的进程空间，具有自己的文件系统、网络和进程。容器可以独立运行，也可以与其他容器进行通信和组合。容器提供了一种轻量级、可移植和可隔离的方式来运行应用程序。容器可以启动、停止、删除和重新创建，而不会影响其他容器或主机系统。</p><p>与拥有自己内核的虚拟机不同，容器只包含与特定发行版相关的所需文件，并使用共享主机内核。</p><p>我们可以在共享相同内核空间的单个主机上运行基于不同 Linux 发行版的容器。例如，我们可以在 Ubuntu 服务器上运行 RHEL、CentOS、基于 SUSE 的容器。因为对于所有 Linux 发行版，只有用户空间不同，内核空间相同。</p></li></ol><p>理解镜像和容器的关系可以类比为面向对象编程中的类和对象的关系。镜像相当于类的定义，它描述了应用程序的结构和属性。而容器则相当于类的实例化对象，它是根据镜像创建的运行实例。</p><p>通过使用镜像，我们可以创建多个相同或不同的容器来运行应用程序。每个容器都是相互隔离的，具有自己的运行环境，但共享同一个镜像作为基础。这种隔离性使得容器可以在不同的环境中运行，而不会相互干扰或冲突。</p><p><a href="https://javaguide.cn/tools/docker/docker-intro.html">https://javaguide.cn/tools/docker/docker-intro.html</a></p><h2 id="场景题与其他问题"><a href="#场景题与其他问题" class="headerlink" title="场景题与其他问题"></a>场景题与其他问题</h2><h3 id="系统日志规范"><a href="#系统日志规范" class="headerlink" title="系统日志规范"></a>系统日志规范</h3><p>系统日志规范及最佳实践：<a href="https://mp.weixin.qq.com/s/V-TIT1Cw5fH8xSYAEMyukQ">https://mp.weixin.qq.com/s/V-TIT1Cw5fH8xSYAEMyukQ</a></p><h3 id="正向代理与反向代理"><a href="#正向代理与反向代理" class="headerlink" title="正向代理与反向代理"></a>正向代理与反向代理</h3><p>正向代理（Forward Proxy）和反向代理（Reverse Proxy）是两种不同的代理服务器配置，它们在工作原理和使用方式上有着显著的区别。</p><ul><li>正向代理：</li></ul><p>　　客户端向代理服务器发送请求，并由代理服务器代表客户端与目标服务器通信。</p><p>　　<strong>代理服务器隐藏了客户端的真实身份和位置</strong>，目标服务器只能看到代理服务器的IP地址。</p><p>　　客户端通过配置代理服务器来访问外部资源，代理服务器可以绕过访问限制、提供缓存和性能优化，并增加访问安全性。</p><p>　　正向代理常见的应用场景包括：绕过网络限制、保护客户端隐私、提供缓存和优化、实施访问控制等。</p><ul><li>反向代理：</li></ul><p>　　反向代理的工作原理是，代理服务器来接受客户端的网络访问连接请求，然后服务器将请求有策略的转发给网络中实际工作的业务服务器，并将从业务服务器处理的结果，返回给网络上发起连接请求的客户端</p><p>　　反向代理<strong>隐藏了目标服务器的真实身份和位置</strong>，客户端只能看到反向代理的IP地址。</p><p>　　反向代理常见的应用场景包括：负载均衡、高可用性、缓存和加速、安全过滤和防护等。它可以提供可靠的请求分发、保护内部服务器、优化性能并增加安全性。</p><p>　　<strong>反向代理常用于Web应用部署中，将客户端的请求分发给多个内部服务器，以实现负载均衡和高可用性</strong>。</p><p>　　正向代理是代表客户端向目标服务器发送请求，隐藏客户端身份和位置的代理配置。它代表客户端与外部资源通信，常用于绕过访问限制、保护隐私、提供缓存和安全性。反向代理是代表目标服务器接收客户端请求，并将请求转发给内部服务器的代理配置。它隐藏了目标服务器身份和位置，常用于负载均衡、高可用性、缓存和安全防护。两者在代理方向、隐藏的对象和应用场景上有明显的区别。</p><h3 id="秒杀应该考虑哪些问题？"><a href="#秒杀应该考虑哪些问题？" class="headerlink" title="秒杀应该考虑哪些问题？"></a>秒杀应该考虑哪些问题？</h3><ol><li><p>超卖问题</p><p>分析秒杀的业务场景,最重要的有一点就是超卖问题，假如备货只有100个，但是最终超卖了200，一般来讲秒杀系统的价格都比较低，如果超卖将严重影响公司的财产利益，因此首当其冲的就是解决商品的超卖问题。</p></li><li><p>高并发</p><p>秒杀具有时间短、并发量大的特点，秒杀持续时间只有几分钟，而一般公司都为了制造轰动效应，会以极低的价格来吸引用户，因此参与抢购的用户会非常的多。短时间内会有大量请求涌进来，后端如何防止并发过高造成缓存击穿或者失效，击垮数据库都是需要考虑的问题。</p></li><li><p>接口防刷</p><p>现在的秒杀大多都会出来针对秒杀对应的软件，这类软件会模拟不断向后台服务器发起请求，一秒几百次都是很常见的，如何防止这类软件的重复无效请求，防止不断发起的请求也是需要我们针对性考虑的。</p></li><li><p>秒杀URL</p><p>对于普通用户来讲，看到的只是一个比较简单的秒杀页面，在未达到规定时间，秒杀按钮是灰色的，一旦到达规定时间，灰色按钮变成可点击状态。这部分是针对小白用户的，如果是稍微有点电脑功底的用户，会通过F12看浏览器的network看到秒杀的url，通过特定软件去请求也可以实现秒杀。或者提前知道秒杀url的人，一请求就直接实现秒杀了。这个问题我们需要考虑解决。</p></li></ol><p>秒杀系统的设计方案</p><ol><li><p>秒杀URL的设计</p><p>为了避免有程序访问经验的人通过下单页面url直接访问后台接口来秒杀货品，我们需要将秒杀的url实现动态化，即使是开发整个系统的人都无法在秒杀开始前知道秒杀的url。具体的做法就是通过md5加密一串随机字符作为秒杀的url，然后前端访问后台获取具体的url，后台校验通过之后才可以继续秒杀。</p></li><li><p>秒杀页面静态化</p><p>将商品的描述、参数、成交记录、图像、评价等全部写入到一个静态页面，用户请求不需要通过访问后端服务器，不需要经过数据库，直接在前台客户端生成，这样可以最大可能的减少服务器的压力。具体的方法可以使用freemarker模板技术，建立网页模板，填充数据，然后渲染网页。</p></li><li><p>单体redis升级为集群redis</p><p>秒杀是一个读多写少的场景，使用redis做缓存再合适不过。不过考虑到缓存击穿问题，我们应该构建redis集群，或采用哨兵模式，可以提升redis的性能和可用性。</p></li><li><p>使用Nginx(en-juhn-eks &#x2F; Engine-X)</p><p>nginx是一个高性能web服务器，它的并发能力可以达到几万，而tomcat只有几百。通过nginx映射客户端请求，再分发到后台tomcat服务器集群中可以大大提升并发能力。</p></li><li><p>精简SQL</p><p>典型的一个场景是在进行扣减库存的时候，传统的做法是先查询库存，再去update。这样的话需要两个sql，而实际上一个sql我们就可以完成的。可以用这样的做法：update miaosha_goods set stock&#x3D;stock-1 where goos_id&#x3D;</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习总结 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>GitHub Pages配置自定义域名并利用Cloudflare CDN加速</title>
      <link href="/2023/11/18/GitHub%20Pages%E9%85%8D%E7%BD%AE%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D/"/>
      <url>/2023/11/18/GitHub%20Pages%E9%85%8D%E7%BD%AE%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D/</url>
      
        <content type="html"><![CDATA[<p>Hexo部署网站到Github Pages后默认访问地址是xxx.github.io，如果想要自定义为自己的域名，该怎么做呢？</p><p>前置条件：</p><ul><li>一个GitHub Pages站点。</li><li>一个自己的域名</li></ul><h3 id="DNS解析"><a href="#DNS解析" class="headerlink" title="DNS解析"></a>DNS解析</h3><p>本人域名是在阿里云购买的，以下操作都以阿里云为例。</p><p>首先添加一条记录。以本人配置的为例，主机记录<code>blog</code>代表二级域名<code>blog.ripplesu.top</code>，记录值<code>s-lucien.github.io</code>即为原先Github Pages的默认网址。</p><p><img src="http://oss.ripplesu.top/blog/Typora/image-20231119150320326.png" alt="image-20231119150320326"></p><h3 id="Github-Pages绑定域名"><a href="#Github-Pages绑定域名" class="headerlink" title="Github Pages绑定域名"></a>Github Pages绑定域名</h3><p>仓库 -&gt; Setting -&gt; Pages -&gt; 在Custom domain中填入刚才配置的域名（例如我的是<code>blog.ripplesu.top</code>）</p><p><img src="http://oss.ripplesu.top/blog/Typora/image-20231119151217002.png" alt="image-20231119151217002"></p><h3 id="Cloudflare-CDN加速"><a href="#Cloudflare-CDN加速" class="headerlink" title="Cloudflare CDN加速"></a>Cloudflare CDN加速</h3><p>在国内直接访问Github Pages速度比较慢，可以考虑用CDN加速。本人使用的是Cloudflare，提供免费版并且没有流量限制。</p><details><summary>什么是CDN？以下来自ChatGPT：</summary>    CDN 是内容分发网络（Content Delivery Network）的缩写。它是一种通过将内容分发到全球各地的服务器网络，提供高效、快速内容传输的技术架构。</br>    传统的网络架构中，当用户请求访问一个网站或应用时，请求会直接发送到网站的源服务器，然后源服务器响应请求并返回内容给用户。这种方式可能会导致延迟和网络拥塞，特别是当用户与源服务器之间的距离较远时。</br>    CDN 的作用是通过在全球各地部署分布式的边缘节点服务器，将内容缓存到这些节点上，并根据用户的地理位置选择最近的节点来响应请求。这样一来，用户可以从离他们更近的服务器获取内容，减少了网络延迟和传输时间，提高了用户体验。</br>    CDN 还可以通过负载均衡和智能路由等技术，根据网络状况和服务器负载情况，动态选择最佳的节点来响应请求。这使得网站和应用在面对高流量和突发访问压力时能够更好地处理请求，并提供稳定可靠的服务。</br>    除了加速内容传输，CDN 还可以提供其他功能，如安全性增强、防御分布式拒绝服务攻击（DDoS）等。它已广泛应用于各种网站、应用、视频流媒体和软件分发等场景，为用户提供更快速、可靠的内容访问体验。</details>    <p>详细配置可以参考：<a href="http://ask.rbluntan.cn/hu/257.html%EF%BC%8C%E8%BF%99%E9%87%8C%E5%B0%B1%E4%B8%8D%E8%B5%98%E8%BF%B0%E4%BA%86%E3%80%82">http://ask.rbluntan.cn/hu/257.html，这里就不赘述了。</a></p><p>下面给出我的网站加速前后对比：</p><p>加速前：</p><p><img src="http://oss.ripplesu.top/blog/Typora/image-20231119150732568.png" alt="image-20231119150732568"></p><p>加速后：</p><p><img src="http://oss.ripplesu.top/blog/Typora/image-20231119150810284.png" alt="image-20231119150810284"></p><p>可以看到速度提升还是很明显的。</p><h3 id="其他问题：Hexo文章推送后自定义域名失效"><a href="#其他问题：Hexo文章推送后自定义域名失效" class="headerlink" title="其他问题：Hexo文章推送后自定义域名失效"></a>其他问题：Hexo文章推送后自定义域名失效</h3><p>在Github Pages绑定域名后，根目录下会生成一个CNAME文件，内容就是你配置的域名。</p><p>后续我们更新文章使用<code>hexo d</code>推送会导致该文件清除。</p><p>解决办法只需在<code>Hexo</code>的<code>source</code>目录下新增一个CNAME文件，内容就是你之前配置的域名。</p><p><img src="http://oss.ripplesu.top/blog/Typora/image-20231119152731698.png" alt="image-20231119152731698"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>工程经济期末复习</title>
      <link href="/2023/06/16/%E5%B7%A5%E7%A8%8B%E7%BB%8F%E6%B5%8E%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"/>
      <url>/2023/06/16/%E5%B7%A5%E7%A8%8B%E7%BB%8F%E6%B5%8E%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="第一章-技术经济学"><a href="#第一章-技术经济学" class="headerlink" title="第一章 技术经济学"></a>第一章 技术经济学</h2><h3 id="技术经济分析一般过程"><a href="#技术经济分析一般过程" class="headerlink" title="技术经济分析一般过程"></a>技术经济分析一般过程</h3><p><strong>第一，确定目标功能，即明确解决的问题。</strong></p><p><strong>第二，提出备选方案。</strong></p><p>  （由工程师、产品设计人员、销售部门、财务部门、工人技师等提出）</p><p><strong>第三，方案评价。</strong></p><p>  （净现值法、内部收益率法、盈亏平衡法等）</p><p><strong>第四，选择最优方案</strong></p><p>  （技术上可行，经济效益最佳的方案）</p><h3 id="技术经济关系"><a href="#技术经济关系" class="headerlink" title="技术经济关系"></a>技术经济关系</h3><ol><li><p><strong>两者之间相互依赖、相互影响、相互制约。</strong></p></li><li><p><strong>技术进步是经济发展的重要条件和手段，对 经济发展起巨大推动作用。</strong> 案例：美国的星球大战计划</p></li><li><p><strong>反过来，技术开发是一项高投入、高风险和周 期长的活动，其产生与应用都需要经济的支持，受到经济的制约。</strong></p><pre><code>据统计：美国研制一种一类新药需要投入数亿美元花费10到20年的研发周期；美国基础研究的成功率为 5%左右，技术开发的成功率为50%左右</code></pre></li><li><p><strong>技术和经济之间是协调发展的。</strong></p></li></ol><h3 id="技术经济学研究对象"><a href="#技术经济学研究对象" class="headerlink" title="技术经济学研究对象"></a>技术经济学研究对象</h3><ul><li>研究技术方案的经济效果，寻求最佳经济效果方案。</li><li>研究技术与经济相互促进与协调发展</li><li>研究技术创新，推动技术进步，促进企业发展和国民经济增长。</li></ul><h2 id="第二章-技术创新"><a href="#第二章-技术创新" class="headerlink" title="第二章 技术创新"></a>第二章 技术创新</h2><h3 id="为什么要研究创新"><a href="#为什么要研究创新" class="headerlink" title="为什么要研究创新"></a>为什么要研究创新</h3><p>1、技术创新是经济增长的根本动力，经济的持续增长来源于技术创新的持续活跃。</p><p>2、技术创新能弥补传统方式所无法弥补的增长鸿沟。</p><pre><code>传统方式：加强营销和销售、行业的自然增长率、消减成本、提高生产效率等</code></pre><p>3、当前创新管理的现实不尽如人意。</p><h3 id="什么是创新"><a href="#什么是创新" class="headerlink" title="什么是创新"></a>什么是创新</h3><p>创新(innovation)：<strong>指企业家对生产要素的重新组合，或者是说是建立一种新的生产函数，将生产要素的“新组合”引入生产体系</strong></p><h4 id="创新与R-D"><a href="#创新与R-D" class="headerlink" title="创新与R&amp;D"></a>创新与R&amp;D</h4><p>研究与开发（R&amp;D, research and development）是在系统的基础上进行的一项创造性工作，其目的在于丰富有关人类、文化和社会的知识库，并利用这一知识进行新的发明</p><p> （1）基础研究（basic research）</p><p> （2）应用研究（applied research）</p><p> （3）实验开发（development）</p><ul><li><p>创新与R&amp;D 的区别</p><p>  创新的产出：商业化过程；product-related</p><p>  R&amp;D的产出：论文、专利、设计图纸、样品等</p></li><li><p>创新与R&amp;D的关联</p><p>  （1）R&amp;D费用已经被普遍采用为创新投入的测度指标：R&amp;D、R&amp;D&#x2F;sales</p><p>  （2）R&amp;D与创新之间的关系是非线性的</p><p>  （3）技术创新始于R＆D而终于市场实现。</p></li></ul><h3 id="如何推动创新"><a href="#如何推动创新" class="headerlink" title="如何推动创新"></a>如何推动创新</h3><h2 id="第三章-经济性评价基本要素"><a href="#第三章-经济性评价基本要素" class="headerlink" title="第三章 经济性评价基本要素"></a>第三章 经济性评价基本要素</h2><p><strong>利润</strong> <strong>&#x3D;</strong> 销售收入 - 总成本 - 税金</p><p><strong>劳动生产率</strong>&#x3D;工业生产总值 &#x2F; 劳动者人数</p><p><strong>投资利润率</strong>&#x3D;（销售收入-总成本-税金）&#x2F; 投资</p><h3 id="现金流量"><a href="#现金流量" class="headerlink" title="现金流量"></a>现金流量</h3><p><strong>现金流入（Cash In Flow , CI）。</strong>流入系统的资金称为现金流入。如：销售（经营）收入、固定资产和流动资产回收、借款等。</p><p><strong>现金流出（ Cash Out Flow , CO）。</strong>流出系统的资金称为现金流出。如：投资、经营成本、税、贷款本息偿还等。</p><p><strong>净现金流量（NCF）。</strong>现金流入与现金流出之差：NCF＝CI－CO</p><h4 id="成本"><a href="#成本" class="headerlink" title="成本"></a>成本</h4><ul><li><p><strong>机会成本</strong>——<strong>是指如果一项资源既能用于甲用途，又能用于其它用途（由于资源的稀缺性，如果用于甲用途就必须放弃其他用途），那么资源用于甲用途的机会成本，就是资源用于次好的、被放弃的其它用途本来可以得到的净收入。</strong></p><p> <strong>例如</strong>，你现在有10000元，你可以以定期形式存在银行，也可以进行短期投资（比如炒股票）。假如存在银行的利息收入为1年1000元，而炒股票的年净收入约为3000元。那么，你选择炒股票的机会成本是1000元，如果你选择存入银行的机会成本是3000元。</p></li><li><p><strong>沉没成本</strong>——<strong>指过去已经支出而现在无法得到补偿的成本。它对企业经营决策不起决定作用。</strong></p><p>某百货公司打算购买一栋销售门市部，为此他为标价100万元的门市部交了20万元优先购买权的订金，若成交，补交80万元；若不成交，订金不予返还。但后来，他发现一栋同样理想的标价75万元的门市部。问应买哪家门市部？</p></li><li><p><strong>经营成本是从投资方案本身考察的，是在一定期间（通常为一年）内由于生产和销售产品及提供劳务而实际发生的现金支出。</strong></p><p><strong>经营成本＝总成本费用—折旧费—摊销费—财务费用</strong></p></li><li><p>会计成本——是会计记录在公司帐册上的实际支出，包括生产、 销售过程中发生的原料、工资、广告、利息等支出。</p></li><li><p>固定成本——在一定产量范围内不随产量变动而变动的费用。如管理人员工资、差旅费、设备折旧费、办公费用、利息支出等。</p><p><strong>特点：</strong></p><p>   <strong>1</strong>）其总额在一定时期和一定业务量范围内不随产量的增加而变动；</p><p>   <strong>2 )</strong> 就单位产品成本而言，其中的固定成本部分与产量的增减成反比，即产量增加时，单位产品的固定成本减少。</p></li><li><p>变动成本——成本中随产量变动而变动的费用，例如直接原材料、直接人工费、直接燃料和动力费及包装费等。</p><p><strong>特点：</strong></p><p> <strong>1</strong>）其变动成本总额随产量的增加而增加。</p><p> <strong>2 )</strong> 就单位产品成本而言，变动成本部分是固定不变的。</p></li><li><p><strong>经济成本是显性成本和隐性成本之和。</strong></p><p><strong>显性成本</strong>——看得见的实际成本（诸如企业购买原材料、设备、劳动力、支付借款利息）。</p><p><strong>隐性成本</strong>——指企业自有的资源，实际上已经投入，但在形式上没有支付报酬的那部分成本。</p></li><li><p><strong>边际成本</strong>——又称增量成本，是企业每增加一个单位产品产量所产生的成本增加量。即企业每增加一单位产量所支付的追加成本。</p><p>例如，生产某种产品100个单位时，总成本为5000元，单位产品成本为50元。若生产101个时，其总成本5 040元，则所增加一个产品的成本为40元，即边际成本为40元。</p></li></ul><h4 id="现金流量图"><a href="#现金流量图" class="headerlink" title="现金流量图"></a>现金流量图</h4><p><strong>用现金流量图来表示一切经济活动：</strong></p><p><strong>（1）横坐标（轴）表示时间(年末)；</strong></p><p><strong>（2）纵坐标（轴）表示现金流量。</strong></p><p><img src="http://oss.ripplesu.top/blog/%E5%B7%A5%E7%A8%8B%E7%BB%8F%E6%B5%8E%E5%A4%8D%E4%B9%A0/image-20231120144634303.png" alt="image-20231120144634303"></p><p><img src="http://oss.ripplesu.top/blog/%E5%B7%A5%E7%A8%8B%E7%BB%8F%E6%B5%8E%E5%A4%8D%E4%B9%A0/image-20231120144652227.png" alt="image-20231120144652227"></p><h3 id="资金时间价值"><a href="#资金时间价值" class="headerlink" title="资金时间价值"></a>资金时间价值</h3><p><strong>资金时间价值——不同时间发生的等额资金在价 值上的差别称为资金的时间价值。</strong> </p><p><strong>利息（或利润）——资金在单位时间内产生的增值。利息（或利润）是衡量资金时间价值的绝对尺度。</strong></p><p><strong>利率（收益率）——利息（或利润）与本金之比，称为“利率”或收益率，它是衡量资金时间价值的相对尺度，记作</strong>i。</p><ul><li><p>单利法</p><p><img src="http://oss.ripplesu.top/blog/%E5%B7%A5%E7%A8%8B%E7%BB%8F%E6%B5%8E%E5%A4%8D%E4%B9%A0/image-20231120144659779.png" alt="image-20231120144659779"></p></li><li><p>复利法</p><p><img src="http://oss.ripplesu.top/blog/%E5%B7%A5%E7%A8%8B%E7%BB%8F%E6%B5%8E%E5%A4%8D%E4%B9%A0/image-20231120144705569.png" alt="image-20231120144705569"></p></li></ul><p><strong>计息周期 —— 一年内计算利息周期的次数，用m来表示。计息周期有年、半年、季、月、周、日等。<br>实际利率 —— 将计息周期实际发生的利率称为计息周期实际利率，用 i来表示。<br>名义利率——计息周期的实际利率乘以每年计息周期数就得到名义利率，用 r来表示。<br>实际利率 i &#x3D;(1 + r／m)<sup>m</sup>  -1</strong><br>当m &#x3D;1时，i&#x3D;r；m&gt;1时，i &gt;r；m∞时，即一年中无限多次计息，连续复利计算。这时的实际利率称连续利率。</p><p><img src="http://oss.ripplesu.top/blog/%E5%B7%A5%E7%A8%8B%E7%BB%8F%E6%B5%8E%E5%A4%8D%E4%B9%A0/image-20231120144711652.png" alt="image-20231120144711652"></p><h4 id="资金等值"><a href="#资金等值" class="headerlink" title="资金等值"></a>资金等值</h4><p><strong>资金等值</strong>——是指在考虑资金时间价值因素后，不同时点上数额不等的资金在一定利率条件下具有相等的价值。<br>影响资金等值的因素有三个：<br>     资金额大小；资金发生的时间；利率<br>将一个时点发生的资金金额换算成另一时点的等值金额，这一过程叫资金等值计算。</p><p>**贴现与贴现率——把将来某一时点处资金金额折算成现在时点的等值金额称为贴现或折现。贴现时所用的利率称贴现率或折现率，用 i 表示。<br>现值——是指资金“现在”价值，用P 表示（Present Value）。<br>终值——现值在未来某一时点的资金金额称为终值或将来值，用F表示（Final Value）。<br>等年值—— 一定时期内每期有等额收支的资金值，用A表示（Annual Value ）。 **</p><h4 id="资金等值计算公式"><a href="#资金等值计算公式" class="headerlink" title="资金等值计算公式"></a>资金等值计算公式</h4><ul><li><p>一次性支付终值公式</p><p><img src="http://oss.ripplesu.top/blog/%E5%B7%A5%E7%A8%8B%E7%BB%8F%E6%B5%8E%E5%A4%8D%E4%B9%A0/image-20231120144717998.png" alt="image-20231120144717998"></p></li><li><p>一次支付现值公式</p><p><img src="http://oss.ripplesu.top/blog/%E5%B7%A5%E7%A8%8B%E7%BB%8F%E6%B5%8E%E5%A4%8D%E4%B9%A0/image-20231120144722828.png" alt="image-20231120144722828"></p></li><li><p>等额分付终值公式</p><p><img src="http://oss.ripplesu.top/blog/%E5%B7%A5%E7%A8%8B%E7%BB%8F%E6%B5%8E%E5%A4%8D%E4%B9%A0/image-20231120144726588.png" alt="image-20231120144726588"></p><p><img src="http://oss.ripplesu.top/blog/%E5%B7%A5%E7%A8%8B%E7%BB%8F%E6%B5%8E%E5%A4%8D%E4%B9%A0/image-20231120144930689.png" alt="image-20231120144930689"></p><p><img src="http://oss.ripplesu.top/blog/%E5%B7%A5%E7%A8%8B%E7%BB%8F%E6%B5%8E%E5%A4%8D%E4%B9%A0/image-20231120144731008.png" alt="image-20231120144731008"></p></li><li><p>等额分付偿债基金公式<br>$$<br>A &#x3D; F(A／F，i ，n) \qquad A&#x3D;F\frac{i}{(1+i)^{n}-1}<br>$$<br><img src="http://oss.ripplesu.top/blog/%E5%B7%A5%E7%A8%8B%E7%BB%8F%E6%B5%8E%E5%A4%8D%E4%B9%A0/image-20231120144737819.png" alt="image-20231120144737819"></p><p>解：<font color = 'red'>A &#x3D; F(A／F，i ，n)</font>&#x3D;6×(A／F，12% ，5) &#x3D; 6 × 0.15741 &#x3D;0.9445（万元）</p><p>如果是年初存款，应多算1年利息，即0.9445&#x2F;1.12</p></li><li><p>等额分付现值公式<br>$$<br>P＝A×(P／A，i ，n)<br>$$</p><p>$$<br>F&#x3D;A\frac{(1+i)^{n}-1}{i} \quad P&#x3D;\frac{F}{(1+i)^{n}}<br>\quad P&#x3D;A\frac{(1+i)^{n}-1}{i(1+i)^{n}}<br>$$</p><p><img src="http://oss.ripplesu.top/blog/%E5%B7%A5%E7%A8%8B%E7%BB%8F%E6%B5%8E%E5%A4%8D%E4%B9%A0/image-20231120144744248.png" alt="image-20231120144744248"></p></li><li><p>资金回收公式<br>$$<br>A＝P×(A／P，i ，n) \quad A&#x3D;P\frac{i(1+i)^{n}}{(1+i)^{n}-1}<br>$$<br><img src="http://oss.ripplesu.top/blog/%E5%B7%A5%E7%A8%8B%E7%BB%8F%E6%B5%8E%E5%A4%8D%E4%B9%A0/image-20231120144747877.png" alt="image-20231120144747877"></p></li></ul><h2 id="第四章-经济性评价办法"><a href="#第四章-经济性评价办法" class="headerlink" title="第四章 经济性评价办法"></a>第四章 经济性评价办法</h2><h3 id="投资回收期法"><a href="#投资回收期法" class="headerlink" title="投资回收期法"></a>投资回收期法</h3><p><strong>投资回收期——是指投资回收的期限。也就是投资方案所产生的净现金收入回收初始全部投资所需的时间。通常用“年”表示。<br>静态投资回收期：不考虑资金时间价值因素。<br>动态投资回收期：考虑资金时间价值因素。<br>投资回收期计算——一般从工程项目开始投入之日算起，即应包括项目的建设期。</strong></p><ul><li>静态投资回收期</li></ul><p>$$<br>投资回收期T&#x3D;累计净现金流量开始出现正值的年份-1+\frac{|上年累计净现金流量|}{当年净现金流量}<br>$$</p><p><img src="http://oss.ripplesu.top/blog/%E5%B7%A5%E7%A8%8B%E7%BB%8F%E6%B5%8E%E5%A4%8D%E4%B9%A0/image-20231120144753319.png" alt="image-20231120144753319"></p><ul><li>动态投资回收期</li></ul><p>$$<br>T&#x3D;累计净现金流量折现值开始出现正值的年份-1+\frac{|上年累计净现金流量折现值|}{当年净现金流量折现值}<br>$$</p><p><img src="http://oss.ripplesu.top/blog/%E5%B7%A5%E7%A8%8B%E7%BB%8F%E6%B5%8E%E5%A4%8D%E4%B9%A0/image-20231120144756894.png" alt="image-20231120144756894"></p><p><em>折现</em>,将未来收入折算成等价的现值</p><table><thead><tr><th><strong>年份</strong></th><th><strong>0</strong></th><th><strong>1</strong></th><th><strong>2</strong></th><th><strong>3</strong></th><th><strong>4</strong></th><th><strong>5</strong></th><th><strong>6</strong></th></tr></thead><tbody><tr><td><strong>1．现金流入</strong></td><td></td><td></td><td><strong>5000</strong></td><td><strong>6000</strong></td><td><strong>8000</strong></td><td><strong>8000</strong></td><td><strong>7500</strong></td></tr><tr><td><strong>2．现金流出</strong></td><td><strong>6000</strong></td><td><strong>4000</strong></td><td><strong>2000</strong></td><td><strong>2500</strong></td><td><strong>3000</strong></td><td><strong>3500</strong></td><td><strong>3500</strong></td></tr><tr><td><strong>3．净现金流量（1-2)</strong></td><td><strong>-6000</strong></td><td><strong>-4000</strong></td><td><strong>3000</strong></td><td><strong>3500</strong></td><td><strong>5000</strong></td><td><strong>4500</strong></td><td><strong>4000</strong></td></tr><tr><td><strong>5．折现系数  (i&#x3D;10%)</strong></td><td></td><td><strong>0.909</strong></td><td><strong>0.826</strong></td><td><strong>0.751</strong></td><td><strong>0.683</strong></td><td><strong>0.62</strong></td><td><strong>0.565</strong></td></tr><tr><td><strong>6．净现金流量折现值</strong></td><td><strong>-6000</strong></td><td><strong>-3636</strong></td><td><strong>2479</strong></td><td><strong>2630</strong></td><td><strong>3415</strong></td><td><strong>2794</strong></td><td><strong>2258</strong></td></tr><tr><td><strong>7．累计净现金流量折现值</strong></td><td><strong>-6000</strong></td><td><strong>-9636</strong></td><td><strong>-7157</strong></td><td><strong>-4527</strong></td><td><strong>-1112</strong></td><td><strong>1682</strong></td><td><strong>3940</strong></td></tr></tbody></table><p>Tp &#x3D; 5 -1 + |-1112| &#x2F;  2794 &#x3D; 4.4 年</p><h3 id="现值法"><a href="#现值法" class="headerlink" title="现值法"></a>现值法</h3><ul><li>净现值（NPV）——是指项目（或方案）在寿命期内各年的净现金流量（CI－CO）t，按照一定的折现率i，折现到期初时点的现值之和，其表达式为：（CO现金流出，CI现金流入）</li></ul><p>$$<br>NPV&#x3D;\sum_{t&#x3D;0}^{n}(CI-CO)_t(1+i)^{-t}<br>$$</p><p><img src="http://oss.ripplesu.top/blog/%E5%B7%A5%E7%A8%8B%E7%BB%8F%E6%B5%8E%E5%A4%8D%E4%B9%A0/image-20231120144800542.png" alt="image-20231120144800542"><br>$$<br>NPV(10%) &#x3D; -1000 + 300(P&#x2F;A,10%,4) + 500(P&#x2F;F,10%,5)&#x3D;261.42<br>$$</p><ul><li><p>净终值</p><p>方<strong>案的净终值（NFV）——是指方案在寿命期内各年的净现金流量（CI－CO）t ，按照一定的折现率 i，折现到期末时的终值之和，其表达式为</strong><br>$$<br>NPV&#x3D;\sum_{t&#x3D;0}^{n}(CI-CO)<em>t(1+i_0)^t&#x3D;\sum</em>{t&#x3D;0}^{n}(CI-CO)_t(F&#x2F;P,i_0,t)<br>$$<br>F存入银行 &#x3D; 1000(F&#x2F;P,10%,5)&#x3D;1611</p><p>F借给朋友 &#x3D; 300(F&#x2F;A,10%,4) (F&#x2F;P,10%,1)+500 &#x3D;2032.02 </p><p>F借给朋友 - F存入银行 &#x3D; 2032.02 – 1611 &#x3D; 421.02</p><p>NFV（10%）&#x3D; -1000 (F&#x2F;P,10%,5)+300(F&#x2F;A,10%,4) (F&#x2F;P,10%,1)+500 &#x3D;421.02</p></li><li><p>净年值</p><p>方案的净年值NAV——是通过资金等值计算，将项目的净现值NPV（或净终值NFV）分摊到寿命期内各年的等额年值。与净现值是等效评价指标。其表达式为：<br>$$<br>NAV &#x3D; NPV(A&#x2F;P,i,n)&#x3D; NFV(A&#x2F;F,i,n)<br>$$</p><ul><li><p>用NPV&#x2F;NFV&#x2F;NAV评价方案的准则：<br>若NAV ≥ 0，则方案是经济合理的；<br>若NAV ＜ 0，则方案应予否定。</p><p>方案NAV＞0，意味着方案除能达到规定的基准收益率之外，还能获得超额收益；<br>方案NAV&#x3D;0，则意味着方案正好达到了规定的基准收益率水平；<br>方案NAV ＜ 0 ，意味着方案达不到规定的基准收益率水平。</p></li></ul></li><li><p>费用现值与费用年值</p><p>PC或AC最小的方案为最优方案。<br>$$<br>费用现值PC&#x3D;\sum_{t&#x3D;0}^{n}CO_t(P&#x2F;F,i,t)<br>$$</p><p>$$<br>费用年值AC&#x3D;PC(A&#x2F;P,i,n)&#x3D;\sum_{t&#x3D;0}^{n}CO_t(P&#x2F;F,i,t)(A&#x2F;P,i,n)<br>$$</p><p><img src="http://oss.ripplesu.top/blog/%E5%B7%A5%E7%A8%8B%E7%BB%8F%E6%B5%8E%E5%A4%8D%E4%B9%A0/image-20231120144806119.png" alt="image-20231120144806119"></p><p>PC(A)&#x3D;70+13（P&#x2F;A,15%,10）&#x3D;135.2<br>PC(B)&#x3D;100+10（P&#x2F;A,15%,5）+15（P&#x2F;A,15%,5） （P&#x2F;F,15%,5） &#x3D;158.5</p><p>AC(A)&#x3D;70(A&#x2F;P,15%,10)+13&#x3D;26.9<br>AC(B)&#x3D;100(A&#x2F;P,15%,10)+10(P&#x2F;A,15%,5)(A&#x2F;P,15%,10) +15(F&#x2F;A,15%,5)(A&#x2F;F,15%,10)&#x3D;31.7</p></li></ul><h3 id="内部收益率IRR"><a href="#内部收益率IRR" class="headerlink" title="内部收益率IRR"></a>内部收益率IRR</h3><p>**内部收益率（IRR）简单地说就是净现值NPV为零时的折现率。 **<br>$$<br>NPV&#x3D;\sum_{t&#x3D;0}^{n}(CI-CO)_t(1+IRR)^{-t}&#x3D;0<br>$$<br> 一般情况下，当IRR ≥ i0时，NPV（ i0 ）≥0;当IRR＜ i0时，NPV（ i0 ）＜0 </p><p>因此，对于单个方案的评价，内部收益率IRR准则与净现值NPV准则，其评价结论是一致的。</p><p><strong>由于内部收益率方程通常为高次方程，不易求解，因此一般采用“试算内插法”求IRR的近似值。</strong></p><p><img src="http://oss.ripplesu.top/blog/%E5%B7%A5%E7%A8%8B%E7%BB%8F%E6%B5%8E%E5%A4%8D%E4%B9%A0/image-20231120144810252.png" alt="image-20231120144810252"></p><p>例：</p><p><img src="http://oss.ripplesu.top/blog/%E5%B7%A5%E7%A8%8B%E7%BB%8F%E6%B5%8E%E5%A4%8D%E4%B9%A0/image-20231120144813127.png" alt="image-20231120144813127"></p><p>例： 一个项目的初始投资为10000元，以后每年均等地获得净收益2000元，项目寿命期为10年。试求内部收益率。 </p><p>NPV(10%)&#x3D; -10000+2000 (P&#x2F;A,10%,10) &#x3D;2081.03<br>NPV(15%)&#x3D; -10000+2000 (P&#x2F;A,15%,10) &#x3D; 32.64<br>NPV(20%)&#x3D; -10000+2000 (P&#x2F;A,20%,10) &#x3D; -1345.88<br>$$<br>\frac{IRR-15%}{20%-15%}&#x3D;\frac{32.64}{1345.88+32.64} \quad IRR&#x3D;15.1%<br>$$</p><h3 id="备选方案"><a href="#备选方案" class="headerlink" title="备选方案"></a>备选方案</h3><ul><li><p>年值法(NAV或者AC)</p><p>一个城市准备修建城市下水系统，有两个被选的提议。第一个寿命为20年，第二个寿命为40年，初期投资分别为1亿元和1.5亿元。两者的收益均为每年0.3亿元，基准收益率是12%，无残值。应选择哪个提议？</p><p>NAV1&#x3D;0.3-1×(A&#x2F;P,12%,20)&#x3D; 0.166亿元NAV2&#x3D;0.3-1.5(A&#x2F;P,12%,40)&#x3D; 0.1亿元<br>应选择第1方案。</p></li><li><p>最小公倍数法(NPV或者PC)</p><p>以各备选方案的寿命周期的最小公倍数作为比选的共同期限，假定各个方案均在这样一个共同的期限内反复实施，对各个方案分析期内各年的净现金流量换算到现值（即NPV法），按最小公倍数进行重复计算，直到分析期结束</p></li><li><p>研究期法(NPV或者PC)</p><p>是针对寿命期不同的互斥方案，直接选取一个适当的分析期作为各个方案共同的研究期，通过比较各个方案在该研究期内的净现值NPV（或者PC）来比选方案。<br>研究期的选择一般以各方案中寿命最短方案为比较的研究期。这种方法计算简便，而且可以避免重复性假设。</p><p>研究期法涉及寿命期结束后，方案的未使用价值的处理问题。其处理方式有三种：<br>第一种考虑方案研究期以外未使用价值；<br>第二种不考虑方案研究期以外未使用价值；<br>第三种预测方案未使用价值在研究期末的价值，并作为现金流入量计算</p></li></ul><p><img src="http://oss.ripplesu.top/blog/%E5%B7%A5%E7%A8%8B%E7%BB%8F%E6%B5%8E%E5%A4%8D%E4%B9%A0/image-20231120144816584.png" alt="image-20231120144816584"></p><ul><li><p>解：年值法</p><p>用净年值(NAV )评价两方案：<br> NAV_A  &#x3D; –10 ( A &#x2F; P,10％,6) + 3 +1.5 ( A／F,10％,6) &#x3D;  0.90 (万元)<br> NAV_B  &#x3D;– 15 ( A／P,10％,9) + 4 + 2 ( A&#x2F;F,10％,9)   &#x3D; 1.54(万元)<br> 所以， B优于A。</p></li><li><p>研究期法</p><p><img src="http://oss.ripplesu.top/blog/%E5%B7%A5%E7%A8%8B%E7%BB%8F%E6%B5%8E%E5%A4%8D%E4%B9%A0/image-20231120144939441.png" alt="image-20231120144939441"></p><ul><li><p>方法一，考虑研究期以外方案未利用价值</p><p>NPVA&#x3D; -10+3 (P&#x2F;A,10%,6) +1.5(P&#x2F;F,10%,6) &#x3D;3.9&gt;0<br>NPVB&#x3D; -15(A&#x2F;P,10%,9) (P&#x2F;A,10%,6) +4 (P&#x2F;A,10%,6) +2(A&#x2F;F,10%,9) (P&#x2F;A,10%,6) &#x3D;6.70&gt;0<br>∴ B比A好</p></li><li><p>方法二，不考虑研究期结束方案未利用价值</p><p>NPVA&#x3D; -10+3 (P&#x2F;A,10%,6) +1.5(P&#x2F;F,10%,6) &#x3D;3.9&gt;0<br>NPVB&#x3D; -15+4 (P&#x2F;A,10%,6) &#x3D;2.42&gt;0<br>A比 B好。</p></li><li><p>方法三，预计研究期结束方案未利用价值为4万元</p><p>NPVA&#x3D; -10+3 (P&#x2F;A,10%,6)+1.5(P&#x2F;F,10%,6)&#x3D;3.9&gt;0<br>NPVB&#x3D; -15+4 (P&#x2F;A,10%,6) ＋ 4(P&#x2F;F,10%,6)&#x3D;4.678&gt;0，　　<br>B 比 A好。</p></li></ul></li></ul><h3 id="不确定性评价"><a href="#不确定性评价" class="headerlink" title="不确定性评价"></a>不确定性评价</h3><p>不确定性评价——主要分析各种外部条件发生变化（如投资、产量、原料价格等发生变化）或者测算数据误差对方案经济效果的影响程度，主要考察方案本身对不确定性因素的承受能力。</p><h4 id="盈亏平衡"><a href="#盈亏平衡" class="headerlink" title="盈亏平衡"></a>盈亏平衡</h4><p><strong>盈亏平衡分析法（BEP法）——是通过分析产品产量、成本和盈利之间的关系，找出方案盈利和亏损在产量、单价、成本等方面的临界点，以判断不确定性因素对方案经济效果的影响程度，说明方案实施风险的大小。</strong></p><p><strong>盈亏平衡点（BEP）：项目的总收入和总成本支出相等时，即不亏不盈状态下的保本产量或保本销售量以及保本单价。</strong></p><p>  利润π＝单价P × 销量Q－（固定成本Cf＋变动成本 Cv × Q）<br>$$<br>Q^*&#x3D;\frac{Cf+利润π}{P*(1-税率)-Cv} \quad P^*&#x3D;C_v+\frac{Cf}{Q_0}<br>$$</p><p>$$<br>盈亏平衡生产能力利用率E&#x3D;\frac{保本销量Q^*}{预期或实际销量Q_0}<em>100%<br>\quad 经营安全率&#x3D;\frac{Q_0-Q^</em>}{Q_0}*100%<br>$$</p><p><img src="http://oss.ripplesu.top/blog/%E5%B7%A5%E7%A8%8B%E7%BB%8F%E6%B5%8E%E5%A4%8D%E4%B9%A0/image-20231120144821021.png" alt="image-20231120144821021"></p><h4 id="敏感性分析"><a href="#敏感性分析" class="headerlink" title="敏感性分析"></a>敏感性分析</h4><p>不确定性因素中对方案经济效果影响程度较大的因素，称之为敏感性因素。<br>敏感性分析法——是分析各种不确定性因素变化一定幅度时（或者变化到何种幅度），对项目方案经济效果的影响程度（或者改变对方案的选择）的一种不确定分析方法。<br>投资者必须及时把握敏感性因素，从敏感性因素发生变化的可能性，分析方案的风险大小。</p><p>分析重点：<br>          1）选择哪些不确定因素作为敏感性因素进行分析。<br>          2）确定敏感性分析的评价指标。</p><p>不确定因素：</p><p> 1）投资额，包括固定资产投资与流动资金占用；<br> 2）产品销售量；<br> 3）产品价格；<br> 4）经营成本，特别是变动成本；<br> 5）汇率、利率；<br> 6）资产残值。</p><p>步骤：</p><p>确定分析的经济效益指标。<br>评价投资项目的经济效益指标主要包括：净现值、内部收益率、投资利润率、投资回收期等。<br>选定不确定性因素，设定其变化范围。<br>计算不确定性因素变动对项目经济效益指标的影响程度，找出敏感性因素。<br>绘制敏感性分析图，求出不确定性因素变化的极限值。</p><h2 id="第六章-设备更新与租赁决策"><a href="#第六章-设备更新与租赁决策" class="headerlink" title="第六章 设备更新与租赁决策"></a>第六章 设备更新与租赁决策</h2><h3 id="设备磨损、补偿与折旧"><a href="#设备磨损、补偿与折旧" class="headerlink" title="设备磨损、补偿与折旧"></a>设备磨损、补偿与折旧</h3><p>设备磨损有<strong>有形磨损、无形磨损</strong>二种形式。</p><ol><li><p>有形磨损（又称物理磨损）<br> 第Ⅰ种有形磨损：设备使用时在<strong>力的作用</strong>下，其零部件到整个设备受到摩擦、冲击、振动或疲劳，使设备的实体遭受到损伤。通常表现为：<br>（1）零部件原始尺寸的改变，甚至其形状发生改变；<br>（2）公差配合性质的改变，以及精度的降低；<br>（3）零部件的损坏。<br> 第Ⅱ种有形磨损：设备在闲置中受到<strong>自然力</strong>的作用产生锈蚀，或是由于缺乏必要的保护、保养而自然丧失精度和工作能力，产生物质磨损。</p></li><li><p>无形磨损（又称精神磨损）<br>第Ⅰ种无形磨损：设备的技术结构和性能并没有变化，但由于设备制造厂<strong>制造工艺不断改进，劳动生产率不断提高而使得生产相同机器设备所需的社会必要劳动减少</strong>，因而使原来购买的设备价值相应贬值了。</p><p>第Ⅱ种无形磨损是由于<strong>科学技术的进步，不断创新出性能更完善、效率更高的设备</strong>，使原有设备相对陈旧落后，其经济效益相对降低而发生贬值。</p></li></ol><p>补偿方式：大修理、现代化改装和更新</p><p>大修理：是更换部分已磨损的零部件和调整设备，以恢复设备的生产功能和效率为主；<br>现代化改造：是对设备的结构作局部的改进和技术上的革新，如增添新的、必须的零部件，以增加设备的生产功能和效率为主。这两者都属于局部补偿。<br>更新：是对整个设备进行更换，属于全部补偿。</p><p>折旧：</p><p><strong>设备资产的折旧</strong>：按期或按活动量将设备磨损转成为产品的成本费用的方式。<br><strong>折旧费</strong>：按期或按活动量转为产品成本费用的设备资产的损耗价值。<br>计算设备折旧时，应考虑以下三个因素：设备资产的原值、净残值和折旧年限。</p><ol><li>设备资产的原值。一般为购置设备时一次性支付的费用，又称初始费用。</li><li>净残值。即设备的残值减去其清理费用以后的余额。</li><li>折旧年限。即按财政部规定的折旧率每年提取折旧，使设备的帐面价值为零所需要的时间。</li></ol><ul><li><p>直线折旧法</p><p>又称平均年限法，它是在设备资产估算的折旧年限里按期平均分摊资产价值的一种计算方法。其每期折旧费的表达式为<br>$$<br>D&#x3D;\frac{P-S}{N_d} \quad 每期折旧率d&#x3D;\frac{D}{P}*100%<br>$$<br>式中：D——每期折旧费，元；<br>        S——折旧期末资产净残值，元；<br>        P——资产的原值，元；<br>      ND——资产的折旧期，单位一般为年；<br> 其中   S＝ S0 － Sc<br>       式中：S0——折旧期末资产预计残值，元；<br>                   Sc——折旧期末预计清理费用，元。</p></li><li><p>年数和折旧法<br>$$<br>D_m&#x3D;\frac{2(N_D-m+1)}{N_D(N_D+1)}(P-S) \quad 折旧率d&#x3D;\frac{D_m}{P}*100%<br>$$</p></li></ul><ul><li><p>双倍余额递减法</p><p>折旧率是按<strong>直线折旧法折旧率的两倍</strong>计算的。这也是一种典型的加速折旧法。<br>年折旧率为：d &#x3D; (2&#x2F;折旧年限) x100%</p></li></ul><p>某设备的资产原值为 10 000元，估计报废时的残值为1000元，清理费用为 0 元，折旧年限为 10 年。计算其年折旧额、折旧率。</p><p><img src="http://oss.ripplesu.top/blog/%E5%B7%A5%E7%A8%8B%E7%BB%8F%E6%B5%8E%E5%A4%8D%E4%B9%A0/image-20230617221004929.png" alt="折旧对比"></p><h3 id="设备更新"><a href="#设备更新" class="headerlink" title="设备更新"></a>设备更新</h3><p>设备更新决策时，应该遵守下面两个原则：<br><strong>不考虑沉没成本</strong>。在设备更新分析中，经常会遇到沉没成本的概念。沉没成本一般不会影响方案的新选择。例如，某设备3年前的原始成本是15 000元，目前的帐面价值是5 000元，现在的净残值仅为3 000元。在进行设备更新分析时，3年前的原始成本为15 000元是过去发生的而与现在决策无关，因此是沉没成本。目前该设备的价值等于净残值3 000元。<br><strong>不要从方案直接陈述的现金流量进行比较分析，而应该立于一个客观介入的立场上比较分析</strong>。</p><ul><li><strong>设备寿命</strong><ol><li>设备的自然寿命，又称物质寿命，即设备从投入使用开始，直到因为在使用过程中发生物质磨损而不能继续使用、报废为止所经历的时间。它主要是由设备的有形磨损所决定的。</li><li>设备的技术寿命，又称有效寿命。它是指设备在市场上维持其价值的时期。具体地说，是指从设备开始使用到因技术落后而被淘汰所延续的时间。它主要是由设备的无形磨损所决定的。</li><li>设备的经济寿命。它是指设备从投入使用开始倒因继续使用不经济而被更新所经历的时间。</li></ol></li></ul><h4 id="年值法"><a href="#年值法" class="headerlink" title="年值法"></a>年值法</h4><p>年值法是指将研究期内的现金流量折算成与之等值的等额支付系列，也即将现金流量年金化。它是估算设备的经济寿命常用的方法。一般情况是要进行逐年比较的，仍然应用年值法。假设年值为AW，年利率为i，则有表达式：<br>$$<br>AW&#x3D;<a href="A/P,i,N">CF_j(P&#x2F;F,i,j)-P</a><br>$$<br>例：某专用设备其购置安装费为12万元，前3年由制造单位保修，第4年、第5年的维护费均为2万元；第5年以后每年比前一年增加2.5万元。不论哪年更新，该设备的残值均不计。假定利率为10％，该设备的经济寿命是多少？</p><p>使用 3年的平均年费用AC＝ 12（A／P， 10％，3）＝ 12 × 0．4021＝4．825（万元）<br>使用 4年的平均年费用&#x3D;［12＋ 2（ P／F， 10％，4）］（A／P， 10％，4）＝（ 12＋ 2 ×0．6830） × 0．3155＝ 4．217（万元）<br>使用 5年的平均年费用&#x3D;［12＋ 2（ P／F， 10％，4）＋ 2（ P／F， 10％，5）］×（A／P，10％，5）＝ （l＋ 2 × 0．6830＋ 2 × 0．6209） ×0．2638＝ 3．854（万元）<br>使用6年的平均年费用＝［12＋2（P／F，10％，4）＋2（P／F，10％，5）＋4．5（P／F，10％，6）］×（A／P，10％，6）＝（12＋2 × 0．6830＋2 ×0．6209＋ 4．5 × 0．5645）× 0．2296＝ 3．937（万元）<br>该设备的经济寿命为5年。</p><h4 id="平均年费用法"><a href="#平均年费用法" class="headerlink" title="平均年费用法"></a>平均年费用法</h4><p>当设备项目的现金流量以考虑费用为主时，可用平均年费用（AAC，就是AC）法。</p><p>使用期为N年设备平均年费用为<strong>AAC＝（P－S）·（A／P，i，N）＋S·i＋Y0＋Ym</strong><br>式中：Y0——平均年营运费，元；Ym——平均年维修费，元</p><p><img src="http://oss.ripplesu.top/blog/%E5%B7%A5%E7%A8%8B%E7%BB%8F%E6%B5%8E%E5%A4%8D%E4%B9%A0/image-20231120144910466.png" alt="image-20231120144910466"></p><p>设新、旧设备的平均年费用分别为AACN与AAC0，则<br> AACN＝（35 000－4 000）×（A／P，12％，10）＋4 000 ×0.12＋500＝31 000 × 0．177＋480 ＋ 500<br>　　＝6  467（元）<br>AACo＝（8000－2000）×（A／P，12％，4）＋2 000×0.12＋[3 000（P／F，12％，1）＋4 000（P／F，12％，2）＋5 000（P／F，12％，3）＋6 000（P／F，12％，4）]（A／P，12％，4） ＝ 6000  × 0.3292＋240＋（3000  × 0.892  9＋4000×0．797 2＋5 000 ×0．7118＋6 000 × 0．635 5）×0.329 2＝6 503.27（元）<br>        AACN＜AACo，所以旧设备应该更换。 </p><p>保留一年：AAC0（1）＝（8 000－6 500）（A／P，12％，l）＋6 500 ×0.12＋3 000＝5460（元）＜6467（元），应保留。<br>保留2年：AAC0（2）＝（6 500－5 000）（A／P，12％，l）＋5 000 ×0.12＋4 000＝6280（元）＜6467（元），应保留。<br>保留3年：<br>AAC0（3）＝（5 000－3 500）×（A／P，12％，l）＋3 500 × 0.12＋5 000＝7100（元）＞6467元，应更换。<br>旧设备应继续保留使用2年，于第2年年末更换。</p><h2 id="第七章-价值工程"><a href="#第七章-价值工程" class="headerlink" title="第七章 价值工程"></a>第七章 价值工程</h2><h3 id="提高价值的五种途径"><a href="#提高价值的五种途径" class="headerlink" title="提高价值的五种途径"></a>提高价值的五种途径</h3><p>成本降低，功能提高</p><p>成本不变，功能提高</p><p>功能不变，成本下降</p><p>成本略有增加，功能大幅度提高</p><p>功能略有下降，成本大幅度下降</p><h3 id="价值工程定义-价值的定义"><a href="#价值工程定义-价值的定义" class="headerlink" title="价值工程定义 价值的定义"></a>价值工程定义 价值的定义</h3><p>价值工程：<strong>以产品或作业的功能分析为核心，以提高产品或作业的价值为目的，力求以最低寿命周期成本实现产品或作业使用所要求的必要功能的一项有组织的创造性活动。</strong></p><p>价值：价值工程中所述的价值，是指对象（产品或作业）具有的必要功能与取得该功能的总成本的比值，即效用（或功能）与费用之比。</p><h2 id="公式总结"><a href="#公式总结" class="headerlink" title="公式总结"></a>公式总结</h2><p><img src="http://oss.ripplesu.top/blog/%E5%B7%A5%E7%A8%8B%E7%BB%8F%E6%B5%8E%E5%A4%8D%E4%B9%A0/image-20231120144917001.png" alt="image-20231120144917001"></p>]]></content>
      
      
      <categories>
          
          <category> 学习总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工程经济 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于commons-pool2自定义对象池</title>
      <link href="/2023/03/22/%E5%9F%BA%E4%BA%8Ecommons-pool2%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AF%B9%E8%B1%A1%E6%B1%A0/"/>
      <url>/2023/03/22/%E5%9F%BA%E4%BA%8Ecommons-pool2%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AF%B9%E8%B1%A1%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<p>大多时候，我们获取对象的方法都是直接 new 一个。但是，对于构造耗时比较久的对象，比如数据库的连接对象、Redis 的连接对象、Http 连接请求对象等等，如果每次要使用都去 new 一个是很不科学的。在设计模式中有一个专门的模式来解决这种场景下的问题，即“享元模式”。  </p><p>“享元模式”其实很好理解，也就是构造一个对象池，这个对象池中维护一定数量的对象，需要的时候就从这个对象池中获取对象，使用完后返还给对象池。这样就避免构造对象所带来的耗时，提升了系统的性能。  </p><p>设计这样的一个对象池看起来好像并不难。但是，如果考虑到系统的伸缩性、健壮性，比如在系统忙时可能需要对象池中有足够的对象可以被拿来使用，同时，在系统闲时又不需要太多的对象存放在对象池中，以免浪费内存。另外，还需要考虑对象何时构造，何时销毁，对象异常的处理等问题。  </p><p>apache 的 commons-pool2正是为了解决这些问题而生。基于它，我们只需要关注对象的生成、销毁、校验等操作就可以了。对象池的具体实现细节都交给 commons-pool2 中的具体对象池实现类来完成。  </p><h3 id="commons-pool2-核心接口"><a href="#commons-pool2-核心接口" class="headerlink" title="commons-pool2 核心接口"></a>commons-pool2 核心接口</h3><p>apache commons-pool2 包提供了一个通用的对象池技术的实现。可以很方便的基于它来实现自己的对象池，比如 DBCP 和 Jedis 他们的内部对象池的实现就是依赖于 commons-pool2 。<br>commons-pool2 由三大模块组成：ObjectPool 、PooledObject 和 PooledObjectFactory 。  </p><h4 id="ObjectPool"><a href="#ObjectPool" class="headerlink" title="ObjectPool"></a>ObjectPool</h4><p>提供所有对象的存取管理。<br>核心方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从对象池中获取对象的方法</span></span><br><span class="line">T <span class="title function_">borrowObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception, NoSuchElementException,</span><br><span class="line">        IllegalStateException;</span><br><span class="line"><span class="comment">//将对象返还给对象池</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">returnObject</span><span class="params">(T obj)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line"><span class="comment">//让对象失效</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">invalidateObject</span><span class="params">(T obj)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line"><span class="comment">//往对象池中新增一个对象</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">addObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception, IllegalStateException,</span><br><span class="line">        UnsupportedOperationException;</span><br><span class="line"><span class="comment">//获取当前闲置在对象池中的对象数量，即没有被拿走使用的对象数量</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getNumIdle</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">//获取已经在使用中的对象数量，即被使用者从对象池中拿走使用的数量</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getNumActive</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">//清空对象池中闲置的所有对象</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> <span class="keyword">throws</span> Exception, UnsupportedOperationException;</span><br><span class="line"><span class="comment">//关闭对象池</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><h4 id="PooledObjectFactory"><a href="#PooledObjectFactory" class="headerlink" title="PooledObjectFactory"></a>PooledObjectFactory</h4><p>工厂类，负责池化对象的创建，对象的初始化，对象状态的销毁和对象状态的验证。其实现要求是线程安全的。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造一个原始对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> T <span class="title function_">create</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line"><span class="comment">// 将原始对象包装为池内对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> PooledObject&lt;T&gt; <span class="title function_">wrap</span><span class="params">(T var1)</span>;</span><br><span class="line"><span class="comment">// 构造原始对象并包装为池内对象</span></span><br><span class="line"><span class="keyword">public</span> PooledObject&lt;T&gt; <span class="title function_">makeObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.wrap(<span class="built_in">this</span>.create());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 销毁对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroyObject</span><span class="params">(PooledObject&lt;T&gt; p)</span> <span class="keyword">throws</span> Exception</span><br><span class="line"><span class="comment">// 验证对象是否可用</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">validateObject</span><span class="params">(PooledObject&lt;T&gt; p)</span> </span><br><span class="line"><span class="comment">// 激活对象，使其可用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">activateObject</span><span class="params">(PooledObject&lt;T&gt; p)</span> <span class="keyword">throws</span> Exception</span><br></pre></td></tr></table></figure><h4 id="PooledObject"><a href="#PooledObject" class="headerlink" title="PooledObject"></a>PooledObject</h4><p>池化的对象，是对真正对象的一个包装，加上了对象的一些其他信息，包括对象的状态（已用、空闲），对象的创建时间等。其实现要求是线程安全的。  </p><p>通常，ObjectPool 会持有 PooledObjectFactory ，将具体的对象的创建、初始化、销毁等任务委托给 PooledObjectFactory 处理，工厂操作的对象是 PooledObject ，即具体的 Object 的包装类。因此，获取对象依赖的是 ObjectPool 而不是 PooledObjectFactory 。</p><h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><h4 id="池化对象工厂类"><a href="#池化对象工厂类" class="headerlink" title="池化对象工厂类"></a>池化对象工厂类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestObjectFactory</span> <span class="keyword">extends</span> <span class="title class_">BasePooledObjectFactory</span>&lt;TestObject&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> TestObject <span class="title function_">create</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="comment">// 构造一个初始对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TestObject</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> PooledObject&lt;TestObject&gt; <span class="title function_">wrap</span><span class="params">(TestObject testObject)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultPooledObject</span>&lt;&gt;(testObject);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroyObject</span><span class="params">(PooledObject&lt;FaceEngine&gt; p)</span>&#123;</span><br><span class="line"><span class="comment">// 自定义销毁方法</span></span><br><span class="line">        p.getObject().unInit();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="对象池"><a href="#对象池" class="headerlink" title="对象池"></a>对象池</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestObjectPool</span> <span class="keyword">extends</span> <span class="title class_">GenericObjectPool</span>&lt;TestObject&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TestObjectPool</span><span class="params">(PooledObjectFactory&lt;TestObject&gt; factory)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(factory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TestObjectPool</span><span class="params">(PooledObjectFactory&lt;TestObject&gt; factory, GenericObjectPoolConfig&lt;TestObject&gt; config)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(factory, config);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TestObjectPool</span><span class="params">(PooledObjectFactory&lt;TestObject&gt; factory, GenericObjectPoolConfig&lt;TestObject&gt; config, AbandonedConfig abandonedConfig)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(factory, config, abandonedConfig);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="配置属性"><a href="#配置属性" class="headerlink" title="配置属性"></a>配置属性</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;pool&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PoolProperties</span> &#123;</span><br><span class="line">    <span class="comment">// 最大空闲</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> maxIdle;</span><br><span class="line">    <span class="comment">// 最大总数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> maxTotal;</span><br><span class="line">    <span class="comment">// 最小空闲</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> minIdle;</span><br><span class="line">    <span class="comment">// 初始化连接数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> initialSize;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="自动配置类"><a href="#自动配置类" class="headerlink" title="自动配置类"></a>自动配置类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableConfigurationProperties(PoolProperties.class)</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PoolAutoConfiguration</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PoolProperties poolProperties;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TestObjectFactory testObjectFactory;</span><br><span class="line">    <span class="keyword">private</span> TestObjectPool pool;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PoolAutoConfiguration</span><span class="params">(PoolProperties poolProperties, TestObjectFactory testObjectFactory)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.poolProperties = poolProperties;</span><br><span class="line">        <span class="built_in">this</span>.testObjectFactory = testObjectFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ConditionalOnClass(&#123;TestObjectFactory.class&#125;)</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">protected</span> TestObjectPool <span class="title function_">testObjectPool</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//设置对象池的相关参数</span></span><br><span class="line">        GenericObjectPoolConfig&lt;TestObject&gt; poolConfig = <span class="keyword">new</span> <span class="title class_">GenericObjectPoolConfig</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 最大闲对象数</span></span><br><span class="line">        poolConfig.setMaxIdle(poolProperties.getMaxIdle());</span><br><span class="line">        <span class="comment">// 最大对象数</span></span><br><span class="line">        poolConfig.setMaxTotal(poolProperties.getMaxTotal());</span><br><span class="line">        <span class="comment">// 最小闲对象数</span></span><br><span class="line">        poolConfig.setMinIdle(poolProperties.getMinIdle());</span><br><span class="line">        <span class="comment">// 30分钟执行一次对象扫描，将无用的对象销毁，默认-1不扫描</span></span><br><span class="line">        poolConfig.setTimeBetweenEvictionRunsMillis(<span class="number">1000</span> * <span class="number">60</span> * <span class="number">30</span>);</span><br><span class="line">        <span class="comment">// 在获取对象的时候检查有效性, 默认false</span></span><br><span class="line">        poolConfig.setTestOnBorrow(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">// 在归还对象的时候检查有效性, 默认false</span></span><br><span class="line">        poolConfig.setTestOnReturn(<span class="literal">false</span>);</span><br><span class="line">        <span class="comment">// 在空闲时检查有效性, 默认false</span></span><br><span class="line">        poolConfig.setTestWhileIdle(<span class="literal">false</span>);</span><br><span class="line">        <span class="comment">// 最大等待时间， 默认的值为-1，表示无限等待。</span></span><br><span class="line">        poolConfig.setMaxWaitMillis(-<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 是否启用后进先出, 默认true</span></span><br><span class="line">        poolConfig.setLifo(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">// 连接耗尽时是否阻塞, false立即抛异常,true阻塞直到超时, 默认true</span></span><br><span class="line">        poolConfig.setBlockWhenExhausted(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">// 每次逐出检查时 逐出的最大数目 默认3</span></span><br><span class="line">        poolConfig.setNumTestsPerEvictionRun(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">//一定要关闭jmx，不然springboot启动会报已经注册了某个jmx的错误</span></span><br><span class="line">        poolConfig.setJmxEnabled(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//新建一个对象池,传入对象工厂和配置</span></span><br><span class="line">        pool = <span class="keyword">new</span> <span class="title class_">TestObjectPool</span>(testObjectFactory, poolConfig);</span><br><span class="line"></span><br><span class="line">        initPool(poolProperties.getInitialSize(), poolProperties.getMaxIdle());</span><br><span class="line">        <span class="keyword">return</span> pool;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 预先加载testObject对象到对象池中</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> initialSize 初始化连接数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> maxIdle     最大空闲连接数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initPool</span><span class="params">(<span class="type">int</span> initialSize, <span class="type">int</span> maxIdle)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (initialSize &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> Math.min(initialSize, maxIdle);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                pool.addObject();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pool != <span class="literal">null</span>) &#123;</span><br><span class="line">            pool.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">TestObjectPool testObjectPool;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">TestObject</span> <span class="variable">testObject</span>  <span class="operator">=</span> testObjectPool.borrowObject();</span><br><span class="line">    <span class="comment">// Do something</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    testObjectPool.returnObject(testObject);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 对象池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hadoop伪分布式集群搭建</title>
      <link href="/2023/03/10/Hadoop%E4%BC%AA%E5%88%86%E5%B8%83%E5%BC%8F%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/"/>
      <url>/2023/03/10/Hadoop%E4%BC%AA%E5%88%86%E5%B8%83%E5%BC%8F%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<p>操作系统：Ubuntu22.04<br>Hadoop：3.3.4<br>参考《大数据技术原理与应用》——林子雨。</p><h3 id="安装SSH和配置无密码登录"><a href="#安装SSH和配置无密码登录" class="headerlink" title="安装SSH和配置无密码登录"></a>安装SSH和配置无密码登录</h3><p>对于 Hadoop 的伪分布式和完全分布式而言，Hadoop 名称节点（NameNode）需要启动集群<br>中所有机器的 Hadoop 守护进程，这个过程可以通过 SSH 登录来实现。Hadoop 并没有提供 SSH输入密码登录的形式，因此，为了能够顺利登录每台机器，需要将所有机器配置为名称节点可以无密码登录它们。<br>为了实现 SSH 无密码登录，需要在 Ubuntu 操作系统上安装 SSH 服务端和客户端。Ubuntu<br>操作系统默认已安装了 SSH 客户端，因此这里只需要安装 SSH 服务端，命令如下：<br><code>$ sudo apt-get install openssh-server</code><br>安装以后，可以使用如下命令登录本机：<br><code>$ ssh localhost</code><br>出现提示后，输人“yes”，并输入密码，就可以登录到本机了。但是，这样登承是需要每次都输入密码的，因此，我们需要配置成 SSH 无密码登录。<br>退出刚才的 SSH 登录，然后利用 ssh-keygen 生成密钥，并将密钥加入授权，具体命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">exit</span></span><br><span class="line">$ <span class="built_in">cd</span> ~/.ssh/</span><br><span class="line">$ ssh-keygen -t rsa</span><br></pre></td></tr></table></figure><p><img src="http://oss.ripplesu.top/blog/Hadoop%E4%BC%AA%E5%88%86%E5%B8%83%E5%BC%8F%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/72873834-99e5-41fe-b1d1-a376ca64a8b0.png" alt="image.png"><br>这里都输入回车即可。然后输入命令：<br><code>$ cat ./id_rsa.pub &gt;&gt;./authorized_keys</code><br>此时再用 ssh localhost 命令，无须输入密码就可以直接登录了。</p><h3 id="安装java环境"><a href="#安装java环境" class="headerlink" title="安装java环境"></a>安装java环境</h3><p>以Hadoop3.3.4而言，需要jdk1.8以上版本。  可以到Oracle官网下载jdk1.8的安装包，也可使用apt安装。<br>以apt为例，输入如下命令搜索jdk：<code>$ apt search jdk</code><br>然后输入<code>$ apt install openjdk-8-jdk</code>安装jdk1.8。<br>接下来配置环境变量。输入<code>$ vim ~/.bashrc</code>，在文件首部加入如下语句：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/usr/lib/jvm/java-<span class="number">8</span>-openjdk-amd64</span><br><span class="line">export JRE_HOME=$&#123;JAVA_HOME&#125;/jre</span><br><span class="line">export CIASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/lib</span><br><span class="line">export PATH=$&#123;JAVA_HOME&#125;/bin:$PATH</span><br></pre></td></tr></table></figure><p>保存并退出即可。</p><h3 id="安装单机Hadoop"><a href="#安装单机Hadoop" class="headerlink" title="安装单机Hadoop"></a>安装单机Hadoop</h3><p>在采用单机模式时，Hadoop 只在一台机器上运行，存储采用本地文件系统，没有采用分布式<br>文件系统 HDFS。这里使用的 Hadoop 版本为 3.3.4，下载地址为 http:&#x2F;hadoop.apache.ong&#x2F;releases.html#Download，在页面中选择 hadoop-3.3.4.targz 进行下载即可。这里假设安装文件被保存到了Ubuntu 操作系统的“～&#x2F;Downloads”目录下，可以执行如下命令进行安装：  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo tar -zxf ~/Downloads/hadoop-3.3.4.tar.gz -C /usr/local</span><br><span class="line">$ <span class="built_in">cd</span> /usr/local/</span><br><span class="line">$ sudo <span class="built_in">mv</span> ./hadoop-3.3.4/ ./hadoop <span class="comment"># 修改目录名</span></span><br><span class="line">$ sudo <span class="built_in">chown</span> -R hadoop ./hadoop <span class="comment"># 修改文件主</span></span><br></pre></td></tr></table></figure><p>然后，可以运行如下命令查看 Hadoop 的版本信息：<br><code>$ ./bin/hadoop version</code><br>Hadoop 文档中还附带了一些例子供我们测试，现在可以运行 Grep 实例来检测一下 Hadoop<br>是否安装成功。<br>首先，在 Hadoop 安装目录下新建 input 目录，用来存放输入数据，命令如下:  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /usr/local/hadoop</span><br><span class="line">$ <span class="built_in">mkdir</span> input</span><br></pre></td></tr></table></figure><p>然后，将“&#x2F;usr&#x2F;local&#x2F;hadoop&#x2F;ete&#x2F;hadoop”目录下的配置文件复制到 input 目录，命令如下：<br><code>$ cp ./etc/hadoop/*.xml ./input</code><br>接下来，执行如下代码运行 Grep 实例：<br><code>$ ./bin/hadoop jar /usr/local/hadoop/share/hadoop/mapreduce/hadoop-mapreduce-examples-3.3.4.jar grep ./input ./output &#39;dfs[a-z.]+&#39;</code><br>最后，可以执行以下命令查看输出数据：<br><code>$ cat ./output/*</code><br>运行上面命令后，可以得到以下结果：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dfsadmin</span><br><span class="line">dfs.replication</span><br><span class="line">dfs.namenode.name.dir</span><br><span class="line">dfs.datanode.data.dir</span><br></pre></td></tr></table></figure><h3 id="Hadoop-伪分布式安装"><a href="#Hadoop-伪分布式安装" class="headerlink" title="Hadoop 伪分布式安装"></a>Hadoop 伪分布式安装</h3><p>在分布式安装时，Hadoop 存储采用分布式文件系统 HDFS，而且，HDFS 的名称节点和数据<br>节点位于集群的不同机器上。伪分布式安装是指在一台机器上模拟一个小的集群，但是集群中只<br>有一个节点。在采用伪分布式模式时，Hadoop 的存储采用分布式文件系统 HDFS，但是，HDFS<br>的名称节点和数据节点都在同一台机器上。需要说明的是，在一台机器上也是可以实现完全分布<br>式安装的（而不是伪分布式)。只要在一台机器上安装多个 Linux 虚拟机，使每个 Linux 虚拟机成为一个节点，就可以实现 Hadoop 的完全分布式安装。这里只介绍伪分布式安装。<br>当 Hadoop 应用于集群时，不论是伪分布式还是真正的分布式运行，都需要通过配置文件对各组件的协同工作进行设置。对于伪分布式配置，我们需要修改 core-site.xml 和 hdfs-site.xml 这两个文件（位于安装目录下的<code>etc/hadoop/</code>目录）。<br>修改后的 core-site.xml 文件的内容如下：  </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>hadoop.tmp.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>file:/usr/local/hadoop/tmp<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">description</span>&gt;</span>Abase for other temporary directories.<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.defaultFS<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://localhost:9000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>修改后的 hdfs-site.xml 文件的内容如下：  </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.replication<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.name.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>file:/usr/local/hadoop/tmp/dfs/name<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.datanode.data.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>file:/usr/local/hadoop/tmp/dfs/data<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对于 hds-sitce.xnl 文件，这里设置 replication 值为1，这也是 Hadoop 运行的默认最小值，它限制了 HDFS 中同一份数据的副本数量。由于这里采用伪分布式，集群中只有一个节点，因此副本数量 replication 的值也只能设置为 1。  </p><p>在配置完成后，首先需要初始化文件系统，由于 Hadeop 的很多工作是在自带的 HDFS 上完成的，因此，需要将文件系统初始化之后才能进一步执行计算任务。执行初始化的命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /usr/local/hadoop</span><br><span class="line">$ ./bin/hdfs namenode -format</span><br></pre></td></tr></table></figure><p>执行结果如下:<br><img src="http://oss.ripplesu.top/blog/Hadoop%E4%BC%AA%E5%88%86%E5%B8%83%E5%BC%8F%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/88f7f863-3fd5-4823-bc67-e78104468f75.png" alt="image.png"><br>出现<strong>successfully formatted</strong>即配置成功。  </p><p>文件系统初始化成功以后，可以用如下命令启动 HDFS：  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /ust/local/hadoop </span><br><span class="line">$ ./sbin/start-dfs.sh</span><br></pre></td></tr></table></figure><p>如遇到如下错误，可在Hadoop安装目录下的<code>etc/hadoop/hadoop-env.sh</code>中添加：<br><code>export JAVA_HOME=/usr/lib/jvm/java-8-openjdk-amd64</code><br><img src="http://oss.ripplesu.top/blog/Hadoop%E4%BC%AA%E5%88%86%E5%B8%83%E5%BC%8F%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/aee9d0ee-41ce-4ac5-b0f3-74aac4cfec57.png" alt="image.png"><br>启动之后，可以输人 jps指令查看所有的 Java 选程。如果 IIDFS 启动成功，可以得到如下类似结果：<br><img src="http://oss.ripplesu.top/blog/Hadoop%E4%BC%AA%E5%88%86%E5%B8%83%E5%BC%8F%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/b86e9970-d50c-409f-bc16-57291d5eb6ce.png" alt="image.png"></p><p>此时，可以访问 Web 页面（htp:&#x2F;localhost:9870）来查看 Hadoop 的信息。<br><img src="http://oss.ripplesu.top/blog/Hadoop%E4%BC%AA%E5%88%86%E5%B8%83%E5%BC%8F%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/f97a261f-3a0d-4df0-aab6-271d53dd7d80.png" alt="image.png">  </p><p>接下来，执行如下命令，在 HDFS 中创建 hadoop 用户的用户目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /usr/local/hadoop</span><br><span class="line">$ ./bin/hdfs dfs -<span class="built_in">mkdir</span> -p /user/hadoop</span><br></pre></td></tr></table></figure><p>然后，在 HDFS 的“&#x2F;user&#x2F;hadoop”目录下创建 input目录，命令如下：<br><code>$ ./bin/hdfs dfs -mkdir input</code><br>如遇到下述问题，可用如下命令解决：  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">groupadd supergroup</span><br><span class="line">usermod -a -G supergroup root <span class="comment"># 要加入组的用户</span></span><br></pre></td></tr></table></figure><p><img src="http://oss.ripplesu.top/blog/Hadoop%E4%BC%AA%E5%88%86%E5%B8%83%E5%BC%8F%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/1dd70553-64d8-4489-a3a4-af9296c4a64f.png" alt="image.png">  </p><p>现在，需要将“&#x2F;us&#x2F;local&#x2F;hadoop&#x2F;ete&#x2F;hadoop”目录下的本地文本文件（配置文件）“上传”到<br>分布式文件系统 HDFS 中的“&#x2F;user&#x2F;hadoop&#x2F;input”目录下。当然，这里的“上传”并不意味着数据通过网络传输。实际上，在伪分布式 Hadoop 环境下，本地的“&#x2F;usr&#x2F;localhadoop&#x2F;et&#x2F;hadoop”目录和 HDFS 中的“&#x2F;user&#x2F;hadoop&#x2F;input”目录都在同一台机器上，并不需要通过网络传输数据。可以执行如下命令实现文件“上传”：<br><code>$ ./bin/hdfs dfs -put ./etc/hadoop/*.xml input</code><br>接着，运行如下命令来执行测试样例程序 Grep：<br><code>$ ./bin/hadoop jar /usr/local/hadoop/share/hadoop/mapreduce/hadoop-mapreduce-examples-3.3.4.jar grep input output &#39;dfs[a-z.]+&#39;</code><br>如遇到错误：<code>ENOENT: No such file or directory</code>，可尝试在su模式下重试上述操作。  </p><p>在计算完成后，系统会自动在 HDFS 中生成“&#x2F;user&#x2F;hadoop&#x2F;output”目录来存储计算结果。可<br>以输人如下命令查看最终结果：<br><code>$ ./bin/hdfs dfs -cat output/*</code><br>运行上面命令后，可以得到以下结果:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dfsadmin</span><br><span class="line">dfs.replication</span><br><span class="line">dfs.namenode.name.dir</span><br><span class="line">dfs.datanode.data.dir</span><br></pre></td></tr></table></figure><p>最后需要指出的是，当需要重新运行程序时，首先应将 HDFS 中的 output目录删除，然后运行程序。删除 output 目录的命令如下：<br><code>$ ./bin/hdfs dfs -rm -r output </code><br>需要停止运行 HDFS 时，可以执行如下命令：  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /usr/local/hadoop</span><br><span class="line">$ ./sbin/stop-dfs.sh</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 实验实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hadoop </tag>
            
            <tag> 配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git常用命令</title>
      <link href="/2023/02/27/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2023/02/27/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="获取-Git-仓库"><a href="#获取-Git-仓库" class="headerlink" title="获取 Git 仓库"></a>获取 Git 仓库</h3><p>有两种取得 Git 项目仓库的方法。</p><ol><li>在现有目录中初始化仓库: 进入项目目录运行 <code>git init</code> 命令,该命令将创建一个名为 <code>.git</code> 的子目录。</li><li>从一个服务器克隆一个现有的 Git 仓库: <code>git clone [url]</code> 自定义本地仓库的名字: <code>git clone [url] directoryname</code></li></ol><h3 id="记录每次更新到仓库"><a href="#记录每次更新到仓库" class="headerlink" title="记录每次更新到仓库"></a>记录每次更新到仓库</h3><ol><li><strong>检测当前文件状态</strong> : <code>git status</code></li><li><strong>提出更改（把它们添加到暂存区</strong>）：<code>git add filename</code> (针对特定文件)、<code>git add *</code>(所有文件)、<code>git add *.txt</code>（支持通配符，所有 .txt 文件）</li><li><strong>忽略文件</strong>：<code>.gitignore</code> 文件</li><li><strong>提交更新:</strong> <code>git commit -m &quot;代码提交信息&quot;</code> （每次准备提交前，先用 <code>git status</code> 看下，是不是都已暂存起来了， 然后再运行提交命令 <code>git commit</code>）</li><li><strong>跳过使用暂存区域更新的方式</strong> : <code>git commit -a -m &quot;代码提交信息&quot;</code>。 <code>git commit</code> 加上 <code>-a</code> 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 <code>git add</code> 步骤。</li><li><strong>移除文件</strong>：<code>git rm filename</code> （从暂存区域移除，然后提交。）加上-n选项则先预览此命令要删除的文件列表，而不会执行删除。</li><li><strong>对文件重命名</strong>：<code>git mv README.md README</code>(这个命令相当于<code>mv README.md README</code>、<code>git rm README.md</code>、<code>git add README</code> 这三条命令的集合)</li></ol><h3 id="推送改动到远程仓库"><a href="#推送改动到远程仓库" class="headerlink" title="推送改动到远程仓库"></a>推送改动到远程仓库</h3><ul><li><p>如果你还没有克隆现有仓库，并欲将你的仓库连接到某个远程服务器，你可以使用如下命令添加：<code>git remote add origin &lt;server&gt;</code> ,比如我们要让本地的一个仓库和 GitHub 上创建的一个仓库关联可以这样<code>git remote add origin https://github.com/Snailclimb/test.git</code></p></li><li><p>将这些改动提交到远端仓库：<code>git push origin master</code> (可以把 <em>master</em> 换成你想要推送的任何分支)</p><p>如此你就能够将你的改动推送到所添加的服务器上去了。</p></li></ul><h3 id="远程仓库的移除与重命名"><a href="#远程仓库的移除与重命名" class="headerlink" title="远程仓库的移除与重命名"></a>远程仓库的移除与重命名</h3><ul><li>将 test 重命名为 test1：<code>git remote rename test test1</code></li><li>移除远程仓库 test1:<code>git remote rm test1</code></li></ul><h3 id="查看提交历史"><a href="#查看提交历史" class="headerlink" title="查看提交历史"></a>查看提交历史</h3><p>在提交了若干更新，又或者克隆了某个项目之后，你也许想回顾下提交历史。 完成这个任务最简单而又有效的工具是 <code>git log</code> 命令。<code>git log</code> 会按提交时间列出所有的更新，最近的更新排在最上面。</p><p><strong>可以添加一些参数来查看自己希望看到的内容：</strong></p><p>只看某个人的提交记录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --author=bob</span><br></pre></td></tr></table></figure><h3 id="撤销操作"><a href="#撤销操作" class="headerlink" title="撤销操作"></a>撤销操作</h3><p>有时候我们提交完了才发现漏掉了几个文件没有添加，或者提交信息写错了。 此时，可以运行带有 <code>--amend</code> 选项的提交命令尝试重新提交：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend</span><br></pre></td></tr></table></figure><p>取消暂存的文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset filename</span><br></pre></td></tr></table></figure><p>撤消对文件的修改:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- filename</span><br></pre></td></tr></table></figure><p>假如你想丢弃你在本地的所有改动与提交，可以到服务器上获取最新的版本历史，并将你本地主分支指向它：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin</span><br><span class="line">git reset --hard origin/master</span><br></pre></td></tr></table></figure><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><p>分支是用来将特性开发绝缘开来的。在你创建仓库的时候，<em>master</em> 是“默认”的分支。在其他分支上进行开发，完成后再将它们合并到主分支上。</p><p>我们通常在开发新功能、修复一个紧急 bug 等等时候会选择创建分支。单分支开发好还是多分支开发好，还是要看具体场景来说。</p><p>创建一个名字叫做 test 的分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>切换当前分支到 test（当你切换分支的时候，Git 会重置你的工作目录，使其看起来像回到了你在那个分支上最后一次提交的样子。 Git 会自动添加、删除、修改文件以确保此时你的工作目录和这个分支最后一次提交时的样子一模一样）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>你也可以直接这样创建分支并切换过去(上面两条命令的合写)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b feature_x</span><br></pre></td></tr></table></figure><p>切换到主分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br></pre></td></tr></table></figure><p>合并分支(可能会有冲突)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>把新建的分支删掉</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d feature_x</span><br></pre></td></tr></table></figure><p>将分支推送到远端仓库（推送成功后其他人可见）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin</span><br></pre></td></tr></table></figure><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="Git冲突？"><a href="#Git冲突？" class="headerlink" title="Git冲突？"></a>Git冲突？</h3><ol><li>手动解决冲突：当 Git 发生冲突时，会提示你哪些文件发生了冲突。此时，你需要手动打开这些文件，查看冲突的部分，并决定如何解决冲突。通常，你可以选择保留自己的修改、保留别人的修改或者合并两者的修改。</li><li>使用 Git 工具解决冲突：Git 提供了一些工具来帮助你解决冲突，例如 <code>git mergetool</code> 命令。这个命令会打开一个图形化的工具，帮助你比较两个版本的文件，并进行合并。</li><li>合并提交：如果你和别人对同一个文件的不同部分进行了修改，那么你可以将你的修改和别人的修改合并到一起，然后提交一个新的版本。这样可以避免冲突。</li></ol><h3 id="gitignore全局配置"><a href="#gitignore全局配置" class="headerlink" title="gitignore全局配置"></a>gitignore全局配置</h3><ul><li>创建.gitignore_global 文件<ul><li>Win<br>在 C盘 -&gt; 用户 -&gt; 当前用户 -&gt; 创建  .gitignore_global 文件</li><li>Linux<br>在home目录创建 ~&#x2F;.gitignore_global 文件</li></ul></li><li>向.gitignore_global文件加入需要忽略的内容</li><li>执行git指令<br><code>git config --global core.excludesfile ~/.gitignore_global</code></li></ul><h3 id="不小心push了一些敏感数据"><a href="#不小心push了一些敏感数据" class="headerlink" title="不小心push了一些敏感数据"></a>不小心push了一些敏感数据</h3><h4 id="方法1：清除git仓库所有提交记录"><a href="#方法1：清除git仓库所有提交记录" class="headerlink" title="方法1：清除git仓库所有提交记录"></a>方法1：清除git仓库所有提交记录</h4><p><strong>参考：<a href="https://blog.csdn.net/icansoicrazy/article/details/128342811">https://blog.csdn.net/icansoicrazy/article/details/128342811</a></strong></p><ol><li>切换到新的分支<br><code>git checkout --orphan latest_branch</code><br>说明：git checkout –orphan 的核心用途是，以类似git init的状态创建新的非父分支，也就是创建一个无提交记录的分支。</li><li>缓存所有文件（除了.gitignore中声明排除的）<br><code>git add -A</code></li><li>提交跟踪过的文件（Commit the changes）<br><code>git commit -am &quot;commit message&quot;</code></li><li>删除master分支（Delete the branch）<br><code>git branch -D master</code></li><li>重命名当前分支为master（Rename the current branch to master）<br><code>git branch -m master</code></li><li>强制提交到远程master分支 （Finally, force update your repository）<br><code>git push -f origin master</code></li></ol><h4 id="方法2：使用bfg"><a href="#方法2：使用bfg" class="headerlink" title="方法2：使用bfg"></a>方法2：使用bfg</h4><ol><li>fork 要清除敏感信息的项目到个人仓库中，并clone仓库到本地：<br><code>$ git clone --mirror git@github.com:xxx/xxx.git</code></li><li>备份xxx.git<br>备份一份到另一个文件夹即可，主要用于操作失败后，重新push该仓库用来恢复数据。</li><li>下载bfg.jar与xxx.git同目录</li><li>准备一个文本文件，里面包含要要替换的文本<br>passwords.txt<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PASSWORD1                       # Replace literal string &#x27;PASSWORD1&#x27; with &#x27;***REMOVED***&#x27; (default)</span><br><span class="line">PASSWORD2==&gt;examplePass         # replace with &#x27;examplePass&#x27; instead</span><br><span class="line">PASSWORD3==&gt;                    # replace with the empty string</span><br><span class="line">regex:password=\w+==&gt;password=  # Replace, using a regex</span><br><span class="line">regex:\r(\n)==&gt;$1               # Replace Windows newlines with Unix newlines</span><br></pre></td></tr></table></figure>如本例中，用127.0.0.1代替敏感IP，只需在passwords.txt中添加172.1.1.1&#x3D;&#x3D;&gt;127.0.0.1。</li><li>cd xxx.git</li><li>开始替换仓库中的敏感信息<br><code>$  java -jar bfg.jar --replace-text passwords.txt --no-blob-protection xxx.git</code></li><li>删除敏感文件<br><code>$  git reflog expire --expire=now --all &amp;&amp; git gc --prune=now --aggressive</code></li><li>提交到远程仓库<br><code>$  git push</code></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈登录认证的几种方式</title>
      <link href="/2023/02/26/%E6%B5%85%E8%B0%88%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
      <url>/2023/02/26/%E6%B5%85%E8%B0%88%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>主流的登录认证的方法一般有Cookie+SessionID、Token+Redis、SSO单点登录（常用JWT）、OAuth第三方登录这几种，以下将简单介绍这几种方式。</p><h2 id="Cookie-SessionID"><a href="#Cookie-SessionID" class="headerlink" title="Cookie+SessionID"></a>Cookie+SessionID</h2><p>由于Http是无状态的，所以需要用Cookie来保存用户信息。Cookie 和 Session 都是用来跟踪浏览器用户身份的会话方式，其主要区别是Cookie存放在客户端，而Session存放在服务端。<br>基于Cookie+SessionId方案实现登录认证的主要流程如下：  </p><ol><li>用户向服务器发送用户名、密码、验证码用于登陆系统。</li><li>服务器验证通过后，服务器为用户创建一个 Session，并将 Session 信息存储起来。</li><li>服务器向用户返回一个 SessionID，写入用户的 Cookie。</li><li>当用户保持登录状态时，Cookie 将与每个后续请求一起被发送出去。</li><li>服务器可以将存储在 Cookie 上的 SessionID 与存储在内存中或者数据库中的 Session 信息进行比较，以验证用户的身份，返回给用户客户端响应信息的时候会附带用户当前的状态。<br><img src="http://oss.ripplesu.top/blog/Typora/%E6%B5%85%E8%B0%88%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/80ab5553-5b7a-4773-8a6b-2bcd918afce3_repeat_1700453389694__325339.png" alt="image.png"></li></ol><p>这种方案有如下几个问题：  </p><ul><li>跨应用的Session共享问题：可以将Session存放在Redis中，或使用Spring Session。</li><li>如果会话信息存放在Cookie中，而客户端禁用Cookie，则这种方案将失效。</li><li>无法防止CSRF(Cross Site Request Forgery， 一般被翻译为<strong>跨站请求伪造</strong>)攻击。由于当前域名下发送的任何请求都会带上Cookie，这就会有SessionId被窃取的风险，攻击者可以用你的身份发送请求。</li></ul><h2 id="Token-Redis"><a href="#Token-Redis" class="headerlink" title="Token+Redis"></a>Token+Redis</h2><p>Token是服务端生成的一串字符串，以作客户端进行请求的一个令牌。当用户第一次登录后，服务器生成一个Token并将此Token返回给客户端，以后客户端只需带上这个Token前来请求数据即可，无需再次带上用户名和密码。Token可以是SessionID，也可以携带一些其他的用户信息（最好经过加密）。SessionID一般存在Cookie里，而token一般放在浏览器的localStorage中。</p><h3 id="单token方案"><a href="#单token方案" class="headerlink" title="单token方案"></a>单token方案</h3><h4 id="流程："><a href="#流程：" class="headerlink" title="流程："></a>流程：</h4><ul><li>客户端发送登录请求</li><li>以随机生成的唯一的token作为redis的key，从数据库中取出用户数据并保存到redis，并设置一个过期时间。然后将token返回给客户端。</li><li>客户端将token保存至localStorage或sessionStorage等。后续客户端发送请求时，都将携带着token进行访问。</li><li>服务器收到请求时，查询redis中是否存在该token。若不存在，即token过期，则拦截该请求。</li></ul><h4 id="token的刷新"><a href="#token的刷新" class="headerlink" title="token的刷新"></a>token的刷新</h4><p>上述流程中，如果token的有效时间较短，则用户体验较差，可能需要频繁登录，甚至导致用户填写的表单信息丢失；而如果token有效时间太长，则redis中需要存储大量的token，可能白白耗费宝贵的内存资源。<br>一种解决办法：客户端每次携带未过期的token发送请求时，服务器就将token的有效时间刷新。<br>以下是简单的代码实现：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Mvc配置类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">RefreshTokenInterceptor</span>(stringRedisTemplate));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 拦截器，用于刷新token</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RefreshTokenInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate redisTemplate;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RefreshTokenInterceptor</span><span class="params">(StringRedisTemplate redisTemplate)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.redisTemplate = redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1.获取请求头中的token</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;token&quot;</span>);</span><br><span class="line">        <span class="comment">// 2.token不存在，则拦截</span></span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isBlank(token))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;key of token in redis&quot;</span></span><br><span class="line">        <span class="comment">// 3.刷新token</span></span><br><span class="line">        redisTemplate.expire(key, <span class="number">7200L</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述方案每次收到未过期的请求时，都需要刷新一次token，效率较低。也可以仅当token快过期时再将token刷新。下述的双token方案也许是一种更好的方案。</p><h3 id="双token方案（token续签）"><a href="#双token方案（token续签）" class="headerlink" title="双token方案（token续签）"></a>双token方案（token续签）</h3><h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><ul><li>登录成功以后，后端返回 <code>access_token</code> 和 <code>refresh_token</code>，客户端缓存此两种token;</li><li>使用 <code>access_token</code> 请求接口资源，成功则调用成功；如果token超时，客户端携带 <code>refresh_token</code> 调用token刷新接口获取新的 <code>access_token</code>;</li><li>后端接受刷新token的请求后，检查 <code>refresh_token</code> 是否过期。如果过期，拒绝刷新，并返回一个错误码。客户端收到该状态后，跳转到登录页；如果未过期，生成新的 <code>access_token</code>和<code>refresh_token</code> 返回给客户端。</li><li>客户端缓存携带新的 token ，并携带之重新调用上面的资源接口。</li><li>客户端退出登录或修改密码后，注销旧的token，使 <code>access_token</code> 和 <code>refresh_token</code> 失效，同时清空客户端的 <code>access_token</code> 和 <code>refresh_toke</code>。</li></ul><p>双 token 的优势：</p><ul><li>accessToken 的存在，保证了登录态的正常验证，因其过期时间的短暂也保证了帐号的安全性；</li><li>refreshToekn 的存在，保证了用户（即使是非活跃用户）无需在短时间内进行反复的登录操作来保证登录态的有效性，同时也保证了活跃用户的登录态可以一直存续而不需要进行重新登录。refresh token并非每次请求都传输，只有access token失效后才用refresh token换一套新的refresh token和access token，减少了暴露的风险。</li></ul><h2 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h2><p>JWT （JSON Web Token） 是目前最流行的跨域认证解决方案，特别适用于分布式站点的单点登录（SSO）场景。它是一种基于 Token 的认证授权机制。JWT 自身包含了身份验证所需要的所有信息，因此，我们的服务器不需要存储 Session 信息。这就能够减轻服务端的压力，但同时也不利于服务端管理用户状态。</p><h3 id="JWT的组成部分"><a href="#JWT的组成部分" class="headerlink" title="JWT的组成部分"></a>JWT的组成部分</h3><p>JWT 本质上就是一组字符串，通过’.’切分成三个为 Base64 编码的部分，其格式为：<br><code>header.payload.signature</code>  </p><ul><li>Header : 描述生成签名的算法以及 Token 的类型。</li><li>Payload : 用来存放实际需要传递的数据，包括注册声明、公有声明和私有声明。常见的注册声明包括jwt签发方、签发时间、过期时间等。注意：payload部分默认<strong>不加密</strong>。</li><li>Signature：服务器使用 Header 里面指定的签名算法（默认是 HMAC SHA256）对整个JWT进行签名，防止被伪造和篡改。</li></ul><h3 id="流程-1"><a href="#流程-1" class="headerlink" title="流程"></a>流程</h3><ol><li>用户向服务器发送用户名、密码以及验证码等用于登陆系统。</li><li>如果用户用户名、密码以及验证码校验正确的话，服务端会返回已经签名的 Token，也就是 JWT。</li><li>用户以后每次向后端发请求都在 Header 中带上这个 JWT（常见做法是将其放在 HTTP Header 的 Authorization 字段中：Authorization: Bearer Token）。</li><li>服务端检查 JWT 并从中获取用户相关信息。</li></ol><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><h4 id="如何防止JWT被篡改？"><a href="#如何防止JWT被篡改？" class="headerlink" title="如何防止JWT被篡改？"></a>如何防止JWT被篡改？</h4><p>只要密匙不泄露，一般无法同时篡改 Signature 、Header 、Payload。因为只要服务端拿到前端发来的JWT，会根据 Header、Payload、密钥再次生成一个 Signature，与原来JWT中的Signature作对比即可直到JWT有无被篡改。</p><h3 id="注销后JWT仍有效"><a href="#注销后JWT仍有效" class="headerlink" title="注销后JWT仍有效"></a>注销后JWT仍有效</h3><p>由于JWT是无状态的，服务端并不存储相关信息，那么直到JWT过期前，它都是有效的。<br>常用解决方案：</p><ul><li>将JWT存放在redis等内存数据库中。如果要让JWT失效只需从redis中将其删除。但这违背了JWT无状态的原则，且与仅使用token的方案没有太大区别。</li><li>黑名单机制。如果想让某个 JWT 失效的话就直接将这个 JWT 加入到 黑名单 即可。然后，每次使用 JWT 进行请求的话都会先判断这个 JWT 是否存在于黑名单中。但同样违背了无状态的原则。</li></ul><h2 id="OAuth"><a href="#OAuth" class="headerlink" title="OAuth"></a>OAuth</h2><p>OAuth（Open Authorization）是一种开放标准的授权协议，用于授权第三方应用程序访问用户在另一个服务提供商上存储的受保护资源，而无需共享用户的凭据（如用户名和密码）。</p><p>OAuth 的设计目标是允许用户授权第三方应用程序代表他们获取受保护的资源，同时保护用户的凭据不被第三方应用程序获取。它通过使用令牌（Token）来实现授权过程。</p><p>下面是 OAuth 的基本流程：</p><ol><li>第三方应用程序向服务提供商注册，并获得一个客户端标识和客户端密钥。</li><li>用户在第三方应用程序中请求访问受保护资源。</li><li>第三方应用程序将用户重定向到服务提供商的授权页面，要求用户进行身份验证和授权。</li><li>用户在服务提供商的授权页面上进行身份验证，并决定是否授权第三方应用程序访问其受保护的资源。</li><li>如果用户授权，服务提供商将生成一个访问令牌（Access Token）并返回给第三方应用程序。</li><li>第三方应用程序使用访问令牌来请求访问用户的受保护资源。</li><li>服务提供商验证访问令牌的有效性，并根据授权范围决定是否提供受保护资源。</li><li>第三方应用程序获取用户的受保护资源，并在用户的授权范围内进行操作。</li></ol><p>OAuth 的优势在于用户不需要共享他们的用户名和密码给第三方应用程序，同时可以控制第三方应用程序对其受保护资源的访问权限。它被广泛应用于各种互联网服务中，如社交媒体平台、云存储服务和API授权等场景，为用户提供了方便、安全的授权机制。</p>]]></content>
      
      
      <categories>
          
          <category> 学习总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 登录认证 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot整合SpringMail的一个demo</title>
      <link href="/2023/02/25/SpringBoot%E6%95%B4%E5%90%88SpringMail%E7%9A%84%E4%B8%80%E4%B8%AAdemo/"/>
      <url>/2023/02/25/SpringBoot%E6%95%B4%E5%90%88SpringMail%E7%9A%84%E4%B8%80%E4%B8%AAdemo/</url>
      
        <content type="html"><![CDATA[<p>使用SpringBoot整合Spring Mail实现邮件发送功能。</p><h3 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h3><h4 id="1-邮箱配置"><a href="#1-邮箱配置" class="headerlink" title="1. 邮箱配置"></a>1. 邮箱配置</h4><p>以QQ邮箱为例，启用SMTP服务：<br>在设置——账户中，开启POP3&#x2F;SMTP服务，保存好授权码。<br><img src="http://oss.ripplesu.top/blog/Typora/SpringBoot%E6%95%B4%E5%90%88SpringMail%E7%9A%84%E4%B8%80%E4%B8%AAdemo/8b599386-1936-4c10-8fa5-b15e865ee6bc_repeat_1700452521700__607495.png" alt="image.png"></p><h4 id="2-Spring-Mail配置"><a href="#2-Spring-Mail配置" class="headerlink" title="2. Spring Mail配置"></a>2. Spring Mail配置</h4><ul><li>POM中导入Spring Mail的Starter  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li>SpringBoot配置文件中配置相关参数<br>官方文档：<a href='https://docs.spring.io/spring-framework/docs/current/reference/html/integration.html#mail'>https://docs.spring.io/spring-framework/docs/current/reference/html/integration.html#mail</a>  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mail:</span></span><br><span class="line">  <span class="attr">host:</span> <span class="string">smtp.qq.com</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">465</span></span><br><span class="line">  <span class="attr">username:</span> <span class="string">xxx@qq.com</span></span><br><span class="line">  <span class="attr">password:</span> <span class="string">你的授权码</span></span><br><span class="line">  <span class="string">//</span> <span class="string">启用安全的smtp协议</span></span><br><span class="line">  <span class="attr">protocol:</span> <span class="string">smtps</span></span><br><span class="line">  <span class="string">//</span> <span class="string">SSL安全连接</span></span><br><span class="line">  <span class="attr">properties:</span></span><br><span class="line">    <span class="attr">mail:</span></span><br><span class="line">      <span class="attr">smtp:</span></span><br><span class="line">        <span class="attr">ssl:</span></span><br><span class="line">          <span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></li><li>编写Mail工具类<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MailClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(MailClient.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JavaMailSender mailSender;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.mail.username&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String from;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMail</span><span class="params">(String to, String subject, String text)</span> <span class="keyword">throws</span> MessagingException &#123;</span><br><span class="line">        <span class="type">MimeMessage</span> <span class="variable">message</span> <span class="operator">=</span> mailSender.createMimeMessage();</span><br><span class="line">        <span class="type">MimeMessageHelper</span> <span class="variable">messageHelper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MimeMessageHelper</span>(message);</span><br><span class="line">        messageHelper.setFrom(from);</span><br><span class="line"><span class="comment">// 接受者邮箱</span></span><br><span class="line">        messageHelper.setTo(to);</span><br><span class="line"><span class="comment">// 邮件主题</span></span><br><span class="line">        messageHelper.setSubject(subject);</span><br><span class="line"><span class="comment">// 邮件内容</span></span><br><span class="line">        messageHelper.setText(text);</span><br><span class="line">        mailSender.send(messageHelper.getMimeMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>测试邮件发送<br>编写测试类：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(classes = xxxApplication.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MailTest</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    MailClient mailClient;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mailClient.sendMail(<span class="string">&quot;to@qq.com&quot;</span>,<span class="string">&quot;测试&quot;</span>,<span class="string">&quot;This is a test mail&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MessagingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Mail </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统课程设计-pintos</title>
      <link href="/2023/02/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1-pintos/"/>
      <url>/2023/02/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1-pintos/</url>
      
        <content type="html"><![CDATA[<p>Pintos是一个用于80x86架构的简单操作系统框架，它以非常简单的方式实现了内核线程、加载和运行用户程序以及文件系统。本次实验将完善其线程与用户程序两个部分。</p><h2 id="1-实验准备"><a href="#1-实验准备" class="headerlink" title="1.实验准备"></a>1.实验准备</h2><h3 id="1-1安装Docker"><a href="#1-1安装Docker" class="headerlink" title="1.1安装Docker"></a>1.1安装Docker</h3><ul><li><p>安装配置Docker Desktop for Windows。</p></li><li><p>然后打开cmd执行：</p><p><code>docker run -it pkuflyingpig/pintos bash</code></p><p>这将下载并运行一个包含完整的Ubuntu18.04以及编译、运行和调试Pintos的所有工具链（包含qemu、gcc等）的镜像。</p></li></ul><h3 id="1-2下载并配置Pintos"><a href="#1-2下载并配置Pintos" class="headerlink" title="1.2下载并配置Pintos"></a>1.2下载并配置Pintos</h3><ul><li><p>进入链接<a href="https://pintos-os.org/cgi-bin/gitweb.cgi?p=pintos-anon;a=tree;h=refs/heads/master;hb=refs/heads/master">https://pintos-os.org/cgi-bin/gitweb.cgi?p=pintos-anon;a=tree;h=refs/heads/master;hb=refs/heads/master</a>  ，单击‘snapshot’下载pintos包并解压至本地。</p></li><li><p>cmd执行：</p><p><code>docker run -it --rm --name pintos --mount type=bind,source=absolute/path/to/pintos/on/your/host/machine,target=/home/PKUOS/pintos pkuflyingpig/pintos bash</code></p><p>将本地的pintos文件夹绑定到docker镜像,这样在vscode中修改代码后就可以马上运行测试。</p></li><li><p>用Vscode打开解压后的pintos文件夹，作如下修改：</p><ul><li>在pintos&#x2F;src&#x2F;utils&#x2F;pintos-gdb中GDBMACROS变量前增加‘~&#x2F;’（修改为完整路径）；</li><li>打开pintos&#x2F;src&#x2F;utils下的Makefile,将LOADLIBES变量名编辑为LDLIBS；</li><li>编辑&#x2F;utils&#x2F;pintos find_disks中的find_file函数采参数：替换kernel.bin为完整路径的（上面cmd命令中target目录pintos前的部分）kernel.bin；</li><li>编辑&#x2F;utils&#x2F;Pintos.pm（362行）：替换loader.bin为完整路径的loader.bin</li></ul></li></ul><h3 id="1-3使用Pintos"><a href="#1-3使用Pintos" class="headerlink" title="1.3使用Pintos"></a>1.3使用Pintos</h3><ul><li><p>运行docker镜像后，执行如下命令：<br>  <code>cd pintos/src/threads/</code></p><p>  <code>make</code></p><p>  <code>cd build</code></p><p>  <code>pintos --</code></p><p>  如果一切正常，则配置成功。</p></li><li><p>执行如下命令以运行pintos：  </p><p><code>pintos [--gdb] -- run mytest</code></p><p>如果使用了–gdb选项，则可以按如下步骤调试pintos：</p><ul><li><p>打开另一个cmd，输入：<br><code>docker exec -it pintos bash</code></p><p><code>cd pintos/src/threads/build</code></p><p><code>pintos-gdb kernel.o</code></p></li><li><p>在打开的gdb中输入‘debugpintos’，然后就可以自由调试pintos。</p></li></ul></li><li><p>调试完毕，则可以运行测试。<br>  例如在threads目录下执行：make check。如果一切正常，将看到测试结果。<br>  如果测试结果没有发生变化，可以先执行make clean删除原来生成的build目录，再重新运行测试。</p></li></ul><h2 id="2-Project1：Threads"><a href="#2-Project1：Threads" class="headerlink" title="2. Project1：Threads"></a>2. Project1：Threads</h2><h3 id="2-1-实验内容"><a href="#2-1-实验内容" class="headerlink" title="2.1 实验内容"></a>2.1 实验内容</h3><h4 id="2-1-1-Alarm-Clock"><a href="#2-1-1-Alarm-Clock" class="headerlink" title="2.1.1 Alarm Clock"></a>2.1.1 Alarm Clock</h4><p>重新实现在“devices&#x2F;timer.c”中定义的“timer_sleep()”。 pintos已经提供了一个可行的实现，但是它是“忙-等待”的，即循环检查当前时间并调用<code>thread_yield()</code>直到经过足够的时间。重新实现它以避免忙等待。</p><p>Function: void <strong>timer_sleep</strong> (int64_t ticks)</p><ul><li>暂停执行调用线程，直到时间提前至少x个计时器滴答为止。除非系统处于空闲状态，否则线程无需在精确的x滴答之后唤醒。他们等待正确的时间后，只需将其放在ready_list中即可。</li><li>“timer_sleep()”的参数以计时器刻度表示，而不是以毫秒或任何其他单位表示。每秒有TIMER_FREQ定时器滴答，其中TIMER_FREQ是在“devices&#x2F;timer.h”中定义的宏。默认值为100。不建议更改此值，因为任何更改都可能导致许多测试失败。</li></ul><h4 id="2-1-2-Priority-Scheduling"><a href="#2-1-2-Priority-Scheduling" class="headerlink" title="2.1.2 Priority Scheduling"></a>2.1.2 Priority Scheduling</h4><p>在Pintos中实施优先级调度。当将一个线程添加到具有比当前正在运行的线程更高的优先级的就绪列表时，当前线程应立即将处理器移交给新线程。同样，当线程正在等待锁、信号量或条件变量时，应首先唤醒优先级最高的线程。线程可以随时提高或降低其自身的优先级，但是降低其优先级以使其不再具有最高优先级时，则必须立即让出CPU。</p><p>线程优先级的范围是从PRI_MIN(0)到PRI_MAX(63)。较低的数字对应较低的优先级，因此优先级0是最低优先级，优先级63是最高优先级。 初始线程优先级作为参数传递给“ thread_create()”。如果没有理由选择其他优先级，则使用<code>PRI_DEFAULT(31)</code>。PRI_宏是在“threads&#x2F;thread.h”中定义的，不应更改其值。</p><p>优先级调度的一个问题是“优先级反转”。分别考虑高、中和低优先级线程H，M和L。如果H需要等待L（例如，等待由L持有的锁），而M在就绪列表中，则H将永远无法获得CPU，因为低优先级线程不会获得任何CPU时间。解决此问题的部分方法是，当L持有锁时，H将其优先级“捐赠”给L。L释放（这样H可以获得）锁。</p><p>实施优先级捐赠。需要考虑适用于需要优先级捐赠的所有不同情况。确保处理多个捐赠，即多个优先级捐赠给单个线程。还必须处理嵌套捐赠：如果H正在等待M持有的锁，而M正在等待L持有的锁，则M和L都应提升为H的优先级。</p><p>最后，实现以下函数，这些函数允许线程检查和修改其自身的优先级。这些功能的框架在“threads&#x2F;thread.c”中提供。</p><p>Function: void <strong>thread_set_priority</strong> (int new_priority )<br>将当前线程的优先级设置为new_priority。 如果当前线程不再具有最高优先级，则让出CPU。</p><p>Function: int <strong>thread_get_priority</strong> (void)<br>返回当前线程的优先级。 在存在优先级捐赠的情况下，返回较高（捐赠的）优先级。</p><p>无需提供任何接口即可允许线程直接修改其他线程的优先级。 </p><h4 id="2-1-3-Advanced-Scheduler"><a href="#2-1-3-Advanced-Scheduler" class="headerlink" title="2.1.3 Advanced Scheduler"></a>2.1.3 Advanced Scheduler</h4><p>实现类似于BSD调度器的多级反馈队列调度程序，以减少在系统上运行作业的平均响应时间。<br>与优先级调度程序类似，高级调度程序根据优先级选择要运行的线程。但是，高级调度程序不会进行优先级捐赠。</p><p>编写代码，以允许在Pintos启动时选择调度算法策略。默认情况下，优先级调度程序必须处于活动状态，但是我们必须能够通过“-mlfqs”内核选项选择BSD调度程序。传递此选项会将在“threads&#x2F;thread.h”中声明的“thread_mlfqs”设置为true。</p><p>启用BSD调度程序后，线程不再直接控制自己的优先级。 应该忽略对thread_create()的优先级参数以及对thread_set_priority()的任何调用，而对thread_get_priority()的调用应返回调度程序设置的线程的当前优先级。</p><p>线程优先级最初是在线程初始化时计算的。每四个时钟滴答也会重新计算一次。无论哪种情况，均由以下公式确定<br>priority &#x3D; PRI_MAX - (recent_cpu &#x2F; 4) - (nice * 2),<br>其中recent_cpu是线程最近使用的CPU时间的估计值，而nice是线程的nice值。结果应向下舍入。<br>有关高级调度器的详细实现，将在以下功能实现中说明。</p><h3 id="2-2-功能实现"><a href="#2-2-功能实现" class="headerlink" title="2.2 功能实现"></a>2.2 功能实现</h3><h4 id="2-2-1-Alarm-Clock"><a href="#2-2-1-Alarm-Clock" class="headerlink" title="2.2.1 Alarm Clock"></a>2.2.1 Alarm Clock</h4><ul><li>数据结构<ul><li><p>thread 新增全局变量<strong>sleep_list</strong>记录所有睡眠线程：</p><p><code>static struct list sleep_list;  </code></p></li><li><p>thread结构体新增成员变量<strong>sleep_ticks</strong>记录sleep时间，<strong>sleep_elem</strong>作为sleep_list的元素:</p><p><code>struct list_elem sleep_elem;</code></p><p><code>int64_t sleep_ticks;</code></p></li></ul></li></ul><p>然后在<code>thread_init</code>中加入sleep_list的初始化；在<code>thread_create</code>中将新线程的sleep_ticks初始化为0。</p><p>调用<code>timer_sleep</code>时，如果传递的参数ticks小于等于0，则调用<code>thread_yield</code>重新竞争cpu；否则调用<code>thread_sleep</code>（新增）方法置该线程的sleep_ticks为ticks，并将该线程加入sleep_list，然后阻塞该线程。</p><p>操作系统每次时钟中断（<code>timer_interrupt</code>）执行完<code>thread_tick</code>后，调用<code>thread_wake_up</code>（新增）方法。<br>该方法检查sleep_list中的每一个线程，将其sleep_ticks–，然后判断其值是否减至0。如是，则将其从sleep_list中移除，并调用<code>thread_unblock</code>唤醒该进程（该过程禁用中断）。</p><h4 id="2-2-2-Priority-Scheduling"><a href="#2-2-2-Priority-Scheduling" class="headerlink" title="2.2.2 Priority Scheduling"></a>2.2.2 Priority Scheduling</h4><h5 id="优先调度高优先级线程"><a href="#优先调度高优先级线程" class="headerlink" title="优先调度高优先级线程"></a>优先调度高优先级线程</h5><p>文档中要求，当一个优先级比当前运行线程优先级更高的线程加入就序列表（ready_list）时，当前线程应立即将处理器移交给新线程。为方便实现上述调度，这里将ready_list修改为优先级队列（头大尾小，因为在<code>next_thread_to_run</code>方法中，其调用的是<code>list_pop_front</code>方法获取ready_list的front线程，即优先级最高线程应在头部）。</p><ul><li>新增线程比较方法<code>thread_less_priority</code>，左参数线程优先级比右参数线程优先级大返回true。该方法可作为<code>list_insert_ordered</code>等方法参数中的比较函数。这样通过<code>list_insert_ordered</code>方法插入线程到ready_list时，优先级高的线程离头部近。</li><li>分别修改<code>thread_unblock</code>和<code>thread_yield</code>中插入ready_list的方法<code>list_push_back</code>为有序插入<code>list_insert_ordered</code>。</li></ul><p>当线程正在等待锁、信号量或条件变量时，首先唤醒优先级最高的线程。</p><ul><li>修改<code>sema_up</code>唤醒线程逻辑，通过<code>list_min</code>方法取出sema-&gt;waiter中优先级最高的线程（由于我的线程比较方法是左比右大返回true，这里用<code>list_min</code>而不是<code>list_max</code>），并将其唤醒。</li><li>类似的，修改<code>cond_signal</code>，以唤醒等待该条件的信号量的线程中优先级最大者。此处不再赘述。</li></ul><h5 id="实现优先级捐赠"><a href="#实现优先级捐赠" class="headerlink" title="实现优先级捐赠"></a>实现优先级捐赠</h5><p>文档中提到“优先级反转”问题可使用“优先级捐赠”来解决，并且必须实现锁的优先级捐赠。</p><p>考虑高、中和低优先级线程H，M和L。如果H需要申请某个锁，但该锁由L持有，且M在就绪列表中，则H将永远无法获得CPU，因为L不会获得任何CPU时间（只要有M存在），即L永远无法释放锁。采用优先级捐赠的方法解决上述问题：当L持有锁时，H将其优先级“捐赠”给L（即置L的优先级与H一致），这样L就能够获得CPU，也就可以释放锁。</p><p>按照本人理解，L释放锁后应该回归它原本的优先级，所以需要新增一个成员以记录线程原始的、不存在捐赠情况的优先级；文档中提到“确保处理多个捐赠，其中将多个优先级捐赠给单个线程”，那么每个线程应该要有一个占有锁的列表以方便应对多个捐赠的情况（相应的，锁也要增加一个list_elem成员）。而一个锁同时可以有多个申请者，最终捐赠的优先级应当是申请者中优先级最高者（文档中提到优先级捐赠不是累加的），因此锁中需要增加一个成员记录申请者中的最大优先级；文档中还提到了嵌套捐赠的情况，线程中可以增加一个成员记录正在等待的锁（如H等待的锁A由M占有，M等待的锁B由L占有，那么当H申请锁A时可以很方便的通过M的该成员（记录着锁B）追溯到L以进行嵌套捐赠）。</p><p>以下介绍锁的优先级捐赠的实现方法。</p><ul><li><p>数据结构：</p><p>thread结构体中增加如下成员：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> origin_priority;   <span class="comment">/* 未被捐赠时的初始priority */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list</span> <span class="title">hold_locks</span>;</span>   <span class="comment">/* 占有的锁 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lock</span> *<span class="title">waiting_lock</span>;</span>   <span class="comment">/* 正等待的锁 */</span></span><br></pre></td></tr></table></figure><p>并在init_thread中添加对上述成员的初始化：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t-&gt;origin_priority = priority;</span><br><span class="line">list_init (&amp;t-&gt;hold_locks);</span><br><span class="line">t-&gt;waiting_lock = <span class="literal">NULL</span>;  </span><br></pre></td></tr></table></figure><p>lock结构体中增加如下成员：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_elem</span> <span class="title">elem</span>;</span>      <span class="comment">/*hold_locks中的元素*/</span></span><br><span class="line"><span class="type">int</span> max_donate_priority;    <span class="comment">/*申请锁的线程中（捐赠者）优先级最大者*/</span></span><br></pre></td></tr></table></figure></li><li><p>修改<code>lock_acquire(struct lock *lock)</code>：</p><p>调用<code>lock_acquire</code>申请锁时（由于后续BSD调度不需要使用优先级捐赠，故这里thread_mlfqs需为false），如果申请的锁lock已被占有，则令当前线程的waiting_lock&#x3D;lock，然后调用<code>thread_donate_priority</code>（新增，见下）判断并处理优先级捐赠。</p><p>当执行完<code>sema_down</code>，即当前线程等待到锁，置其waiting_lock为空，更新获得锁的最大优先级（max_donate_priority）为当前线程优先级，并将其加入当前线程hold_locks列表（此处thread_mlfqs也为false）。最后将lock-&gt;holder置为当前线程。<code>sema_down</code>之后的过程不可被中断。</p><p>上面提到的<code>thread_donate_priority</code>方法判断是否存在优先级捐赠的情况：如果当前线程的优先级大于等待的锁的申请者中的最大优先级（max_donate_priority），则将其更新为当前线程优先级，并调用<code>thread_update_priority</code>（新增）更新锁的占有者的优先级（捐赠优先级）；然后从锁的占有者向上追溯，判断锁的占有者等待的锁（处理嵌套捐赠）。重复上述过程，直到没有等待的锁或当前线程的优先级不大于等待的锁的max_donate_priority（无需捐赠）。上述过程不可被中断。</p><p>其中的<code>thread_update_priority</code>将比较当前线程原始优先级（origin_priority）与其占有锁中申请者中的优先级最大者（hold_locks列表中的max_donate_priority最大者），取其较大者作为线程的实际优先级priority。</p><p>为实现上述获取hold_locks列表中的max_donate_priority最大者的功能，需新增lock的比较函数。根据比较函数的逻辑，可通过list_min或list_max方法获取最大元素。比较函数具体实现此处不再赘述。</p><p>整个lock_acquire流程如下：</p><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1-pintos/lock_acquire.png"></li><li><p>修改lock_release：</p><p>调用sema_up唤醒线程前，先调用<code>thread_remove_lock</code>将锁从hold_locks列表中删除，并调用<code>thread_update_priority</code>更新当前线程优先级（原先可能存在优先级捐赠情况，即实际优先级是其他线程捐赠的优先级）。</p></li></ul><h5 id="补充实现priority的get、set方法"><a href="#补充实现priority的get、set方法" class="headerlink" title="补充实现priority的get、set方法"></a>补充实现priority的get、set方法</h5><p>这些函数允许线程检查和修改其自身的优先级。set_priority后，如果当前线程不再具有最高优先级，则让出CPU。</p><ul><li>Function: void <strong>thread_set_priority</strong> (int new_priority )</li></ul><p>该过程不可被中断。如果不存在优先级捐赠情况，或新设置的优先级大于原来的实际优先级（可能是被捐赠的优先级），则将当前线程的实际优先级设置为new_priority。然后调用<code>thread_yield</code>重新竞争CPU。</p><ul><li><p>Function: int <strong>thread_get_priority</strong> (void)</p><p>返回当前线程的实际优先级priority。</p></li></ul><h4 id="2-2-3-Advanced-Scheduler"><a href="#2-2-3-Advanced-Scheduler" class="headerlink" title="2.2.3 Advanced Scheduler"></a>2.2.3 Advanced Scheduler</h4><p>这个部分整体上只需在正确的时间按文档要求套用公式计算对应的值即可。这里只维持一个优先级队列即ready_list。</p><p>每四个ticks使用以下公式重新计算一次所有线程优先级：</p><p><code>priority = PRI_MAX - (recent_cpu / 4) - (nice * 2)</code></p><p>每个线程有一个整数nice值，该值确定该线程与其他线程应该有多“不错”。nice为零不会影响线程优先级。正的nice会降低线程的优先级，并导致该线程放弃原本可以接收的CPU时间。nice值在-20~20之间。</p><p>recent_cpu测量线程“最近”接收到的CPU时间。在每个tick中，运行线程的recent_cpu递增1。每个线程的recent_cpu每秒一次以下述方式更新：</p><p><code>recent_cpu = (2*load_avg)/(2*load_avg + 1) * recent_cpu + nice</code>.</p><p>load_avg估计过去一分钟准备运行的平均线程数。它在引导时初始化为0，并每秒按如下公式重新计算一次：</p><p><code>load_avg = (59/60)*load_avg + (1/60)*ready_threads</code>.</p><p>其中ready_threads是在更新时正在运行或准备运行的线程数（不包括空闲线程）。  </p><p>在上面的公式中，priority，nice和ready_threads是整数，而recent_cpu和load_avg 是实数。Pintos在内核中并不支持浮点运算。因此必须使用整数来模拟实际数量的计算。</p><ul><li><p>Fixed-Point Real Arithmetic</p><p>本实验中，将带符号的32位整数的最低14位指定为小数位，这样整数x就表示实数x&#x2F;2^14。这被称为17.14定点数字表示形式，因为小数点前有17位，小数点后有14位，还有一个符号位。具体实现参考文档中给出的计算方法，以宏定义的方式实现。详情参见threads\fpra.h。</p></li></ul><p>基于上述计算方法，实现调度方法如下：</p><ul><li><p>数据结构：</p><ul><li><p>thread结构体内新增成员：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> nice; <span class="comment">/* 该值确定该线程与其他线程应该有多“不错” */</span></span><br><span class="line">fixed_point recent_cpu;  <span class="comment">/* 线程最近使用的CPU时间的估计值 */</span></span><br></pre></td></tr></table></figure><p>并在init_thread中初始化：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t-&gt;nice = <span class="number">0</span>;</span><br><span class="line">t-&gt;recent_cpu = FPRA_CONVERT_INT(<span class="number">0</span>);</span><br></pre></td></tr></table></figure></li><li><p>thread.c增加全局变量：</p><p><code>fixed_point load_avg;  /*系统平均负载*/</code></p><p>并在thread_start中初始化：</p><p><code>load_avg = FPRA_CONVERT_INT (0);</code></p></li></ul></li><li><p>修改timer_interrupt，使其完成以下功能：</p><p>对正在执行的非空闲线程的recent_cpu+1（通过新增方法<code>mlfqs_thread_recent_cpu_plus_one</code>），然后判断ticks：如果到达TIMER_FREQ（一秒）的倍数，更新一次load_avg和所有非闲线程(all_list中)的recent_cpu（通过新增方法<code>mlfqs_thread_update_per_second</code>）；如果为4的倍数，只重新计算并更新所有非闲线程优先级（通过新增方法<code>mlfqs_thread_update_priority</code>）。</p><p>上述几个方法只需用fpra.h中定义的计算方法套用文档中给出的计算公式即可。详情参见源代码。需要注意的是，当前正运行的非闲线程也应该计入ready_threads；计算完priority后需要将其调整为处于PRI_MIN至PRI_MAX的范围内。</p><p>流程如下：</p><img src="http://oss.ripplesu.top/blog/Typora/操作系统课程设计-pintos/流程图mlfqs.png"></li><li><p>最后，完善有关值的get、set方法：</p><ul><li><p><code>thread_set_nice(int nice)</code>：<br>将当前线程的nice值设置为nice，并根据新值调用<code>mlfqs_thread_update_priority</code>重新计算当前线程的优先级。然后调用<code>thread_yield</code>重新竞争CPU。</p></li><li><p><code>thread_get_nice(void)</code>:返回当前线程nice值即可。</p></li><li><p><code>thread_get_load_avg</code>:返回当前系统平均负载的100倍，四舍五入到最接近的整数：<br><code>FPRA_TO_INT_TO_NEAREST (FPRA_MULT_INT (load_avg, 100))</code></p></li><li><p><code>thread_get_recent_cpu</code>:返回当前线程的recent_cpu值的100倍，四舍五入到最接近的整数:<br><code>FPRA_TO_INT_TO_NEAREST (FPRA_MULT_INT (thread_current ()-&gt;recent_cpu, 100))</code></p></li></ul></li></ul><h3 id="2-3-测试结果"><a href="#2-3-测试结果" class="headerlink" title="2.3 测试结果"></a>2.3 测试结果</h3><ul><li>在线判题结果：<img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1-pintos/threads.png"></li></ul><h2 id="3-Project2：User-Programs"><a href="#3-Project2：User-Programs" class="headerlink" title="3. Project2：User Programs"></a>3. Project2：User Programs</h2><h3 id="3-1-实验内容"><a href="#3-1-实验内容" class="headerlink" title="3.1 实验内容"></a>3.1 实验内容</h3><h4 id="3-1-1-Process-Termination-Messages"><a href="#3-1-1-Process-Termination-Messages" class="headerlink" title="3.1.1 Process Termination Messages"></a>3.1.1 Process Termination Messages</h4><p>每当用户进程终止时，不管是因为它调用exit或任何其他原因，需打印该进程的名称和退出代码，其格式类似于由printf（“％s：exit（％d）\ n”，… ）;。 打印的名称应为传递给process_execute（）的全名，并省略命令行参数。当不是用户进程的内核线程终止时，或者在调用“halt”系统调用时，请勿打印这些消息。当进程无法加载时，此消息是可选的。</p><h4 id="3-1-2-Argument-Passing"><a href="#3-1-2-Argument-Passing" class="headerlink" title="3.1.2 Argument Passing"></a>3.1.2 Argument Passing</h4><p>当前，process_execute()不支持将参数传递给新进程。 通过扩展process_execute（）来实现此功能，以使它不仅将程序文件名作为参数，而且还将按空格分隔。第一个单词是程序名称，第二个单词是第一个参数，依此类推。也就是说，process_execute（“grep foo bar”）应该运行grep，并传递两个参数foo和bar。</p><h4 id="3-1-3-System-Calls"><a href="#3-1-3-System-Calls" class="headerlink" title="3.1.3 System Calls"></a>3.1.3 System Calls</h4><p>在“userprog&#x2F;syscall.c”中实现系统调用处理程序。它将需要检索系统调用号，然后检索系统调用参数，并执行适当的操作。</p><p>实现 halt~close 13个系统调用。列出的原型是由包含“lib&#x2F;user&#x2F;syscall.h”的用户程序看到的原型。（此头文件以及“lib&#x2F;user”中的所有其他头文件仅供用户程序使用。）每个系统调用的系统调用号在“lib&#x2F;syscall-nr.h”中定义。</p><p>要实现系统调用，需要提供在用户虚拟地址空间中读取和写入数据的方法。在获得系统调用号之前需要此功能，因为系统调用号位于用户的虚拟地址空间中的用户堆栈上。如果用户提供了无效的指针，指向内核内存的指针或部分位于这些区域之一的块，应该能够检查出并通过终止用户进程来处理这些情况。</p><p>必须同步系统调用，以便任意数量的用户进程可以进行调用。特别地，同时从多个线程调用“filesys”目录中提供的文件系统代码是不安全的。系统调用实现必须将文件系统代码视为临界区。不要忘记process_execute()也可以访问文件。</p><p>用户程序无法执行的任何操作都不会导致OS崩溃、死机、断言失败或其他故障。强调这一点很重要：测试将尝试以多种方式中断系统调用。需要考虑所有极端情况并加以处理。用户程序应该能够导致OS停止的唯一方法是调用“halt”系统调用。</p><p>如果系统调用传递了无效的参数，则可接受的选项包括返回错误值（对于那些返回值的调用），返回未定义的值或终止过程。</p><h4 id="3-1-4-Denying-Writes-to-Executables"><a href="#3-1-4-Denying-Writes-to-Executables" class="headerlink" title="3.1.4 Denying Writes to Executables"></a>3.1.4 Denying Writes to Executables</h4><p>添加代码以拒绝写入用作可执行文件的文件。如果进程尝试运行当时正在磁盘上进行更改的代码，结果将无法预测。</p><p>可以使用file_deny_write（）防止写入打开的文件。在文件上调用file_allow_write（）将重新启用它们（除非文件被另一个打开程序拒绝写入）。关闭文件也会重新启用写操作。因此，要拒绝写入进程的可执行文件，只要进程仍在运行，就必须保持打开状态。</p><h3 id="3-2-功能实现"><a href="#3-2-功能实现" class="headerlink" title="3.2 功能实现"></a>3.2 功能实现</h3><h4 id="3-2-1-Process-Termination-Messages"><a href="#3-2-1-Process-Termination-Messages" class="headerlink" title="3.2.1 Process Termination Messages"></a>3.2.1 Process Termination Messages</h4><ul><li><p>数据结构：<br>thread结构体中增加成员：</p><p><code>int exit_code; </code> &#x2F;&#x2F;退出代码</p><p>在<code>init_thread</code>中将其初始化为0：</p><p><code>t-&gt;exit_code = 0;</code></p><p>该值为0表示成功退出，非零值表示错误。</p></li></ul><p>然后在<code>thread_exit</code>方法执行完<code>process_exit</code>后，添加如下代码，按文档要求打印出进程的信息：<br><code>printf(&quot;%s: exit(%d)\n&quot;,thread_name(),thread_current()-&gt;exit_code);</code></p><p>后续测试中发现按我写的代码逻辑，无条件打印退出信息将导致测试点“exec-missing”失败。故后续将修改为子进程加载失败，在退出时不打印上述错误信息。</p><h4 id="3-2-2-Argument-Passing"><a href="#3-2-2-Argument-Passing" class="headerlink" title="3.2.2 Argument Passing"></a>3.2.2 Argument Passing</h4><h5 id="process-execute"><a href="#process-execute" class="headerlink" title="process_execute"></a>process_execute</h5><p>文档中提到，系统提供的process_execute函数不支持参数传递。它将程序文件名作为一个整体传递给thread_create作为程序名称。例如<code>process_execute（&quot;grep foo bar&quot;）</code>，它将”grep foo bar”整体作为程序的名称。而要求的实现是以”grep”作为程序名，并传递”foo bar”两个参数（程序名位于argv[0]）。</p><p>所以，修改<code>process_execute</code>以实现上述功能：</p><p>定义fn_copy、fn_copy1作为file_name的两个copy。其中fn_copy1通过strtok_r函数按空格分割为程序名与参数两部分，第一部分（程序名）存储在fn_copy1中作为参数传递给<code>thread_create</code>作为程序名称。由于<code>start_process</code>函数仍需要程序名，因此将fn_copy（file_name的完整拷贝）同样作为thread_create的参数。该参数将传递给start_process方法。</p><h5 id="start-process"><a href="#start-process" class="headerlink" title="start_process"></a>start_process</h5><p>start_process方法的任务是以文件名加载一个 ELF 格式的可执行文件（ELF是Linux、Solaris和许多其他操作系统使用的文件格式，用于目标文件、共享库和可执行文件），同时传递正确的参数。</p><p>start_process方法中同样以fn_copy作为file_name的拷贝，并执行与上述类似的分割方法。分割出的程序名存储在proc_name中作为参数传递给load方法，参数部分则存储在args中。load方法将返回加载是否成功的信息，并保存在success中。如果<code>success == true</code>，则开始解析参数，并将其放在堆栈上;如果执行失败，则置当前线程exit_code为-1，然后调用<code>thread_exit</code>。无论成功与否，最后都需要释放申请的字符串空间。</p><p>例如处理以下示例命令的参数：“&#x2F;bin&#x2F;ls -l foo bar” 其过程如下：<br>首先，将命令分解为单词：“&#x2F;bin &#x2F;ls”，“-l”，“foo”，“bar”，并将单词放在堆栈的顶部。<br>然后，按从右到左的顺序将每个字符串的地址以及一个空指针哨兵压入堆栈。这些是“argv”的元素。空指针sentinel可以确保C标准所要求的argv[argc]是空指针。该命令确保“argv[0]”位于最低虚拟地址。字对齐的访问比未对齐的访问要快，因此为了获得最佳性能，在第一次压入之前将堆栈指针向下舍入为4的倍数。<br>然后，依次将“argv”（“argv[0]”的地址）和“argc”入栈。<br>最后，推送一个伪造的“返回地址”。</p><p>详细代码以及每一步的意义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(success)&#123;</span><br><span class="line">  <span class="type">int</span> argc = <span class="number">0</span>;   <span class="comment">/* 参数个数 */</span></span><br><span class="line">  <span class="type">void</span>* argv[<span class="number">128</span>];<span class="comment">/* pintos实用程序可以传递给内核的命令行参数有128个字节的不相关限制。*/</span></span><br><span class="line">  <span class="type">char</span>* word; <span class="comment">/* 单词 */</span></span><br><span class="line">  <span class="comment">/*用户虚拟内存的范围从虚拟地址0到“PHYS_BASE”，默认为“ 0xc0000000”（3GB）。内核虚拟内存占用了其余的虚拟地址空间，从“PHYS_BASE”到最大4GB。</span></span><br><span class="line"><span class="comment">  应在用户虚拟地址空间的最顶部，即虚拟地址“PHYS_BASE”（在“threads/vaddr.h”中定义）下方的页面中开始堆栈。*/</span></span><br><span class="line">  <span class="comment">/*堆栈指针初始化为PHYS_BASE*/</span></span><br><span class="line">  if_.esp = PHYS_BASE;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 解析参数，将其放在栈顶。顺序无关紧要，因为它们将通过指针引用。*/</span></span><br><span class="line">  <span class="comment">/* char *strtok_r(char *str, const char *delim, char **saveptr);</span></span><br><span class="line"><span class="comment">    第一次调用strtok_r时，str参数必须指向待提取的字符串。</span></span><br><span class="line"><span class="comment">    连续调用时，str赋值为NULL。saveptr为上次调用后剩余的字符串。 */</span></span><br><span class="line">  <span class="keyword">for</span> (word = strtok_r (fn_copy, <span class="string">&quot; &quot;</span>, &amp;args); word != <span class="literal">NULL</span>; word = strtok_r (<span class="literal">NULL</span>, <span class="string">&quot; &quot;</span>, &amp;args)) &#123;</span><br><span class="line">    <span class="type">size_t</span> arg_len = <span class="built_in">strlen</span>(word) + <span class="number">1</span>; <span class="comment">//&#x27;\0&#x27;</span></span><br><span class="line">    if_.esp -= arg_len; <span class="comment">//地址空间从PHYS_BASE向下延伸</span></span><br><span class="line">    <span class="built_in">memcpy</span>(if_.esp, word, arg_len);<span class="comment">//将word复制到对应地址空间</span></span><br><span class="line">    argv[argc++] = if_.esp; <span class="comment">//通过指针引用参数</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 单词对齐的访问比未对齐的访问要快，因此为了获得最佳性能,在第一次压入之前将堆栈指针向下舍入为4的倍数。 */</span></span><br><span class="line">  <span class="comment">/* uintptr_t能够存储指针的无符号整数类型。这通常意味着它与指针的大小相同。*/</span></span><br><span class="line">  <span class="type">uintptr_t</span> tmp = (<span class="type">uintptr_t</span>)if_.esp; </span><br><span class="line">  <span class="keyword">if</span> (tmp % <span class="number">4</span> != <span class="number">0</span>)</span><br><span class="line">    tmp -= tmp % <span class="number">4</span>;</span><br><span class="line">  if_.esp = (<span class="type">void</span> *)tmp;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 按从右到左的顺序将每个字符串的地址以及一个空指针哨兵压入堆栈。</span></span><br><span class="line"><span class="comment">  这些是“argv”的元素。空指针sentinel(哨兵)可以确保C标准所要求的argv[argc]是空指针。</span></span><br><span class="line"><span class="comment">  该顺序确保“argv[0]”位于最低虚拟地址。*/</span></span><br><span class="line">  <span class="type">size_t</span> ptr_size = <span class="keyword">sizeof</span>(<span class="type">void</span> *); <span class="comment">//指针大小</span></span><br><span class="line">  if_.esp -= ptr_size;</span><br><span class="line">  <span class="built_in">memset</span>(if_.esp, <span class="number">0</span>, ptr_size); <span class="comment">//空指针</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = argc<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">    if_.esp -= ptr_size;</span><br><span class="line">    <span class="built_in">memcpy</span>(if_.esp, &amp;argv[i], ptr_size);<span class="comment">//依次将参数地址入栈</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 然后，依次将“argv”（“argv[0]”的地址）和“argc”入栈。*/</span></span><br><span class="line">  if_.esp -= ptr_size;</span><br><span class="line">  *(<span class="type">uintptr_t</span> *)if_.esp = ((<span class="type">uintptr_t</span>)if_.esp + ptr_size); </span><br><span class="line">  if_.esp -= ptr_size;</span><br><span class="line">  *(<span class="type">int</span> *)if_.esp = argc;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 最后，推送一个伪造的“返回地址”：</span></span><br><span class="line"><span class="comment">  尽管入口函数将永远不会返回，但其堆栈框架必须具有与其他任何结构相同的结构。 */</span></span><br><span class="line">  if_.esp -= ptr_size;</span><br><span class="line">  <span class="built_in">memset</span>(if_.esp, <span class="number">0</span>, ptr_size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* If load failed, quit. */</span></span><br><span class="line">palloc_free_page (file_name);  </span><br><span class="line">palloc_free_page (fn_copy);</span><br><span class="line"><span class="keyword">if</span> (!success) &#123;</span><br><span class="line">  thread_current()-&gt;exit_code = <span class="number">-1</span>;</span><br><span class="line">  thread_exit ();    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-3-System-Calls"><a href="#3-2-3-System-Calls" class="headerlink" title="3.2.3 System Calls"></a>3.2.3 System Calls</h4><h5 id="用户内存访问"><a href="#用户内存访问" class="headerlink" title="用户内存访问"></a>用户内存访问</h5><p>作为系统调用的一部分，内核必须经常通过用户程序提供的指针访问内存。内核必须非常小心，因为用户可能传递一个空指针，一个指向未映射虚拟内存的指针或一个指向内核虚拟地址空间的指针（在PHYS_BASE之上）。必须通过终止有问题的进程并释放其资源，拒绝所有这些类型的无效指针，而不会损害内核或其他正在运行的进程。<br>文档提供了两种设计思路，这里选择第二种（但又不完全是，此处实现可能并不完善，虽然能过测试点）。</p><p>检查用户指针的<code>check_user_ptr</code>方法实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> * </span><br><span class="line"><span class="title function_">check_user_ptr</span><span class="params">(<span class="type">void</span> *ptr)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* 判断传入的地址是否是用户可用的虚拟地址（地址是否在PHYS_BASE以下）*/</span></span><br><span class="line">  <span class="keyword">if</span> (!is_user_vaddr(ptr)) &#123;</span><br><span class="line">    kill_process();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* 判断虚拟地址及其上4字节的位置的内容是否正确，</span></span><br><span class="line"><span class="comment">    若不正确则调用kill_process()函数异常退出。否则将这个指针视作是正确的。 */</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123; </span><br><span class="line">    <span class="keyword">if</span> (get_user(ptr + i) == <span class="number">-1</span>) &#123;</span><br><span class="line">      kill_process();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法首先通过<code>is_user_vaddr</code>（定义在threads&#x2F;vaddr.h中）检查用户指针是否指向“PHYS_BASE”下方；然后通过文档中提供的<code>get_user</code>函数（从所给地址读取一个字节，如果成功则返回字节代表的值，否则返回-1）判断该地址及其上4字节（每个系统调用参数在堆栈中占用4个字节）地址是否可用。如是，则认为该指针是正确的，将其返回；否则调用<code>kill_process</code>（新增）将当前线程的exit_code置为-1，然后调用<code>thread_exit</code>终止该进程。</p><p>以下所有的系统调用获取参数时都需要通过该方法检查用户指针。</p><p>无效的用户指针将导致“页面错误”，因此需修改page_fault方法。文档中提到内核中的页面错误仅将eax设置为0xffffffff（-1）并将其以前的值复制到eip中，故修改page_fault方法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">user = (f-&gt;error_code &amp; PF_U) != <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (!user) &#123;</span><br><span class="line">  f-&gt;eip =  f-&gt;eax;</span><br><span class="line">  f-&gt;eax = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，page_fault的最后调用了<code>kill</code>方法，该方法中如果用户引发了段错误将调用<code>thread_exit</code>结束用户进程。而我在线程初始化时将exit_code初始化为0（正常退出），此处显然为异常退出，应在thread_exit前将当前线程的exit_code置为-1（否则bad开头的若干测试点无法通过，因为这些测试直接访问NULL引发了段错误）。</p><h5 id="系统调用基础结构"><a href="#系统调用基础结构" class="headerlink" title="系统调用基础结构"></a>系统调用基础结构</h5><p>本小节按照文档给出的推荐实现步骤，完成系统调用基础结构，实现halt、exit、write（部分）系统调用，使用户进程可以正常运行。</p><ul><li><p>改写syscall_handler，使其能够检索系统调用号，并根据系统调用号转移到对应的系统调用。</p><p>系统调用号在调用者的堆栈指针的32位字中，第一个参数在下一个更高地址的32位字中，依此类推。调用syscall_handler()的调用者的堆栈指针可以作为传递给它的“struct intr_frame”的“esp”成员访问。<br>先获取堆栈指针并通过<code>check_user_ptr</code>检查其合法性，然后转换为int*类型并将其解引用得到系统调用号（以下系统调用获取参数的过程与此类似）。再通过switch-case语句转移到对应的系统调用（系统调用号在“lib&#x2F;syscall-nr.h”中定义）。后续增加的系统调用只需在switch-case中增加对应的语句即可。</p></li><li><p>System Call: void halt (void)</p><p>halt系统调用很简单，只需通过调用“shutdown_power_off()”（在“threads&#x2F;init.h”中声明）终止Pintos。如下：</p></li><li><p>System Call: void exit (int status)</p><p>检查并获取参数status（系统调用号即intr_frame-&gt;esp的高32位字），将其作为当前线程的exit_code的值。然后调用thread_exit终止当前用户程序。按照惯例，状态状态为0表示成功，非零值表示错误。</p></li><li><p>System Call: int write (int fd, const void *buffer, unsigned size)</p><p>首先依次获取各个参数指针并检查其合法性，然后将其解引用。需要注意的是buf不仅要检查其指针，还需检查其字符串本体所在的地址空间。</p><p>如果文件描述符<code>fd == 1</code>，即写入标准输出，按照文档要求用<code>putbuf</code>一次性将size个字节从buffer写入打开的文件fd，并返回size。</p><p>fd不是1的情况将在后面文件系统调用部分补充。</p></li></ul><p>至此，只需将process_wait（）更改为无限循环，用户进程至少可以正常运行。后面将完善各个系统调用。</p><h5 id="exec与wait"><a href="#exec与wait" class="headerlink" title="exec与wait"></a>exec与wait</h5><p>exec系统调用的文档描述中提到“父进程在知道子进程是否成功加载其可执行文件之前不能从exec返回。您必须使用适当的同步来确保这一点”，在wait系统调用的描述中也大量提到父子进程的要求。故本小节的任务是实现父子进程，并实现与之相关的exec与wait系统调用。</p><ul><li><p>数据结构：</p><p>根据文档中描述，父进程需要知道子进程是否成功加载其可执行文件，并且在其加载完成之前不能返回。故在thread结构体中增加一个父进程指针<code>parent</code>、<code>sema_exec</code>信号量使父进程等待子进程的执行结果、<code>exec_success</code>标志子进程是否加载成功。<br>文档中又提到，“等待子进程pid并检索子进程的退出状态.如果pid仍然有效，请等待直到终止”、“进程可以生成任意数量的子代，以任何顺序等待它们”，这说明需要有一个列表记录所有子进程，并且对于每一个子进程需要有一个信号量以实现父子进程的同步、在子进程退出后父进程仍能检索子进程的相关信息。因此这里设计<code>child_info</code>结构体记录子进程需要向父进程传递的必要的信息，并在thread结构体中增加<code>children</code>列表记录其所有子进程。为方便子进程向父进程传递信息，且使得子进程退出后父进程仍能知晓子进程的相关信息，在thread结构体中增加child_info类型<code>as_child</code>成员，该成员在进程退出后不会马上销毁。</p><p>有关这些数据结构的详细使用，将在下面描述。</p><p>thread结构体中新增：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread</span> *<span class="title">parent</span>;</span>             <span class="comment">/* 父进程指针 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> <span class="title">sema_exec</span>;</span>        <span class="comment">/* 等待子进程加载其可执行文件 */</span></span><br><span class="line"><span class="type">bool</span> exec_success;                 <span class="comment">/* 加载是否成功 */</span>  </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list</span> <span class="title">children</span>;</span>              <span class="comment">/* 子进程列表 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">child_info</span> *<span class="title">as_child</span>;</span>       <span class="comment">/* 作为子进程提供给父进程的信息 */</span></span><br></pre></td></tr></table></figure><p>child_info结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">child_info</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">tid_t</span> tid;                  <span class="comment">/* 子进程tid */</span></span><br><span class="line">  <span class="type">bool</span> is_waiting;            <span class="comment">/* 父进程是否在等待该子进程 */</span></span><br><span class="line">  <span class="type">int</span> exit_code;              <span class="comment">/* 系统调用exit中的status */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> <span class="title">wait_sema</span>;</span> <span class="comment">/* 同步父子进程 */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_elem</span> <span class="title">elem</span>;</span>      <span class="comment">/* children中的list_elem */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在thread_create中初始化这些成员：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">t-&gt;as_child = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> child_info));</span><br><span class="line">t-&gt;as_child-&gt;tid = tid;</span><br><span class="line">t-&gt;as_child-&gt;is_waiting = <span class="literal">false</span>;</span><br><span class="line">t-&gt;as_child-&gt;exit_code = <span class="number">0</span>;</span><br><span class="line">sema_init(&amp;t-&gt;as_child-&gt;wait_sema, <span class="number">0</span>);</span><br><span class="line">sema_init(&amp;t-&gt;sema_exec, <span class="number">0</span>);</span><br><span class="line">t-&gt;parent = thread_current();</span><br><span class="line">list_push_back(&amp;t-&gt;parent-&gt;children, &amp;t-&gt;as_child-&gt;elem);</span><br></pre></td></tr></table></figure></li><li><p>System Call: pid_t exec (const char *cmd_line)</p><p>系统调用的任务是运行其名称在 cmd_line 中给出的可执行文件，并传递任何给定的参数，返回新进程的进程ID（pid）。 如果程序由于任何原因无法加载或运行，则必须返回pid -1，否则不应为有效pid。</p><p>用户指针的检查与参数的获取上面已经多次描述，以下不再叙述。<br>该系统调用将cmd_line中给出的可执行文件名以及参数一起传递给<code>process_execute</code>，该方法将根据加载的成功与否返回新进程的pid（pintos中为单线程，故pid也即tid）或-1，返回值写入到f-&gt;eax（函数返回值的80x86约定是将它们放在“EAX”寄存器中。 返回值的系统调用可以通过修改struct intr_frame的“eax”成员来实现）。<br><code>process_execute</code>方法的基本实现已经在3.2.2中描述。下面给出其在thread_create后增加的部分：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">tid = thread_create (fn_copy1, PRI_DEFAULT, start_process, fn_copy);</span><br><span class="line">···</span><br><span class="line">  <span class="comment">/* 由于未知原因此处sema_exec可能尚未初始化，导致assertion(is_tail) failed </span></span><br><span class="line"><span class="comment">    故这里手动判断并将其初始化 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_elem</span> *<span class="title">tail</span> =</span> list_tail(&amp;thread_current()-&gt;sema_exec.waiters);</span><br><span class="line"><span class="keyword">if</span>(tail-&gt;prev == <span class="literal">NULL</span>)</span><br><span class="line">  sema_init(&amp;thread_current()-&gt;sema_exec,<span class="number">0</span>);</span><br><span class="line">sema_down(&amp;thread_current()-&gt;sema_exec);</span><br><span class="line"><span class="keyword">if</span> (!thread_current()-&gt;exec_success) &#123;</span><br><span class="line">  <span class="keyword">return</span> TID_ERROR;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> tid;</span><br></pre></td></tr></table></figure><p>在创建子进程之后，为等待子进程加载其可执行文件的结果，这里调用<code>sema_down</code>阻塞父进程，等待子进程信号。然后父进程根据子进程修改的exec_success值返回相应的结果给exec系统调用。<br>在<code>start_process</code>中，若子进程成功加载（load返回true），将通过其父进程指针parent修改父进程的exec_success字段为true，并用<code>sema_up</code>唤醒父进程；若加载失败，则置自身的exit_code为-1，然后唤醒父进程，再调用<code>thread_exit</code>退出。</p></li><li><p>System Call: int wait (pid_t pid)</p><p>等待子进程pid并检索子进程的退出状态。文档中建议根据函数顶部的注释实现process_wait()，然后再根据process_wait()实现wait系统调用。</p><p>wait系统调用中只需检查并获取参数中的pid，将其作为参数传递给process_exit执行，执行的返回值写入到f-&gt;eax。</p><p><code>process_wait</code>方法将返回子进程的退出状态（exit_code）。<br>该方法首先根据系统调用中给出的pid(tid)检索该进程的children列表，如果找到对应pid的子进程，且<code>is_waiting == false</code>（父进程首次在pid上调用过wait），则将子进程的is_waiting字段置为true，然后调用sema_down等待该子进程终止。而如果is_waiting值为ture（文档原话：调用“wait”的进程已经在pid上调用过wait了），则根据文档要求，立即返回-1且不再等待。<br>如果检索完children列表但未找到对应pid的子进程，说明pid不是父进程的直接子级，则立即返回-1。<br>最后将pid从父进程的children列表中移除，并返回pid的exit_code给wait系统调用。</p><p>具体实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">process_wait</span> <span class="params">(<span class="type">tid_t</span> child_tid)</span> </span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">thread</span> *<span class="title">cur</span> =</span> thread_current();</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list</span> *<span class="title">children</span> =</span> &amp;cur-&gt;children;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_elem</span> *<span class="title">e</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">child_info</span> *<span class="title">child</span>;</span></span><br><span class="line">  <span class="keyword">for</span> (e = list_begin (children); e != list_end (children); e = list_next (e))</span><br><span class="line">  &#123;</span><br><span class="line">    child = list_entry(e, <span class="keyword">struct</span> child_info, elem);</span><br><span class="line">    <span class="keyword">if</span> (child-&gt;tid == child_tid) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!child-&gt;is_waiting) &#123;</span><br><span class="line">        child-&gt;is_waiting = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">/* 等待子进程终止。然后，返回子进程传递给exit的状态 */</span></span><br><span class="line">        sema_down(&amp;child-&gt;wait_sema); </span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/* 调用“wait”的进程已经在pid上调用过wait了。*/</span></span><br><span class="line">      <span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* pid不是父进程的直接子级 */</span></span><br><span class="line">  <span class="keyword">if</span> (e == list_end(children))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="comment">/* 将其从父进程的children中移除 */</span></span><br><span class="line">  list_remove(e);</span><br><span class="line">  <span class="keyword">return</span> child-&gt;exit_code;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>文档中还提到“父进程等待在父进程调用wait之前已经终止的子进程是完全合法的，但是内核仍必须允许父进程检索其子进程的退出状态，或者得知该子进程已被终止”。即如果调用wait前pid已经终止，此时再调用<code>sema_wait</code>将导致父进程忙等（终止的进程不可能再调用<code>sema_up</code>）。故子进程退出时需传递相关信息。</p><p>在thread_exit中添加如下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cur-&gt;as_child-&gt;exit_code = cur-&gt;exit_code;</span><br><span class="line">sema_up(&amp;cur-&gt;as_child-&gt;wait_sema);</span><br></pre></td></tr></table></figure><p>这样就能避免上述情况。</p></li></ul><h5 id="文件系统调用"><a href="#文件系统调用" class="headerlink" title="文件系统调用"></a>文件系统调用</h5><p>文档中提到，“您必须同步系统调用，以便任意数量的用户进程可以进行调用。特别地，同时从多个线程调用“filesys”目录中提供的文件系统代码是不安全的。您的系统调用实现必须将文件系统代码视为临界区。”</p><p>我用锁机制实现上述功能：<br>在syscall.h中加入：</p><p><code>struct lock file_lock;  /* 用于互斥访问file */</code></p><p>然后在syscall_init中完成对锁的初始化：</p><p><code>lock_init(&amp;file_lock);</code></p><p>以下系统调用对文件操作时都需要先加锁、后释放锁。</p><p>pintos在“filesys”目录下提供了一个简单但完整的文件系统，部分系统调用只需在加锁后调用对应函数即可。</p><ul><li><p>System Call: bool create (const char *file, unsigned initial_size)</p><p>创建一个名为file的新文件，其初始大小为 initial_size个字节。如果成功，则返回true，否则返回false。</p><p>filesys_create已经提供了相关的实现。该系统调用只需获取并检查参数、加锁、调用<code>filesys_create</code>并将返回值写入f-&gt;eax、释放锁即可。</p><p>如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> </span><br><span class="line"><span class="title function_">syscall_create</span><span class="params">(<span class="keyword">struct</span> intr_frame *f)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *file_name = *(<span class="type">char</span> **)check_user_ptr(f-&gt;esp + ptr_size);</span><br><span class="line">  check_user_ptr(file_name);</span><br><span class="line">  <span class="type">int</span> file_size = *(<span class="type">int</span> *)check_user_ptr(f-&gt;esp + <span class="number">2</span> * ptr_size);</span><br><span class="line"></span><br><span class="line">  lock_acquire(&amp;file_lock);  </span><br><span class="line">  f-&gt;eax = filesys_create(file_name, file_size);</span><br><span class="line">  lock_release(&amp;file_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>System Call: bool remove (const char *file)</p><p>删除名为file的文件。如果成功，则返回true，否则返回false。</p><p>具体实现同上，只需略去file_size参数、换为执行<code>filesys_remove</code>即可，此处不再赘述。</p></li><li><p>进程与文件</p><p>下面的系统调用中提到，每个进程可以打开多个文件，每个打开的文件有一个&gt;1的文件描述符，每个进程有一组独立的文件描述符。还需要根据文件描述符找到打开的文件。</p><p>为实现这些功能，增加如下数据结构与方法：</p><ul><li>数据结构：</li></ul><p><code>struct list file_list;   /* 打开文件列表 */</code></p><p><code>int next_fd;             /* 下一个打开文件的文件描述符，从2开始递增 */</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_info</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">int</span> fd;                             <span class="comment">/* 文件描述符 */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span>;</span>                     </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_elem</span> <span class="title">elem</span>;</span>              <span class="comment">/* file_list中的list_elem */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>并在<code>init_thread</code>初始化file_list、将next_fd初始化为2。</p><ul><li>方法：<br>下面的<code>find_in_file_list</code>方法根据fd在当前线程的file_list中找到对应的file_info。如果没有对应文件，则返回NULL。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> file_info *</span><br><span class="line"><span class="title function_">find_in_file_list</span><span class="params">(<span class="type">int</span> fd)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">thread</span> *<span class="title">cur</span> =</span> thread_current();</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_elem</span> *<span class="title">e</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file_info</span> *<span class="title">file</span>;</span></span><br><span class="line">  <span class="keyword">for</span> (e = list_begin (&amp;cur-&gt;file_list); e != list_end (&amp;cur-&gt;file_list); e = list_next (e))</span><br><span class="line">  &#123;</span><br><span class="line">    file = list_entry(e, <span class="keyword">struct</span> file_info, elem);</span><br><span class="line">    <span class="keyword">if</span> (file-&gt;fd == fd) &#123;</span><br><span class="line">      <span class="keyword">return</span> file;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>System Call: int open (const char *file)</p><p>打开（<code>filesys_open</code>）名为 file_name 的文件，返回文件描述符（fd写入到f-&gt;eax）。如果打开成功，则新建file_info类型变量，用malloc为其分配空间，然后令其fd的值为线程的next_fd，将其文件指针f指向打开的文件。然后将其加入当前线程的file_list。<br>如果无法打开文件，则返回-1。</p></li><li><p>System Call: int filesize (int fd)</p><p>返回以fd打开的文件的大小。</p><p>先得到参数fd，然后在当前线程的file_list中寻找文件描述符为fd的文件（通过<code>find_in_file_list</code>），若存在，filesys中已经提供了对应的实现file_length，调用之并将返回值写入f-&gt;eax即可。若不存在，则返回-1。</p></li><li><p>System Call: int read (int fd, void *buffer, unsigned size)</p><p>从打开为fd的文件中读取size个字节到buffer中。返回实际读取的字节数（文件末尾为0），如果无法读取文件（由于文件末尾以外的条件），则返回-1。</p><p>fd为0（标准输入）则使用<code>input_getc()</code>从键盘读取size个字节，然后将size返回。<br>否则，在当前线程的file_list中找到对应的文件，并用<code>file_read</code>方法读取文件，并将file_read的返回值（实际读取字节数）写到f-&gt;eax。如果找不到对应文件，则返回-1.</p></li><li><p>System Call: int write (int fd, const void *buffer, unsigned size)</p><p>write系统调用已经在3.2.3系统调用基础结构中实现了<code>fd == 1</code>的部分。这里只需将其补充完整。<br>与上面的read类似，只需要将<code>file_read</code>换成<code>file_write</code>即可。</p><p>以下是补充的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_info</span> *<span class="title">file</span> =</span> find_in_file_list(fd);</span><br><span class="line"><span class="keyword">if</span> (file)&#123;</span><br><span class="line">  lock_acquire(&amp;file_lock);  </span><br><span class="line">  f-&gt;eax = file_write(file-&gt;f, buf, size);</span><br><span class="line">  lock_release(&amp;file_lock);    </span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">  f-&gt;eax = <span class="number">0</span>; <span class="comment">//文档要求如果根本无法写入任何字节，则返回0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>System Call: void seek (int fd, unsigned position)</p><p>将打开文件fd中要读取或写入的下一个字节更改为position，以从文件开头开始的字节表示。</p><p>文档中提出这里已经在文件系统中（<code>file_seek</code>）实现，不需要额外的工作。即只需找到fd对应的file，并将其与参数中的position传递给file_seek执行。如果找不到fd则返回-1。其余与其他文件系统调用类似。</p></li><li><p>System Call: unsigned tell (int fd)</p><p>返回打开文件fd中要读取或写入的下一个字节的位置，以从文件开头开始的字节数表示。类似的，调用file_tell即可。</p></li><li><p>System Call: void close (int fd)<br>调用<code>file_close</code>关闭文件描述符fd。需要注意的是，关闭该文件后需要将其从file_list中移除，并释放其空间。其余与上相同。</p><p>另外，文档中提到“退出或终止进程会隐式关闭其所有打开的文件描述符，就像通过为每个进程调用此函数一样”。</p><p>因此，在线程退出时需要检索其file_list，关闭其打开的所有文件，并释放空间。<br>为thread_exit增加如下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 关闭所有已打开的文件 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_info</span> *<span class="title">file_opened</span>;</span></span><br><span class="line"><span class="keyword">while</span> (!list_empty(&amp;cur-&gt;file_list))</span><br><span class="line">&#123;</span><br><span class="line">  e = list_pop_front(&amp;cur-&gt;file_list);</span><br><span class="line">  file_opened = list_entry(e, <span class="keyword">struct</span> file_info, elem);</span><br><span class="line">  lock_acquire(&amp;file_lock);</span><br><span class="line">  file_close(file_opened-&gt;f);</span><br><span class="line">  lock_release(&amp;file_lock);</span><br><span class="line">  <span class="built_in">free</span>(file_opened);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-2-4-Denying-Writes-to-Executables"><a href="#3-2-4-Denying-Writes-to-Executables" class="headerlink" title="3.2.4 Denying Writes to Executables"></a>3.2.4 Denying Writes to Executables</h4><p>文档的最后要求添加代码以拒绝写入用作可执行文件的文件。并提示可以使用<code>file_deny_write（）</code>防止写入打开的文件，只要进程仍在运行，文件就必须保持打开状态。</p><p>故在thread结构体中增加成员以方便在进程退出时关闭打开的可执行文件：</p><p><code>struct file *file_executed;          /* 正在执行的文件 */</code></p><p>进程启动时将通过<code>process_execute</code>方法创建一个新线程，并在<code>start_process</code>中通过<code>load</code>加载可执行文件。<br>当加载成功后，添加如下代码以拒绝该可执行文件被修改：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line">success = load (proc_name, &amp;if_.eip, &amp;if_.esp);</span><br><span class="line"><span class="keyword">if</span>(success)&#123;</span><br><span class="line">  <span class="comment">// 这里的file_lock即上面在syscall.h中声明的锁</span></span><br><span class="line">  lock_acquire(&amp;file_lock);</span><br><span class="line">  <span class="comment">// 进程仍在运行，文件就必须保持打开状态</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span> =</span> filesys_open(proc_name);</span><br><span class="line">  <span class="comment">// 拒绝写入</span></span><br><span class="line">  file_deny_write(f);</span><br><span class="line">  lock_release(&amp;file_lock);</span><br><span class="line">  thread_current()-&gt;file_executed = f;</span><br><span class="line">  ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在进程结束时，关闭该可执行文件。这将重新启用写操作。</p><p>在<code>process_exit</code>的最后添加如下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lock_acquire(&amp;file_lock);</span><br><span class="line">file_close(cur-&gt;file_executed);</span><br><span class="line">lock_release(&amp;file_lock);</span><br></pre></td></tr></table></figure><p>至此，userprog完成。</p><h3 id="3-3测试结果"><a href="#3-3测试结果" class="headerlink" title="3.3测试结果"></a>3.3测试结果</h3><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1-pintos/userprog1.png"><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>本次实验完成了thread和userprog两部分，并且通过了全部测试点，从中我学到了很多东西。</p><p>thread实验中主要困难在于实现线程的调度。刚接触pintos让我有点无从下手，但在理解了pintos中的时钟中断处理与线程调度过程后，写起代码来也就得心应手。不过即使最后通过了所有测试点，在此过程中我仍有一些没有完全理解的地方；写报告的时候回过头来看又发现了一些不影响测试结果的错误。</p><p>例如原来在实现Alarm Clock的时候，原本只在thread结构体中增加了sleep_ticks变量，而没有sleep_list记录睡眠的线程。在调用timer_sleep时设置sleep_ticks的值并将其挂起，然后在timer_interrupt中查找all_list中的线程，使每个睡眠线程的sleep_ticks–；减至0时，将其唤醒。但是这种设计效率较低，而且不知为何导致后面一个测试点始终无法pass。<br>后来增加了sleep_list记录睡眠的线程，调用timer_sleep时将该线程放入sleep_list列表，在每个timer_interrupt时只检查sleep_list中的线程；若到达睡眠时间，则将其从sleep_list移除，并放入ready_list。从我个人理解来说，这样只减少了timer_interrupt中执行的任务量，提高了系统的效率。但修改之后，之前过不了的测试点莫名其妙也过了。这说明我的代码中可能还存在其他的错误。</p><p>再比如说，在将信号量和条件的等待队列改造为优先队列时，原本sema_down和cond_wait中通过list_insert_ordered进行有序插入，然后在唤醒线程时调用list_pop_front唤醒优先级最高的线程。理论上讲上述过程应该没有问题，但在执行过程中发现有几个测试点过不了；在pop_front前对队列执行一次排序后，对应的测试点就通过了。考虑可能是没有唤醒优先级最高的线程，但始终无法找到问题的根源。<br>最终版本中，我把insert_ordered都换回了push_back，然后在唤醒线程时调用list_min（max）找到优先级最大的线程，从而通过了上述的几个测试点。</p><p>这也让我深刻体会到，要编写一个没有漏洞的、能够实际使用的操作系统内核有多么困难。</p><p>而userprog的难点对我来说，主要在于对内核堆栈、程序加载与启动的理解。有了前面的基础，在理解了相关内容（例如指针的偏移）后编写代码也并不难，而且会发现有许多相似的工作。pintos也已经很大程度上简化了这部分的工作量，比如说每个进程只有一个线程、每个系统调用参数在堆栈中都占用4个字节、filesys中已经提供了许多功能的实现等等，文档中也给出了足够的提示。</p><p>相较于thread来说，个人认为userprog没有什么复杂的流程，但要通过所有测试点要比thread难不少，因为要考虑好父子进程的同步问题、文件的互斥问题、资源的回收、指针的检查等，稍不留神就可能导致父进程忙等、kernel panic等错误，这些错误又很难用gdb调试找到根源。</p><p>在这两个实验中，并发、互斥与同步都是重点，测试点中也有很多相关的地方。如何通过信号量、锁、条件变量来实现进程间的互斥与同步、临界区的访问等，这部分知识在课堂上也是重点内容。两个实验做下来，我认为难点不在于编写代码，而是理解操作系统底层知识、任务要求、内核代码的运行逻辑。在编写代码前，需要对pintos的同步机制、中断等有一个全面的认识。掌握了这些基本原理以后，解决实际问题时就更加得心应手。各种算法设计方案的正确与否，都能够通过测试来检验，测试中如果遇到问题，有了这些基本理论的加持，也就不会手足无措。本次课程设计很好地检验了我这部分知识的掌握情况，也锻炼了我将这部分知识投入实践的能力。</p><p>如何设计实验方案也是一个重要的内容。虽然文档中给出较为详细的任务要求，userprog中还给出了推荐的实现步骤，但最终还是要靠自己设计一个正确的实验方案与实现步骤。不合理的实现步骤可能徒增工作量甚至导致冲突。本次实验也锻炼了我这部分能力。</p>]]></content>
      
      
      <categories>
          
          <category> 实验实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>非关系式数据库期末复习</title>
      <link href="/2023/02/23/%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"/>
      <url>/2023/02/23/%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h3 id="非关系式数据库产生的原因"><a href="#非关系式数据库产生的原因" class="headerlink" title="非关系式数据库产生的原因"></a>非关系式数据库产生的原因</h3><p>关系式数据库局限性：高可用、高并发、高性能</p><h4 id="互联网环境下：数据量极大、访问量大、需求千变万化"><a href="#互联网环境下：数据量极大、访问量大、需求千变万化" class="headerlink" title="互联网环境下：数据量极大、访问量大、需求千变万化"></a>互联网环境下：数据量极大、访问量大、需求千变万化</h4><p>要求数据库系统有<strong>高可伸缩性</strong>、<strong>低成本开销</strong>、<strong>高度的灵活性</strong>和<strong>高度的可用性</strong></p><p><strong>可伸缩性</strong>是指有效应对负载变化的能力。</p><p>横向扩展：添加服务器；纵向扩展：升级服务器，配置更多的处理器、内存、网络资源。</p><h3 id="分布式数据库"><a href="#分布式数据库" class="headerlink" title="分布式数据库"></a>分布式数据库</h3><h4 id="集群架构"><a href="#集群架构" class="headerlink" title="集群架构"></a>集群架构</h4><p>集群（cluster）是互相连接的多个独立计算 机的集合，这些计算机可以是单机或多处理器系统（PC、工作站或SMP），每个结点都有自己的存储器、I&#x2F;O设备和操作系统，对用户来说是一个单一的系统，它可以提供低价高效的高性能环境和快速可靠的服务。</p><h4 id="分布式数据库管理的任务"><a href="#分布式数据库管理的任务" class="headerlink" title="分布式数据库管理的任务"></a>分布式数据库管理的任务</h4><p><strong>①</strong>持久的存储数据</p><p>为保证数据可用性，一份数据有多个副本。</p><p><strong>②</strong>维护数据一致性</p><p>用户所查询的数据与数据库中实际存储的数据的一致性， 以及不同数据副本之间的一致性。</p><p>强一致性：</p><p>任何时刻所有的用户查询到的都是最近一次成功更新的数据。这是要求</p><p>最高的标准，也是最难实现的，关系型数据库采用该标准。</p><p>弱一致性：</p><p>某个用户更新了某数据副本，但是系统不能保证后面的用户能够读取到</p><p>最新的值。</p><p><strong>最终一致性</strong>：</p><p>最终一致性是弱一致性的一种特例。某用户更新了副本的数据，如果没有其他用户更新这个副本的数据，系统最终一定能够保证后续用户能够读取到该用户写的最新值。最终一致性存在一个不一致性的窗口，也就是用户写入数据到其他用户读取所写的新值所用的时间。</p><p>a) 因果一致性</p><p>如果用户A通知用户B它已更新了一个数据项，那么用户 B的后续访问将返回更新后的值，且下一次写入将保证取代前一次写入。与用户A无因果关系的用户C的访问遵守一般的 最终一致性规则。</p><p>b) 读写一致性</p><p>当用户A自己更新一个数据项之后，它总是访问到更新过的值，绝不会看到旧值。这是因果一致性模型的一个特例。</p><p>c) 会话一致性</p><p>把访问系统的所有用户放到会话的上下文中，只要会 话还存在，系统就保证读写一致性。如果由于某些失败情 形令会话终止，就要建立新的会话，而且系统保证不会延 续到新的会话。</p><p>d) 单调读一致性</p><p>如果用户已经看到过数据对象的某个值，那么任何后续 访问都不会返回在那个值之前的值。</p><p>e) 单调写一致性</p><p>系统保证来自同一个用户的写操作按顺序执行。</p><p><strong>③</strong>保证数据可用性</p><p>数据库可用性指数据库应该随时可供使用。一般设置主服务器和备份服务器，通过两阶段提交（先写主，在写备份）策略保证数据一致性。</p><h3 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h3><p>在一个<strong>分布式系统</strong>中，一致性（Consistency） 、可用性（Availability）、分区容错性（Partition tolerance）三个基本需求最多只能同时满足两个， 不可能三者兼顾。</p><p>一致性（C） ：各服务器中的数据副本要彼此相同，当一个节点的数据更新完成后，要求其他副 本的数据与此相同。</p><p>可用性（A）：系统能够持续不断地提供相应服务，响应任意的查询请求。</p><p>分区容错性（P）： 由于网络故障，集群被切分成了若干个孤立的区域，这就是分区。分区容错性要求各分区之间虽然不能够通信，但各分区依然可以提供数据服务。一般地，分布式数据库必须尽力在网络发生故障的情况下继续工作，因此分区容错性是<strong>基本要求</strong>。</p><p>CA：SQLServer、MySql</p><p>AP：Cassandra、CouchDB、Riak</p><p>CP：Neo4j、MongoDB、Redis、HBASE、Bigtable</p><h3 id="ACID原理"><a href="#ACID原理" class="headerlink" title="ACID原理"></a>ACID原理</h3><p>ACID是指<strong>事务</strong>必须具备的四个特性:</p><p>(1)原子性(Atomicity)：每个事务是不可分割的数据库逻辑工作单位。</p><p>(2)一致性(Consistency)：事务的执行结果必须使数据库从一个一致性状态变到另一个一致性状态。</p><p>(3)隔离性(Isolation)：并发执行的各个事务之间不能相互干扰。</p><p>(4)持续性(Durability)：持续性也称为永久性，指一个事务一旦提交，它对数据库中数据的改变应该是永久性的。</p><h3 id="BASE原理"><a href="#BASE原理" class="headerlink" title="BASE原理"></a>BASE原理</h3><p>BASE原理与ACID原理不同，它满足CAP原理，通过牺牲强一致性获得可用性，通过达到<strong>最终一致性</strong>来尽量满足业务的绝大多数需求，是NoSQL的性质：</p><p>• BA：Basically Available 基本可用：如果分布式系统中的某些服务器出现了故障，其他服务器仍然可以继续提供服务。</p><p>• S：Soft state 软状态，数据库中的数据最终会被新值所覆盖。</p><p>• E：Eventually consistency 最终一致性，数据副本有可能在短时间内出现彼此不一致的现象，但最终将完成所有副本的更新，保持一致性。</p><h3 id="非关系式数据库基本特征"><a href="#非关系式数据库基本特征" class="headerlink" title="非关系式数据库基本特征"></a>非关系式数据库基本特征</h3><p>1）不需要预定义模式：每条记录都可能有不同的属性和格式，其模式在插入数据时动态定义。</p><p>2）弹性可扩展：可以动态增加或者删除集群节点，数据可自行迁移。</p><p>3）数据分区存放：将数据进行分区之后存储在多个节点上，节点间自动进行数据复制，制作多个数据副本。</p><p>4）异步复制数据：将数据先写入一个节点，再根据数据备份的数量复制数据，这样可以尽快地写入一个节点。</p><p>5）BASE：相对于事务严格的ACID特性，NoSQL数据库保证的是BASE特性。</p><p>非关系式数据库适用的范围： 1）数据模型比较简单； 2）需要灵活性更强的集群系统； 3）关注更高的性能； 4）不需要保证强一致性。</p><h2 id="键值数据库"><a href="#键值数据库" class="headerlink" title="键值数据库"></a>键值数据库</h2><h3 id="键值数据库的数据结构"><a href="#键值数据库的数据结构" class="headerlink" title="键值数据库的数据结构"></a>键值数据库的数据结构</h3><p>键值数据库根据键名（Key）来读写键值（Value），其采用的数据模型是关联数组。</p><p>关联数组（associative array）是和普通数组类似的一种数据结构，但与数组相比具有两个不同的特点：</p><p>（1） 关联数组的每个元素的数据类型可以不同，如其中的元素可以分别是整数、浮点数、字符、列表、对象等；</p><p>（2） 关联数组的下标不仅可以是整数，还可以是字符串。</p><p>也就是说，关联数组是数组概念的泛化，它以唯一的标识符作为下标的有序列表，这个下标称为键（Key），而数组元素称为值（Value）。关联数组也被称为字典、映射、哈希或者符号表等，在键值数据库中被称为键值对。</p><p>键值数据库的数据结构就是<strong>关联数组</strong>，也称为Hash表，形式上是一个键值对（Key，Value）。</p><p>– 键（Key）：用来查询值的唯一标识符。</p><p>– 值（Value）：是一个实例，与唯一的Key相关联，可以是任意的数据类型。</p><p>– 命名空间键(namespace):键值对构成的集合，也称为桶（bucket）或数据库(database)。</p><p>• 同一个命名空间中的键不允许相同，不同命名空间中的键可以相同。</p><p>– 分区：根据键名，把数据分割成不同的单元，存储在集群中的不同服务器上，实现负载均衡。</p><h3 id="键的设计与分区"><a href="#键的设计与分区" class="headerlink" title="键的设计与分区"></a>键的设计与分区</h3><p><strong>键</strong></p><p>键命名一般方法： 实体名：实体标识符：实体属性</p><p><strong>分区</strong></p><p>集群中的一组或一个服务器称为集群的分区。 目标：尽可能将键值对均衡地分配给集群中的不同分区。</p><p>一般以“键”作为分区的依据，通过所定义的Hash哈希函数直接将键值对映射到相应分区。</p><p>如果两个不同的键产生了相同的哈希值，则称为<strong>碰撞</strong>。 解决的基本方法是在对应的存储空间中另外设置一个列表，类似于一个链表。</p><p>如果某个键无法实现<strong>负载均衡</strong>，可以采取的办法： 另选合适的分区键，使得分区结果更加均衡；改变哈希分区算法。</p><p><strong>命名空间</strong></p><p>由互不相同的<strong>键值对</strong>所构成<strong>集合</strong>称为命名空间，也称为桶。同一个命名空间中的键互不相同；不同命名空间中的键可以相同。</p><p><strong>无纲要模式</strong></p><p>对于关系型数据库，一般需要先构建数据库纲要 （<strong>数据库结构</strong>），然后再添加数据。 • 在键值数据库中，则采用无纲要模型： – 不需要在添加数据之前定义所有的键，也无需 指定值的数据类型； – 可以任意的修改数据。</p><h3 id="键值数据库特点"><a href="#键值数据库特点" class="headerlink" title="键值数据库特点"></a>键值数据库特点</h3><p>数据模型简单-键值对、速度快-缓存、易缩放-动态增减结点</p><p>局限性：只能通过键来查询数据；不支持查询某个范围的值；不支持SQL式的标准查询语言。</p><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><p>String 是 Redis 最基本的数据类型，一个 key 对应一个 value，可以存储任何数据，最大能存储 512MB。数值型数据作为字符串处理。</p><p>–SET key value：设置指定 key 的值</p><p>-GET key：获取指定 key 的值。</p><p>–GETRANGE key start end:返回 key 中字符串值的子串</p><h4 id="Hash数据类型"><a href="#Hash数据类型" class="headerlink" title="Hash数据类型"></a>Hash数据类型</h4><p>哈希Hash是一个String类型的field和value的映射表，用于 存储对象,每个hash可以存储232-1键值对（40多亿）。</p><p>–HSET key field value:将哈希表 key 中的 field 的值设为 value</p><p>–HGET key field：获取指定 key 的指定字段的值。</p><p>–HMSET key field1 value1 field2 value2…：同时设置多个Hash</p><p>–HGETALL key:获得哈希表中指定key的所有字段和值。</p><h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><p>List列表是简单的字符串列表，按照插入顺序排序。</p><p>–LPUSH key value1 [value2]:将一个或多个值插入到列表 头部（左部）</p><p>–LRANGE key start stop:获取列表指定范围内的元素</p><p>–RPUSH key value1 [value2]:将一个或多个值插入到列表 尾部（右部）</p><h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><p>Set是String类型的无序集合，集合成员是唯一的，不能出现重复的数据。通过哈希表实现，每个集合可存储40 多亿个成员。</p><p>–SADD key member1 [member2]：向集合添加一个或多个成员</p><p>–SMEMBERS key:返回集合中的所有成员。</p><p>–SREM key member1 [member2]：移除集合中一个或多个成员</p><h4 id="Sorted-Set"><a href="#Sorted-Set" class="headerlink" title="Sorted Set"></a>Sorted Set</h4><p>Sorted Set有序集合和集合一样也是String类型元素的 集合，且不允许重复的成员。不同的是每个元素都会关联一个double类型的数，Redis通过这个数来为集合中的成员进行从小到大的排序。</p><p>–ZADD key score1 member1 [score2 member2]：向有序集 合添加一个或多个成员，或者更新已存在成员的数值</p><p>–ZRANGE key start stop [WITHSCORES]:通过索引区间返回有序集合指定区间内的成员</p><h4 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h4><p>Redis事务的定义方法：</p><p>–执行MULTI:开始一个事务。</p><p>–命令入队。</p><p>–执行EXEC：依次执行队列中的命令。</p><p>单个命令是原子性的，但事务不是原子性的。</p><p>批量操作在发送 EXEC 命令前被放入队列缓存；</p><p>收到 EXEC 命令后进入事务执行，事务中任意命令执行失败，其余的命令依然被执行（非原子性）；</p><p>在事务执行过程，其他客户端提交的命令请求不会插入 到事务执行命令序列中。</p><h2 id="文档数据库"><a href="#文档数据库" class="headerlink" title="文档数据库"></a>文档数据库</h2><p>文档数据库是将数据以文档的形式存储，若干个文档形成一个集合，若干个集合构成了一个独立的文档数据库。</p><p>文档是由一些键值对构成的有序集合。而键值对是由键和值组成的， 且每个键值对只能出现一次。文档通常用 JSON 格式进行编写，也可以用 XML 格式进行描述。</p><p>集合是由相似文档构成的组，同一个集合内的文档结构可以是不同的。集合没有类似SQL数据库中严格的数据库结构（称为模式或纲要），无需提前为集合中的文档定义模式，是无纲要的数据库。一般地，集合内的文档通常都与同一个主题相关。</p><p>文档数据库是存放集合的容器。</p><h3 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h3><p>1）垂直分区：对文档的键值对进行分区，不同的键值 对存储到不同的服务器上</p><p>2）水平分区 将不同的文档划分在不同的分区上，称为“分片”，这些分片会保存在不同的服务器上。</p><p>–优势：提高文档数据库的访问性能，并发度；提高文档数据库的可扩展性。</p><p>–用分片键来划分：用某个键去划分文档，如名称、 类型、日期、地域等。</p><p>–用分区算法来实现数据划分，如按照范围、标准、 哈希分区等。</p><h3 id="设计策略"><a href="#设计策略" class="headerlink" title="设计策略"></a>设计策略</h3><p>在关系数据库中，规范化的目标是减少数据冗余 和更新异常。在文档数据库中，为了提高性能，尽量少地进行连接操作，把相关的数据都放在同一份文档之内，这个过程称为去规范化。 1：n关系</p><p>– 采用嵌套的两个文档表示一对多关系中的两个实体</p><p>– 在文档中给出父节点&#x2F;子节点的引用</p><p>N:M关系</p><p>– 采用两个集合来建模，每个集合表示一种实体， 每个集合内的文档维护一份标识符列表。</p><h3 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h3><p>show dbs；db 显示当前数据库；use dbname；db.dropDatabase()</p><h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><p>1）db.createCollection(name, options)：创建集合，类似 数据库中的表。</p><p>– name: 要创建的集合名称；</p><p>– options: 可选参数, 指定有关内存大小及索引的选 项；</p><p>例如：db.createCollection(“orders”,{size:1024,capped:true,ma x:100}) &#x2F;&#x2F;指定size 1024KB，大小固定，满了就会删除旧文 档，最多存放100个文档。</p><p>2）show collections：显示当前数据库中的集合。</p><p>3）db.collection.drop()：删除集合</p><h4 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h4><p>1）db.COLLECTION_NAME**.insert(**document):向集合中添加文档，注意大小写敏感。</p><p>db.firstcollect.insert({</p><p>person_id:319,</p><p>name:”Gang zhang”,</p><p>occupation:”teacher”,</p><p>address: [</p><p>{street:”Zhaohui road”, zip: 310014},</p><p>{street:”Liuhe road”, zip:310032} ]</p><p>})</p><p>2）db.COLLECTION_NAME.insertOne():向指定集合中插入一条文档数据</p><p>– db.firstcollect.insertOne({“a”: 3})</p><p>3）db.COLLECTION_NAME.**insertMany():**向指定集合中插入多条文档数据</p><p>– db.firstcollect.insertMany([{“b”: 3}, {‘c’: 4}])</p><p>4）db.COLLECTION_NAME.<strong>find({query}, {projection})</strong>: 查询指定集合中的文档，注意大小写敏感。</p><p>–query：使用查询操作符指定查询条件，<strong>必填，但可以是空</strong>。类似于SQL中的where子句。</p><p>–projection ：可选参数，使用<strong>投影</strong>操作符指定返回的键。如果返回所有键值，省略该参数。类似于 SQL中的Select子句</p><p>db.COLLECTION_NAME.find().pretty():</p><p>–pretty()方法：可选，以格式化的方式来显示所有 文档。</p><p>–sort({key: 1&#x2F;-1}) 方法：对文档按照key排序，1为升序排列，-1降序排列。</p><p>–skip()方法 ：可选，跳过指定数量的记录，优先级 2（&gt;3）。</p><p>–limit()方法：可选，指定读取的记录条数，优先级 3。</p><p>例如：db.orders.find({},{_id:0}) db.orders.find({cust_id:“A123”})</p><p>db.orders.find({},{_id:0,cust_id:1,amount:1}).limit(2).skip(1).sort({amount:-1})</p><p><img src="http://oss.ripplesu.top/blog/Typora/%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/1ee8d632-1ad1-46f2-8f81-aaffca6d1e22.png" alt="image.png"></p><p>5）db.COLLECTION_NAME.<strong>update</strong>(<strong>&lt;query&gt;,&lt;update&gt;,</strong></p><p>{<strong>upsert</strong>:&lt;boolean&gt;,<strong>multi</strong>: &lt;boolean&gt;, <strong>writeConcern</strong>: &lt;document&gt;})</p><p>– query:更新条件，必填。</p><p>– update:更新的对象和一些更新的操作符，必填。</p><p>– 更新参数：</p><p>• upsert:如果不存在update的记录，是否插入新文档，true为插入，</p><p>默认是false，不插入。选填</p><p>·multi: 默认是false,只更新找到的第一条记录，如果这个参数为true, 就把按条件查出来多条记录全部更新。选填</p><p>db.orders.update({cust_id:”A123”},{$set:{amount:500}},true,false)</p><p>6）db.COLLECTION_NAME.save(&lt;document&gt;):插入或更新已存在的文档。</p><p>指定 _id 字段更新，否则insert</p><p>7）db.COLLECTION_NAME.remove({}) : 移除集合中的文档。</p><p>– query: 删除文档的条件，必填。</p><p>– justOne：如果设为 true 或 1，则只删除一个文档，如果不设置该参数，或使用默认值 false，则删除所有匹配条件的文档。</p><p>deleteOne（）、deleteMany（）类似。</p><h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><p>1）db.collection.createIndex({keys：value}, options})</p><p>– Key:要创建的索引字段，value值是1按升序创建索引，-1则按降序创建索引。</p><p>– Options：根据该参数创建不同类型的索引。</p><p>• 在title上按升序创建一个索引</p><p>db.col.createIndex({“title”:1})</p><p>• 在title和description多个Key上创建复合、唯一索引”cust_index”</p><p>db.col.createIndex({“title”:1,”description”:-1}, { name:”cust_index”,unique: true}) db.collection.dropIndex(“cust_index”) db.orders.getIndexes()</p><h4 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h4><p>db.COLLECTION.aggregate([{pipeline1},{pipelin e2},{pipeline3}…]): 主要用于数据的分组统计，如求平均值、求和等，类似sql语句中的 sum()、count()等。</p><p>– Pipeline操作: 管道操作的目的在于将上一个管道命令的输出作为下一个管道命令的输入。</p><p>db.orders.aggregate([{$match:{status:”A”}},{$group:{ _id:”$cust_id”,totals:{$sum:”$amount”}}}])</p><p>–先使用$match命令查询符合条件的文档，再使用$group命令根据”cust_id”分组统计。</p><h4 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h4><p>MongoDB 模糊查询使用反斜杠“&#x2F;”，并结合一些转义字符实现模糊查询，通过例子来说明具 体使用方法。</p><p>查询图书名称中包含”office”的文档，其语句为：</p><p>db.Books.find({“book_name”:<strong>&#x2F;office&#x2F;</strong>}).pretty()</p><p><img src="http://oss.ripplesu.top/blog/Typora/%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/393f21eb-cfcb-42fa-9f7c-1ab7ee12591d.png" alt="image.png"></p><h2 id="列族数据库"><a href="#列族数据库" class="headerlink" title="列族数据库"></a>列族数据库</h2><h3 id="集群机制"><a href="#集群机制" class="headerlink" title="集群机制"></a>集群机制</h3><h4 id="列族数据库特点"><a href="#列族数据库特点" class="headerlink" title="列族数据库特点"></a>列族数据库特点</h4><p>① 弹性可扩展： Cassandra高度可扩展，允许添加更 多的硬件以适应更多的客户和更多的数据。 ② 始终基于架构：Cassandra没有单点故障，它可以 连续用于不能承担故障的关键业务应用程序。 ③ 线性可扩展： Cassandra通过增加集群中的节点数 量增加吞吐量，保持一个快速的响应时间。 ④ 灵活的数据存储：Cassandra适应所有可能的数据 格式，包括：结构化，半结构化和非结构化。可 以根据需要动态地适应变化的数据结构。⑤ 便捷的数据分发：Cassandra通过在多个数据中 心之间复制数据，可以灵活地在需要时分发数据。 ⑥ 事务支持：支持最终一致性（AP）。 ⑦ 快速写入：被设计为在廉价的商品硬件上运行。 它执行快速写入，并可以存储数百TB的数据， 而不牺牲读取效率。</p><h4 id="Cassandra架构"><a href="#Cassandra架构" class="headerlink" title="Cassandra架构"></a>Cassandra架构</h4><p>Cassandra的设计目的是处理跨多个节点的大数据工作负载，而没有任何单点故障；节点之间具有对等分布式系统，并且数据分布在集群中的所有节点之间。</p><p>– Cassandra集群是一个对等的网络，所有节点都扮演相同的 角色， 每个节点是独立的，并且同时互连到其他节点。</p><p>– Cassandra集群中的每个节点都可以接受读取和写入请求， 无论数据实际位于集群中的何处。</p><p>– 当某节点关闭时，可以从网络中的其他节点提供读&#x2F;写请求。</p><p>1）Cassandra<strong>存储机制</strong>：</p><p>• <strong>提交日志</strong>（CommitLog）： Cassandra在写入数据之前，都要先写日志，用于崩溃后的恢复。</p><p>• <strong>存储表</strong>（Mem表）：是一个驻留在内存中的数据结构，当超过存储表的块大小时，批量写入到磁盘上，即SSTable上。</p><p>• <strong>磁盘文件</strong>（SSTable）： Cassandra在磁盘上存储列族数据的文件。</p><p>• <strong>布隆（Bloom）过滤器</strong>：Cassandra中使用了Bloom过滤器来检测行键所代表的数据是否存在。</p><p>2）Cassandra<strong>通信机制</strong>：</p><p>Cassandra采用<strong>Gossiper协议</strong>进行节点间通信，通过该机制可以了解集群中包含哪些节点、每个节点的状态，这使得集群中任何一个节点都可以收到其他服务器的状态信息，完成任意读取和写入操作；</p><p>此外，Cassandra采用<strong>反熵机制</strong>定期检查节点数据，保障不同副本数据之间的一致性。这里采用的检查不一致的方法是<strong>Merkle Tree</strong>（默克尔树）。</p><p>3）Cassandra<strong>数据复制</strong></p><p>• 数据复制方式：将数据分配到各个节点上，每个节点会存放部分数据的一个副本，允许数据在节点间相互复制，对用户透明。但要求同一行的所有数据必须放在集群的同一节点上。</p><p>• 数据副本因子：定义了集群中存储的副本数量，例如副本 因子是3，则存储3份数据副本。</p><p>数据复制策略：定义数据的副本如何放置到集群环上。</p><p>– <strong>SimpleStrategy</strong> ：不考虑机架的因素，存储在连续的几个节点。假如副本数为3，属于A节点的数据存储在相邻的两个节点中。</p><p>– <strong>OldNetworkTopologyStrategy</strong> :考虑机架的因素，先找一个与第一个数据副本不在同一个数据中心的节点放置第二个 副本；然后再继续找与第二个备份节点位于同一个数据中心，但是不同机架的节点进行备份；接下来所有的备份节点寻找策略就按照SimpleStrategy的备份策略继续寻找。</p><p>– <strong>NetworkTopologyStrategy</strong> ：将M个副本放置到其他的数据中心，将N-M-1的副本放置在同一数据中心的不同机架中。</p><p>4）Cassandra<strong>读写过程</strong></p><p>• 写操作：</p><p>– 节点的每个写入活动都由提交日志捕获。</p><p>– 稍后数据将被存储在内存表中。</p><p>– 每当内存表满时，数据将写入SStable数据文件。</p><p>– 所有写入都会在整个集群中自动分区和复制。</p><p>– Cassandra会定期整合SSTables，丢弃不必要的数据。</p><p>• 读操作：</p><p>– 先从内存表读取所需要的值。</p><p>– 否则从保存所需数据的SSTable中读取。</p><h3 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h3><p>·Keyspace：键空间，概念同早期版本，对应一个数据库。</p><p>• Table：表，与键族的概念相对应，且与RDBMS中的表很类似，不同的是在 Cassandra 中属于同一张表的数据在物理上是分布在不同节点上存储的，同 一张表由多个分区（Partition）组成。</p><p>• 主键：同之前的行键，是一行数据的唯一标识符；如果主键由多个键组成，则称为复合主键。</p><p>• 复合主键：复合主键各部分作用不同：</p><p>– 分区键（partition key）：复合主键的第一个或者第一组 是分区键，将根据这个column的值来分区。不同的分区 会被存储在不同的节点上，<strong>同一行数据分配到相同节点</strong>。</p><p>– 聚类键（clustering columns）：复合主键的第二个及之后 的键为聚类键，用来给数据<strong>排序</strong>，或者索引。</p><p>• <strong>只有主键中涉及的column，才可以作为查询的条件</strong>。</p><p>• 集合数据类型：Cassandra新版本通过设置集合数据 类型来灵活实现超级列：</p><p>– List数据类型：列表，存储类型相同且可以重复的值。</p><p>• [value, value,…]</p><p>– Set数据类型：集合，存储类型相同但不重复的值。</p><p>• {value, value, …}</p><p>– Map数据类型：提供了键到值的映射，每一个元素在内部 作为一列存储，可以修改，替换，删除和查询。</p><p>• {‘key1’:value1, ‘key2’:value2}</p><h3 id="操作语言"><a href="#操作语言" class="headerlink" title="操作语言"></a>操作语言</h3><h4 id="创建键空间"><a href="#创建键空间" class="headerlink" title="创建键空间"></a>创建键空间</h4><p>CREATE KEYSPACE KeySpaceName WITH replication &#x3D; {‘<strong>class</strong>‘: ‘Strategy name’, ‘<strong>replication_factor</strong>‘ : ‘No.Of replicas’}</p><h4 id="增删改-类似于SQL"><a href="#增删改-类似于SQL" class="headerlink" title="增删改 类似于SQL"></a>增删改 类似于SQL</h4><p>CREATE (TABLE | COLUMNFAMILY) ( primary key， [static] ，…… )</p><p>– 静态列：列为静态(STATIC)则能够在在一个给定<strong>分区键</strong>里的多行数据之间共享数据</p><p>例如：</p><p>CREATE TABLE users (</p><p>username text,</p><p>id timeuuid,</p><p>email text STATIC,</p><p>encrypted_password blob STATIC,</p><p>body text,</p><p>PRIMARY KEY (username, id)</p><p>);</p><p>– 将 email 和 encrypted_password 两个字段设置为 STATIC列了，则意味着同一个 username 只会有一个 email 和 encrypted_password 。</p><p>– 在插入获修改数据时，email和encrypted_password 都被设置为相同的值</p><h4 id="查"><a href="#查" class="headerlink" title="查"></a>查</h4><p>SELECT * FROM &lt;table name&gt;</p><p>WHERE &lt;condition&gt;;</p><p>• Where 条件中只支持主键列及索引列的查询。</p><p>• <strong>分区主键</strong>只能用”**&#x3D;**”比较运算符进行查询。</p><p>• 聚类主键支持&#x3D;、&gt;、 &lt;、 &gt;&#x3D;、 &lt;&#x3D;，且要<strong>依次使用</strong>。</p><p>primary key(key1, key2, key3) key1&#x3D;</p><p>• <strong>索引列</strong>只支持**&#x3D;**查询。</p><p>• 否则，需要增加<strong>allow filtering</strong>短语，表示强制查询。</p><p>·删除 DELETE [ column_name ] FROM &lt;identifier&gt; WHERE &lt;condition&gt;</p><h4 id="集合-1"><a href="#集合-1" class="headerlink" title="集合"></a>集合</h4><p><img src="http://oss.ripplesu.top/blog/Typora/%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/28a19bd6-a78d-4262-b974-fb8e1e4519fb.png" alt="image.png"></p><p><img src="http://oss.ripplesu.top/blog/Typora/%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/14e4b88e-c183-4e65-9e15-b842a712b22c.png" alt="image.png"></p><p><img src="http://oss.ripplesu.top/blog/Typora/%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/30f31845-e3e1-4641-9682-03b5528f6aa6.png" alt="image.png"></p><p><img src="http://oss.ripplesu.top/blog/Typora/%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/dd461fe5-4301-4925-ac53-beb0de97b177.png" alt="image.png"></p><p><img src="http://oss.ripplesu.top/blog/Typora/%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/73d8fafe-0b86-4c57-8c02-7f6d3876e578.png" alt="image.png"></p><p><img src="http://oss.ripplesu.top/blog/Typora/%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/21e8df2c-ddd8-4f26-95e2-63c4b64ee096.png" alt="image.png"></p><p><img src="http://oss.ripplesu.top/blog/Typora/%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/ba1ca70b-5b06-4bde-8426-3b899abb2666.png" alt="image.png"></p><h2 id="图数据库"><a href="#图数据库" class="headerlink" title="图数据库"></a>图数据库</h2><p>图数据库是一种基于图论的新型NoSQL数据库， 它的数据存储结构和数据查询方式都是以图论为基础：</p><p>· 节点：表示对象，对象可 以有属性和标签；</p><p>• 边：表示对象间的关系， 边也可以有属性和类型；</p><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><h4 id="属性图数据模型"><a href="#属性图数据模型" class="headerlink" title="属性图数据模型"></a>属性图数据模型</h4><p>图数据模型定义了图中节点以及关系的存储和实现方法。</p><p>属性图是一种常用的图数据模型，被广泛采用，如Neo4j，其主要特点如下：</p><p>– 图由节点和关系（边）组成；</p><p>– 节点有一个或多个标签；</p><p>– 节点有一组属性（键值对）；</p><p>– 关系有一个类型，可以有一组属性；</p><p>– 关系是有方向的，只有一个开始节点和一个结束节点。</p><h4 id="三元组图数据模型"><a href="#三元组图数据模型" class="headerlink" title="三元组图数据模型"></a>三元组图数据模型</h4><p>三元组模型是另外一种重要的图数据模型，包含主谓宾的数据结构，通过三元组来表达实体与实体之间的关系，或者属性与属性值之间的关系，有两种形式：</p><p>– （实体，关系，实体）</p><p>– （实体，属性，属性值）</p><h4 id="超图"><a href="#超图" class="headerlink" title="超图"></a>超图</h4><p>一条边可以关联多个节点</p><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p><strong>写语句：</strong></p><h4 id="创建节点Create语句"><a href="#创建节点Create语句" class="headerlink" title="创建节点Create语句"></a>创建节点Create语句</h4><p>节点用一对小括号<strong>（）</strong>表示，是图数据库的一个节点，节点可以有一个或多个标签，可以有一个或多个 属性。</p><p>Create (Variable:Lable1:Lable2 {Key1:Value1, Key2:Value2})</p><h4 id="创建关系Create语句"><a href="#创建关系Create语句" class="headerlink" title="创建关系Create语句"></a>创建关系Create语句</h4><p>关系用**[]<strong>表示，创建关系时要指定头节点、尾节点和</strong>类型**， 并指定关系方向</p><p>– 符号“（a）-[r:type]-&gt;（b）”，表示有方向的关系。</p><p>StartNode-[Variable:Type {Key1: Value1, Key2:Value2}] -&gt; EndNode</p><p>• 创建两个节点和一个关系</p><p>CREATE (n:Person { name: ‘Robert’, born: 1951 })</p><p>-[r:DIRECTED] -&gt; (m:Movie { title: ‘Forrest’, released: 1951 })</p><p>RETURN n,r,m</p><p>• Create语句<strong>无法创建没有方向的关系</strong></p><h4 id="MERGE语句"><a href="#MERGE语句" class="headerlink" title="MERGE语句"></a>MERGE语句</h4><p>MERGE语句的作用有两个：</p><p>– 若模式存在，则匹配指定的模式；</p><p>– 若模式不存在，则创建新的模式；</p><p>– 功能是Match子句和Create子句的组合。</p><p>当在整个模式上使用MERGE时，要么整个模式匹配到，要么整个模式被创建。MERGE不能部分应用于模式</p><p>• 检查‘michael’节点是否存在，若不存在该节点，则创建该节点并设置它的属性；若存在所匹配的节点，则不设置它的属性。</p><p>Merge (n:Person{name:’michael’}) <em>on create</em> set n.age&#x3D;20 return n</p><h4 id="SET语句"><a href="#SET语句" class="headerlink" title="SET语句"></a>SET语句</h4><p>SET语句用于更新节点的标签以及节点和关系的属性。</p><p>• 为节点新增一个属性。</p><p>MATCH (n:Person{name:’michael’}) SET <strong>n.born</strong> &#x3D; 1955 RETURN n</p><p>• 为节点新增两个标签。</p><p>MATCH (n:Person{name:’michael’}) SET <strong>n:Teacher:Man</strong> RETURN n</p><p>• 将一个节点的属性值设置为Null，此时属性被删除</p><p>MATCH (n:Person{name:’michael’}) SET n.name&#x3D;<strong>NULL</strong> RETURN n</p><p>• 匹配节点，若匹配成功，则在该节点上设置属性； 若匹配不成功，则创建新节点，不设置属性。</p><p>Merge(n:Teacher{name: ‘michael’}) <strong>on match</strong> set n.title&#x3D;’Professor’ return</p><h4 id="DELETE语句"><a href="#DELETE语句" class="headerlink" title="DELETE语句"></a>DELETE语句</h4><p>DELETE语句用于删除图元素（节点、关系或者路径）。</p><p>– 不能只删除节点，而不删除与之相连的关系，要么显式地删除对应的关系。</p><p>– <strong>DETACH</strong> DELETE语句能够删除一个节点及其所有关系。</p><h4 id="REMOVE语句"><a href="#REMOVE语句" class="headerlink" title="REMOVE语句"></a>REMOVE语句</h4><p>REMOVE语句用于移除节点的标签或者节点和关系的属性。</p><p>• 移除节点的一个属性。</p><p>MATCH (n:Person{name:’michael’}) Remove n.born RETURN n</p><p>• 移除节点的一个（或多个）标签。</p><p>Match(n:Person{name:’Cheng long’}) remove n:Person:Man return n</p><h4 id="FOREACH语句"><a href="#FOREACH语句" class="headerlink" title="FOREACH语句"></a>FOREACH语句</h4><p>FOREACH语句能够更新列表、路径等集合中的每一个元素，可执行的更新命令包括CREATE、SET、 CREATE UNIQUE、DELETE。</p><p>语法格式： <strong>FOREACH (变量 IN [列表] | 更新语句)</strong></p><p>例如：FOREACH (n IN <strong>nodes(p)</strong> | SET n.marked&#x3D;TRUE)</p><p><strong>读语句：</strong></p><h4 id="Match"><a href="#Match" class="headerlink" title="Match"></a>Match</h4><p>• 查询与给定节点<strong>有关系</strong>的节点</p><p>match (n)<strong>–</strong>(m:Movie{title:’American’}) return n,m</p><h4 id="OPTIONAL-MATCH语句"><a href="#OPTIONAL-MATCH语句" class="headerlink" title="OPTIONAL MATCH语句"></a>OPTIONAL MATCH语句</h4><p>OPTIONAL MATCH匹配模式与Match类似，不同之处在于，如果没有匹配到，OPTIONAL MATCH将用 <strong>NULL作为未匹配到部分的值</strong>。</p><h4 id="aggregation"><a href="#aggregation" class="headerlink" title="aggregation"></a>aggregation</h4><p>count、sum、avg、min、max、<strong>collect（放入一个列表）</strong></p><p><strong>通用语句：</strong></p><h4 id="Return：返回查询结果集中的内容。"><a href="#Return：返回查询结果集中的内容。" class="headerlink" title="Return：返回查询结果集中的内容。"></a>Return：返回查询结果集中的内容。</h4><h4 id="Order-by：对输出结果进行排序。"><a href="#Order-by：对输出结果进行排序。" class="headerlink" title="Order by：对输出结果进行排序。"></a>Order by：对输出结果进行排序。</h4><p>ORDER BY语句用于对输出的结果进行排序，要<strong>紧跟在RETURN或WITH的后面</strong>，它指定了输出的结果 应该如何排序，ASC升序，DESC降序。</p><h4 id="Limit：限制输出的行数。"><a href="#Limit：限制输出的行数。" class="headerlink" title="Limit：限制输出的行数。"></a>Limit：限制输出的行数。</h4><h4 id="Skip：跳过开始的一部分结果。"><a href="#Skip：跳过开始的一部分结果。" class="headerlink" title="Skip：跳过开始的一部分结果。"></a>Skip：跳过开始的一部分结果。</h4><h4 id="With：将分段的查询部分连接在一起，查询结果从一部分以管道形式传递给另外一部分作为开始点。"><a href="#With：将分段的查询部分连接在一起，查询结果从一部分以管道形式传递给另外一部分作为开始点。" class="headerlink" title="With：将分段的查询部分连接在一起，查询结果从一部分以管道形式传递给另外一部分作为开始点。"></a>With：将分段的查询部分连接在一起，查询结果从一部分以管道形式传递给另外一部分作为开始点。</h4><p>一个复杂的查询语句可能需要经多次处理。WITH语句把上一个查询语句的结果作为输入，经适当处理， 再把结果传递到后面的语句中。类似于<strong>管道</strong></p><p>MATCH (d{name:’D’})–(n1)–&gt;(n2) WITH n1, <strong>count</strong>(n2) AS num WHERE num &gt;1 RETURN n1.name,num</p><p><strong>聚合的结果必须通过with子句才能被过滤</strong>，即with子句保留n1，并新增聚合查询count(*)，通过where子句过滤。</p><p>• 按照姓名排序后，收集姓名的列表</p><p>MATCH (n) WITH n ORDER BY n.name DESC RETURN collect(n.name)</p><p>ORDER BY子句不可以跟在Match语句后面，要紧跟RETURN或者WITH的后面</p><h4 id="Unwind：将一个列表展开为一个行的序列，列表可以以参数的形式传入。"><a href="#Unwind：将一个列表展开为一个行的序列，列表可以以参数的形式传入。" class="headerlink" title="Unwind：将一个列表展开为一个行的序列，列表可以以参数的形式传入。"></a>Unwind：将一个列表展开为一个行的序列，列表可以以参数的形式传入。</h4><p><img src="http://oss.ripplesu.top/blog/Typora/%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/5815713f-66fb-4daf-9f31-36e7f04be7b0.png" alt="image.png"></p><h4 id="Union：将多个查询结果组合起来。"><a href="#Union：将多个查询结果组合起来。" class="headerlink" title="Union：将多个查询结果组合起来。"></a>Union：将多个查询结果组合起来。</h4><p>• UNION语句：将两个结果集进行合并，去掉重复的。</p><p>• UNION ALL语句：将两个结果集合并，不去掉重复的。</p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="断言函数"><a href="#断言函数" class="headerlink" title="断言函数"></a>断言函数</h4><p>断言是一个布尔函数，即对给定的输入返回true 或false，用于过滤子图。</p><p>• All：判断断言是否适用于列表中的所有元素。</p><p>• Any：判断断言是否至少适用于列表中的一个元素。</p><p>• None：断言不适用于列表中的任何元素，则返回true。</p><p>• Single：断言刚好只适用于列表中的某一个元素，则返回true 。</p><p>语法：</p><p>All&#x2F;Any&#x2F;None&#x2F;Single (variable IN list WHERE predicate)</p><p>– variable：断言变量</p><p>– list：列表表达式</p><p>– predicate：测试列表中所有元素的断言</p><p>例如：</p><p>Any(var IN nodes(p) WHERE var.eyes&#x3D;’blue’)</p><p>• Exists：数据库存在该<strong>模式</strong>或节点中存在该<strong>属性</strong>时，返回true 。</p><p>返回具有name属性，且是否已婚的信息。</p><p>MATCH (n) WHERE <strong>exists(n.name)</strong> &#x2F;&#x2F;存在指定name属性</p><p>RETURN n.name AS name, <strong>exists((n)-[:MARRIED]-&gt;())</strong> AS is_married</p><h4 id="标量函数"><a href="#标量函数" class="headerlink" title="标量函数"></a>标量函数</h4><p>• Size：返回列表中元素的个数。</p><p>返回模式表达式匹配的<strong>子图的个数</strong></p><p>MATCH(a) WHERE a.name&#x3D;’Alice’ RETURN <strong>size((a)–&gt;()–&gt;())</strong> AS num</p><p>• Length：返回路径的长度（关系的个数）。</p><p>• <strong>Type：返回关系的类型(关系的类型只有一个)。</strong></p><p>• Id：返回关系或者节点的id.</p><p>• Coalesce：返回表达式列表中第一个非空的值，若全为空， 返回null。</p><p>• Head：返回列表中的第一个元素。</p><p>• Last ：返回列表中最后一个元素。</p><p>• startNode:返回一个关系的开始节点。</p><p>• endNode：返回一个关系的结束节点。</p><p>·<strong>PROPERTIES()<strong>：返回节点或关系的</strong>属性及属性值</strong>。</p><h4 id="列表函数"><a href="#列表函数" class="headerlink" title="列表函数"></a>列表函数</h4><p>• <strong>Nodes</strong>：返回<strong>路径中的所有节点</strong>的属性和属性值。</p><p>• <strong>Relationships</strong>：返回路径中的<strong>所有关系</strong>的属性和属性值。</p><p>• <strong>Labels</strong>：返回节点的标签(标签可以有多个)。</p><p>• Keys：以字符串形式返回一个节点、关系或map的所有<strong>属性名称</strong>。</p><p>• Tail：返回除首元素之外的所有元素。</p><p>• Range：返回某个范围内的数值，值之间默认步长为1。</p><p>返回0-10之间步长为1，2-18步长为3的所有值。</p><p>RETURN range(0,10),range(2,18,3)</p><p>• Reduce：对列表中每个元素执行表达式，将表达式结果存入累加器。</p><p>将路径中每个节点的age数值加起来，返回一个单值</p><p>RETURN reduce(totalAge&#x3D;0, n IN nodes(p) | totalAge+n.age) AS reduction</p><h3 id="模式操作"><a href="#模式操作" class="headerlink" title="模式操作"></a>模式操作</h3><p><strong>模式用于描述如何查询图数据</strong>，包括节点模式、关系模式、关联节点模式、变长路径的模式、 路径变量。</p><h4 id="模式概念"><a href="#模式概念" class="headerlink" title="模式概念"></a>模式概念</h4><p>1、节点模式</p><p>节点模式使用一对小括号()表示，节点具有标签和属性，如果需要引用节点，则需要定义节点变量，常见的节点模式如下：</p><p>· ()：该模式用于描述节点，且是匿名节点；</p><p>·(n) ：该模式用于描述节点，节点变量名是 n；</p><p>· (n:label)：该模式用于描述节点，节点具有指定的标签 label，也可以指定多个标签；</p><p>··(n{name: ‘Vic’})：该模式用于描述节点，节点具有 name 属性，并且属性值是’Vic’，也可以指定多个属性；</p><p>· (n:label{name: ‘Vic’})：该模式用于描述节点，节点具有指定的标签 label 和属性 name，并且属性值是 ‘Vic’。</p><p>2、关系模式</p><p>关系模式使用一对中括号[]表示，如果需要引用关系，则需要定义关系变量，常见的关系模式如下：</p><p>· []：该模式用于描述关系，且是匿名关系；</p><p>· [r]：该模式用于描述关系，关系变量名是 r；</p><p>· [r: type]：该模式用于描述关系，type 是关系类型，每一个关系必须有且仅有一个类型；</p><p>· [r:type {name: ‘Friend’}]：该模式用于描述关系，关系的类型是 type，关系具有属性 name，并且属性值是 ‘Friend’。</p><p>3、关联节点模式</p><p>节点之间通过关系联系在一起，由于关系具有方向性，因此，–&gt;表示有向关系，–表示存在关系，但不指定方向，常见的关联节点模式如下：</p><p>· (a)-[r]-&gt;(b) ：该模式用于描述节点 a 和 b 之间存在的有向关系 r；</p><p>· (a)–&gt;(b)：该模式用于描述节点 a 和节点 b 之间存在的有向关系；</p><p>· (a)-[r]-(b)：该模式用于描述节点 a 和 b 之间存在关系 r，不指定方向。</p><p>4、路径模式</p><p>路径（Path）是节点和关系的有序组合。从一个节点通过直接关系链接到另外一个节点，这个过程叫遍历，经过的关系个数称为路径长度，也称为步长。Neo4j 支持变长路径模式，**[*N..M]表示路径长度的最小值为 N，最大值为 M**，常见的路径模式如下：</p><p>· (a)–&gt;(b)：是步长为 1 的路径，节点 a 和 b 之间存在直接关系，且方向从 a 到 b；</p><p>· (a)–&gt;()–&gt;(b)：是步长为 2 的路径，从节点 a 经过两个关系和一个节点，到达节点 b；</p><p>· (a)-[*2]-&gt;(b)：表示路径长度固定为 2，头节点是 a，尾节点是 b；</p><p>· (a)-[*3..5]-&gt;(b)：表示路径长度的最小值是 3，最大值是 5，头节点是 a，尾节点是 b；</p><p>· (a)-[*3..]-&gt;(b)：表示路径长度的最小值是 3，头节点是 a，尾节点是 b；</p><p>· (a)-[*..5]-&gt;(b)：表示路径长度的最大值是 5，头节点是 a，尾节点是 b；</p><p>· (a)-[*]-&gt;(b)：表示不限制路径长度，头节点是 a，尾节点是 b。</p><p>此外，路径可以赋给一个变量，该变量是路径变量，用于查询路径。5、路径变量</p><p>路径可以指定（assign）给一个变量，该变量是路径变量，用于引用查询路径。</p><p>• 返回‘Alice‘节点到’Daniel‘节点，且长度不超过3的路径:</p><p>MATCH <strong>p&#x3D;(a)-[*1..3]-&gt;(b)</strong>  WHERE a.name&#x3D;’Alice’ AND</p><p>b.name&#x3D;’Daniel’ RETURN p</p><h4 id="索引-1"><a href="#索引-1" class="headerlink" title="索引"></a>索引</h4><p>使用CREATE INDEX ON 可以在<strong>拥有某个标签的所有节点的某个属性</strong>上创建索引。</p><p>• 在拥有Person标签的节点name属性上创建索引</p><p>CREATE（Drop） INDEX ON :Person(name)</p><h4 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h4><p>约束 Neo4j通过使用约束来保证数据完整性。约束可应用于节点 或者关系，可以创建节点属性的唯一性约束，也可以创建节点 和关系的属性存在性约束。</p><p>在节点的 name 属性上添加唯一性约束。</p><p><strong>CREATE CONSTRAINT ON (b:Person) ASSERT b.name IS UNIQUE</strong></p><p>通过上述唯一性约束，<strong>具有 Person 标签的节点，其 name属性值是唯一的</strong>。</p><p>在关系的 day 属性上添加<strong>存在性约束</strong>。</p><p>CREATA CONSTRAINT ON <strong>()-[k: Knows]-()</strong> <em>ASSERT</em> <strong>exists</strong><em>(k.day)</em></p><p>通过上述唯一性约束，具有 <strong>Knows 类型的关系必须具有 name 属性</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> 学习总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NoSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL注入实验</title>
      <link href="/2023/02/23/SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E9%AA%8C/"/>
      <url>/2023/02/23/SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="实验任务"><a href="#实验任务" class="headerlink" title="实验任务"></a>实验任务</h2><h3 id="搭建DVWA环境"><a href="#搭建DVWA环境" class="headerlink" title="搭建DVWA环境"></a>搭建DVWA环境</h3><p>包括：</p><p>1、搭建LAMP服务；</p><p>2、部署DVWA服务；</p><p>3、访问DVWA主页。</p><h3 id="判断是否存在SQL注入漏洞"><a href="#判断是否存在SQL注入漏洞" class="headerlink" title="判断是否存在SQL注入漏洞"></a>判断是否存在SQL注入漏洞</h3><p>1、在1的环境基础上判断是否存在SQL注入漏洞。</p><p>2、使用sql注入查询数据库用户名和数据库名。</p><h3 id="获取数据库表名、列名"><a href="#获取数据库表名、列名" class="headerlink" title="获取数据库表名、列名"></a>获取数据库表名、列名</h3><p>1、在2的基础上获取数据库表名、列名。</p><p>2、使用sql注入查询dvwa数据库的所有表名。</p><h3 id="获取用户名密码，并猜测root用户"><a href="#获取用户名密码，并猜测root用户" class="headerlink" title="获取用户名密码，并猜测root用户"></a>获取用户名密码，并猜测root用户</h3><p>1、在3的基础上获取用户名密码并猜测root用户。</p><p>2、使用sql注入查询users表中管理员的密码，并将密码解密。</p><h2 id="实验原理"><a href="#实验原理" class="headerlink" title="实验原理"></a>实验原理</h2><p>前置知识：Linux基本使用。</p><h3 id="LAMP和DVWA简介"><a href="#LAMP和DVWA简介" class="headerlink" title="LAMP和DVWA简介"></a>LAMP和DVWA简介</h3><p>LAMP是指一组通常一起使用来运行动态网站或者服务器的自由软件名称首字母缩写。</p><p>L:Linux，操作系统</p><p>A:Apache网页服务器</p><p>M:MySQL，数据库管理软件</p><p>P:PHP，脚本语言</p><p>DVWA（Damn Vulnerable Web Application）是一个用来进行安全脆弱性鉴定的PHP&#x2F;MySQL Web应用，旨在为安全专业人员测试自己的专业技能和工具提供合法的环境，帮助web开发者更好的理解web应用安全防范的过程。</p><h3 id="SQL注入分类"><a href="#SQL注入分类" class="headerlink" title="SQL注入分类"></a>SQL注入分类</h3><p>SQL 注入的分类，基于从服务器接收到的响应，可以划分为：</p><p><strong>联合查询注入：</strong></p><p>前提要求：数据会进行回显，页面有显位符，在一个网站的正常页面，服务端执行SQL语句查询数据库中的数据，客户端将数据展示在页面中，这个展示数据的位置就叫显示位。</p><p>在判断注入点是否存在后，首先可以使用联合查询判断当前数据库类型、版本信息以便于进一步进行注入。</p><p>因为联合查询要求两个语句所查询的字段数与类型需要一致，因此，在进行联合查询之前首先应当判断查询语句中涉及的字段数为多少,使用order by 字段加数字的方法进行测试，order by 原本用来对查询结果进行排序，后面跟上的字段或者数字表示根据那一列来进行排序，若超出结果，则会进行报错，因此可以判断出原本查询中涉及多少个字段。</p><p><strong>基于布尔 SQL 盲注：</strong></p><p>布尔为计算机中的一种数据类型，分为true、False两种类型，盲注则是表示注入过程中数据不会回显，只能根据页面返回两种内容的的不同来判断注入语句判断的内容是否正确。在布尔盲注中通常需要使用连接符号and、or等字符来连接两个字符串。</p><p><strong>基于时间的 SQL 盲注：</strong></p><p>时间类型的盲注本质是利用插入的SQL语句执行造成时间延迟;在猜解正确或者失败时执行造成时间延迟的语句,辅助判断是否内容猜解正确。</p><p>还有基于错误的 SQL 注入、堆查询注入、基于报错的 SQL 盲注等等。</p><h3 id="注入中常用的系统函数"><a href="#注入中常用的系统函数" class="headerlink" title="注入中常用的系统函数"></a>注入中常用的系统函数</h3><p>列举 mysql 中几个常用函数（这些函数常用与 SQL 注入点的判断）。</p><p>version()——MySQL 版本</p><p>user()——数据库用户名</p><p>database()——数据库名</p><p>@@datadir——数据库路径</p><p>@@version_compile_os——操作系统版本</p><h3 id="字符串连接函数"><a href="#字符串连接函数" class="headerlink" title="字符串连接函数"></a>字符串连接函数</h3><p>字符串连接函数在构造 SQL 注入中也常使用：</p><p>concat(str1,str2,…)——没有分隔符地连接字符串；</p><p>concat_ws(separator,str1,str2,…)——含有分隔符地连接字符串；</p><p>group_concat(str1,str2,…)——连接一个组的所有字符串，并以逗号分隔每一条数据。</p><h3 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h3><p>逻辑运算符在 SQL 注入中发挥着十分重要的作用如：||、&amp;&amp;、&amp; 等，其本身含义很容易理解，这里不做过多介绍，等到后面涉及到真正的实操时再做进一步解释。</p><h2 id="实验过程与分析"><a href="#实验过程与分析" class="headerlink" title="实验过程与分析"></a>实验过程与分析</h2><h3 id="搭建DVWA环境-1"><a href="#搭建DVWA环境-1" class="headerlink" title="搭建DVWA环境"></a>搭建DVWA环境</h3><h4 id="1-安装apache2"><a href="#1-安装apache2" class="headerlink" title="1.安装apache2"></a>1.安装apache2</h4><p>打开终端，首先更新源：apt update</p><p>安装apache2：apt install apache2 -y</p><p>启动apache2：service apache2 start</p><p>浏览器访问localhost查看apache2是否正常运行：</p><p><img src="http://oss.ripplesu.top/blog/Typora/SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E9%AA%8C/b81c8833-b285-4898-ab74-d6e23e0a2779.png" alt="image.png"></p><h4 id="2-安装php"><a href="#2-安装php" class="headerlink" title="2.安装php"></a>2.安装php</h4><p>安装PHP：apt install php -y</p><p>安装常用模块：apt install php-pear php-fpm php-dev php-zip php-curl php-xmlrpc php-gd php-mysql php-mbstring php-xml libapache2-mod-php</p><p>查看PHP版本：php -v</p><p><img src="http://oss.ripplesu.top/blog/Typora/SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E9%AA%8C/b4786590-2232-4d9a-9c26-a6e8078bf7f5.png" alt="image.png"></p><p>修改apache配置文件：sudo vim &#x2F;etc&#x2F;php&#x2F;8.1&#x2F;apache2&#x2F;php.ini</p><p>#allow_url_include &#x3D; Off</p><p>allow_url_include &#x3D; On # 设置为On</p><p>vim打开后可输入‘&#x2F;allow_url_include’搜索，然后按‘a’进入插入模式将‘Off’修改为‘On’。修改完成按ESC退出插入模式，然后输入‘:wq’回车保存并退出vim。</p><h4 id="3-安装mysql"><a href="#3-安装mysql" class="headerlink" title="3.安装mysql"></a>3.安装mysql</h4><p>安装mysql：apt install mysql-server -y</p><p>启动mysql服务：service mysql start</p><p>测试数据库是否安装成功，使用root登录数据库。由于是root权限不需要密码：mysql -u root</p><p><img src="http://oss.ripplesu.top/blog/Typora/SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E9%AA%8C/4e4f57f6-c2cb-4182-a3dc-6613d999efa9.png" alt="image.png"></p><p>然后按Ctrl+Z回到终端。</p><p>mysql安全配置初始化：终端输入mysql_secure_installation</p><p>输入y为root用户添加密码插件：</p><p><img src="http://oss.ripplesu.top/blog/Typora/SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E9%AA%8C/b6870c6f-a591-47ef-a8f2-3d40d14cb3cd.png" alt="image.png"></p><p>密码强度与密码可自行设置。</p><p><img src="http://oss.ripplesu.top/blog/Typora/SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E9%AA%8C/8baf3994-b8ec-476c-b494-6946a87242ea.png" alt="image.png"></p><p>如遇到下图错误，可用root登录mysql后输入如下语句修改密码：</p><p>ALTER USER ‘root‘@’localhost’ IDENTIFIED WITH mysql_native_password by ‘mynewpassword’;</p><p><img src="http://oss.ripplesu.top/blog/Typora/SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E9%AA%8C/88adcdca-8883-4052-9344-c26d60ef343d.png" alt="image.png"></p><p>然后回到终端重新输入：mysql_secure_installation，输入刚才设置的密码</p><p><img src="http://oss.ripplesu.top/blog/Typora/SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E9%AA%8C/71b552fe-8596-4f98-b060-06b556ed3002.png" alt="image.png"></p><p>随后即可自行配置（移除匿名用户、禁止远程登录、删除test数据库、重新加载权限表）。这里全部选择y：</p><p><img src="http://oss.ripplesu.top/blog/Typora/SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E9%AA%8C/4f6cd6bf-f915-49f4-a9bf-43354633ba1b.png" alt="image.png"></p><p>最后在终端输入sudo mysql -u root -p，输入密码登录mysql，为dvwa创建数据库：create database dvwa;</p><p><img src="http://oss.ripplesu.top/blog/Typora/SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E9%AA%8C/7c611504-1baa-4cc1-8221-5c8d72af522d.png" alt="image.png"></p><h4 id="4-安装dvwa"><a href="#4-安装dvwa" class="headerlink" title="4.安装dvwa"></a>4.安装dvwa</h4><p>终端输入：cd &#x2F;var&#x2F;www&#x2F;html 回车，然后输入：</p><p>git clone <a href="https://github.com/digininja/DVWA.git">https://github.com/digininja/DVWA.git</a> 下载dvwa（如未下载git可先输入sudo apt install git下载git）。</p><p><img src="http://oss.ripplesu.top/blog/Typora/SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E9%AA%8C/a169bab5-a2b7-4ad6-8245-ac58c7ddf96a.png" alt="image.png"></p><p>修改配置文件，依次输入如下命令：</p><p>1. cd &#x2F;var&#x2F;www&#x2F;html&#x2F;DVWA&#x2F;config &#x2F;&#x2F;切换目录</p><p>2. cp config.inc.php.dist config.inc.php &#x2F;&#x2F;复制文件</p><p>3. vim config.inc.php &#x2F;&#x2F;编辑配置文件</p><p>做如下修改：</p><p>$_DVWA[ ‘db_user’ ] &#x3D; ‘root’;</p><p>$_DVWA[ ‘db_password’ ] &#x3D; ‘dvwa123456’;&#x2F;&#x2F;自行设置的密码</p><p>$_DVWA[ ‘recaptcha_public_key’ ] &#x3D; ‘6LdJJlUUAAAAAH1Q6cTpZRQ2Ah8VpyzhnffD0mBb’;</p><p>$_DVWA[ ‘recaptcha_private_key’ ] &#x3D; ‘6LdJJlUUAAAAAM2a3HrgzLczqdYp4g05EqDs-W4K’;</p><p>最终如下图所示，保存并退出：</p><p><img src="http://oss.ripplesu.top/blog/Typora/SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E9%AA%8C/67a7777b-7acc-4f36-bab8-abaae476ff88.png" alt="image.png"></p><p>给文件夹赋予权限（777代表所有权限）：在终端依次输入如下命令：</p><p>sudo chmod 777 -R &#x2F;var&#x2F;www&#x2F;html&#x2F;DVWA&#x2F;hackable&#x2F;uploads&#x2F;</p><p>sudo chmod 777 &#x2F;var&#x2F;www&#x2F;html&#x2F;DVWA&#x2F;external&#x2F;phpids&#x2F;0.6&#x2F;lib&#x2F;IDS&#x2F;tmp&#x2F;phpids_log.txt</p><p>sudo chmod 777 -R &#x2F;var&#x2F;www&#x2F;html&#x2F;DVWA&#x2F;config</p><p>访问127.0.0.1&#x2F;DVWA&#x2F;setup.php，点击Create&#x2F;Reset Database<br><img src="http://oss.ripplesu.top/blog/Typora/SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E9%AA%8C/edf0454e-de8b-423a-967d-badba1deea9a.png" alt="image.png"></p><p>成功之后会自动跳转到登录界面用户名为admin，密码为password。登陆成功页面如下：</p><p><img src="http://oss.ripplesu.top/blog/Typora/SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E9%AA%8C/89646331-b1a2-46cb-9879-96a442f05241.png" alt="image.png">  </p><p>至此，环境搭建结束。</p><h3 id="SQL注入漏洞的判断"><a href="#SQL注入漏洞的判断" class="headerlink" title="SQL注入漏洞的判断"></a>SQL注入漏洞的判断</h3><p>登录dvwa平台，用户名为”admin”，密码为”password”，并访问127.0.0.1&#x2F;DVWA&#x2F;security.php，设置安全等级为low（此安全级别完全易受攻击，根本没有安全措施）。</p><p><img src="http://oss.ripplesu.top/blog/Typora/SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E9%AA%8C/1c9baa1e-9da2-4f80-9ac2-9443bf7c97cb.png" alt="image.png"></p><p>在终端输入：</p><p>sudo cat &#x2F;var&#x2F;www&#x2F;html&#x2F;DVWA&#x2F;vulnerabilities&#x2F;sqli&#x2F;source&#x2F;low.php</p><p>以查看low级别的sql注入源码。其中最关键的为sql语句的拼接代码，$query &#x3D; “SELECT first_name, last_name FROM users WHERE user_id &#x3D; ‘$id’;”;。代码直接将输入的id拼接在sql语句后并没有对输入的id进行过滤。</p><p><img src="http://oss.ripplesu.top/blog/Typora/SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E9%AA%8C/f0dbcaf9-c56a-41d0-953a-470aef3d562f.png" alt="image.png"></p><p>点击SQL Injection，并在id处输入1。可以看到：</p><p><img src="http://oss.ripplesu.top/blog/Typora/SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E9%AA%8C/19d88b7d-b992-4a33-9893-80df87be5cdd.png" alt="image.png"></p><p>输入1’,可以看到报错。原因是1后的单引号和前面的单引号产生了闭合，导致原有后面的那个单引号变成了多余，而sql语法中引号是必须成对出现的否则就会报错。即可能存在sql注入。</p><p><img src="http://oss.ripplesu.top/blog/Typora/SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E9%AA%8C/46f1ab22-4b67-4169-b2ac-411f3df791f7.png" alt="image.png"></p><p>使用肯定为真的语句测试1’ or ‘1’ &#x3D; ‘1。输出了所有用户信息，判断肯定存在sql注入：</p><p><img src="http://oss.ripplesu.top/blog/Typora/SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E9%AA%8C/9b6c5860-8f24-4d55-aad2-66265652e5b2.png" alt="image.png"></p><p>上面提到low级别sql注入源码直接将输入的id拼接在sql语句后并没有对输入的id进行过滤，那么我们就可以构造语句将单引号进行闭合。我们在1后面加上单引号，与前面的引号构成闭合，再接着在后面插入我们自己想要查询的语句就可以查询我们想要查询的数据。上面的永真语句1’ or ‘1’ &#x3D; ‘1正是如此。</p><p>接下来判断sql注入返回的列数。下面order by x表示输出按照第x列排序，#表示注释后面的sql语句（也可在最后加上’构造单引号的闭合）。当x&#x3D;3时报错，说明sql语句只返回两列信息。</p><p><img src="http://oss.ripplesu.top/blog/Typora/SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E9%AA%8C/efa75692-87b9-4397-b5d7-3a2bbfaa3f97.png" alt="image.png"></p><p>使用联合查询方法查询MySQL 版本和操作系统版本：</p><p>1’ union select version(),@@version_compile_os#</p><p><img src="http://oss.ripplesu.top/blog/Typora/SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E9%AA%8C/6162a72d-4650-4cf4-a864-809d76aefcfb.png" alt="image.png"></p><p>至此完成sql注入的准备活动。</p><h3 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h3><h4 id="1-查询用户名与数据库名"><a href="#1-查询用户名与数据库名" class="headerlink" title="1.查询用户名与数据库名"></a>1.查询用户名与数据库名</h4><p>输入：1’ and 1&#x3D;2 union select user(),database()# （‘1&#x3D;2’为永假语句，这样就可以使前面的查询条件失效，只保留union后查询的数据。）后提交：</p><p><img src="http://oss.ripplesu.top/blog/Typora/SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E9%AA%8C/296529ad-77be-46a6-8fcc-117506023d8b.png" alt="image.png"></p><p>可见用户名为：root@localhost；数据库名：dvwa</p><h4 id="2-查询dvwa数据库的所有表名"><a href="#2-查询dvwa数据库的所有表名" class="headerlink" title="2. 查询dvwa数据库的所有表名"></a>2. 查询dvwa数据库的所有表名</h4><p>每一个mysql都存在一个系统库information_schema，里面有mysql的“骨架”即所有的数据库、数据表、相应的字段名。以下语句查询所有数据库名。得到一个dvwa数据库与1中database()获得的数据库名称相同。</p><p>1’ and 1&#x3D;2 UNION SELECT 1,database() from information_schema.schemata#</p><p><img src="http://oss.ripplesu.top/blog/Typora/SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E9%AA%8C/8cf463ed-ec5e-48b6-b389-6e0eebffe389.png" alt="image.png"></p><p>利用下面语句可以查询information_schema下所有表的名字：</p><p>1’ UNION SELECT 1,table_name from information_schema.tables where table_schema&#x3D;’information_schema’#（table_schema：数据库名）</p><p><img src="http://oss.ripplesu.top/blog/Typora/SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E9%AA%8C/68b29bb3-738d-4b92-8adc-17cb745530d4.png" alt="image.png"></p><p>下面的语句可以查询dvwa表中的所有表名：</p><p>1’ and 1&#x3D;2 UNION SELECT 1,table_name FROM information_schema.tables WHERE TABLE_SCHEMA &#x3D; ‘dvwa’#</p><p><img src="http://oss.ripplesu.top/blog/Typora/SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E9%AA%8C/8837a34a-d669-4844-badc-1c21c16aef52.png" alt="image.png"></p><p>可见dvwa数据库中含guestbook和users两个表。</p><h4 id="3-获取users表中用户名密码，并猜测root用户"><a href="#3-获取users表中用户名密码，并猜测root用户" class="headerlink" title="3. 获取users表中用户名密码，并猜测root用户"></a>3. 获取users表中用户名密码，并猜测root用户</h4><p>在2中，我们已经得到了数据库dvwa的表名guestbook和users。</p><p>可以使用联合查询的方法查询guestbook表的所有列名分别为comment_id、comment、name：</p><p>1’ UNION SELECT 1,column_name from information_schema.columns where table_schema&#x3D;’dvwa’ and table_name&#x3D;’guestbook’#</p><p><img src="http://oss.ripplesu.top/blog/Typora/SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E9%AA%8C/00cb64fa-cd73-42f8-b64c-b90b65394306.png" alt="image.png"></p><p>可以使用联合查询获取获得数据，因为列的数量大于2，所以需要使用group_concat将所有数据合并，并使用0x3a（0x3a是”:”的16进制）分割。</p><p>1’ UNION SELECT 1,group_concat(comment_id,0x3a,comment,0x3a,name) from guestbook#</p><p><img src="http://oss.ripplesu.top/blog/Typora/SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E9%AA%8C/7d1e0a5e-60b0-4e52-ab79-dffd7f1a76ea.png" alt="image.png"></p><p>以下语句可以查看users表中所有列的名字：</p><p>1’ and 1&#x3D;2 UNION SELECT 1,column_name from information_schema.columns where table_schema&#x3D;’dvwa’ and table_name&#x3D;’users’#</p><p><img src="http://oss.ripplesu.top/blog/Typora/SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E9%AA%8C/6e9c3da8-ccdb-4b7c-8b6d-a3500bbf9d1e.png" alt="image.png"></p><p>可以看到users表中有‘user’和‘password’两个列，推测其为用户名和密码。用连接查询获得这两列的数据（或使用上述的group_concat合并所有列的数据），语句如下：</p><p>1’ and 1&#x3D;2 UNION SELECT user,password from users#<br><img src="http://oss.ripplesu.top/blog/Typora/SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E9%AA%8C/53fdf1a2-8bf3-434e-956b-772c214a0b52.png" alt="image.png"></p><p>查出的数据中有用户名为admin的数据。</p><p>将密码：5f4dcc3b5aa765d61d8327deb882cf99通过在线网站解密得明文密码：password。</p><p>至此，实验结束。</p>]]></content>
      
      
      <categories>
          
          <category> 实验实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息安全 </tag>
            
            <tag> SQL注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法</title>
      <link href="/2023/02/20/%E7%AE%97%E6%B3%95/"/>
      <url>/2023/02/20/%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="LeetCode-15-三数之和"><a href="#LeetCode-15-三数之和" class="headerlink" title="LeetCode-15 三数之和"></a><a href="https://leetcode.cn/problems/3sum/">LeetCode-15 三数之和</a></h3><p>题目中要求找到所有「不重复」且和为 00 的三元组，这个「不重复」的要求使得我们无法简单地使用三重循环枚举所有的三元组。这是因为在最坏的情况下，数组中的元素全部为 00，即</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[0, 0, 0, 0, 0, ..., 0, 0, 0]</span><br></pre></td></tr></table></figure><p>任意一个三元组的和都为 0。如果我们直接使用三重循环枚举三元组，会得到 O(N^3^)个满足题目要求的三元组（其中 N 是数组的长度）时间复杂度至少为 O(N^3^)。在这之后，我们还需要使用哈希表进行去重操作，得到不包含重复三元组的最终答案，又消耗了大量的空间。这个做法的时间复杂度和空间复杂度都很高，因此我们要换一种思路来考虑这个问题。</p><p>「不重复」的本质是什么？我们保持三重循环的大框架不变，只需要保证：</p><ul><li><p>第二重循环枚举到的元素不小于当前第一重循环枚举到的元素；</p></li><li><p>第三重循环枚举到的元素不小于当前第二重循环枚举到的元素。</p></li></ul><p>也就是说，我们枚举的三元组 (a, b, c) 满足 a≤b≤c，保证了只有 (a, b, c) 这个顺序会被枚举到，而 (b, a, c)、(c, b, a) 等等这些不会，这样就减少了重复。要实现这一点，我们可以将数组中的元素从小到大进行排序，随后使用普通的三重循环就可以满足上面的要求。</p><p>同时，对于每一重循环而言，相邻两次枚举的元素不能相同，否则也会造成重复。举个例子，如果排完序的数组为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[0, 1, 2, 2, 2, 3]</span><br><span class="line"> ^  ^  ^</span><br></pre></td></tr></table></figure><p>我们使用三重循环枚举到的第一个三元组为 (0, 1, 2)，如果第三重循环继续枚举下一个元素，那么仍然是三元组 (0, 1, 2)，产生了重复。因此我们需要将第三重循环「跳到」下一个不相同的元素，即数组中的最后一个元素 3，枚举三元组 (0, 1, 3)。</p><p>下面给出了改进的方法的伪代码实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">nums.sort()</span><br><span class="line">for first = 0 .. n-1</span><br><span class="line">    // 只有和上一次枚举的元素不相同，我们才会进行枚举</span><br><span class="line">    if first == 0 or nums[first] != nums[first-1] then</span><br><span class="line">        for second = first+1 .. n-1</span><br><span class="line">            if second == first+1 or nums[second] != nums[second-1] then</span><br><span class="line">                for third = second+1 .. n-1</span><br><span class="line">                    if third == second+1 or nums[third] != nums[third-1] then</span><br><span class="line">                        // 判断是否有 a+b+c==0</span><br><span class="line">                        check(first, second, third)</span><br></pre></td></tr></table></figure><p>这种方法的时间复杂度仍然为 O(N^3^)，毕竟我们还是没有跳出三重循环的大框架。然而它是很容易继续优化的，可以发现，如果我们固定了前两重循环枚举到的元素 a 和 b，那么只有唯一的 cc 满足 a+b+c&#x3D;0a+b+c&#x3D;0。当第二重循环往后枚举一个元素 b’时，由于 b’ &gt; b，那么满足 a+b’+c’&#x3D;0的 c’一定有 c’ &lt; c，即 c’在数组中一定出现在 c 的左侧。也就是说，我们可以从小到大枚举 b，同时从大到小枚举 c，即第二重循环和第三重循环实际上是并列的关系。</p><p>有了这样的发现，我们就可以保持第二重循环不变，而将第三重循环变成一个从数组最右端开始向左移动的指针，从而得到下面的伪代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">nums.sort()</span><br><span class="line">for first = 0 .. n-1</span><br><span class="line">    if first == 0 or nums[first] != nums[first-1] then</span><br><span class="line">        // 第三重循环对应的指针</span><br><span class="line">        third = n-1</span><br><span class="line">        for second = first+1 .. n-1</span><br><span class="line">            if second == first+1 or nums[second] != nums[second-1] then</span><br><span class="line">                // 向左移动指针，直到 a+b+c 不大于 0</span><br><span class="line">                while nums[first]+nums[second]+nums[third] &gt; 0</span><br><span class="line">                    third = third-1</span><br><span class="line">                // 判断是否有 a+b+c==0</span><br><span class="line">                check(first, second, third)</span><br></pre></td></tr></table></figure><p>这个方法就是我们常说的「双指针」，当我们需要枚举数组中的两个元素时，如果我们发现随着第一个元素的递增，第二个元素是递减的，那么就可以使用双指针的方法，将枚举的时间复杂度从 O(N^2^)减少至 O(N)。为什么是 O(N) 呢？这是因为在枚举的过程每一步中，「左指针」会向右移动一个位置（也就是题目中的 b），而「右指针」会向左移动若干个位置，这个与数组的元素有关，但我们知道它一共会移动的位置数为 O(N)，均摊下来，每次也向左移动一个位置，因此时间复杂度为 O(N)。</p><p>注意到我们的伪代码中还有第一重循环，时间复杂度为 O(N)，因此枚举的总时间复杂度为 O(N^2^)。由于排序的时间复杂度为 O(NlogN)，在渐进意义下小于前者，因此算法的总时间复杂度为 O(N^2^)。</p><p>上述的伪代码中还有一些细节需要补充，例如我们需要保持左指针一直在右指针的左侧（即满足 b≤c），具体可以参考下面的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>; a &lt; n ;a++)&#123;</span><br><span class="line">    <span class="comment">// 需要和上一次枚举的数不相同</span></span><br><span class="line">            <span class="keyword">if</span>(a &gt; <span class="number">0</span> &amp;&amp; nums[a] == nums[a-<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> n - <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> -nums[a];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> a + <span class="number">1</span>; b &lt; c; b++)&#123;</span><br><span class="line"><span class="comment">// 需要和上一次枚举的数不相同</span></span><br><span class="line">                <span class="keyword">if</span> (b &gt; a + <span class="number">1</span> &amp;&amp; nums[b] == nums[b-<span class="number">1</span>])&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span>(b &lt; c &amp;&amp; nums[b] + nums[c] &gt; target)&#123;</span><br><span class="line">                    c--;</span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">// 如果指针重合，随着 b 后续的增加</span></span><br><span class="line">                <span class="comment">// 就不会有满足 a+b+c=0 并且 b&lt;c 的 c 了，可以退出循环</span></span><br><span class="line">                <span class="keyword">if</span>(b == c)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(nums[b] + nums[c] == -nums[a])&#123;</span><br><span class="line">                    result.add(Arrays.asList(nums[a], nums[b], nums[c]));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度：O(N^2)，其中 N 是数组 nums 的长度。</li><li>空间复杂度：O(logN)。我们忽略存储答案的空间，额外的排序的空间复杂度为 O(logN)。然而我们修改了输入的数组 nums，在实际情况下不一定允许，因此也可以看成使用了一个额外的数组存储了 nums 的副本并进行排序，空间复杂度为 O(N)。</li></ul><h3 id="LeetCode-19-删除链表的倒数第-N-个结点"><a href="#LeetCode-19-删除链表的倒数第-N-个结点" class="headerlink" title="LeetCode-19 删除链表的倒数第 N 个结点"></a><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">LeetCode-19 删除链表的倒数第 N 个结点</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// 双指针。l指向倒数第n个结点的前驱，r指向尾结点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">l</span> <span class="operator">=</span> head, r = head;</span><br><span class="line">        <span class="comment">// 直到r为尾结点</span></span><br><span class="line">        <span class="keyword">while</span>(r.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">// n减至0时，l与r距离正好为n</span></span><br><span class="line">            n--;</span><br><span class="line">            r = r.next;</span><br><span class="line">            <span class="comment">// 同步将l右移，以保持间距为n</span></span><br><span class="line">            <span class="keyword">if</span>(n &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                l = l.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 代表要删除的是头结点（头尾节点距离为n-1）</span></span><br><span class="line">        <span class="keyword">if</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 否则l的next即为待删除结点</span></span><br><span class="line">            l.next = l.next.next;            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LeetCode-23-合并-K-个升序链表"><a href="#LeetCode-23-合并-K-个升序链表" class="headerlink" title="LeetCode-23 合并 K 个升序链表"></a><a href="https://leetcode.cn/problems/merge-k-sorted-lists/">LeetCode-23 合并 K 个升序链表</a></h3><ul><li>前置-合并两个有序链表</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode list1, ListNode list2)</span> &#123;</span><br><span class="line">    <span class="comment">// head为哨兵</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>), p = head;</span><br><span class="line">    <span class="keyword">while</span>(list1 != <span class="literal">null</span> &amp;&amp; list2 != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(list1.val &lt; list2.val)&#123;</span><br><span class="line">            p.next = list1;</span><br><span class="line">            list1 = list1.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p.next = list2;</span><br><span class="line">            list2 = list2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果l1或l2还有元素，直接将当前队尾p的next指向之</span></span><br><span class="line">    p.next = list1 == <span class="literal">null</span> ? list2 : list1;</span><br><span class="line">    <span class="keyword">return</span> head.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>顺序合并</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">mergeKLists</span><span class="params">(ListNode[] lists)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;lists.length;i++)&#123;</span><br><span class="line">        head = mergeTwoLists(head,lists[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://oss.ripplesu.top/blog/%E7%AE%97%E6%B3%95/6214d5d0-ae6d-4074-9388-ccbf21380a58.png" alt="image.png"></p><ul><li>分治</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">mergeKLists</span><span class="params">(ListNode[] lists)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> merge(lists, <span class="number">0</span>, lists.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">merge</span><span class="params">(ListNode[] lists, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        <span class="keyword">return</span> lists[l];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l &gt; r) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> mergeTwoLists(merge(lists, l, mid), merge(lists, mid + <span class="number">1</span>, r));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://oss.ripplesu.top/blog/%E7%AE%97%E6%B3%95/b7882cfe-44cc-4d76-a6c4-bbbcf5dcb9b8.png" alt="image.png"></p><h3 id="LeetCode-46-全排列"><a href="#LeetCode-46-全排列" class="headerlink" title="LeetCode-46 全排列"></a><a href="https://leetcode.cn/problems/permutations/">LeetCode-46 全排列</a></h3><p>这个问题可以看作有 n 个排列成一行的空格，我们需要从左往右依此填入题目给定的 n 个数，每个数只能使用一次。那么很直接的可以想到一种穷举的算法，即从左往右每一个位置都依此尝试填入一个数，看能不能填完这 n 个空格，在程序中我们可以用「<strong>回溯法</strong>」来模拟这个过程。</p><p>我们定义递归函数 <code>backtrack(first,output)</code> 表示从左往右填到第 first 个位置，当前排列为 output。 那么整个递归函数分为两个情况：</p><ul><li><p>如果 first&#x3D;n ，说明我们已经填完了 n 个位置（注意下标从 0 开始），找到了一个可行的解，我们将 output 放入答案数组中，递归结束。</p></li><li><p>如果 first&lt;n，我们要考虑这第 first 个位置我们要填哪个数。根据题目要求我们肯定不能填已经填过的数，因此很容易想到的一个处理手段是我们定义一个标记数组 <code>vis</code> 来标记已经填过的数，那么在填第 first 个数的时候我们遍历题目给定的 n 个数，如果这个数没有被标记过，我们就尝试填入，并将其标记，继续尝试填下一个位置，即调用函数<code>backtrack(first+1,output)</code>。回溯的时候要撤销这一个位置填的数以及标记，并继续尝试其他没被标记过的数。<br>使用标记数组来处理填过的数是一个很直观的思路，但是可不可以去掉这个标记数组呢？毕竟标记数组也增加了我们算法的空间复杂度。<br>答案是可以的，我们可以将题目给定的 n 个数的数组 nums 划分成左右两个部分，左边的表示已经填过的数，右边表示待填的数，我们在回溯的时候只要动态维护这个数组即可。<br>具体来说，假设我们已经填到第 first 个位置，那么 nums 数组中 <code>[0,first−1]</code> 是已填过的数的集合，<code>[first,n−1]</code> 是待填的数的集合。我们肯定是尝试用 <code>[first,n−1]</code> 里的数去填第 first 个数，假设待填的数的下标为 i，那么填完以后我们将第 i 个数和第 first 个数交换，即能使得在填第 <code>first+1</code> 个数的时候 nums 数组的 <code>[0,first]</code> 部分为已填过的数，<code>[first+1,n−1]</code> 为待填的数，回溯的时候交换回来即能完成撤销操作。</p></li><li><p>官方解答（无需标记数组，不按字典序）</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; output = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            output.add(num);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        backtrack(n, output, res, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span> n, List&lt;Integer&gt; output, List&lt;List&lt;Integer&gt;&gt; res, <span class="type">int</span> first)</span> &#123;</span><br><span class="line">        <span class="comment">// 所有数都填完了</span></span><br><span class="line">        <span class="keyword">if</span> (first == n) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(output));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> first; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 动态维护数组</span></span><br><span class="line">            Collections.swap(output, first, i);</span><br><span class="line">            <span class="comment">// 继续递归填下一个数</span></span><br><span class="line">            backtrack(n, output, res, first + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 撤销操作</span></span><br><span class="line">            Collections.swap(output, first, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>标记数组</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; numsList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="comment">// 标记每一位是否已使用 </span></span><br><span class="line">    <span class="type">int</span>[] used = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    backTrace(numsList, list, n, nums, <span class="number">0</span>, used);</span><br><span class="line">    <span class="keyword">return</span> numsList;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backTrace</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; numsList,List&lt;Integer&gt; numList, <span class="type">int</span> n, <span class="type">int</span>[] nums, <span class="type">int</span> depth, <span class="type">int</span>[] used)</span>&#123;</span><br><span class="line">    <span class="comment">// 当n == 递归深度，说明已经找到一个排列</span></span><br><span class="line">    <span class="keyword">if</span>(n == depth)&#123;</span><br><span class="line">        <span class="comment">// 递归函数共享numList，因此需new一个数组放入结果集中</span></span><br><span class="line">        numsList.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(numList));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="comment">// 当前数尚未使用</span></span><br><span class="line">        <span class="keyword">if</span>(used[i] != <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">// 添加进数组中，并标记</span></span><br><span class="line">            numList.add(nums[i]);</span><br><span class="line">            used[i] = <span class="number">1</span>;</span><br><span class="line">            backTrace(numsList, numList, n, nums, depth + <span class="number">1</span>, used);</span><br><span class="line">            <span class="comment">// 回溯</span></span><br><span class="line">            used[i] = <span class="number">0</span>;</span><br><span class="line">            numList.remove(depth);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LeetCode-33-搜索旋转排序数组"><a href="#LeetCode-33-搜索旋转排序数组" class="headerlink" title="LeetCode-33 搜索旋转排序数组"></a><a href="https://leetcode.cn/problems/search-in-rotated-sorted-array/">LeetCode-33 搜索旋转排序数组</a></h3><p>我们将数组从中间分开成左右两部分的时候，一定有一部分的数组是有序的。</p><p>这启示我们可以在常规二分查找的时候查看当前 mid 为分割位置分割出来的两个部分 [l, mid] 和 [mid + 1, r] 哪个部分是有序的，并根据有序的那个部分确定我们该如何改变二分查找的上下界，因为我们能够根据有序的那部分判断出 target 在不在这个部分：</p><ul><li>如果 [l, mid - 1] 是有序数组，且 target 的大小满足 <code>[nums[l],nums[mid]]</code>，则我们应该将搜索范围缩小至 [l, mid - 1]，否则在 [mid + 1, r] 中寻找。</li><li>如果 [mid, r] 是有序数组，且 target 的大小满足 <code>[nums[mid+1],nums[r]]</code>，则我们应该将搜索范围缩小至 [mid + 1, r]，否则在 [l, mid - 1] 中寻找。</li></ul><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>] == target ? <span class="number">0</span> : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">        mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 左边是有序的</span></span><br><span class="line">        <span class="comment">// 注意等号：mid向下取整</span></span><br><span class="line">        <span class="keyword">if</span>(nums[l] &lt;= nums[mid])&#123;</span><br><span class="line">            <span class="comment">// target在左半边</span></span><br><span class="line">            <span class="keyword">if</span>(nums[l] &lt;= target &amp;&amp; nums[mid] &gt; target)&#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target &amp;&amp; nums[r] &gt;= target)&#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LeetCode-39-组合总和"><a href="#LeetCode-39-组合总和" class="headerlink" title="LeetCode-39 组合总和"></a><a href="https://leetcode.cn/problems/combination-sum/">LeetCode-39 组合总和</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> candidates.length;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 升序排序，以便剪枝</span></span><br><span class="line">    Arrays.sort(candidates);</span><br><span class="line">    backTrace(result, candidates, <span class="number">0</span>, target, n, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backTrace</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; result, <span class="type">int</span>[] candidates, <span class="type">int</span> index, <span class="type">int</span> target</span></span><br><span class="line"><span class="params">                      , <span class="type">int</span> n, List&lt;Integer&gt; list, <span class="type">int</span> sum)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index; i &lt; n; i++)&#123;</span><br><span class="line">        list.add(candidates[i]);</span><br><span class="line">        sum += candidates[i];</span><br><span class="line">        <span class="keyword">if</span>(sum &lt; target)&#123;</span><br><span class="line">            <span class="comment">// 由于同一个数可以被无限制重复选取，因此递归的index仍是i</span></span><br><span class="line">            backTrace(result, candidates, i, target, n, list, sum);                </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(sum == target)&#123;</span><br><span class="line">                result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(list));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当sum&gt;=target，则由于candidates已经按升序排序，</span></span><br><span class="line">            <span class="comment">// 则回溯后sum加上后面的数一定&gt;target，故可以剪枝</span></span><br><span class="line">            <span class="comment">// 但因为与上层函数共享list，故仍需remove</span></span><br><span class="line">            list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 回溯</span></span><br><span class="line">        list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">        sum -= candidates[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="LeetCode-49-字母异位词分组"><a href="#LeetCode-49-字母异位词分组" class="headerlink" title="LeetCode-49.字母异位词分组"></a><a href="https://leetcode.cn/problems/group-anagrams/">LeetCode-49.字母异位词分组</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">groupAnagrams</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">    Map&lt;String, List&lt;String&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, List&lt;String&gt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String str : strs) &#123;</span><br><span class="line">        <span class="comment">// 方法1：计数</span></span><br><span class="line">        <span class="comment">// 由于字母异位词的各个字母出现次数必定相等</span></span><br><span class="line">        <span class="comment">// 故可用26位长的整形数组记录每个词的字母出现次数</span></span><br><span class="line">        <span class="comment">// 并按字母顺序及出现次数拼接为map的key</span></span><br><span class="line">        <span class="comment">// int[] counts = new int[26];</span></span><br><span class="line">        <span class="comment">// int length = str.length();</span></span><br><span class="line">        <span class="comment">// for (int i = 0; i &lt; length; i++) &#123;</span></span><br><span class="line">        <span class="comment">//     counts[str.charAt(i) - &#x27;a&#x27;]++;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// // 将每个出现次数大于 0 的字母和出现次数按顺序拼接成字符串，作为哈希表的键</span></span><br><span class="line">        <span class="comment">// StringBuffer sb = new StringBuffer();</span></span><br><span class="line">        <span class="comment">// for (int i = 0; i &lt; 26; i++) &#123;</span></span><br><span class="line">        <span class="comment">//     if (counts[i] != 0) &#123;</span></span><br><span class="line">        <span class="comment">//         sb.append((char) (&#x27;a&#x27; + i));</span></span><br><span class="line">        <span class="comment">//         sb.append(counts[i]);</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// String key = sb.toString();</span></span><br><span class="line">        <span class="comment">// 方法二：排序</span></span><br><span class="line">        <span class="type">char</span>[] array = str.toCharArray();</span><br><span class="line">        Arrays.sort(array);</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(array);</span><br><span class="line">        <span class="comment">// 存在key则返回对应值，否则返回第二个参数</span></span><br><span class="line">        List&lt;String&gt; list = map.getOrDefault(key, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;());</span><br><span class="line">        list.add(str);</span><br><span class="line">        map.put(key, list);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;String&gt;&gt;(map.values());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LeetCode-55-跳跃游戏"><a href="#LeetCode-55-跳跃游戏" class="headerlink" title="LeetCode-55 跳跃游戏"></a><a href="https://leetcode.cn/problems/jump-game/?envType=featured-list&envId=2cktkvj?envType=featured-list&envId=2cktkvj">LeetCode-55 跳跃游戏</a></h3><p>刚开始很快就想到了回溯的方法，兴高采烈地写完代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canJump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> backTrace(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">backTrace</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> index, <span class="type">int</span> n)</span>&#123;</span><br><span class="line"><span class="comment">// 当前位置可以直接跳到末尾</span></span><br><span class="line">        <span class="keyword">if</span>(index + nums[index] &gt;= n)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 否则，依次尝试跳[1,nums[index]]步</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= nums[index]; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(backTrace(nums, index + i, n))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一提交…<br><img src="http://oss.ripplesu.top/blog/%E7%AE%97%E6%B3%95/ac3625b2-de3e-4e9c-94f1-2a15519742d9.png" alt="image.png"><br>一看提示，好家伙，数组长度最大为3*10^4^…<br>思索许久，也没什么好思路。不得已偷瞄了一下题解，才发现可以用贪心来做（距离上次接触贪心，已经是大半年以前上算法课的时候了)。  </p><p>我们依次遍历数组中的每一个位置，并实时维护 <strong>最远可以到达的位置</strong>。对于当前遍历到的位置 i，如果它在 <strong>最远可以到达的位置</strong> 的范围内，那么我们就可以从起点通过若干次跳跃到达该位置，因此我们可以用 i+nums[i] 更新 <strong>最远可以到达的位置</strong>。<br>在遍历的过程中，如果 <strong>最远可以到达的位置</strong> 大于等于数组中的最后一个位置，那就说明最后一个位置可达，我们就可以直接返回 <code>true</code> 作为答案。反之，如果在遍历结束后，最后一个位置仍然不可达，我们就返回 <code>false</code> 作为答案。<br>代码如下：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canJump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length, right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n &amp;&amp; i &lt;= right; i++)&#123;</span><br><span class="line">            right = Math.max(right, i + nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(right &gt;= n - <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成功通过！<br><img src="http://oss.ripplesu.top/blog/%E7%AE%97%E6%B3%95/e798982a-a697-4501-a5ef-6d52dbd8819a.png" alt="image.png"></p><h3 id="LeetCode-56-合并区间"><a href="#LeetCode-56-合并区间" class="headerlink" title="LeetCode-56 合并区间"></a><a href="https://leetcode.cn/problems/merge-intervals/?envType=featured-list&envId=2cktkvj?envType=featured-list&envId=2cktkvj">LeetCode-56 合并区间</a></h3><p>常规的排序的题目，但需要自定义排序规则。好久没写了，这里简单记录一下。<br>排序规则可以使用常规的重写Comparator的方法，也可以使用简洁的lambda表达式，不过实测执行耗时lambda要比重写Comparator的方式慢三分之一。<br>toArray方法可将list转为数组。参数数组的初始化大小list.size如果大于等于list的列表的长度，那么就默认使用当前的参数数组；如果小于list的长度就会重新创建一个数组，效率略低。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] merge(<span class="type">int</span>[][] intervals) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> intervals.length;</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> intervals;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 按左端点升序排序 </span></span><br><span class="line">        Arrays.sort(intervals, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;<span class="type">int</span>[]&gt;() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">int</span>[] interval1, <span class="type">int</span>[] interval2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> interval1[<span class="number">0</span>] - interval2[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// Arrays.sort(intervals, (v1, v2) -&gt; v1[0] - v2[0]); </span></span><br><span class="line">        List&lt;<span class="type">int</span>[]&gt; merge = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> merge.size();</span><br><span class="line">            <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> intervals[i][<span class="number">0</span>], r = intervals[i][<span class="number">1</span>];</span><br><span class="line">    <span class="comment">// merge为空则直接放入</span></span><br><span class="line">    <span class="comment">// 或如果上一数对的右端点小于当前数对的左端点，即无交集 </span></span><br><span class="line">            <span class="keyword">if</span>(size == <span class="number">0</span> || merge.get(size - <span class="number">1</span>)[<span class="number">1</span>] &lt; l)&#123;</span><br><span class="line">                merge.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;l ,r&#125;);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 上一数对右端点小于当前的左端点，由于按左端点排序</span></span><br><span class="line"><span class="comment">// 故取右端点中较大的作为新的右端点的值</span></span><br><span class="line">                merge.get(size - <span class="number">1</span>)[<span class="number">1</span>] = Math.max(merge.get(size - <span class="number">1</span>)[<span class="number">1</span>], r);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> merge.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[merge.size()][]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LeetCode-62-不同路径"><a href="#LeetCode-62-不同路径" class="headerlink" title="LeetCode-62 不同路径"></a><a href="https://leetcode.cn/problems/unique-paths/?envType=featured-list&envId=2cktkvj?envType=featured-list&envId=2cktkvj">LeetCode-62 不同路径</a></h3><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><p>最开始想到的仍然是DFS，不出意料又超时了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        Set&lt;String&gt; result = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        backTrace(m , n, <span class="number">0</span>, <span class="number">0</span>, result, <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> result.size();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backTrace</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n, <span class="type">int</span> i, <span class="type">int</span> j, Set&lt;String&gt; result, StringBuilder path)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == m - <span class="number">1</span> &amp;&amp; j == n - <span class="number">1</span>)&#123;</span><br><span class="line">            result.add(path.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i + <span class="number">1</span> &lt;= m - <span class="number">1</span>)&#123;</span><br><span class="line">            path.append(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">            backTrace(m, n, i + <span class="number">1</span>, j, result, <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(path.toString()));</span><br><span class="line">            path.deleteCharAt(path.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j + <span class="number">1</span> &lt;= n - <span class="number">1</span>)&#123;</span><br><span class="line">            path.append(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">            backTrace(m, n, i, j + <span class="number">1</span>, result, <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(path.toString()));</span><br><span class="line">            path.deleteCharAt(path.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>我们用<code>f(i,j)</code> 表示从左上角走到 <code>(i,j)</code> 的路径数量，其中 i 和 j 的范围分别是 <code>[0,m)</code> 和 <code>[0,n)</code>。<br>由于我们每一步只能从向下或者向右移动一步，因此要想走到 <code>(i,j)</code>，如果向下走一步，那么会从 <code>(i−1,j)</code> 走过来；如果向右走一步，那么会从 <code>(i,j−1)</code> 走过来。因此我们可以写出动态规划转移方程：  <code>f(i,j)=f(i−1,j)+f(i,j−1)</code><br>需要注意的是，如果 <code>i=0</code>，那么 <code>f(i−1,j)</code> 并不是一个满足要求的状态，我们需要忽略这一项；同理，如果 <code>j=0</code>，那么 <code>f(i,j−1)</code> 并不是一个满足要求的状态，我们需要忽略这一项。<br>初始条件为 <code>f(0,0)=1</code>，即从左上角走到左上角有一种方法。</p><p>最终的答案即为 <code>f(m−1,n−1)</code>。</p><h4 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h4><p>为了方便代码编写，我们可以将所有的 <code>f(0,j)</code> 以及 <code>f(i,0)</code> 都设置为边界条件，它们的值均为 1。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] f = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            f[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            f[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                f[i][j] = f[i - <span class="number">1</span>][j] + f[i][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LeetCode-64-最小路径和"><a href="#LeetCode-64-最小路径和" class="headerlink" title="LeetCode-64 最小路径和"></a><a href="https://leetcode.cn/problems/minimum-path-sum/?envType=featured-list&envId=2cktkvj?envType=featured-list&envId=2cktkvj">LeetCode-64 最小路径和</a></h3><p>又是一题动态规划的题目，吸取了上次的教训，这次没有再尝试DFS的方法。<br>由于路径的方向只能是<strong>向下或向右</strong>，因此网格的第一行的每个元素只能从左上角元素开始向右移动到达，网格的第一列的每个元素只能从左上角元素开始向下移动到达，此时的路径是唯一的，因此每个元素对应的最小路径和即为对应的路径上的数字总和。  </p><p>对于不在第一行和第一列的元素，可以从其上方相邻元素向下移动一步到达，或者从其左方相邻元素向右移动一步到达，元素对应的最小路径和等于其上方相邻元素与其左方相邻元素两者对应的最小路径和中的最小值加上当前元素的值。由于每个元素对应的最小路径和与其相邻元素对应的最小路径和有关，因此可以使用动态规划求解。  </p><p>创建二维数组 dp，与原始网格的大小相同，dp[i][j] 表示从左上角出发到 (i,j) 位置的最小路径和。显然，dp[0][0]&#x3D;grid[0][0]。对于 dp 中的其余元素，通过以下状态转移方程计算元素值。</p><p>当 <code>i&gt;0</code> 且 <code>j=0</code> 时，<code>dp[i][0]=dp[i−1][0]+grid[i][0]</code>。</p><p>当 <code>i=0</code> 且 <code>j&gt;0</code> 时，<code>dp[0][j]=dp[0][j−1]+grid[0][j]</code>。</p><p>当 <code>i&gt;0</code> 且 <code>j&gt;0</code> 时，<code>dp[i][j]=min(dp[i−1][j],dp[i][j−1])+grid[i][j]</code>。</p><p>最后得到 <code>dp[m−1][n−1]</code> 的值即为从网格左上角到网格右下角的最小路径和。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minPathSum</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> grid.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">if</span>(m == <span class="number">1</span> &amp;&amp; n == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[][] result = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">        result[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m; i++)&#123;</span><br><span class="line">            result[i][<span class="number">0</span>] = result[i - <span class="number">1</span>][<span class="number">0</span>] + grid[i][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">            result[<span class="number">0</span>][j] = result[<span class="number">0</span>][j - <span class="number">1</span>] + grid[<span class="number">0</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">                result[i][j] = Math.min(result[i - <span class="number">1</span>][j], result[i][j - <span class="number">1</span>]) + grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LeetCode-75-颜色分类"><a href="#LeetCode-75-颜色分类" class="headerlink" title="LeetCode-75 颜色分类"></a><a href="https://leetcode.cn/problems/sort-colors/?envType=featured-list&envId=2cktkvj?envType=featured-list&envId=2cktkvj">LeetCode-75 颜色分类</a></h3><p>一开始就想到了双指针的做法，但思路出现了偏差：我的想法是把2交换到数组尾部，然后让尾部指针–；把0交换到数组首部，然后让指针++。但是尝试了许久都没成功。看了下官方题解的方法三，也是这个思路。但我在细节上考虑不周。<br>以下是官方题解：<br>用指针 p0 来交换 0 ， p2 来交换 2。此时，p0 的初始值仍然为 0，而 p2 的初始值为 n−1。在遍历的过程中，我们需要找出所有的 0 交换至数组的头部，并且找出所有的 2 交换至数组的尾部。  </p><p>由于此时其中一个指针 p2 是从右向左移动的，因此当我们在从左向右遍历整个数组时，如果遍历到的位置超过了 p2，那么就可以直接停止遍历了。  </p><p>具体地，我们从左向右遍历整个数组，设当前遍历到的位置为 i，对应的元素为 nums[i]；<br>如果找到了 0，那么与前面两种方法类似，将其与 nums[p0] 进行交换，并将 p0向后移动一个位置；  </p><p>如果找到了 2，那么将其与 nums[p2] 进行交换，并将 p2向前移动一个位置。  </p><p>这样做是正确的吗？可以发现，对于第二种情况，当我们将 nums[i] 与 nums[p2] 进行交换之后，新的 nums[i] 可能仍然是 2，也可能是 0。然而此时我们已经结束了交换，开始遍历下一个元素 nums[i+1]，不会再考虑 nums[i] 了，这样我们就会得到错误的答案。<br>因此，当我们找到 2 时，我们需要不断地将其与 nums[p2] 进行交换，直到新的 nums[i] 不为 2。此时，如果 nums[i] 为 0，那么对应着第一种情况；如果 nums[i] 为 1，那么就不需要进行任何后续的操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sortColors</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p0</span> <span class="operator">=</span> <span class="number">0</span>, p2 = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= p2; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt;= p2 &amp;&amp; nums[i] == <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">                nums[i] = nums[p2];</span><br><span class="line">                nums[p2] = temp;</span><br><span class="line">                --p2;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">                nums[i] = nums[p0];</span><br><span class="line">                nums[p0] = temp;</span><br><span class="line">                ++p0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LeetCode-87-子集"><a href="#LeetCode-87-子集" class="headerlink" title="LeetCode-87 子集"></a><a href="https://leetcode.cn/problems/subsets/?envType=featured-list&envId=2cktkvj?envType=featured-list&envId=2cktkvj">LeetCode-87 子集</a></h3><p>又是回溯，感觉这块掌握的还可以了，10分钟搞定。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsets</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;());</span><br><span class="line">        backTrace(result, <span class="number">0</span>, nums.length, nums, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backTrace</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; result, <span class="type">int</span> index, <span class="type">int</span> n, <span class="type">int</span>[] nums, List&lt;Integer&gt; cur)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &gt;= n)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index; i &lt; n; i++)&#123;</span><br><span class="line">            cur.add(nums[i]);</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(cur));</span><br><span class="line">            backTrace(result, i + <span class="number">1</span>, n, nums, cur);</span><br><span class="line">            cur.remove(cur.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LeetCode-79-单词搜索"><a href="#LeetCode-79-单词搜索" class="headerlink" title="LeetCode-79 单词搜索"></a><a href="https://leetcode.cn/problems/word-search/?envType=featured-list&envId=2cktkvj?envType=featured-list&envId=2cktkvj">LeetCode-79 单词搜索</a></h3><p>原来以为是单纯的搜索，但仔细想想又是一题回溯，因为相邻字母可能不止一个与单词中下一个字母一致，这条路走不通必须回溯查看有无下一条可行路径。<br>需要注意的是，字母不能重复使用，所以必须增加一个标记数组来标志当前字母是否已经使用。  </p><p>整体思路是：找到单词中第一个字母在数组中所处的位置，然后调用search依次尝试其相邻的字母：如果与单词中下一个字母一致，则在标记数组中将该位置标记为1，然后继续搜索，直到搜索深度与单词长度一致，返回true。若其中一个返回true，则可结束搜索；否则回溯，将标记数组对应位置重置为0。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">exist</span><span class="params">(<span class="type">char</span>[][] board, String word)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> board.length, c = board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span>[][] flag = <span class="keyword">new</span> <span class="title class_">int</span>[r][c];</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; r; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; c; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == word.charAt(<span class="number">0</span>))&#123;</span><br><span class="line">                    flag[i][j] = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span>(search(board, word, flag, <span class="number">1</span>, word.length(), i, j) == <span class="literal">true</span>)&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    &#125; </span><br><span class="line">                    flag[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(<span class="type">char</span>[][] board, String word, <span class="type">int</span>[][] flag, <span class="type">int</span> depth, <span class="type">int</span> n, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(depth == n)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i - <span class="number">1</span> &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i - <span class="number">1</span>][j] == word.charAt(depth) &amp;&amp; flag[i - <span class="number">1</span>][j] != <span class="number">1</span>)&#123;</span><br><span class="line">                flag[i - <span class="number">1</span>][j] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(search(board, word, flag, depth + <span class="number">1</span>, n, i - <span class="number">1</span>, j) == <span class="literal">true</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;      </span><br><span class="line">                flag[i - <span class="number">1</span>][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j - <span class="number">1</span> &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i][j - <span class="number">1</span>] == word.charAt(depth) &amp;&amp; flag[i][j - <span class="number">1</span>] != <span class="number">1</span>)&#123;</span><br><span class="line">                flag[i][j - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(search(board, word, flag, depth + <span class="number">1</span>, n, i, j - <span class="number">1</span>) == <span class="literal">true</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;     </span><br><span class="line">                flag[i][j - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j + <span class="number">1</span> &lt; board[<span class="number">0</span>].length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i][j + <span class="number">1</span>] == word.charAt(depth) &amp;&amp; flag[i][j + <span class="number">1</span>] != <span class="number">1</span>)&#123;</span><br><span class="line">                flag[i][j + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(search(board, word, flag, depth + <span class="number">1</span>, n, i, j + <span class="number">1</span>) == <span class="literal">true</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;   </span><br><span class="line">                flag[i][j + <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i + <span class="number">1</span> &lt; board.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i + <span class="number">1</span>][j] == word.charAt(depth) &amp;&amp; flag[i + <span class="number">1</span>][j] != <span class="number">1</span>)&#123;</span><br><span class="line">                flag[i + <span class="number">1</span>][j] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(search(board, word, flag, depth + <span class="number">1</span>, n, i + <span class="number">1</span>, j) == <span class="literal">true</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125; </span><br><span class="line">                flag[i + <span class="number">1</span>][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LeetCode-146-LRU缓存"><a href="#LeetCode-146-LRU缓存" class="headerlink" title="LeetCode-146 LRU缓存"></a><a href="https://leetcode.cn/problems/lru-cache/?envType=featured-list&envId=2cktkvj?envType=featured-list&envId=2cktkvj">LeetCode-146 LRU缓存</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用LinkedList</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> <span class="keyword">extends</span> <span class="title class_">LinkedHashMap</span>&lt;Integer, Integer&gt;&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capacity;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LRUCache</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(capacity, <span class="number">0.75F</span>, <span class="literal">true</span>);</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.getOrDefault(key, -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">removeEldestEntry</span><span class="params">(Map.Entry&lt;Integer, Integer&gt; eldest)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size() &gt; capacity; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义双向链表</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">capacity</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">ListNode</span>&#123;</span><br><span class="line">        <span class="type">int</span> key;</span><br><span class="line">        <span class="type">int</span> value;</span><br><span class="line">        ListNode prev;</span><br><span class="line">        ListNode next;</span><br><span class="line">        ListNode(<span class="type">int</span> key, <span class="type">int</span> value)&#123;</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode()&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">tail</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LRUCache</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        <span class="built_in">this</span>.map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(capacity);</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.prev = head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, ListNode&gt; map;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        moveToHead(node);</span><br><span class="line">        <span class="keyword">return</span> node.value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">        <span class="keyword">if</span>(node != <span class="literal">null</span>)&#123;</span><br><span class="line">            node.value = value;</span><br><span class="line">            moveToHead(node);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">n</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(key, value);</span><br><span class="line">            map.put(key, n);</span><br><span class="line">            addToHead(n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(map.size() &gt; capacity)&#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">res</span> <span class="operator">=</span> removeTail();</span><br><span class="line">            map.remove(res.key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">removeNode</span><span class="params">(ListNode node)</span>&#123;</span><br><span class="line">        node.prev.next = node.next;</span><br><span class="line">        node.next.prev = node.prev;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addToHead</span><span class="params">(ListNode node)</span>&#123;</span><br><span class="line">        node.prev = head;</span><br><span class="line">        node.next = head.next;</span><br><span class="line">        node.next.prev = node;</span><br><span class="line">        head.next = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">moveToHead</span><span class="params">(ListNode node)</span>&#123;</span><br><span class="line">        removeNode(node);</span><br><span class="line">        addToHead(node);</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode <span class="title function_">removeTail</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">res</span> <span class="operator">=</span> tail.prev;</span><br><span class="line">        removeNode(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LeetCode-152-乘积最大子数组"><a href="#LeetCode-152-乘积最大子数组" class="headerlink" title="LeetCode-152 乘积最大子数组"></a>LeetCode-152 乘积最大子数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProduct</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxF</span> <span class="operator">=</span> nums[<span class="number">0</span>], minF = nums[<span class="number">0</span>], result = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; length; i++)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> maxF, min = minF;</span><br><span class="line">        <span class="comment">// 如果当前位置是一个正数的话，我们更希望以它前一个位置结尾的某个段的积也是个正数，并且希望它尽可能地大。考虑当前位置如果是一个负数的话，那么我们希望以它前一个位置结尾的某个段的积也是个负数，这样就可以负负得正，并且我们希望这个积尽可能「负得更多」，即尽可能小。</span></span><br><span class="line">        maxF = Math.max(max * nums[i], Math.max(nums[i], min * nums[i]));</span><br><span class="line">        minF = Math.min(min * nums[i], Math.min(nums[i], max * nums[i]));</span><br><span class="line">        result = Math.max(maxF, result);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LeetCode-200-岛屿数量"><a href="#LeetCode-200-岛屿数量" class="headerlink" title="LeetCode-200 岛屿数量"></a>LeetCode-200 岛屿数量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 深度优先搜索，时间击败了100%</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numIslands</span><span class="params">(<span class="type">char</span>[][] grid)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">width</span> <span class="operator">=</span> grid.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; width; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; length; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(grid[i][j] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                <span class="comment">// 每找到一块陆地，就进行搜索，</span></span><br><span class="line">                <span class="comment">// 搜索结束该陆地所有相连陆地都被标记为水地，故搜索次数即为岛屿数量</span></span><br><span class="line">                sum ++;</span><br><span class="line">                dfs(grid, i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[][] grid, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &gt;= grid.length || j &gt;= grid[<span class="number">0</span>].length || i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(grid[i][j] == <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(grid[i][j] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">        <span class="comment">// 如果是陆地，则标记为水地代表已搜索</span></span><br><span class="line">        grid[i][j] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="comment">// 上下左右四个方向搜索</span></span><br><span class="line">        dfs(grid, i + <span class="number">1</span>, j);</span><br><span class="line">        dfs(grid, i, j + <span class="number">1</span>);</span><br><span class="line">        dfs(grid, i - <span class="number">1</span>, j);</span><br><span class="line">        dfs(grid, i, j - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LeetCode-206-反转链表"><a href="#LeetCode-206-反转链表" class="headerlink" title="LeetCode-206 反转链表"></a><a href="https://leetcode.cn/problems/reverse-linked-list/">LeetCode-206 反转链表</a></h3><p>小小反转链表竟暗藏玄机。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public ListNode reverseList(ListNode head) &#123;</span><br><span class="line">    ListNode prev = null;</span><br><span class="line">    ListNode curr = head;</span><br><span class="line">    while (curr != null) &#123;</span><br><span class="line">        ListNode next = curr.next;</span><br><span class="line">        curr.next = prev;</span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = next;</span><br><span class="line">    &#125;</span><br><span class="line">    return prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LeetCode-208-前缀树"><a href="#LeetCode-208-前缀树" class="headerlink" title="LeetCode-208 前缀树"></a>LeetCode-208 前缀树</h3><p>Trie，又称前缀树或字典树，是一棵有根树，其每个节点包含以下字段：</p><ul><li><p>指向子节点的指针数组 children。对于本题而言，数组长度为 26，即小写英文字母的数量。此时 children[0] 对应小写字母 a，children[1]对应小写字母 b，…，children[25] 对应小写字母 z。</p></li><li><p>布尔字段 isEnd，表示该节点是否为字符串的结尾。</p></li></ul><p>插入字符串</p><p>我们从字典树的根开始，插入字符串。对于当前字符对应的子节点，有两种情况：</p><ul><li><p>子节点存在。沿着指针移动到子节点，继续处理下一个字符。</p></li><li><p>子节点不存在。创建一个新的子节点，记录在 children数组的对应位置上，然后沿着指针移动到子节点，继续搜索下一个字符。</p></li></ul><p>重复以上步骤，直到处理字符串的最后一个字符，然后将当前节点标记为字符串的结尾。</p><p>查找前缀</p><p>我们从字典树的根开始，查找前缀。对于当前字符对应的子节点，有两种情况：</p><ul><li>子节点存在。沿着指针移动到子节点，继续搜索下一个字符。</li><li>子节点不存在。说明字典树中不包含该前缀，返回空指针。</li></ul><p>重复以上步骤，直到返回空指针或搜索完前缀的最后一个字符。</p><p>若搜索到了前缀的末尾，就说明字典树中存在该前缀。此外，<strong>若前缀末尾对应节点的 isEnd 为真，则说明字典树中存在该字符串</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Trie[] children;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> isEnd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Trie</span><span class="params">()</span> &#123;</span><br><span class="line">        children = <span class="keyword">new</span> <span class="title class_">Trie</span>[<span class="number">26</span>];</span><br><span class="line">        isEnd = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="type">Trie</span> <span class="variable">node</span> <span class="operator">=</span> <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; word.length(); i++)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> word.charAt(i);</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> ch - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(node.children[index] == <span class="literal">null</span>)&#123;</span><br><span class="line">                node.children[index] = <span class="keyword">new</span> <span class="title class_">Trie</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.children[index];</span><br><span class="line">        &#125;</span><br><span class="line">        node.isEnd = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="type">Trie</span> <span class="variable">node</span> <span class="operator">=</span> searchPrefix(word);</span><br><span class="line">        <span class="keyword">return</span> node != <span class="literal">null</span> &amp;&amp; node.isEnd;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">startsWith</span><span class="params">(String prefix)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> searchPrefix(prefix) != <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Trie <span class="title function_">searchPrefix</span><span class="params">(String prefix)</span>&#123;</span><br><span class="line">        <span class="type">Trie</span> <span class="variable">node</span> <span class="operator">=</span> <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; prefix.length(); i++)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> prefix.charAt(i);</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> ch - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(node.children[index] == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.children[index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LeetCode-226-翻转二叉树"><a href="#LeetCode-226-翻转二叉树" class="headerlink" title="LeetCode-226 翻转二叉树"></a>LeetCode-226 翻转二叉树</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 依次翻转左右子树</span></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> invertTree(root.left);</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> invertTree(root.right);</span><br><span class="line">    root.left = right;</span><br><span class="line">    root.right = left;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LeetCode-236-二叉树的最近公共祖先"><a href="#LeetCode-236-二叉树的最近公共祖先" class="headerlink" title="LeetCode-236 二叉树的最近公共祖先"></a>LeetCode-236 二叉树的最近公共祖先</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    search(root, stack, p);</span><br><span class="line">    <span class="comment">// 最近公共祖先节点可以为节点本身，所以还需将结点本身入栈</span></span><br><span class="line">    stack.push(p);</span><br><span class="line">    TreeNode node;</span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">        node = stack.pop();</span><br><span class="line">        <span class="keyword">if</span>(search(node, stack, q))&#123;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将node结点的所有父节点放入栈中</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">search</span><span class="params">(TreeNode root, Stack&lt;TreeNode&gt; stack, TreeNode node)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root == node)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    stack.push(root);</span><br><span class="line">    <span class="keyword">if</span>(search(root.left, stack, node) || search(root.right, stack, node))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    stack.pop();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LeetCode-347-前K个高频元素"><a href="#LeetCode-347-前K个高频元素" class="headerlink" title="LeetCode-347 前K个高频元素"></a>LeetCode-347 前K个高频元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] topKFrequent(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    PriorityQueue&lt;<span class="type">int</span>[]&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;<span class="type">int</span>[]&gt;()&#123;</span><br><span class="line">        <span class="comment">// 小顶堆</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">int</span>[] m, <span class="type">int</span>[] n)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> m[<span class="number">1</span>] - n[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i : nums)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> map.getOrDefault(i, <span class="number">0</span>);</span><br><span class="line">        map.put(i, ++j);</span><br><span class="line">    &#125;</span><br><span class="line">    map.entrySet().stream().forEach(entry -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span>(queue.size() &lt; k)&#123;</span><br><span class="line">            queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;entry.getKey(), entry.getValue()&#125;);                </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (queue.peek()[<span class="number">1</span>] &lt; entry.getValue()) &#123;</span><br><span class="line">                queue.poll();</span><br><span class="line">                queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;entry.getKey(), entry.getValue()&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="type">int</span>[] ret = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">        ret[i] = queue.poll()[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LeetCode-240-搜索二维矩阵II"><a href="#LeetCode-240-搜索二维矩阵II" class="headerlink" title="LeetCode-240 搜索二维矩阵II"></a>LeetCode-240 搜索二维矩阵II</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">searchMatrix</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> matrix.length, col = matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">lastj</span> <span class="operator">=</span> col;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; row; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix[i][<span class="number">0</span>] &gt; target)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从右边开始搜索，因为每行、列都递增，</span></span><br><span class="line">        <span class="comment">// 如果当前搜索位置比目标元素小，下次从当前位置左下角元素开始搜索</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> lastj - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][j] == target)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][j] &lt; target)&#123;</span><br><span class="line">                lastj = j + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LeetCode-287-寻找重复数"><a href="#LeetCode-287-寻找重复数" class="headerlink" title="LeetCode-287 寻找重复数"></a>LeetCode-287 寻找重复数</h3><p>快慢指针</p><p>我们对 nums 数组建图，每个位置 i 连一条 i→nums[i] 的边。由于存在的重复的数字 target，因此 target 这个位置一定有起码两条指向它的边，因此整张图一定存在环，且我们要找到的 target 就是这个环的入口，那么整个问题就等价于 142. 环形链表 II。</p><p>假设环长为 L，从起点到环的入口的步数是 a，从环的入口继续走 b 步到达相遇位置，从相遇位置继续走 c 步回到环的入口，则有 b+c&#x3D;L，其中 L、a、b、c 都是正整数。根据上述定义，慢指针走了 a+b 步，快指针走了 2(a+b ) 步。从另一个角度考虑，在相遇位置，快指针比慢指针多走了若干圈，因此快指针走的步数还可以表示成 a+b+kL，其中 k 表示快指针在环上走的圈数。联立等式，可以得到 <code>2(a+b)=a+b+kL</code><br>解得 <code>a=kL−b</code>，整理可得<code>a = (k − 1)L + (L − b) = (k − 1)L + c</code><br>从上述等式可知，如果慢指针从起点出发，快指针从相遇位置出发，每次两个指针都移动一步，则慢指针走了 a 步之后到达环的入口，快指针在环里走了 k−1 圈之后又走了 c 步，由于从相遇位置继续走 c 步即可回到环的入口，因此快指针也到达环的入口。两个指针在环的入口相遇，相遇点就是答案。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findDuplicate</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="number">0</span>, fast = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        slow = nums[slow];</span><br><span class="line">        fast = nums[nums[fast]];</span><br><span class="line">    &#125; <span class="keyword">while</span>(slow != fast);</span><br><span class="line">    slow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(slow != fast)&#123;</span><br><span class="line">        slow = nums[slow];</span><br><span class="line">        fast = nums[fast];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LeetCode-394-字符串解码"><a href="#LeetCode-394-字符串解码" class="headerlink" title="LeetCode-394 字符串解码"></a>LeetCode-394 字符串解码</h3><p>给定一个经过编码的字符串，返回它解码后的字符串。</p><p>编码规则为: <code>k[encoded_string]</code>，表示其中方括号内部的 <code>encoded_string</code> 正好重复 <code>k</code> 次。注意 <code>k</code> 保证为正整数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">decodeString</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    Stack&lt;Integer&gt; nums = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    Stack&lt;String&gt; strs = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">        <span class="keyword">if</span>(Character.isDigit(ch))&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> ch - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">while</span>(Character.isDigit(ch = s.charAt(++i)))&#123;</span><br><span class="line">                num = num * <span class="number">10</span> + (ch - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            nums.push(num);</span><br><span class="line">            i--;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ch == <span class="string">&#x27;]&#x27;</span>)&#123;</span><br><span class="line">            String letter;</span><br><span class="line">            Stack&lt;String&gt; sub = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span>(!<span class="string">&quot;[&quot;</span>.equals((letter = strs.pop())))&#123;</span><br><span class="line">                sub.push(letter);</span><br><span class="line">            &#125;</span><br><span class="line">            Collections.reverse(sub);</span><br><span class="line">            letter = getString(sub);</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> nums.pop();</span><br><span class="line">            <span class="keyword">while</span>(num-- &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                strs.push(letter);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            strs.push(String.valueOf(ch));    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getString(strs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getString</span><span class="params">(Stack&lt;String&gt; v)</span> &#123;</span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">    <span class="keyword">for</span> (String s : v) &#123;</span><br><span class="line">        ret.append(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LeetCode-406-根据身高重建队列"><a href="#LeetCode-406-根据身高重建队列" class="headerlink" title="LeetCode-406 根据身高重建队列"></a>LeetCode-406 根据身高重建队列</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[][] reconstructQueue(<span class="type">int</span>[][] people) &#123;</span><br><span class="line">    <span class="keyword">if</span> (people == <span class="literal">null</span> || people.length == <span class="number">0</span> || people[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    Arrays.sort(people, (a, b) -&gt; (a[<span class="number">0</span>] == b[<span class="number">0</span>] ? a[<span class="number">1</span>] - b[<span class="number">1</span>] : b[<span class="number">0</span>] - a[<span class="number">0</span>]));</span><br><span class="line">    List&lt;<span class="type">int</span>[]&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 矮的对高的位置没有影响，但需要自己找位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>[] p : people) &#123;</span><br><span class="line">        queue.add(p[<span class="number">1</span>], p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> queue.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[queue.size()][]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LeetCode-437-路径总和-III"><a href="#LeetCode-437-路径总和-III" class="headerlink" title="LeetCode-437 路径总和 III"></a>LeetCode-437 路径总和 III</h3><h5 id="方法一：搜索（我的方法）"><a href="#方法一：搜索（我的方法）" class="headerlink" title="方法一：搜索（我的方法）"></a>方法一：搜索（我的方法）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pathSum</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">        res += doSearch(node, targetSum);</span><br><span class="line">        <span class="keyword">if</span>(node.left != <span class="literal">null</span>)&#123;</span><br><span class="line">            stack.push(node.left);                </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node.right != <span class="literal">null</span>)&#123;</span><br><span class="line">            stack.push(node.right);                </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">doSearch</span><span class="params">(TreeNode node, <span class="type">long</span> targetSum)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    targetSum -= node.val;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> == targetSum)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + doSearch(node.left, targetSum) + doSearch(node.right, targetSum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> doSearch(node.left, targetSum) + doSearch(node.right, targetSum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="方法二：前缀和"><a href="#方法二：前缀和" class="headerlink" title="*方法二：前缀和"></a>*方法二：前缀和</h5><p>我们仔细思考一下，解法一中应该存在许多重复计算。我们定义节点的前缀和为：由根结点到当前结点的路径上所有节点的和。我们利用先序遍历二叉树，记录下根节点 root 到当前节点 p 的路径上除当前节点以外所有节点的前缀和，在已保存的路径前缀和中查找是否存在前缀和刚好等于当前节点到根节点的前缀和 curr 减去 targetSum。</p><ul><li><p>对于空路径我们也需要保存预先处理一下，此时因为空路径不经过任何节点，因此它的前缀和为 0。</p></li><li><p>假设根节点为 root，我们当前刚好访问节点 node，则此时从根节点 root 到节点 node 的路径（无重复节点）刚好为 root→p1→p2→…→pk→node，此时我们可以已经保存了节点 p1,p2,p3,…,pk 的前缀和，并且计算出了节点 node的前缀和。</p></li><li><p>假设当前从根节点 root 到节点 node 的前缀和为 curr，则此时我们在已保存的前缀和查找是否存在前缀和刚好等于 curr−targetSum。假设从根节点 root 到节点 node 的路径中存在节点 pi 到根节点 root 的前缀和为 curr−targetSum，则节点 pi 到 node 的路径上所有节点的和一定为 targetSum。</p></li><li><p>我们利用深度搜索遍历树，当我们退出当前节点时，我们需要及时更新已经保存的前缀和。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pathSum</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">    Map&lt;Long, Integer&gt; prefix = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Long, Integer&gt;();</span><br><span class="line">    prefix.put(<span class="number">0L</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> dfs(root, prefix, <span class="number">0</span>, targetSum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(TreeNode root, Map&lt;Long, Integer&gt; prefix, <span class="type">long</span> curr, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    curr += root.val;</span><br><span class="line"></span><br><span class="line">    ret = prefix.getOrDefault(curr - targetSum, <span class="number">0</span>);</span><br><span class="line">    prefix.put(curr, prefix.getOrDefault(curr, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    ret += dfs(root.left, prefix, curr, targetSum);</span><br><span class="line">    ret += dfs(root.right, prefix, curr, targetSum);</span><br><span class="line">    prefix.put(curr, prefix.getOrDefault(curr, <span class="number">0</span>) - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">作者：力扣官方题解</span><br><span class="line">链接：https:<span class="comment">//leetcode.cn/problems/path-sum-iii/solutions/1021296/lu-jing-zong-he-iii-by-leetcode-solution-z9td/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><h3 id="LeetCode-438-找到字符串中所有字母异位词"><a href="#LeetCode-438-找到字符串中所有字母异位词" class="headerlink" title="LeetCode-438 找到字符串中所有字母异位词"></a>LeetCode-438 找到字符串中所有字母异位词</h3><ul><li>方法一（我的方法，时空双5%）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">findAnagrams</span><span class="params">(String s, String p)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">slen</span> <span class="operator">=</span> s.length(), plen = p.length();</span><br><span class="line">    <span class="keyword">if</span>(s.length() &lt; p.length())&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span>[] pc = p.toCharArray();</span><br><span class="line">    Arrays.sort(pc);</span><br><span class="line">    Set&lt;Character&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(Character ch : pc)&#123;</span><br><span class="line">        set.add(ch);</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; slen; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; slen; )&#123;</span><br><span class="line">            <span class="keyword">if</span>(set.contains(s.charAt(j)))&#123;</span><br><span class="line">                j++;</span><br><span class="line">                <span class="keyword">if</span>(j == i + plen)&#123;</span><br><span class="line">                    <span class="type">char</span>[] sc = s.substring(i, j).toCharArray();</span><br><span class="line">                    Arrays.sort(sc);</span><br><span class="line">                    <span class="keyword">if</span>(Arrays.equals(pc, sc))&#123;</span><br><span class="line">                        res.add(i);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                i = j;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>方法二：滑动窗口</p><p>方法一中其实不需要排序，只要字符串中每个字符数量相等即可</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">findAnagrams</span><span class="params">(String s, String p)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sLen</span> <span class="operator">=</span> s.length(), pLen = p.length();</span><br><span class="line">    <span class="keyword">if</span>(s.length() &lt; p.length())&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">    <span class="type">int</span>[] sCount = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="type">int</span>[] pCount = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; pLen; ++i) &#123;</span><br><span class="line">        ++sCount[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        ++pCount[p.charAt(i) - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Arrays.equals(sCount, pCount)) &#123;</span><br><span class="line">        ans.add(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; sLen - pLen; ++i) &#123;</span><br><span class="line">        --sCount[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        ++sCount[s.charAt(i + pLen) - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Arrays.equals(sCount, pCount)) &#123;</span><br><span class="line">            ans.add(i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LeetCode-560-和为k的子数组"><a href="#LeetCode-560-和为k的子数组" class="headerlink" title="LeetCode-560 和为k的子数组"></a>LeetCode-560 和为k的子数组</h3><ul><li><p>前缀和 O（N2）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">subarraySum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="comment">// 计算前缀和数组</span></span><br><span class="line">    <span class="type">int</span>[] preSum = <span class="keyword">new</span> <span class="title class_">int</span>[len + <span class="number">1</span>];</span><br><span class="line">    preSum[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        preSum[i + <span class="number">1</span>] = preSum[i] + nums[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>; left &lt; len; left++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> left; right &lt; len; right++) &#123;</span><br><span class="line">            <span class="comment">// 区间和 [left..right]，注意下标偏移</span></span><br><span class="line">            <span class="keyword">if</span> (**preSum[right + <span class="number">1</span>] - preSum[left] == k**) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>前缀和+哈希表 O（N）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">subarraySum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="comment">// 前缀和，结果</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// key为前缀和，value是key对应前缀和的出现次数</span></span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">0</span>; r &lt; nums.length; r++)&#123;</span><br><span class="line">        sum += nums[r];</span><br><span class="line">        <span class="comment">// 当前和为sum，以r结尾的子数组值为k的次数 = 前缀和为sum - k的出现次数</span></span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(sum - k))&#123;</span><br><span class="line">            res += map.get(sum - k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 前缀和为sum的出现次数+1</span></span><br><span class="line">        map.put(sum, map.getOrDefault(sum, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><h4 id="LeetCode-234-回文链表"><a href="#LeetCode-234-回文链表" class="headerlink" title="LeetCode-234 回文链表"></a>LeetCode-234 回文链表</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="comment">// 找到链表中点</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head, slow = head;</span><br><span class="line">    <span class="keyword">while</span>(fast.next != <span class="literal">null</span> &amp;&amp; fast.next.next != <span class="literal">null</span>)&#123;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 反转后半链表</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">curr</span> <span class="operator">=</span> slow.next;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span>(curr != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> curr.next;</span><br><span class="line">        curr.next = prev;</span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 逐一比对</span></span><br><span class="line">    <span class="keyword">while</span>(prev != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(head.val != prev.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        prev = prev.next;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// return前最好将后半链表反转回去</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="LeetCode-148-排序链表"><a href="#LeetCode-148-排序链表" class="headerlink" title="LeetCode-148 排序链表"></a>LeetCode-148 排序链表</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 归并排序</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">sortList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sort(head, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode <span class="title function_">sort</span><span class="params">(ListNode head, ListNode tail)</span>&#123;</span><br><span class="line">        <span class="comment">// 先通过快慢指针找出链表中点</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(head.next == tail)&#123;</span><br><span class="line">            head.next = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(fast != tail)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            <span class="keyword">if</span>(fast != tail)&#123;</span><br><span class="line">                fast = fast.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">mid</span> <span class="operator">=</span> slow;</span><br><span class="line">        <span class="comment">// 分别对两段链表排序，然后归并</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">list1</span> <span class="operator">=</span> sort(head, mid);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">list2</span> <span class="operator">=</span> sort(mid, tail);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">sorted</span> <span class="operator">=</span> merge(list1, list2);</span><br><span class="line">        <span class="keyword">return</span> sorted;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 合并两个有序链表</span></span><br><span class="line">    ListNode <span class="title function_">merge</span><span class="params">(ListNode list1, ListNode list2)</span>&#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">sentinel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> sentinel, head1 = list1, head2 = list2;</span><br><span class="line">        <span class="keyword">while</span>(head1 != <span class="literal">null</span> &amp;&amp; head2 != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(head1.val &lt; head2.val)&#123;</span><br><span class="line">                cur.next = head1;</span><br><span class="line">                head1 = head1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur.next = head2;</span><br><span class="line">                head2 = head2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(head1 != <span class="literal">null</span>)&#123;</span><br><span class="line">            cur.next = head1;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(head2 != <span class="literal">null</span>)&#123;</span><br><span class="line">            cur.next = head2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sentinel.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="动态规划-1"><a href="#动态规划-1" class="headerlink" title="动态规划"></a>动态规划</h3><h4 id="LeetCode-198-打家劫舍"><a href="#LeetCode-198-打家劫舍" class="headerlink" title="LeetCode-198 打家劫舍"></a>LeetCode-198 打家劫舍</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 暴力法，超出时间限制</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(doRub(nums, <span class="number">0</span>, <span class="number">0</span>), doRub(nums, <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">doRub</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> start, <span class="type">int</span> sum)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start &gt;= nums.length)&#123;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> Math.max(doRub(nums, start + <span class="number">2</span>, sum + nums[start]), </span><br><span class="line">                    doRub(nums, start + <span class="number">3</span>, sum + nums[start]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 动态规划 O（N）</span></span><br><span class="line"><span class="comment">// 状态转移方程：dp[i]=max(dp[i−2]+nums[i],dp[i−1])</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="keyword">if</span>(nums == <span class="literal">null</span> || length == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(length == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">first</span> <span class="operator">=</span> nums[<span class="number">0</span>], second = Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> second;</span><br><span class="line">        second = Math.max(first + nums[i], second);</span><br><span class="line">        first = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="LeetCode-337-打家劫舍-III"><a href="#LeetCode-337-打家劫舍-III" class="headerlink" title="LeetCode-337 打家劫舍 III"></a>LeetCode-337 打家劫舍 III</h4><p>一棵二叉树，树上的每个点都有对应的权值，每个点有两种状态（选中和不选中），问在不能同时选中有父子关系的点的情况下，能选中的点的最大权值和是多少。</p><p>我们可以用 f(o) 表示选择 o 节点的情况下，o 节点的子树上被选择的节点的最大权值和；g(o) 表示不选择 o 节点的情况下，o 节点的子树上被选择的节点的最大权值和；l 和 r 代表 o 的左右孩子。</p><p>当 o 被选中时，o 的左右孩子都不能被选中，故 o 被选中情况下子树上被选中点的最大权值和为 l 和 r 不被选中的最大权值和相加，即 <code>f(o)=g(l)+g(r)</code>。<br>当 o 不被选中时, o 的左右孩子可以被选中，也可以不被选中。对于 o 的某个具体的孩子 x，它对 o 的贡献是 x 被选中和不被选中情况下权值和的较大值。故 <code>g(o)=max⁡&#123;f(l),g(l)&#125;+max⁡&#123;f(r),g(r)&#125;</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] result = doRob(root);</span><br><span class="line">    <span class="keyword">return</span> Math.max(result[<span class="number">0</span>], result[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] doRob(TreeNode node) &#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] l = doRob(node.left);</span><br><span class="line">    <span class="type">int</span>[] r = doRob(node.right);</span><br><span class="line">    <span class="type">int</span> <span class="variable">select</span> <span class="operator">=</span> node.val + l[<span class="number">1</span>] + r[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">notSelect</span> <span class="operator">=</span> Math.max(l[<span class="number">0</span>], l[<span class="number">1</span>]) + Math.max(r[<span class="number">0</span>], r[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;select, notSelect&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="LeetCode-300-最长递增子序列"><a href="#LeetCode-300-最长递增子序列" class="headerlink" title="LeetCode-300 最长递增子序列"></a>LeetCode-300 最长递增子序列</h4><ul><li><p>方法一：动态规划</p><p>定义 dp[i] 为考虑前 iii 个元素，以第 i 个数字结尾的最长上升子序列的长度，注意 nums[i] 必须被选取。</p><p>我们从小到大计算 dp 数组的值，在计算 dp[i] 之前，我们已经计算出 dp[0…i−1] 的值，则状态转移方程为：</p><p><code>dp[i] = max⁡(dp[j]) + 1, 其中 0 ≤ j &lt; i 且  num[j] &lt; num[i]</code></p><p>即考虑往 dp[0…i−1] 中最长的上升子序列后面再加一个 nums[i]。由于 dp[j] 代表 nums[0…j] 中以 nums[j] 结尾的最长上升子序列，所以如果能从 dp[j] 这个状态转移过来，那么 nums[i] 必然要大于 nums[j]，才能将 nums[i] 放在 nums[j] 后面以形成更长的上升子序列。</p><p>时间复杂度：O（n2）</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">        dp[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; nums[j])&#123;</span><br><span class="line">                dp[i] = Math.max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        max = Math.max(dp[i], max);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="LeetCode-279-完全平方数"><a href="#LeetCode-279-完全平方数" class="headerlink" title="LeetCode-279 完全平方数"></a>LeetCode-279 完全平方数</h4><p>给你一个整数 <code>n</code> ，返回 <em>和为 <code>n</code> 的完全平方数的最少数量</em> 。</p><p><strong>完全平方数</strong> 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，<code>1</code>、<code>4</code>、<code>9</code> 和 <code>16</code> 都是完全平方数，而 <code>3</code> 和 <code>11</code> 不是。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numSquares</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] f = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">minn</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j * j &lt;= i; j++) &#123;</span><br><span class="line">            minn = Math.min(minn, f[i - j * j]);</span><br><span class="line">        &#125;</span><br><span class="line">        f[i] = minn + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="LeetCode-221-最大正方形"><a href="#LeetCode-221-最大正方形" class="headerlink" title="LeetCode-221 最大正方形"></a>LeetCode-221 最大正方形</h4><ul><li>方法一：暴力法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximalSquare</span><span class="params">(<span class="type">char</span>[][] matrix)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> matrix.length, col = matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; row; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; col; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][j] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">while</span>(flag)&#123;</span><br><span class="line">                    len++;</span><br><span class="line">                    <span class="keyword">if</span>(i + len &gt;= row || j + len &gt;= col)&#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> j; m &lt;= j + len; m++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(matrix[i + len][m] == <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">                            flag = <span class="literal">false</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> i; n &lt;= i + len; n++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(matrix[n][j + len] == <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">                            flag = <span class="literal">false</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                max = Math.max(len, max);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max * max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>方法二：动态规划</p><p>用 dp(i, j) 表示以 (i, j) 为右下角，且只包含 1 的正方形的边长最大值。如果我们能计算出所有 dp(i, j) 的值，那么其中的最大值即为矩阵中只包含 1 的正方形的边长最大值，其平方即为最大正方形的面积。</p><p>那么如何计算 dp 中的每个元素值呢？对于每个位置 (i, j)，检查在矩阵中该位置的值：</p><ul><li>如果该位置的值是 0，则 dp(i,j)&#x3D;0，因为当前位置不可能在由 111 组成的正方形中；</li><li>如果该位置的值是 1，则 dp(i,j)的值由其上方、左方和左上方的三个相邻位置的 dp 值决定。具体而言，当前位置的元素值等于三个相邻位置的元素中的最小值加 1，状态转移方程如下：<br><code>dp(i, j) = min(dp(i − 1, j), dp(i − 1, j − 1), dp(i, j − 1)) + 1</code></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximalSquare</span><span class="params">(<span class="type">char</span>[][] matrix)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> matrix.length, col = matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[row][col];</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; row; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; col; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][j] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span> || j == <span class="number">0</span>)&#123;</span><br><span class="line">                    dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = Math.min(Math.min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]), </span><br><span class="line">                                        dp[i - <span class="number">1</span>][j - <span class="number">1</span>]) + <span class="number">1</span>;                           </span><br><span class="line">                &#125;</span><br><span class="line">                max = Math.max(max, dp[i][j]);   </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max * max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="LeetCode-309-买卖股票的最佳时机含冷冻期"><a href="#LeetCode-309-买卖股票的最佳时机含冷冻期" class="headerlink" title="LeetCode-309 买卖股票的最佳时机含冷冻期"></a>LeetCode-309 买卖股票的最佳时机含冷冻期</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> prices.length;</span><br><span class="line">    <span class="keyword">if</span>(length &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">dp0</span> <span class="operator">=</span> -prices[<span class="number">0</span>], dp1 = <span class="number">0</span>, dp2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; length; i++)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">odp0</span> <span class="operator">=</span> dp0, odp1 = dp1, odp2 = dp2;</span><br><span class="line">        <span class="comment">// 前一天不卖或前一天买入</span></span><br><span class="line">        dp0 = Math.max(odp0, odp2 - prices[i]);</span><br><span class="line">        <span class="comment">// 前一天卖</span></span><br><span class="line">        dp1 = odp0 + prices[i];</span><br><span class="line">        <span class="comment">// 前一天没有卖且不持有股票</span></span><br><span class="line">        dp2 = Math.max(odp1, odp2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.max(dp1, dp2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="LeetCode-322-零钱兑换"><a href="#LeetCode-322-零钱兑换" class="headerlink" title="LeetCode-322 零钱兑换"></a>LeetCode-322 零钱兑换</h4><p>给你一个整数数组 <code>coins</code> ，表示不同面额的硬币；以及一个整数 <code>amount</code> ，表示总金额。</p><p>计算并返回可以凑成总金额所需的 <strong>最少的硬币个数</strong> 。如果没有任何一种硬币组合能组成总金额，返回 <code>-1</code> 。</p><p>你可以认为每种硬币的数量是无限的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">coinChange</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span> amount)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">    Arrays.fill(dp, amount + <span class="number">1</span>);</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= amount; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; coins.length; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i - coins[j] &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                dp[i] = Math.min(dp[i], dp[i - coins[j]] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[amount] &gt; amount ? -<span class="number">1</span> : dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="LeetCode-416-分隔等和子集"><a href="#LeetCode-416-分隔等和子集" class="headerlink" title="*LeetCode-416 分隔等和子集"></a>*LeetCode-416 分隔等和子集</h4><p><img src="http://oss.ripplesu.top/blog/Typora/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20231004111522094.png" alt="image-20231004111522094"></p><p>上述代码的空间复杂度是 O(n×target)。但是可以发现在计算 dp 的过程中，每一行的 dp 值都只与上一行的 dpdpdp 值有关，因此只需要一个一维数组即可将空间复杂度降到 O(target)。此时的转移方程为：</p><p><code>dp[j]=dp[j] ∣ dp[j−nums[i]]</code><br>且需要注意的是第二层的循环我们需要从大到小计算，因为如果我们从小到大更新 dp 值，那么在计算 dp[j] 值的时候，dp[j−nums[i]] 已经是被更新过的状态，不再是上一行的 dp 值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canPartition</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>, maxNum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            sum += num;</span><br><span class="line">            maxNum = Math.max(maxNum, num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> sum / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (maxNum &gt; target) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span>[] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[target + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> nums[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> target; j &gt;= num; --j) &#123;</span><br><span class="line">                dp[j] |= dp[j - num];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="LeetCode-338-比特位计数"><a href="#LeetCode-338-比特位计数" class="headerlink" title="LeetCode-338 比特位计数"></a>LeetCode-338 比特位计数</h4><p>定义正整数 x 的「最低设置位」为 x 的二进制表示中的最低的 1 所在位。例如，10 的二进制表示是 1010，其最低设置位为 2，对应的二进制表示是 10 。</p><p>令 <code>y=x &amp; (x−1)</code>，则 y 为将 x 的最低设置位从 1 变成 0 之后的数，显然<code> 0≤y&lt;x0</code>，<code>bits[x]=bits[y]+1</code>。因此对任意正整数 x，都有 <code>bits[x]=bits[x &amp; (x−1)]+1</code>。</p><p>遍历从 1 到 n 的每个正整数 i，计算 bits 的值。最终得到的数组 bits 即为答案。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] countBits(<span class="type">int</span> n) &#123;</span><br><span class="line">    <span class="type">int</span>[] bits = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        bits[i] = bits[i &amp; (i - <span class="number">1</span>)] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bits;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="LeetCode-494-目标和"><a href="#LeetCode-494-目标和" class="headerlink" title="LeetCode-494 目标和"></a>LeetCode-494 目标和</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findTargetSumWays</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i : nums)&#123;</span><br><span class="line">        sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">diff</span> <span class="operator">=</span> sum - target;</span><br><span class="line">    <span class="keyword">if</span>(diff &lt; <span class="number">0</span> || diff %<span class="number">2</span> != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">neg</span> <span class="operator">=</span> diff / <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][neg + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> nums[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= neg; j++)&#123;</span><br><span class="line">            <span class="comment">// 不选</span></span><br><span class="line">            <span class="keyword">if</span>(j &lt; num)&#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i - <span class="number">1</span>][j - num];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][neg];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 优化空间</span></span><br><span class="line"><span class="comment">// 由于 dp 的每一行的计算只和上一行有关，因此可以使用滚动数组的方式，去掉 dp 的第一个维度，将空间复杂度优化到 O(neg)。</span></span><br><span class="line"><span class="comment">// 实现时，内层循环需采用倒序遍历的方式，这种方式保证转移来的是 dp[i−1][] 中的元素值</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findTargetSumWays</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i : nums)&#123;</span><br><span class="line">        sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">diff</span> <span class="operator">=</span> sum - target;</span><br><span class="line">    <span class="keyword">if</span>(diff &lt; <span class="number">0</span> || diff %<span class="number">2</span> != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">neg</span> <span class="operator">=</span> diff / <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[neg + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> num : nums)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> neg; j &gt;= num; j--)&#123;</span><br><span class="line">            dp[j] += dp[j - num];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[neg];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="LeetCode-739-每日温度"><a href="#LeetCode-739-每日温度" class="headerlink" title="LeetCode-739 每日温度"></a>LeetCode-739 每日温度</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自己想的，可能不算动态规划</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] dailyTemperatures(<span class="type">int</span>[] temperatures) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> temperatures.length;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    dp[n - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        dp[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(temperatures[i] &lt; temperatures[i + <span class="number">1</span>])&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">do</span>&#123;</span><br><span class="line">                dp[i] += dp[j];</span><br><span class="line">                <span class="keyword">if</span>(dp[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i] = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                j += dp[j];</span><br><span class="line">            &#125;<span class="keyword">while</span>(temperatures[j] &lt;= temperatures[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h2><h3 id="LeetCode-185-部门工资前三高的所有员工"><a href="#LeetCode-185-部门工资前三高的所有员工" class="headerlink" title="LeetCode-185 部门工资前三高的所有员工"></a>LeetCode-185 部门工资前三高的所有员工</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> d.name <span class="keyword">as</span> Department, e1.name <span class="keyword">as</span> Employee, salary <span class="keyword">as</span> salary</span><br><span class="line"><span class="keyword">from</span> Employee e1 </span><br><span class="line"><span class="keyword">join</span> Department d <span class="keyword">on</span> e1.departmentId <span class="operator">=</span> d.id </span><br><span class="line">    <span class="keyword">where</span> <span class="number">3</span> <span class="operator">&gt;</span> (</span><br><span class="line">        <span class="keyword">select</span> <span class="built_in">count</span>(<span class="keyword">distinct</span>(e2.salary))</span><br><span class="line">        <span class="keyword">from</span> Employee e2</span><br><span class="line">        <span class="keyword">where</span> </span><br><span class="line">        e2.salary <span class="operator">&gt;</span> e1.salary </span><br><span class="line">        <span class="keyword">and</span> e1.departmentId <span class="operator">=</span> e2.departmentId</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><h3 id="LeetCode-196-删除重复的电子邮箱"><a href="#LeetCode-196-删除重复的电子邮箱" class="headerlink" title="LeetCode-196 删除重复的电子邮箱"></a>LeetCode-196 删除重复的电子邮箱</h3><p><strong>删除</strong> 所有重复的电子邮件，只保留一个具有最小 <code>id</code> 的唯一电子邮件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DELETE p1 FROM Person p1,</span><br><span class="line">    Person p2</span><br><span class="line">WHERE</span><br><span class="line">    p1.Email = p2.Email AND p1.Id &gt; p2.Id</span><br></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>操作系统期末复习</title>
      <link href="/2023/02/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"/>
      <url>/2023/02/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="操作系统概述"><a href="#操作系统概述" class="headerlink" title="操作系统概述"></a>操作系统概述</h2><h3 id="教学目的"><a href="#教学目的" class="headerlink" title="教学目的"></a>教学目的</h3><ul><li>熟悉<font color='blue'>操作系统作用和定义</font>，了解操作系统的历史。</li><li>熟练掌握<font color='red'>多道程序设计技术</font>的概念，掌握<font color='orange'>批处理系统、分时系统及实时系统</font>三种操作系统基本类型，了解微机操作系统、网络操作系统、分布式操作系统和嵌入式操作系统。</li><li>掌握操作系统<font color='orange'>并发性、共享性、虚拟性和异步性</font>等特征，了解现代操作系统特征，熟悉<font color='blue'>操作系统功能</font>。</li></ul><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a><font color='blue'>定义</font></h3><ul><li>从计算机系统组成观点――操作系统是系统软件  </li><li>从资源管理程序观点――操作系统是系统资源管理者  </li><li>从软件分层、扩充机器的观点――操作系统是扩充裸机的第一层系统软件  </li><li>从服务用户的观点――操作系统是用户与裸机之间接口<br>作业级接口：提供一组键盘命令<br>程序级接口：提供一组系统调用  </li><li>从进程的观点——操作系统是由若干个可以并发执行的进程和一个对进程进行控制和协调的核心（kernel）组成。</li></ul><h3 id="基本特征"><a href="#基本特征" class="headerlink" title="基本特征"></a><font color='orange'>基本特征</font></h3><ul><li>并发:是指两个或多个活动在同一给定的时间<br>间隔中进行。</li><li>共享:是指计算机系统中的资源被多个进程所<br>共用。</li><li>异步:进程以不可预知的速度向前推进</li><li>虚拟:把一个物理上的实体变为若干个逻辑上<br>的对应物。<br>最基本特征:并发、共享(两者互为存在条<br>件)</li></ul><h3 id="发展"><a href="#发展" class="headerlink" title="发展"></a>发展</h3><h4 id="串行处理（无操作系统）"><a href="#串行处理（无操作系统）" class="headerlink" title="串行处理（无操作系统）"></a>串行处理（无操作系统）</h4><p>程序员直接与硬件打交道。计算机系统串行工作。<br>缺点：人机速度矛盾、计算机资源利用率低</p><h4 id="批处理"><a href="#批处理" class="headerlink" title="批处理"></a><font color='orange'>批处理</font></h4><h5 id="简单批处理"><a href="#简单批处理" class="headerlink" title="简单批处理"></a>简单批处理</h5><p>目标：为了解决人工操作（无操作系统）严重降低了计算机资源利用率的问题，即解决CPU等待人工操作和高速CPU与低速I&#x2F;O间矛盾等问题。</p><h5 id="多道程序设计"><a href="#多道程序设计" class="headerlink" title="多道程序设计"></a><font color='red'>多道程序设计</font></h5><p>多程序设计是一种操作模式，它由一个处理器交替执行两个或多个计算机程序。<br>目标：为了进一步提高资源利用率，在硬件采用通道和中断技术支持并行操作的情况下，引入了多道程序设计技术，由此引入多道批处理系统。<br>宏观上并行执行，微观上串行，即多道程序轮流地使用部件，交替执行。  </p><ul><li>首先要考虑：周转时间和系统吞吐量</li></ul><h4 id="分时系统"><a href="#分时系统" class="headerlink" title="分时系统"></a><font color='orange'>分时系统</font></h4><p>多个用户分时共享使用同一台计算机，也就是说把计算机的系统资源（尤其是CPU时间）进行时间上分割，即将整个工作时间分成一个个的时间片，每个时间片分给一个用户使用，依次轮流使用一个时间片。  </p><ul><li>采用调进／调出的单道分时系统<br>单道分时系统内存中只驻留一道程序，其余程序都在外存上。每当内存中一个程序运行一个时间片后，便调至外存（称为调出）。</li><li>基于多道程序设计的多道分时系统<br>在<strong>内存</strong>中存放多道作业排成一个队列，依次轮流地获得一个时间片来运行。由于切换作业就在内存，不要花费大量时间用于调进调出，故多道分时系统具有较好的系统性能。</li><li>重要指标——响应时间T&#x3D;n*q<br>响应时间是分时系统的重要指标，它是用户发出终端命令到系统开始作出响应的时间间隔。<br>优点：提供人机交互<br>缺点：不能优先处理紧急事件  </li><li>首要考虑：交互性和响应时间</li></ul><h4 id="实时系统"><a href="#实时系统" class="headerlink" title="实时系统"></a><font color='orange'>实时系统</font></h4><p>目标：为了提高系统的响应时间，对随机发生的外部事件作出及时响应并对其进行处理。<br>分类：实时控制系统、实时信息处理系统<br>快速的响应时间、有限的交互能力（弱于分时）、高可靠性（高于分时），能优先处理紧急任务    </p><ul><li>首要考虑：实时性和可靠性</li></ul><h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><h2 id="进程描述与控制"><a href="#进程描述与控制" class="headerlink" title="进程描述与控制"></a>进程描述与控制</h2><ul><li>熟悉<font color='blue'>进程引入的必要性</font>；</li><li>熟练掌握<font color='red'>进程的定义和特征</font>，</li><li>熟练掌握<font color='red'>进程的三个基本状态、状态转换的条件</font>；</li><li>熟练掌握<font color='red'>进程存在的唯一实体——进程控制块</font>；</li><li>熟悉<font color='blue'>进程上下文</font>。</li></ul><h3 id="进程引入的必要性"><a href="#进程引入的必要性" class="headerlink" title="进程引入的必要性"></a><font color='blue'>进程引入的必要性</font></h3><p>为了提高资源利用率，系统采用多道程序设计，程序执行环境由顺序执行变为并发执行。<br>由于程序在<strong>并发执行时</strong>，可能会造成<strong>执行结果的不可再现</strong>，所以用“程序”这个概念已无法描述程序的并发执行，所以必须引入新的概念—进程来<strong>描述程序的并发执行</strong>，并要对进程进行必要的管理，以<strong>保证进程在并发执行时结果可再现</strong>。</p><h3 id="进程的定义和特征"><a href="#进程的定义和特征" class="headerlink" title="进程的定义和特征"></a><font color='red'>进程的定义和特征</font></h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>进程是一个正在执行的程序，它被操作系统控制和调度。<br>可并发执行的程序在一个数据集合上的运行过程。  </p><ul><li>一段可执行的程序</li><li>计算机中正在运行的程序的一个实例</li><li>可以分配给处理器并由处理器执行的一个实体</li><li>由一个顺序的执行线程、一个当前的状态以及一组相关的系统资源所描述的活动单元</li></ul><h4 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h4><ul><li>动态性：动态性是进程的<strong>最基本特征</strong>，它是程序执行过程，它是有一定的生命期。它由创建而产生、由调度而执行，因得不到资源而暂停，并由撤消而死亡。而程序是静态的，它是存放在介质上一组有序指令的集合，无运动的含义。</li><li>并发性：并发性是进程的重要特征。并发性指多个进程实体同存于内存中，能在一段时间内同时运行。</li><li>独立性：进程是一个能独立运行的基本单位，即是一个独立获得资源和独立调度的单位。</li><li>异步性：进程按各自独立的不可预知的速度向前推进，即进程按异步方式进行，正是这一特征，将导致程序执行的不可再现性，因此OS必须采用某种措施来限制各进程推进序列以保证各程序间正常协调运行。</li><li>结构特征：从结构上，进程实体由<strong>程序段、数据段和进程控制块</strong>三部分组成。</li></ul><h3 id="进程控制块PCB——进程存在的唯一实体"><a href="#进程控制块PCB——进程存在的唯一实体" class="headerlink" title="进程控制块PCB——进程存在的唯一实体"></a><font color='red'>进程控制块PCB——进程存在的唯一实体</font></h3><ul><li>包含描述进程的基本信息<ul><li>标识符（Identifier ）</li><li>进程状态（State ）</li><li>优先级（Priority ）</li><li>程序计数器（Program counter ）</li><li>内存指针（Memory pointers ）</li><li>上下文数据（Context data ）</li><li>I&#x2F;O状态信息（I&#x2F;O status information ）</li><li>统计信息（Accounting information ）</li></ul></li><li>由操作系统创建并管理</li></ul><h3 id="五状态模型"><a href="#五状态模型" class="headerlink" title="五状态模型"></a><font color='red'>五状态模型</font></h3><ul><li>运行（Running）：占有CPU</li><li>就绪（Ready ）：除了CPU，其它所需资源都已占有，一旦得到处理机即可运行，则称此进程处于就绪状态</li><li>阻塞（Blocked ）：等待某些事件</li><li>新建（New ）: 已经创建了PCB并保存在主存中，但程序代码和相关数据还没有读入主存</li><li>退出（Exit ）<br><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/66a58bdc-d059-4f78-9241-79f69d31d8b8_repeat_1700459209057__806745.png" alt="image.png"></li></ul><h4 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h4><ul><li>就绪态――＞运行态：当处理机空闲时，进程调度程序必将处理机分配给一个处于就绪态的进程，该进程便由就绪态转换为运行态。</li><li>运行态――＞阻塞态：处于运行态的进程在运行过程中需要等待某一事件发生后，才能继续运行，则该进程放弃处理机，从运行态转换为阻塞态。</li><li>阻塞态――＞就绪态：处于阻塞态的进程，若其等待的事件已经发生，进程由阻塞态转换为就绪态。</li><li>运行态――＞就绪态：处于运行状态的进程在其运行过程中，因分给它的处理机时间片已用完，而不得不让出（被抢占）处理机，于是进程由运行态转换为就绪态。</li><li>阻塞态――＞运行态和就绪态――＞阻塞态这二种状态转换不可能发生。</li></ul><h4 id="挂起态"><a href="#挂起态" class="headerlink" title="挂起态"></a>挂起态</h4><p>处理器运行的速度远远地快于I&#x2F;O设备，运行一段时间后会出现所有进程都处于阻塞态（等待I&#x2F;O操作），就绪态进程数为0，此时处理器必须等待。<br>解决：</p><ol><li>扩充内存  </li><li>将进程交换到磁盘，释放内存空间<br>当进程被交换到磁盘上，则该进程从阻塞状态转换到挂起状态。<br>进程处于挂起状态是指该进程不在主存中。</li></ol><ul><li><p>进程不能立即执行；</p></li><li><p>进程可能在等待某个事件，也可能不等待事件，即进程挂起与否与进程阻塞与否没有必然的联系。</p></li><li><p>单挂起态<br><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/5b7c3132-2b6c-42d6-afb4-99c5e032468e_repeat_1700459257035__949762.png" alt="image.png"></p></li><li><p>双挂起态<br><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/4b91da04-ceb5-4d91-b77b-a15c8dfe3205_repeat_1700459264652__015256.png" alt="image.png"><br>阻塞&#x2F;挂起（Blocked&#x2F;Suspend ）<br>就绪&#x2F;挂起（Ready&#x2F;Suspend )</p></li></ul><h3 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h3><ul><li>用户模式（目态）<ul><li>通常在该模式下执行用户程序</li><li>权限较低</li></ul></li><li>系统模式、控制模式或内核模式（管态）<ul><li>在该模式下执行操作系统内核</li><li>可执行特权指令，权限更高</li></ul></li></ul><h4 id="三个问题"><a href="#三个问题" class="headerlink" title="三个问题"></a>三个问题</h4><ul><li>为什么需要两种执行模式?<br>保护操作系统和重要数据不受用户干扰</li><li>处理器如何知道当前系统处于哪个执行模式下?<br>程序状态字（PSW）中管理程序&#x2F;用户模式位记录了当前系统所处的模式信息</li><li>模式如何切换?<br>用户调用操作系统服务（<strong>系统调用</strong>）或发生<strong>中断</strong>时，执行模式从用户模式切换到内核模式<br>当系统服务返回或中断返回到用户进程时，执行模式从内核模式切换到用户模式</li></ul><h4 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h4><ul><li>给进程分配一个唯一的进程标识号</li><li>给进程分配空间</li><li>初始化进程控制块  </li><li>将进程控制块加入到正确的队列中</li><li>创建或扩充操作系统所需的其他数据结构</li></ul><h4 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h4><ul><li>何时切换<br>中断、陷阱（进程运行错误或异常）、系统调用</li><li>进程切换与模式切换<ul><li>模式切换是系统执行模式的改变，发生模式切换可以不改变正处于运行态的进程状态 </li><li>进程切换时，操作系统必须使其运行环境发生改变</li><li>进程切换必然会存在模式切换（只有在内核模式下才能实现进程调度），但模式切换不一定会发生进程切换</li><li>进程切换比模式切换更复杂</li></ul></li></ul><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>了解线程的概念、引入线程的好处和线程的应用 。</p><h3 id="并发进程的基本单位"><a href="#并发进程的基本单位" class="headerlink" title="并发进程的基本单位"></a>并发进程的基本单位</h3><ul><li>资源拥有者<br>一个进程包括一个存放进程映像的虚拟地址空间，进程需要申请并拥有系统资源，如主存、I&#x2F;O设备、文件等。</li><li>调度或执行的基本单位<br> 一个进程沿着其执行轨迹执行，在多道情况下，其执行过程可能与其他进程的执行过程交替进行<br>这两个基本属性使进程成为并发执行的基本单位。 大多数操作系统将这两个属性<strong>独立对待</strong>。</li></ul><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p>操作系统在一个进程内支持多个线程的能力。  </p><ul><li>资源分配与保护以进程为单位</li><li>调度执行以线程为基本单位。<ul><li>线程只拥有一点在运行中必不可省的资源（程序计数器、一组寄存器和栈），但它可与同属一个进程的其它线程<strong>共享进程拥有的全部资源</strong></li><li>线程定义为进程内一个执行单元或一个可调度实体</li></ul></li></ul><h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><ul><li>执行状态 (running, ready等)</li><li>未运行时需保存线程的上下文（一个独立的程序计数器）</li><li>一个执行栈</li><li>每个线程一些局部变量的静态存储空间</li><li>和这个进程的其它线程共享对这个进程的存储器和资源的访问<br>进程内的所有线程驻留在同一块地址空间中，并且可以访问到相同的数据</li></ul><h3 id="引入线程的好处"><a href="#引入线程的好处" class="headerlink" title="引入线程的好处"></a>引入线程的好处</h3><ul><li>在一个已有进程中创建一个新线程比创建一个全新进程所需的时间更少</li><li>终止一个线程比终止一个进程花费的时间更少</li><li>在同一进程内二个线程间切换时间要比二个进程切换时间小得多</li><li>同一个进程内的所有线程共享存储器和文件，当一个线程修改了数据，其他线程都能访问到修改后的结果。因此，线程间通信不需要调用内核就可以实现。  </li><li>总结：提高并发执行的程度,减少管理的时空开销。</li></ul><h3 id="线程特性"><a href="#线程特性" class="headerlink" title="线程特性"></a>线程特性</h3><ul><li>线程与进程共享地址空间，故挂起线程将导致进程内所有线程被挂起</li><li>进程终止，所有线程随之终止</li><li>三个基本状态：运行、就绪、阻塞</li></ul><h3 id="两种实现方式"><a href="#两种实现方式" class="headerlink" title="两种实现方式"></a>两种实现方式</h3><h4 id="用户级线程（ULTs）"><a href="#用户级线程（ULTs）" class="headerlink" title="用户级线程（ULTs）"></a>用户级线程（ULTs）</h4><p>线程管理的所有工作都由应用程序来完成，内核并不知道线程的存在。</p><ul><li>优点  <ul><li><strong>不依赖于OS内核</strong>，应用进程利用线程库提供创建、同步、调度和管理线程的函数来控制用户线程，可以在任何操作系统中运行</li><li>调度由应用软件内部进行，通常采用非抢占式或更简单的规则，<strong>无需用户态&#x2F;核心态切换</strong>，所以速度特别快，用户线程调度算法可针对应用优化</li><li>同一进程内各<strong>线程的切换不需要内核参与</strong>，减少了模式切换的开销</li></ul></li><li>缺点<ul><li>当一个线程因系统调用而被阻塞时，该进程内的所有线程都被阻塞<br>——系统调用使得模式从用户模式切换到内核模式，操作系统只知道进程，故操作系统将进程置为阻塞状态，从而使得该进程内的所有线程都被阻塞</li><li>内核一次只把一个进程分配给一个处理器，因此一次进程中只有一个线程可以执行，使多线程技术不能得到应用</li></ul></li></ul><h4 id="内核级线程（KLTs）"><a href="#内核级线程（KLTs）" class="headerlink" title="内核级线程（KLTs）"></a>内核级线程（KLTs）</h4><p>有关线程管理的所有工作都由内核来完成；应用程序只调用内核级线程的API；操作系统基于线程进行调度。</p><ul><li>优点<ul><li>内核可以同时把同一个进程中的多个线程调度到多个处理器中，从而更好地利用多道程序设计技术</li><li>如果一个进程内的线程阻塞，内核可以调度同一进程内的其他线程运行，不会导致整个进程被阻塞</li><li>内核自身也可以使用多线程</li></ul></li><li>缺点<br>同一个进程内两个线程的切换需要内核模式的切换</li></ul><h1 id="并发：互斥与同步"><a href="#并发：互斥与同步" class="headerlink" title="并发：互斥与同步"></a>并发：互斥与同步</h1><ul><li>熟悉<font color='blue'>进程间制约关系</font>，掌握<font color='orange'>临界资源和临界区概念</font>，掌握<font color='orange'>进程同步和进程同步机制</font>，熟悉<font color='blue'>利用软件、硬件技术解决进程同步机制</font>。</li><li>熟练掌握<font color='red'>信号量机制(记录型信号量和wait、signal操作)的概念、定义和实质</font>，熟练掌握<font color='red'>利用信号量机制实现进程互斥和同步</font>。掌握<font color='orange'>利用信号量解决生产者-消费者等经典同步问题</font>，掌握<font color='orange'>进程同步分析方法</font>。</li></ul><h3 id="并发进程间的制约关系"><a href="#并发进程间的制约关系" class="headerlink" title="并发进程间的制约关系"></a><font color='blue'>并发进程间的制约关系</font></h3><p>在多道程序环境下，系统中各进程以不可预测的速度向前推进，进程的异步性会造成结果的不可再现性。为防止这种现象，异步的进程间推进受到两种限制：</p><ul><li>资源共享关系<br>多进程共享资源时，每次只允许一个进程使用资源，等该进程使用完毕后再将资源分配给其它进程。这种使用原则称为<strong>互斥</strong>使用。<br>进程之间竞争资源面临三个控制问题：<ul><li>互斥（mutual exclusion)指多个进程不能同时使用同一个资源；</li><li>死锁（ deadlock )指多个进程互不相让，都得不到足够的资源；</li><li>饥饿（ starvation )指一个进程一直得不到资源（其他进程可能轮流占用资源）</li></ul></li><li>相互合作关系<br>   在某些进程之间还存在合作关系，进程并发执行时推进序列受到限制，要保证其合作关系正确。进程间这种关系称为<strong>同步</strong>关系。</li></ul><h3 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h3><ul><li><font color='orange'>临界资源</font> —— 一次只允许一个进程使用的资源。</li><li><font color='orange'>临界区</font> —— 多个进程共享临界资源时必须互斥使用，将程序中使用临界资源的那一段代码称为临界区。</li><li>竞争条件 —— 多个进程或线程在读写一个共享数据时，结果依赖于它们执行的相对时间，这种情形叫竞争。</li></ul><h3 id="进程同步机制"><a href="#进程同步机制" class="headerlink" title="进程同步机制"></a><font color='orange'>进程同步机制</font></h3><p>进程在并发执行时为了保证结果的可再现性，各进程执行序列必须加以限制以保证互斥地使用临界资源，相互合作完成任务。<br><strong>多个相关进程在执行次序上的协调</strong>称为进程同步。用于保证多个进程在执行次序上的协调关系的相应机制称为进程同步机制。<br>所有的进程同步机制应遵循下述<strong>四条准则</strong>：  </p><ul><li>空闲让进<br>  当无进程进入临界区时，相应的临界资源处于空闲状态，因而允许一个请求进入临界区的进程立即进入自己的临界区。</li><li>忙则等待<br>   当已有进程进入自己的临界区时，即相应的临界资源正被访问，其它试图进入临界区的进程必须等待，以保证进程互斥地访问临界资源。    </li><li>有限等待<br>   对要求访问临界资源的进程，应保证进程能在有限时间进入临界区，以免陷入“饥饿”状态。</li><li>让权等待<br>   当进程不能进入自己的临界区时，应立即释放处理机，以免进程陷入忙等。<br>   进程同步机制在临界区前加上进入区，它负责对欲访问的临界资源状态进行检查，以决定是否允许该进程进入临界区还是等待。同时在临界区后加上退出区，它负责释放临界资源以便其它等待该临界资源的进程使用。</li></ul><h3 id="互斥的三种实现方法"><a href="#互斥的三种实现方法" class="headerlink" title="互斥的三种实现方法"></a>互斥的三种实现方法</h3><ul><li>软件方法：由进程本身负责实施互斥，不需要操作系统支持。<ul><li>增加一定的开销</li></ul></li><li>硬件方法：使用专门的机器指令来实现互斥。 <ul><li>可减少开销，但依赖于硬件，难以成为通用的解决办法</li></ul></li><li>操作系统层提供支持解决互斥 <ul><li>信号量机制、管程机制和消息传递机制</li></ul></li></ul><h3 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a><font color='red'>信号量机制</font></h3><p>Dijkstra</p><ul><li>基本原理：两个或多个进程可以通过简单的信号进行合作，一个进程可以被迫在某一个位置停止，直到它接收到一个特定的信号。</li></ul><h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><ul><li>特殊的变量，初始化为<strong>非负数</strong>，称为信号量，用于发送信号</li><li>一个进程为了通过信号量s发送信号,它需要执行原语 semSignal(s)&#x2F;V(s)。该操作使信号量值减1。如果信号量值变为负数，则执行该操作的进程被阻塞。</li><li>一个进程通过信号量s接收信号, 它需要执行原语semWait(s) &#x2F;P(s)。该操作使信号量值增1。如果值小于或等于零，表示之前有进程在等该信号，则需要在该信号量的阻塞队列中唤醒一个进程。</li><li>如果相应的信号没有接收到，该进程将被<strong>挂起</strong>，直到它所需的信号发送为止</li></ul><h4 id="二元信号量"><a href="#二元信号量" class="headerlink" title="二元信号量"></a>二元信号量</h4><p>只有0和1两个值。</p><h4 id="信号量的类型"><a href="#信号量的类型" class="headerlink" title="信号量的类型"></a>信号量的类型</h4><ul><li>互斥信号量（公用信号量）：它为一组需互斥共享临界资源的并发进程而设置，它代表永久性共享的临界资源，每个进程均可对它施加wait、signal操作，即可申请和释放该临界资源，其初始值置为1。</li><li>同步信号量（专用信号量）：它为一组需同步协作完成任务的并发进程而设置，它代表消耗性的专用资源，只有拥有该资源的进程才能对它施加wait操作（即可申请资源），而由其合作进程对它施加signal操作（即释放资源）。</li></ul><h4 id="使用信号量机制实现进程互斥"><a href="#使用信号量机制实现进程互斥" class="headerlink" title="使用信号量机制实现进程互斥"></a>使用信号量机制实现进程互斥</h4><p>为使多个进程能互斥地访问某临界资源，只需为该资源设置一个互斥信号量<strong>mutex</strong>, 其初值为1。<br>规定每个进程在<strong>进入临界区CS前</strong>必须申请资源，即对互斥信号量mutex进行<strong>semwait</strong>操作，在<strong>退出临界区CS后</strong>必须释放资源，即对互斥信号量mutex进行<strong>semsignal</strong>操作；即将各进程的临界区CS置于semwait（mutex）和semsignal(mutex)操作之间。<br><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/59fb6e49-2b14-4368-b6b7-46e7e61c2fa7_repeat_1700459269065__771836.png" alt="image.png">  </p><h4 id="使用信号量机制实现进程同步"><a href="#使用信号量机制实现进程同步" class="headerlink" title="使用信号量机制实现进程同步"></a>使用信号量机制实现进程同步</h4><p>例：进程p打印进程c计算后放入缓冲区的数据<br>两条规则：</p><ul><li>只有当C进程把数据送入Buffer后，P进程才能从Buffer中取出数据来打印，否则P进程只能等待。</li><li>只有当P进程从Buffer中取走数据后，C进程才能将新计算的数据再存入Buffer,否则C进程也只能等待。<br><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/3ee9319e-1c28-4e66-bd55-ec5d47ba7d3b_repeat_1700459272361__816461.png" alt="image.png">  </li><li>同步信号量full，它代表的消耗性的专用资源是缓冲器装满数据；  </li><li>同步信号量empty，它代表的消耗性的专用资源是缓冲器空。</li></ul><h5 id="同步的物理意义"><a href="#同步的物理意义" class="headerlink" title="同步的物理意义"></a>同步的物理意义</h5><p>先做动作的进程C在动作完成后对同步信号量施加signal操作，代表发送消息；后做动作的进程P在动作前对同步信号量施加wait操作，代表测试消息是否到达。</p><h4 id="利用信号量机制描述前驱关系"><a href="#利用信号量机制描述前驱关系" class="headerlink" title="利用信号量机制描述前驱关系"></a>利用信号量机制描述前驱关系</h4><p><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/d32274cb-d4ae-4a25-af54-517b961ed5fe_repeat_1700459282414__279457.png" alt="image.png"></p><h4 id="经典进程同步问题"><a href="#经典进程同步问题" class="headerlink" title="经典进程同步问题"></a><font color='orange'>经典进程同步问题</font></h4><h5 id="生产者-消费者问题"><a href="#生产者-消费者问题" class="headerlink" title="生产者&#x2F;消费者问题"></a>生产者&#x2F;消费者问题</h5><p>问题描述：<br>一个或多个生产者生产某种类型的数据（记录、字符），并放置在缓冲区中；<br>有一个消费者从缓冲区中取数据，每次取一项；<br>任何时候只有一个生产者或消费者可以访问缓冲区</p><ul><li><p>情况一：缓冲区无限大<br><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/16d9f92b-18f4-4caf-88c5-2deef1d1822f_repeat_1700459285427__215664.png" alt="image.png"></p></li><li><p>情况二：缓冲区有限  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">producer:  </span><br><span class="line">while (true) &#123;  </span><br><span class="line">/* produce item v */  </span><br><span class="line">while   </span><br><span class="line">((in + 1) % n == out)   </span><br><span class="line"> /* do nothing */;  </span><br><span class="line">b[in] = v;  </span><br><span class="line">in = (in + 1) % n  </span><br><span class="line">&#125;    </span><br><span class="line">consumer:  </span><br><span class="line">while (true) &#123;  </span><br><span class="line">while (in == out)  </span><br><span class="line">/* do nothing */;   </span><br><span class="line">w = b[out];  </span><br><span class="line">out = (out + 1) % n;  </span><br><span class="line">/* consume item w */  </span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><p><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/0c52cfd8-e687-4f34-8752-130291ea6235_repeat_1700459489858__243453.png" alt="image.png"></p></li></ul><h5 id="读者-写者问题"><a href="#读者-写者问题" class="headerlink" title="读者&#x2F;写者问题"></a>读者&#x2F;写者问题</h5><p>问题描述：<br>有一个许多进程共享的数据区（文件、主存空间或处理器寄存器）；有一些进程只从该数据区中读数据，称为读者；有一些进程只往该数据区中写数据，称为写者。<br>任意多的读者可以同时读数据<br>一次只有一个写者可以往数据区写数据<br>如果写者正在写数据时，禁止任何读者读数据  </p><ul><li>解决方法一：读者优先  <ul><li>写者之间必须保证互斥，因此设置wsem 信号量，其初始值为1</li><li>写者只有在没有读者读数据时才能写数据，因此写进程可能会处于“饥饿”状态</li><li>写者在写数据时，不允许读者进来，因此第一个读者进程需要在wsem 信号量上等待</li><li>当有读者在读时，其他读者都可以进入数据区访问数据，不需要等待（因此称为读者优先）</li><li>为了记录读者的个数，定义readcount 变量，初始值为0</li><li>每个读者进程都会修改readcount变量，为了确保该共享变量修改的一致性，定义x信号量，初始值为1<br><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/c8204aca-27b9-488c-83cc-8f14f8939e79_repeat_1700459292233__505324.png" alt="image.png"></li></ul></li><li>解决方法二：写者优先<ul><li>当一个写者进程想写数据时，不允许新的读者进程访问数据区（解决饥饿的问题）</li><li>信号量 rsem ：当至少有一个写者进程准备访问数据区时，禁止所有的读进程 </li><li>writecount ： 记录写进程的个数，用于控制对信号量rsem的操作</li><li>信号量y ：用于确保对writecount的更新</li><li>信号量z：为了避免rsem阻塞队列太长，除了一个读者进程阻塞在rsem队列上，其它所有的读进程都阻塞在信号量z上<br><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/ab7519bb-5dfe-48ca-98da-88133c8307d8_repeat_1700459295039__352366.png" alt="image.png"></li></ul></li></ul><h4 id="进程操作总结"><a href="#进程操作总结" class="headerlink" title="进程操作总结"></a>进程操作总结</h4><ul><li>信号量的物理含义：<br> S&gt;0表示有S个资源可用；<br>S&#x3D;0表示无资源可用；<br>S&lt;0则| S |表示S等待队列中的进程个数。<br>信号量的初值应该大于等于0<br>wait(s)（P(S)）:表示申请(等待)一个资源<br>signal(s)（V(S)）:表示释放一个资源。  </li><li>wait(P)&#x2F;signal(V)操作必须成对出现，有一个wait(P)操作就一定有一个signal(V)操作<br>当为互斥操作时，它们同处于同一进程<br>当为同步操作时，则不在同一进程中出现<br>如果wait(S1)和wait(S2)两个操作在一起，那么wait操作的顺序至关重要,一个同步wait操作与一个互斥wait操作在一起时同步wait操作在互斥wait操作前；而两个signal操作无关紧要</li></ul><h4 id="例"><a href="#例" class="headerlink" title="例"></a>例</h4><ul><li>假定系统有三个并发进程read, move和print共享缓冲器B1和B2。进程read负责从输入设备上读信息，每读出一个记录后把它存放到缓冲器B1中。进程move从缓冲器B1中取出一记录，加工后存入缓冲器B2。进程print将B2中的记录取出打印输出。缓冲器B1和B2某个时刻只能被一个进程访问。要求三个进程协调完成任务，使打印出来的与读入的记录的个数，次序完全一样。请用wait&#x2F;signal操作，写出它们的并发程序。<br><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/0e29d14b-f956-4401-9918-7a8a12536b0a_repeat_1700459297678__021441.png" alt="image.png"><br><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/b8658aa3-5de1-49e0-b97b-3a285ef94c9d_repeat_1700459496666__050823.png" alt="image.png"></li></ul><h1 id="并发：死锁与饥饿"><a href="#并发：死锁与饥饿" class="headerlink" title="并发：死锁与饥饿"></a>并发：死锁与饥饿</h1><ul><li>掌握<font color='orange'>死锁的定义和产生死锁的原因</font>，掌握<font color='orange'>死锁的四个必要条件</font>；熟悉<font color='blue'>预防死锁的方法</font>，熟练掌握<font color='red'>银行家算法及其在死锁避免中的应用</font>；掌握<font color='orange'>资源分配图的简化及其死锁定理</font>，熟悉<font color='blue'>解除死锁的方法</font>。</li></ul><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a><font color='orange'>死锁</font></h3><p>死锁是指计算机系统和进程所处的一种状态。在系统中，两个或多个进程无限期地等待永远不会发生的条件，此时称系统处于死锁状态。 </p><h4 id="产生死锁的原因"><a href="#产生死锁的原因" class="headerlink" title="产生死锁的原因"></a><font color='orange'>产生死锁的原因</font></h4><ul><li>竞争资源<br>两个进程都在等待对方释放出自己所需要的资源，但它们又都因不能获得所需的资源而不能继续推进，从而也不能释放出自己占有的资源，以致进入死锁状态。<ul><li>资源分配图<br>可用资源分配图表示系统状态。资源分配图由结点和边组成。<br>结点有两类，一类是进程结点，用圆圈表示；另一类是资源结点，用小方框表示一类资源，方框中的小圈表示资源数。<br>边也有两类，一类是分配边，它由资源结点指向进程结点，另一类是申请边，它由进程结点指向资源结点。<br><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/8fb875e7-e2d0-438c-b21d-512aa4cf9bd1_repeat_1700459303828__410008.png" alt="image.png"></li></ul></li><li>进程推进顺序不当<br>在多道程序系统中，并发执行的进程推进序列不可预测，有些推进顺序会引起进程无限期地等待永远不会发生的条件而不能向前推进，造成了死锁。</li></ul><h4 id="死锁的条件"><a href="#死锁的条件" class="headerlink" title="死锁的条件"></a><font color='orange'>死锁的条件</font></h4><ul><li>互斥(Mutual exclusion)<br>一次只有一个进程可以使用资源</li><li>占有且等待 (Hold-and-wait)<br>当一个进程在等待分配得到其他资源时，将继续占有已分配到的资源</li><li>非剥夺 (No preemption )<br>不能强行抢占进程已占有的资源</li><li>循环等待 (Circular wait)<br>存在一个封闭的进程-资源链，每个进程至少占有一个该链中下一个进程所需要的资源</li></ul><h4 id="死锁的解决办法"><a href="#死锁的解决办法" class="headerlink" title="死锁的解决办法"></a>死锁的解决办法</h4><ul><li>死锁的预防<br>静态方法：在进程执行前采取的措施，通过设置某些限制条件，去破坏产生死锁的四个必要条件之一，防止发生死锁。  </li><li>死锁的避免<br>动态的方法：在进程执行过程中采取的措施，不需事先采取限制措施破坏产生死锁的必要条件，而是在进程申请资源时用某种方法去防止系统进入不安全状态，从而避免发生死锁。  </li><li>死锁的检测（Detection）和解除<br>这种方法预先并不采用任何限制措施，允许系统在运行过程中发生死锁，但可通过系统设置的检测机构及时检测死锁的发生（定期执行死锁检测算法），如检测到死锁，则采用撤消进程等死锁解除方法使系统恢复正常工作。</li></ul><h4 id="死锁的预防"><a href="#死锁的预防" class="headerlink" title="死锁的预防"></a><font color='blue'>死锁的预防</font></h4><p>预防死锁的方法是破坏四个产生死锁的必要条件之一。</p><ul><li>破坏互斥条件<br>互斥使用是资源本身特征所决定的。使用硬软件结合可改变资源本身特性。一般不破坏互斥条件。</li><li>破坏不可抢占条件<br>可采用<strong>抢占式调度</strong>，但抢占式调度法主要用于处理机和存储器资源调度，它们的状态容易保存和恢复。此法对外部设备和私有数据不宜使用。</li><li>破坏请求和保持条件<br>系统可采用<strong>资源静态预先全分配</strong>方式来破坏请求保持条件。系统要求所有进程<strong>一次性地申请在整个运行过程中全部资源</strong>，若系统有足够资源满足给进程，则在运行前，一次性将其所需要的所有资源分配给该进程。这样该进程在整个运行期间，便不再提出资源要求，从而摒弃了请求条件。<br>优点是简单、易于实现且很安全，但其资源利用率很低，进程也延迟运行。</li><li>破坏循环等待条件<br>有序资源使用法：<br>  该方法将所有的资源<strong>按类型进行线性排队，并赋予不同的序号</strong>。所有进程对资源的请求必须<strong>严格按资源序号递增的次序</strong>提出。这样在所形成的资源分配图中不可能再出现环路，因而摒弃了“循环等待”条件，在采用这种策略时总有一个进程占据了较高序号的资源，它继续请求的资源必然是空闲的，因而进程可以一直向前推进。<br>可提高资源利用率，但在进程使用各类资源的顺序与系统规定的顺序不同时会造成资源浪费的情况。</li></ul><h4 id="死锁的避免（Avoidance）"><a href="#死锁的避免（Avoidance）" class="headerlink" title="死锁的避免（Avoidance）"></a>死锁的避免（Avoidance）</h4><p>允许进程动态地申请资源，系统在进行资源分配之前，<strong>先计算资源分配的安全性</strong>。若此次分配不会导致系统从安全状态向不安全状态转换，便可将资源分配给进程；否则不分配资源，进程必须阻塞等待。从而避免发生死锁。<br>限制：  </p><ol><li>必须事先声明每个进程请求的最大资源数</li><li>考虑的进程必须是无关的，即进程之间不存在同步关系</li><li>分配的资源数目必须是固定的</li><li>在占有资源时，进程不能退出</li></ol><ul><li>资源分配拒绝  <ul><li>系统的安全状态是指系统的一种状态，在此状态下系统能按某种顺序（例如P1、P2……Pn）来为各个进程分配其所需资源，直至最大需求，使每个进程都可顺序地一个个地完成。这个序列（P1、P2…….Pn）称为安全序列。</li><li>若系统在某个状态下<strong>不存在一个安全序列</strong>，使所有进程能运行结束，则称系统处于不安全状态。不安全状态并不是死锁状态，而是<strong>存在死锁的可能性</strong>。</li></ul></li></ul><h5 id="银行家算法——Dijkstra"><a href="#银行家算法——Dijkstra" class="headerlink" title="银行家算法——Dijkstra"></a><font color='red'>银行家算法——Dijkstra</font></h5><ul><li>数据结构<br>考虑一个具有n个进程和 m 种不同类型资源系统。  <ul><li>Resource&#x3D;R&#x3D;(R1,R2,…,Rm)：向量，表示系统中<strong>每种资源的总量</strong> </li><li>Available&#x3D;V&#x3D;(V1,V2,…,Vm)：向量，未分配给进程的每种资源的总量，即<strong>可用的资源数</strong>  </li><li>Claim&#x3D;C：矩阵，Cij表示进程i对资源j的<strong>最大需求</strong></li><li>Allocation&#x3D;A：矩阵，Aij表示当前进程i<strong>已分配到的资源</strong>j的数量  </li><li>Need&#x3D;N：矩阵，表示每个进程<strong>尚需的各类资源数</strong>，Need[i,j]&#x3D;k 表示进程i还需要j类资源k个。Need[i,j]&#x3D;Claim[i,j]-Allocation[i,j]</li></ul></li><li>算法思想<br>假设在进程并发执行时，进程i提出请求j类资源k个后，表示为Request<del>i</del>[j]&#x3D;k。系统按下述步骤进行安全检查：</li></ul><ol><li>如果alloc[i,<em>]+Request[</em>]≤claim[i,*]，则继续以下检查，否则显示需求申请超出最大需求值的错误。</li><li>如果Request[<em>]≤Available[</em>]则继续以下检查，否则显示系统无足够资源，P<del>i</del>阻塞等待。</li><li>系统假设同意进程i的请求，将系统状态修改为满足请求之后的状态，然后对此状态执行安全性算法检测，判断在此次资源分配后，系统是否处于安全状态，若安全，才正式将资源分配给进程i，以完成本次分配；否则将恢复原来的资源分配状态，让进程P<del>i</del>等待，即进程P<del>i</del>置为阻塞状态。</li></ol><h5 id="例-1"><a href="#例-1" class="headerlink" title="例"></a>例</h5><p><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/509c51e1-4df9-45c8-8840-55cfe131c21b_repeat_1700459306266__927083.png" alt="image.png"></p><ul><li>T<del>0</del>时刻是否安全？<br><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/81bf2dff-a55f-43c0-a177-334eb8ff68ad_repeat_1700459502220__462474.png" alt="image.png"></li><li>P<del>1</del>请求资源Request<del>1</del>(1,0,2)可否允许？<ul><li>Request1(1,0,2)≤Need1(1,2,2)，P1请求在最大需求范围内。</li><li>Request1(1,0,2)≤ Available(3,3,2)，可用资源可满足P1请求需要。</li><li>试探把要求的资源分配给进程P1并修改有关数据结构的数值：<br>Available &#x3D; Available(3，3，2)－Request<del>1</del>(1,0,2)&#x3D;(2,3,0)；<br>Need<del>1</del> &#x3D; Need<del>1</del>(1,2,2)－Request<del>1</del>(1,0,2)&#x3D; (0,2,0)；<br>Allocation<del>1</del> &#x3D;Allocation<del>1</del>(2,0,0)+Request<del>1</del>(1,0,2) &#x3D;(3,0,2)；<br>利用安全性算法检查试探将资源分配后状态的安全性如下：<br><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/04b518f0-9297-4c94-b7e3-60a79944b4c1_repeat_1700459311309__846656.png" alt="image.png"><br>因为先分配资源给P1进程符合按安全序列{P1、P3、P4、P2、P0}分配资源，所以试探将资源分配给进程P1后的状态是安全的，可将资源分配给进程P1。</li></ul></li><li>P<del>4</del>请求资源Request<del>4</del>(3,3,0)是否允许？<br>Request<del>4</del>(3,3,0)≤Need<del>4</del>(4,3,1)，P<del>4</del>请求在最大需求范围内。<br>Request<del>4</del>(3,3,0)≤Available(2,3,0)不成立，即可用资源暂不能满足P4请求资源需要，P<del>4</del>阻塞等待。</li></ul><h4 id="死锁的检测（Detection）和解除"><a href="#死锁的检测（Detection）和解除" class="headerlink" title="死锁的检测（Detection）和解除 "></a><font color='blue'>死锁的检测（Detection）和解除 </font></h4><p>不限制资源访问或约束进程的行为;<br>只要系统资源能满足进程的请求就立即满足;<br>操作系统定期执行一个算法（死锁检测算法），检测当前系统是否满足了循环等待的条件，即当前系统是不是出现死锁;<br>若出现死锁，则进行相应的恢复。<br><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/f04b5ba1-cb40-41d0-9741-ecaef7be0d67_repeat_1700459313750__290804.png" alt="image.png"><br><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/f4b4a089-bd49-4a1b-b82f-96c5423f6590_repeat_1700459508199__508024.png" alt="image.png"></p><h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><h3 id="教学要求"><a href="#教学要求" class="headerlink" title="教学要求"></a>教学要求</h3><ul><li>熟悉<font color='blue'>存储管理目的和功能</font>，掌握<font color='orange'>地址重定位的概念</font>。</li><li>熟悉<font color='blue'>固定分区分配、动态分区分配的实现原理</font>；掌握<font color='orange'>可变分区分配的数据结构和分配回收算法</font>，熟悉<font color='blue'>可变分区碎片和压缩技术</font>。</li><li>熟练掌握<font color='red'>分页存储管理原理</font>，熟练掌握<font color='red'>分页存储管理基本的地址变换机构</font>。</li><li>掌握<font color='orange'>分段存储管理原理和分段地址变换机构</font>，掌握<font color='orange'>分页和分段比较</font>，熟悉<font color='blue'>分页和分段的共享</font>。</li></ul><h3 id="目的和功能"><a href="#目的和功能" class="headerlink" title="目的和功能"></a><font color='blue'>目的和功能</font></h3><h4 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h4><p>程序的指令和数据只有被调入内存（RAM）里才能被CPU直接访问，程序才能够被执行。</p><h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><p>1.内存分配<br>内存分配的主要任务是：为每一道程序分配内存空间；程序撤消时，收回它占用的内存空间。分配时注意提高存储器的利用率。<br>2.地址映射<br>目标程序所访问的地址是逻辑地址集合的地址空间，而内存空间是内存中物理地址的集合，在多道程序环境下，这两者是不一致的，因此，存储管理必须提供地址映射功能，用于<strong>把程序地址空间中的逻辑地址转换为内存空间中对应的物理地址</strong>。<br>3.存储保护<br>内存保护的任务是确保每道程序都在自己的内存空间运行，互不干扰。保护系统程序区不被用户侵犯（有意或无意的），不允许用户程序读写不属于自己地址空间的数据（系统区地址空间，其他用户程序的地址空间）。<br>4.提高主存储器的利用率<br>减少不可用的存储空间（称为“碎片”、“零头”），允许多道程序动态共享主存。<br>5.内存扩充<br>内存扩充的任务是从<strong>逻辑上</strong>来扩充内存容量，使用户认为系统所拥有的内存空间远比其实际的内存空间（硬件RAM）大的多。  </p><h3 id="地址重定位"><a href="#地址重定位" class="headerlink" title="地址重定位"></a><font color='orange'>地址重定位</font></h3><p>地址重定位，也称地址映射（map），它将相对地址转换成内存中的绝对地址。按照重定位的时机，可分为静态重定位和动态重定位。  </p><ul><li>静态重定位<br>静态重定位是在程序执行之前进行重定位。它根据装配模块将要装入的内存起始地址，直接修改装配模块中的有关使用地址的指令。</li><li>动态重定位<br>动态重定位是指在程序执行过程中进行地址重定位，即在每次访问内存单元前才进行地址变换。</li></ul><h3 id="内存分区"><a href="#内存分区" class="headerlink" title="内存分区"></a><font color='blue'>内存分区</font></h3><p>内存管理最基本的操作是由处理器将程序装入主存中执行。<br>分区存储管理是能够满足多道程序运行的最简单的存储器管理方案，其基本思想是将内存划分成若干个连续的区域，称为分区。<br>每个分区只能存储一个程序，而且程序也只能在它所驻留的分区中运行。<br>分区存储管理根据分区个数及分区大小的可变性分为固定分区和动态分区两种。</p><h4 id="固定分区"><a href="#固定分区" class="headerlink" title="固定分区"></a>固定分区</h4><p>在作业装入之前，系统管理员或操作系统<strong>事先</strong>将内存划分成若干个分区。一旦划分完成，在系统运行期间不再重新划分，即分区的<strong>个数不可变</strong>，分区的<strong>大小不可变</strong>，所以，固定式分区又称为静态分区。<br>可划分为大小相等的分区 (Equal-size partitions) 和大小不等的分区(Unequal-size partitions) 任何小于或等于分区大小的进程都可以装入到任何可用的分区中。<br>如果所有的分区都满了，系统可以换出一个进程，将其所占用的分区分配给另一个进程使用。<br><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/fde5cf36-3770-4314-a1b1-d39f7e8b7c64_repeat_1700459319176__108479.png" alt="image.png"></p><h5 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h5><ul><li>程序可能太大而不能放到一个分区中，必须使用覆盖技术，使得在任何时候该程序只有一部分放到主存中。</li><li>主存的利用率不高。任何进程，即使很小，都需要<strong>占据一个完整的分区</strong>。 一个进程的大小不可能正好等于某个分区的大小，所以每个被分配的分区内总有一部分被浪费，我们把这部分被浪费的存储区称为<strong>内部碎片</strong>( fragmentation)或内零头。</li></ul><h5 id="放置算法"><a href="#放置算法" class="headerlink" title="放置算法"></a>放置算法</h5><ul><li>大小相等的分区<br>所有分区大小都相等，只要存在可用的分区，进程就可以装入</li><li>大小不等的分区<br>把每个进程指定到足够容纳它的最小分区</li></ul><h4 id="动态分区"><a href="#动态分区" class="headerlink" title="动态分区"></a><font color='orange'>动态分区</font></h4><p>动态分区是指在作业装入内存时，从可用的内存中划出一块连续的区域分配给它，且<strong>分区大小正好等于该作业的大小</strong>。<br>动态分区中分区的大小和分区的个数都是可变的，而且是根据作业的大小和多少动态地划分，因此又称可变分区。<br><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/896224c5-3f40-407c-b0aa-8d6e60596d1c_repeat_1700459322193__184774.png" alt="image.png"><br>在分配时，首先找到一个足够大的空闲分区，系统再将这个空闲分区分成两部分：一部分成为已分配的分区（大小正好等于作业要求的大小），剩余的部分仍作为空闲区。<br>回收撤除作业所占领的分区时，要检查回收的分区是否与前后空闲的分区相邻接，若是，则加以合并，使之成为一个连续的大空间。<br>随着作业的不断分配和撤除，内存中会产生越来越多的碎片（外部碎片），内存的利用率下降，因此，必须定期使用压缩技术(compaction)，移动进程，使进程所占用的空间连续，并且所有空闲空间连成一片。</p><h5 id="分配算法"><a href="#分配算法" class="headerlink" title="分配算法"></a>分配算法</h5><ul><li>最佳适应算法BF（Best Fit）：它从全部空闲区中找出能满足作业要求的、且大小最小的空闲分区，这种方法能使碎片尽量小。为适应这种算法，空闲分区表（空闲区链）中的空闲分区要<strong>按大小从小到大进行排序</strong>，自表头开始查找到第一个满足要求的自由分区分配。该算法保留大的空闲区，但造成许多小的空闲区。</li><li>首次适应算法FF（First Fit）：从空闲分区表的第一个表目起查找该表，把最先能够满足要求的空闲区分配给作业，这种方法目的在于减少查找时间。为适应这种算法，空闲分区表（空闲区链）中的空闲分区要<strong>按地址由低到高进行排序</strong>。该算法优先使用低址部分空闲区，在低址空间造成许多小的空闲区，在高地址空间保留大的空闲区。</li><li>循环首次适应算法&#x2F;邻近算法NF(Next Fit)：该算法是首次适应算法的变种，它把空闲分区表（空闲区链）中的空闲分区按<strong>地址递增</strong>构成一个循环链。在分配内存空间时，不再每次从表头（链首）开始查找，而是从<strong>上次找到的空闲区的下一个空闲区</strong>开始查找，直到找到第一个能满足要求的的空闲区为止，并从中划出一块与请求大小相等的内存空间分配给作业。该算法能使内存中的空闲区分布得比较均匀。</li><li>最坏适应法：从所有未分配的分区中挑选最大的且大于和等于作业大小的分区分给要求的作业；空闲分区按大小<strong>由大到小排序</strong>。该算法使小的空闲区减少，但造成大的空闲区不够大。</li></ul><h5 id="回收算法"><a href="#回收算法" class="headerlink" title="回收算法"></a>回收算法</h5><p>邻接则合并，否则新建条目并插入合适位置。<br>分区存储保护：选中作业运行时将其边界存入上下界寄存器，作业运行过程中超出范围则产生越界中断。</p><h5 id="伙伴系统"><a href="#伙伴系统" class="headerlink" title="伙伴系统"></a>伙伴系统</h5><p>可用于分配的整个内存空间看做一个大小为2U的块<br>如果请求分配的空间大小s满足2U-1 &lt; s &lt;&#x3D; 2U, 则分配整个空间块（2U）<br>否则，将2U 一分为二，分为两个大小相等的伙伴，大小均为2U-1<br>这个过程一直继续，直到产生大于或等于s的最小块，并分配给该请求。<br>可用二叉树来表示，树的叶节点表示内存中的当前分区。如果两个伙伴都是叶节点且都未分配，则必须将它们合成一个更大的块。<br><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/d78b2477-9d42-47ab-a9f4-a5e332155964_repeat_1700459324979__686508.png" alt="image.png"></p><h3 id="分页存储管理方式"><a href="#分页存储管理方式" class="headerlink" title="分页存储管理方式"></a><font color='red'>分页存储管理方式</font></h3><p>分页存储管理是将一个<strong>进程的地址空间</strong>划分成若干个<strong>大小相等的片</strong>，称为页面或<strong>页</strong>，相应地，将<strong>内存空间</strong>划分成<strong>与页相同大小</strong>的若干个块，称为（物理）<strong>帧</strong>（块）或页帧。在为进程分配内存时，将进程中的若干页离散地装入不相邻接的物理帧中。<br>页面的大小通常在512B到4KB之间，每块物理块可离散地分配给进程的一页，这样不断地分配，直到剩余的物理块数不能满足一个进程的要求为止。而对每个进程只有最后一页经常装不满一块，平均产生半页“页内碎片”。由此可知，分页存储管理<strong>解决了“碎片”问题，提高了存储器的利用率</strong>。</p><h4 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h4><p>系统在内存为每个进程建立了一张页面映射表，简称<strong>页表</strong>(page table)（<strong>有多少个进程就有多少个页表</strong>）。每个页在页表中占一个表项，记录该页在内存中对应的物理块号或帧号（页号可以省略，通常默认从0开始）。<br>进程在执行时，通过查找页表，就可以找到每页所对应的物理块号或帧号。<br>可见，页表的作用是实现从<strong>页号到物理块号的地址映射</strong>。 </p><h4 id="地址结构"><a href="#地址结构" class="headerlink" title="地址结构"></a>地址结构</h4><p>分页系统的地址结构如下图所示，它由两部分组成：前一部分为<strong>页号P</strong>；后一部分为<strong>页内位移量W</strong>，即页内地址，由页的大小决定。<br>图中的地址长度为16位，其中0～9位为页内地址（每页的大小为1KB），10～15位为页号，所以允许地址空间的大小最多为64个页（26）。<br><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/da703385-537b-43bb-9fcb-99f20bd5b4d7_repeat_1700459327568__540114.png" alt="image.png"></p><h4 id="地址变换"><a href="#地址变换" class="headerlink" title="地址变换"></a>地址变换</h4><p>基本任务：利用硬件实现查页表把用户程序中的逻辑地址变换成内存中的物理地址。<br>为了实现地址变换功能，在系统中设置页表寄存器，用来存放页表的始址和页表的长度。在进程未执行时，每个进程对应的页表的始址和长度存放在进程的PCB中，当该进程被调度时，就将它们装入页表寄存器。<br>在进行地址变换时，系统将逻辑地址截成页号和页内地址二部分，将页号与页表长度进行比较，如果<strong>页号大于等于</strong>页表寄存器中的<strong>页表长度</strong>，则访问越界，产生<strong>越界中断</strong>。如未出现越界，则根据页表寄存器中的页表始址和页号计算出该页在页表项中的位置，查页表得到该页的物理块号，<strong>将物理块号与逻辑地址中页内地址二者拼接成物理地址</strong>，这样便完成了从逻辑地址到物理地址的变换。<br><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/dc2f0f14-47d2-4493-97c6-dae3d0c71140_repeat_1700459329985__639592.png" alt="image.png"><br><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/5d88d5fc-2fef-4fd0-8a35-1ab4bdaf6f6a_repeat_1700459514557__570614.png" alt="image.png"></p><h3 id="分段"><a href="#分段" class="headerlink" title="分段"></a><font color='orange'>分段</font></h3><p>在分段存储管理方式中，作业的地址空间<strong>按逻辑信息完整性被划分为若干个段</strong>，每个段都有自己的名字，编译后都是从零开始编址的一段连续的地址空间，段的长度由相应逻辑信息组的长度决定，因而<strong>各段长度是不等的</strong>。每个段分配到一个连续的分区，而进程中的各个段可以离散地分配到内存中不同的分区中。<br>分段系统的地址结构由<strong>段号</strong>和<strong>段内地址</strong>两部分组成。<br><strong>取最大段的长度为段内地址位数</strong>。</p><h4 id="段表"><a href="#段表" class="headerlink" title="段表"></a>段表</h4><p>每个段在表中占有一表项，在其中记录了该段在内存中的起始地址（又称为“基址”）和段的长度。<br><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/f6d910ba-9c42-460c-aa71-17b3647b9a1e_repeat_1700459335095__308089.png" alt="image.png"></p><h4 id="地址变换-1"><a href="#地址变换-1" class="headerlink" title="地址变换"></a>地址变换</h4><p>段表寄存器，存放段表始址和段表长度。<br>逻辑地址中的段号S与段表长度TL进行比较。若 S≥TL，产生越界中断信号；<br>若未越界，则根据段表的始址和该段的段号，计算出该段对应段表项的位置，从中读出该段在内存中的起始地址，然后再检查段内地址d是否超过该段的段长SL。若超过，即d≥SL，同样发出越界中断信号；若未越界，则将该段的基址与段内地址d相加，得要访问的内存物理地址。<br><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/03f11728-90ae-4e06-ace5-bed36e8cbb71_repeat_1700459337644__615445.png" alt="image.png"></p><h4 id="共享"><a href="#共享" class="headerlink" title="共享"></a><font color='blue'>共享</font></h4><p>段是信息的逻辑单位,因此分段系统的一个突出的优点是易于实现段的共享。<br>下图为分段系统中共享 editor编辑程序的示意图。<br><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/d02af489-3904-4a07-a93f-0a4862084418_repeat_1700459340116__972054.png" alt="image.png"></p><h3 id="分页与分段对比"><a href="#分页与分段对比" class="headerlink" title="分页与分段对比"></a><font color='orange'>分页与分段对比</font></h3><p><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/c0cf0068-7958-4cb6-8e7f-9464ec9e94d6_repeat_1700459519735__882813.png" alt="image.png"><br><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/0d25a699-acfd-4c86-b886-2fb940f0a546_repeat_1700459343642__349734.png" alt="image.png"></p><h1 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h1><h3 id="教学要求-1"><a href="#教学要求-1" class="headerlink" title="教学要求"></a>教学要求</h3><ul><li>掌握<font color='orange'>虚拟存储器的理论基础和定义</font>，熟悉<font color='blue'>虚拟存储器实现方式和特征</font>。</li><li>掌握<font color='orange'>请求分页的页表机制、缺页中断机构和地址变换机构</font>，熟悉<font color='blue'>页面的分配和置换策略、页面的分配的算法</font>。</li><li>掌握<font color='orange'>请求分段的段表机制、缺段中断机构和地址变换机构</font>，熟悉<font color='blue'>分段的共享和保护</font>。</li><li>掌握<font color='orange'>段页式存储管理原理和地址变换机构</font>。</li><li>熟练掌握<font color='red'>最佳置换算法、先进先出（FIFO）置换算法、最近最久未使用置换算法LRU</font>，熟悉<font color='blue'>Clock置换算法和页面缓冲算法</font>；了解工作集概念。</li></ul><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>前面的存储器管理方式，有一个共同的特点，即要求将一个作业<strong>全部装入内存</strong>才能运行。如果有的作业很大，其所要求的内存空间超过了内存总容量，作业就不能全部被装入内存，致使该作业无法运行；有时大量作业要求运行，但由于内存容量不足以容纳所有这些作业，只能将少数作业装入内存让它们先运行，而将其它大量的作业留在外存上等待。<br>显而易见的一种解决方法，是从物理上增加内存容量，但这往往会受到机器自身的限制，而且增加了系统成本。<br>另一种方法是从<strong>逻辑上扩充内存容量</strong>，这正是虚拟存储技术所要解决的主要问题。 </p><h4 id="虚拟存储的优点"><a href="#虚拟存储的优点" class="headerlink" title="虚拟存储的优点"></a>虚拟存储的优点</h4><ul><li>内存中可以容纳更多的进程  <ul><li>每个进程只有<strong>一部分</strong>的数据块读入内存，其他数据块仍保存在磁盘上</li><li>内存可以<strong>容纳更多的进程</strong>，并发性得到更大的提高，从而也使得处理器得到了更有效的利用</li></ul></li><li>进程可以比主存的全部空间还大<ul><li>实存 (Real memory)：内存</li><li>虚存 (Virtual memory)：磁盘的存储空间</li></ul></li></ul><h3 id="虚拟存储器理论基础"><a href="#虚拟存储器理论基础" class="headerlink" title="虚拟存储器理论基础"></a><font color='orange'>虚拟存储器理论基础</font></h3><h4 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h4><p>程序在执行时将呈现出局部性规律，即在一段时间内，程序的执行仅局限于某个部分；相应地，它所访问的存储空间也局限于某个区域内。</p><ul><li>时间局部性<br>如果程序中的某条指令一旦执行，则不久的将来该指令可能再次被执行；如果某个存储单元被访问，则不久以后该存储单元可能再次被访问。产生时间局限性的典型原因是在程序中存在着大量的<strong>循环</strong>操作。</li><li>空间局部性<br>一旦程序访问了某个存储单元，则在不久的将来，其附近的存储单元也最有可能被访问。 即程序在一段时间内所访问的地址，可能集中在一定的范围内，其典型原因是程序是<strong>顺序执行</strong>的。<br>局部性原理确保了虚拟存储机制的可行性。但利用局部性原理的同时，要避免系统出现抖动现象（thrashing），即处理器大部分时间都用于交换块，而不是执行指令。</li></ul><h4 id="软硬件支撑"><a href="#软硬件支撑" class="headerlink" title="软硬件支撑"></a>软硬件支撑</h4><h5 id="硬件支撑"><a href="#硬件支撑" class="headerlink" title="硬件支撑"></a>硬件支撑</h5><ul><li>有相当容量的辅存（磁盘）以存放所有并发作业的地址空间</li><li>有一定容量的内存来存放运行作业的部分程序</li><li>有支持分页或分段的硬件<ul><li>请求分页系统和请求分段系统</li><li>动态地址转换机构</li></ul></li></ul><h5 id="软件支撑"><a href="#软件支撑" class="headerlink" title="软件支撑"></a>软件支撑</h5><ul><li>操作系统能提供页或段在主存和辅存之间有效交换的管理模块</li></ul><h4 id="特征-1"><a href="#特征-1" class="headerlink" title="特征"></a>特征</h4><ul><li>离散性<br>指在内存分配时采用离散的分配方式，它是虚拟存储器的<strong>最基本</strong>的特征。</li><li>多次性<br>指一个作业被分成多次调入内存运行，即在作业运行时没有必要将其全部装入，只须将当前要运行的那部分程序和数据装入内存即可。多次性是虚拟存储器<strong>最重要</strong>的特征。</li><li>对换性<br>指允许在作业的运行过程中在内存和外存的对换区之间换进、换出。</li><li>虚拟性<br>指能够从逻辑上扩充内存容量，使用户所看到的内存容量远大于实际内存容量。</li></ul><h3 id="请求分页"><a href="#请求分页" class="headerlink" title="请求分页"></a><font color='orange'>请求分页</font></h3><p>请求分页存储管理系统是在纯分页系统的基础上，增加了<strong>请求调页</strong>功能、<strong>页面置换</strong>功能所形成的页式虚拟存储系统，它是目前常用的一种虚拟存储器的方式。<br>它允许只装入若干页(而非全部页)的用户程序和数据，便可启动运行。以后，再通过调页功能及页面置换功能，陆续地把即将要运行的页面调入内存，同时把暂不运行的页面换出到外存上，置换时以页面为单位。  </p><h4 id="硬件支持"><a href="#硬件支持" class="headerlink" title="硬件支持"></a>硬件支持</h4><h5 id="页表-1"><a href="#页表-1" class="headerlink" title="页表"></a>页表</h5><p><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/97ca00b8-5137-4724-90a3-7497e27a315f_repeat_1700459348613__844897.png" alt="image.png"><br>其中各字段说明如下：  </p><ul><li>状态位（中断位P）：用于指示该页<strong>是否已调入内存</strong>，供程序访问时参考。</li><li>访问字段A：用于记录本页在一段时间内被访问的次数，或最近已有多长时间未被访问，提供给置换算法选择换出页面时参考。</li><li>修改位M：表示该页在调入内存后是否被修改过。由于内存中的每一页都在外存上保留一份副本，因此，若未被修改，在置换该页时就不需将该页写回到外存上，以减少系统的开销和启动磁盘的次数；若已被修改，则必须将该页重写到外存上，以保证外存中所保留的始终是最新副本。</li><li>外存(辅存)地址：用于指出该页在外存上的地址，通常是物理块号，供调入该页时使用</li></ul><h5 id="缺页中断"><a href="#缺页中断" class="headerlink" title="缺页中断"></a>缺页中断</h5><p>在请求分页系统中，每当所要访问的页面不在内存时，便要产生缺页中断，请求OS将所缺页调入内存。</p><h4 id="请求分页带来的问题"><a href="#请求分页带来的问题" class="headerlink" title="请求分页带来的问题"></a>请求分页带来的问题</h4><ul><li>每个进程都有一个页表，页表保存在哪里？<br>一个2GB (2^31^ )的进程，如果页大小为512B(2^9^) ，则需要的页表项为2^22^<br>页表占据了大量的空间，应该保存在虚存上，可使用<strong>多级页表</strong>结构</li><li>每个虚存访问会引起<strong>两次</strong>物理内存访问，导致存储器访问时间加倍<br>第一次取相应的页表项，第二次取需要数据。<br>可使用<strong>快表</strong>机制来解决</li></ul><h4 id="快表-Translation-Lookaside-Buffer，TLB）"><a href="#快表-Translation-Lookaside-Buffer，TLB）" class="headerlink" title="快表(Translation Lookaside Buffer，TLB）"></a>快表(Translation Lookaside Buffer，TLB）</h4><p>为了提高地址变换的速度，增设了一个具有按内容查找、并行查询功能的特殊的<strong>高速缓冲存储器</strong>，称为 “快表”，或称为“关联存储器(TLB, 转换后备缓冲器)”，用以存放当前访问的那些页表项，每个页表项包括<strong>页号和相应的块号</strong>（页号不能省略）。<br>引入快表之后的存储访问修改如下：  </p><ul><li>处理器首先将逻辑地址中的页号与TLB中的各页表项的页号进行比较</li><li>如果有相同的 (TLB命中)， 则直接从TLB的输出寄存器输出相应的块号</li><li>如果没有找到(TLB不命中) ，则访问内存从该进程的页表中查找</li><li>检查该页是否在内存中(检查P位) 。如果不在，则发生缺页中断</li><li>页访问之后，++同时要将该页的页表项读入TLB++</li></ul><h4 id="例-2"><a href="#例-2" class="headerlink" title="例"></a>例</h4><p><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/4c69bf10-9885-46e8-a99d-ffa1ca04f2e4_repeat_1700459351096__291351.png" alt="image.png"><br><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/43c6d03f-f094-4dfe-bde7-a157d2f1a7b1_repeat_1700459526149__252103.png" alt="image.png"></p><h3 id="段页式存储"><a href="#段页式存储" class="headerlink" title="段页式存储"></a><font color='orange'>段页式存储</font></h3><p><strong>将内存空间划分成大小相同的若干个块，将用户程序先按逻辑完整性分为若干个段</strong>，并为每个段赋予一个段名，再把<strong>每个段划分成若干个与块大小相同的页</strong>，将这些页离散装入不相邻接的块中。<br>段页式系统中的地址结构由段号、段内页号和页内地址三部分组成。<br><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/fcbba89a-5d4d-4431-b5b8-7072cd02a7fb_repeat_1700459356211__143176.png" alt="image.png"><br>在段页式系统中，为了实现从逻辑地址到物理地址的变换，系统中必需同时配置段表和页表。由于将段中的页进行离散地分配，<strong>段表中的内容不再是段的内存始址和段长，而是页表始址和页表长度</strong>。</p><h4 id="地址变换-2"><a href="#地址变换-2" class="headerlink" title="地址变换"></a>地址变换</h4><ol><li>系统将逻辑地址截成段号S、段内页号P与页内地址W，先用段号S与段长TL（存在段表寄存器中）进行比较。若 S≥TL，表示段号太大，访问越界，于是产生越界中断信号；</li><li>若S＜TL，表示未越界，于是利用段表始址（存在段表寄存器中）和段号求出该段对应的段表项在段表中的位置，从中得到该段的页表始址；</li><li>利用逻辑地址中的段内页号P来获得对应页的页表项在页表中位置，判断状态P位，若P位为0表示该页不在内存中，产生缺页中断；</li><li>若P位为1，则从中读出该页所在的物理块号b，再用块号b和页内地址W拼成物理地址。</li></ol><ul><li>段页式系统中，为了获得一条指令或数据，需要访问几次内存？<br>需访问三次内存：<br>第一次访问内存中的段表，从中取得页表始址；<br>第二次访问内存中的页表，从中取出该页所在的物理块号，并将该块号与页内地址一起形成指令或数据的物理地址；<br>第三次访问才是真正根据所得的物理地址取出指令或数据。  <ul><li>如何提高速度？<br>在地址变换机构中增设一高速缓冲寄存器（如TLB），记录最近访问过的地址信息。每次访问它时，都同时利用段号和页号去检索高速缓存。</li></ul></li></ul><h3 id="替换策略"><a href="#替换策略" class="headerlink" title="替换策略"></a><font color='red'>替换策略</font></h3><ul><li>读取一个新页时，应该替换内存中的哪一页?<br>在进程运行过程中，如果发生缺页，此时内存中又无空闲块时，为了保证进程能正常运行，就必须从内存中调出一页到磁盘。<br>页面置换算法的性能指标：<strong>缺页率（ page fault rate ）&#x3D;“缺页次数 &#x2F; 内存访问次数” (比率)</strong></li></ul><h4 id="最佳替换（OPT）"><a href="#最佳替换（OPT）" class="headerlink" title="最佳替换（OPT）"></a>最佳替换（OPT）</h4><p><strong>选择那些永不使用的，或者是在最长时间内不再被访问的页面置换出去。</strong><br>它是一种理想化的算法，性能最好，但在实际上难于实现。<br><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/0c5ad9f3-a5ee-4f99-bd74-94e826266136_repeat_1700459358690__752195.png" alt="image.png"></p><h4 id="先进先出（FIFO）"><a href="#先进先出（FIFO）" class="headerlink" title="先进先出（FIFO）"></a>先进先出（FIFO）</h4><p>总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面予以淘汰。<br>是一种最直观的算法，但性能最差，有<strong>Belady异常</strong>现象。<br><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/2519d0a1-57e7-4676-bb99-956d8043c9c7_repeat_1700459531928__256827.png" alt="image.png"></p><h5 id="Belady现象"><a href="#Belady现象" class="headerlink" title="Belady现象"></a>Belady现象</h5><p>采用FIFO算法时，如果对一个进程未分配它所要求的全部页面，有时就会出现<strong>分配的页面数增多，缺页率反而提高的异常现象</strong>。<br>对页面访问序列A B C D A B E A B C D E ，分配3块物理块时，缺页次数为9次；分配4块物理块时，缺页次数反而为10次。<br>原因在于++刚换出去的页马上又被访问到++。 </p><h4 id="最近最久未使用（Least-Recently-Used，LRU）"><a href="#最近最久未使用（Least-Recently-Used，LRU）" class="headerlink" title="最近最久未使用（Least Recently Used，LRU）"></a>最近最久未使用（Least Recently Used，LRU）</h4><p>该算法是选择<strong>最近最久未使用</strong>的页面予以淘汰，这是局部性原理的合理近似，性能<strong>接近最佳</strong>算法。<br>但由于需要记录页面使用时间的先后关系，硬件开销太大。系统在每个页面设置一个访问字段，用以记录这个页面自上次被访问以来所经历的时间T，当要淘汰一个页面时，选择T最大的页面。但在实现时需要硬件的支持（寄存器或栈）。<br><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/caf33a80-2ed6-4df7-8916-7e315fe84bc0_repeat_1700459362384__409531.png" alt="image.png"></p><h4 id="Clock置换"><a href="#Clock置换" class="headerlink" title="Clock置换"></a><font color='blue'>Clock置换</font></h4><p>Clock置换算法是一种LRU的近似算法。该算法为每个页面设置一位<strong>访问位</strong>，将内存中的所有页面都通过链接指针链成一个<strong>循环队列</strong>，并设置一个<strong>循环替换指针</strong>，指向当前被置换页所在块。<br><strong>当页第一次读入内存时，其访问位为1；当某页被访问时，其访问位置1</strong>。<br>在选择一页淘汰时，沿循环替换指针检查页面，如其<strong>访问位是“0”，就选择该页换出；若为“1”，则重新置为“0”，暂不换出该页，在循环队列中检查下一个页面，直到访问位为“0”的页面为止</strong>。<br>由于该算法只有一位访问位，只能用它表示该页是否已经使用过，而置换时是将未使用过的页面换出去，所以把该算法称为最近未用算法NRC（Not Recently Used），又称第二次机会算法。<br><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/ed68301c-5f14-443b-893b-65f520b0adc6_repeat_1700459364712__065924.png" alt="image.png"></p><h3 id="例-3"><a href="#例-3" class="headerlink" title="例"></a>例</h3><h4 id="例1"><a href="#例1" class="headerlink" title="例1"></a>例1</h4><p><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/01d20b96-e391-40e6-af4b-3de0b1477ce3_repeat_1700459368605__015389.png" alt="image.png"><br><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/22ad2d00-64e2-4318-a222-09104a57b6c0_repeat_1700459370445__892849.png" alt="image.png"><br><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/697e0f9f-80b7-449c-98f2-c6689ae1f977_repeat_1700459390247__010186.png" alt="image.png"><br><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/cd5b4d5a-fbaa-40da-a156-898c3579bcc4_repeat_1700459538857__293361.png" alt="image.png"><br><img src="http://oss.ripplesu.top/blog/Typora/7730d39f-a7da-4f6a-8719-b3014da70abb.png" alt="image.png"></p><h4 id="例2"><a href="#例2" class="headerlink" title="例2"></a>例2</h4><p><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/114fe841-c52b-42c3-a151-e06e7754517f_repeat_1700459396946__240115.png" alt="image.png"><br>驻留集：操作系统为进程分配的物理页框的集合（驻留在内存中）<br><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/4297c7c2-0ad2-4db1-a0e9-6241a7e3d4e1_repeat_1700459558415__931007.png" alt="image.png"></p><h1 id="单处理器调度"><a href="#单处理器调度" class="headerlink" title="单处理器调度"></a>单处理器调度</h1><h3 id="调度分类"><a href="#调度分类" class="headerlink" title="调度分类"></a>调度分类</h3><ul><li>长程调度<br><strong>决定哪一个程序可以进入到系统中被处理</strong>；<br>一个进程终止时可以执行该调度，选择某个程序加入到就绪队列或就绪&#x2F;挂起队列中，供短程调度或中程调度处理。</li><li>中程调度<br><strong>对换功能（内存管理）</strong>。<br>目的是为了提高主存利用率和系统吞吐量。<br>为了充分发挥内存的效能，需将那些暂时不能运行的进程从内存调到外存盘交换区去等待，而将那些在盘交换区的等待事件已经发生急需调度运行的进程从盘交换区调入内存。<br>有时内存中进程数目过多也需将处于就绪态的进程从内存调到盘交换区，当然在盘交换区等待时间过长的就绪态的进程也要调入内存。 </li><li>短程调度<br>通常称为分派程序，决定将处理器分配给哪个就绪进程。执行得最频繁，是最基本的调度，任何操作系统都有短程调度&#x2F;进程调度。<br>可由以下事件激发：  <ul><li>时钟中断</li><li>I&#x2F;O 中断</li><li>操作系统调用</li><li>信号<br><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/571f18da-1c29-451a-ad2a-f7eb43264cfa_repeat_1700459404670__341102.png" alt="image.png"></li></ul></li></ul><h3 id="调度方式的选择准则"><a href="#调度方式的选择准则" class="headerlink" title="调度方式的选择准则"></a>调度方式的选择准则</h3><h4 id="面向用户-User-oriented-的准则和评价"><a href="#面向用户-User-oriented-的准则和评价" class="headerlink" title="面向用户(User-oriented)的准则和评价"></a>面向用户(User-oriented)的准则和评价</h4><ul><li>周转时间(Turnaround Time)短<br>它是评价批处理系统的重要性能指标。作业周转时间Ti是指从<strong>作业提交给系统开始，到作业完成为止的这段时间间隔</strong>。<br><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/e4570ac3-76eb-454e-9ebc-86c38d76c78c_repeat_1700459407877__243925.png" alt="image.png"></li><li>响应时间(Response Time)快<br>响应时间是评价分时系统的性能指标。响应时间是从<strong>用户通过键盘提交一个请求开始，直至系统首次产生响应为止的时间</strong>。  </li><li>截止时间(Deadline)的保证<br>它是用来评价实时系统的重要指标，截止时间是某任务必须执行的最迟时间，或完成的最迟时间。</li><li>优先权(Enforcing Priorities)准则<br>在选择批处理、分时和实时系统的调度算法时，都可引用优先权准则，以便让那些紧急的作业（或事件），得到及时的处理。在要求较严格的场合，往往还需选择抢占调度方式，才能保证紧急作业得到及时的处理。</li></ul><h4 id="面向系统-System-oriented-的准则"><a href="#面向系统-System-oriented-的准则" class="headerlink" title="面向系统(System-oriented)的准则"></a>面向系统(System-oriented)的准则</h4><ul><li>达到系统设计目标<br>  系统的设计目标是选择算法的主要依据。例如批处理系统所追求的是充分发挥和提高计算机的效率，分时系统则侧重于保护用户的请求及时给予响应，实时系统所关心的是不要丢失实时信息并给予处理。</li><li>系统吞吐量(throughput)大<br>  这是用来评价批处理系统的重要指标。系统吞吐量是<strong>单位时间内完成的作业数</strong>，它与批处理作业的平均长度具有密切关系。</li><li>处理机利用率(Processor Utilization)高<br>  对于大中型多用户系统，由于CPU价格十分昂贵，所以处理机利用率成为衡量大、中型系统性能的十分重要指标，但对单用户微机或某些实时系统，该准则就不那么重要。</li><li>各类资源的平衡利用(Balancing Resources)<br>  在大中型系统中，有效地利用各类资源（包括CPU、外存、I&#x2F;O设备等）也是一个重要指标，对于微型机和某些实时系统，该准则也不重要。</li></ul><h3 id="调度策略"><a href="#调度策略" class="headerlink" title="调度策略"></a>调度策略</h3><ul><li>选择函数决定在就绪进程中选择哪一个进程分配处理机执行。可基于优先级、资源需求或进程的执行特性选择。  <ul><li>w&#x3D;等待的时间  </li><li>e&#x3D;到目前为止，花费的执行时间  </li><li>s&#x3D;进程所需的总服务时间，包括e</li></ul></li><li>决策模式说明选择函数在被执行的瞬间的处理方式  <ul><li>非抢占：进程一旦运行则不断执行直到终止或自己阻塞自己  </li><li>抢占：操作系统可打断正在执行的进程将其转移到就绪态</li></ul></li></ul><h4 id="先来先服务-First-Come-First-Served-FCFS"><a href="#先来先服务-First-Come-First-Served-FCFS" class="headerlink" title="先来先服务 (First-Come-First-Served, FCFS)"></a>先来先服务 (First-Come-First-Served, FCFS)</h4><p>当前正在运行的进程停止执行时，选择在<strong>就绪队列中存在时间最长</strong>的进程运行。</p><ul><li>非抢占模式</li><li>选择函数为max(w)</li><li>特点<ul><li>算法易于实现，表面上很公平</li><li>有利于长进程，对短进程不利，短进程可能需要等待较长时间才能运行</li><li>有利于受CPU限制的进程，不利于受I&#x2F;O限制的进程</li><li>I&#x2F;O限制的进程会经常阻塞在I&#x2F;O事件上，因此需要等待较长的时间</li><li>可与优先级调度算法相结合</li><li>缺点：平均周转时间长</li></ul></li></ul><h4 id="时间片轮转-Round-Robin-RR"><a href="#时间片轮转-Round-Robin-RR" class="headerlink" title="时间片轮转 (Round-Robin, RR)"></a>时间片轮转 (Round-Robin, RR)</h4><p>总是选择<strong>就绪队列中第一个进程</strong>，允许其占有处理机一个时间片的时间。当执行的时间片用完时，调度程序便停止该进程的执行，并将它送到就绪队列的末尾，等待分配下一时间片再执行。然后把处理机分配给就绪队列中新的队首进程，同时也让它执行一个时间片。</p><ul><li>采用基于时间片的<strong>抢占</strong>模式</li><li>周期性地发生时钟中断，使操作系统获得控制权</li><li>每次就绪进程的选择都基于FCFS策略</li><li>时间片的大小决定了每个进程每次所能占用处理器的时间，其值对性能有影响。<ul><li>如果时间片太大，大到每个进程都能在该时间片内执行完毕，则RR算法已退化为FCFS调度算法</li><li>如果时间片过小，在一个时间片内切换开销相对增加，一个进程要花费更多的时间片才能运行结束，一个进程在系统中的周转时间大大增长。</li></ul></li></ul><h4 id="最短进程优先-Shortest-Process-Next-，SPN"><a href="#最短进程优先-Shortest-Process-Next-，SPN" class="headerlink" title="最短进程优先(Shortest Process Next ，SPN)"></a>最短进程优先(Shortest Process Next ，SPN)</h4><p>在就绪队列中选择<strong>所需服务时间最短</strong>的进程。</p><ul><li>非抢占模式</li><li>选择函数为min(s)</li><li>有利于短进程，对长进程不利<ul><li>短进程将越过长进程，跳到就绪队列头被调度</li><li>如果不断地有短进程进入系统，长进程可能会饿死。这一算法有利于短作业，对长作业不利。</li></ul></li><li>需要估计每个进程的服务时间，如果估计不准确，系统可能终止该作业</li><li>有利于系统减少平均周转时间和平均带权周转时间</li></ul><h4 id="最短剩余时间优先-Shortest-Remaining-Time-SRT"><a href="#最短剩余时间优先-Shortest-Remaining-Time-SRT" class="headerlink" title="最短剩余时间优先(Shortest Remaining Time,SRT)"></a>最短剩余时间优先(Shortest Remaining Time,SRT)</h4><p>在就绪队列中选择运行<strong>所需剩余时间最短</strong>的进程。</p><ul><li>抢占模式</li><li>选择函数min(s-e) </li><li>需要估计服务时间</li><li>比SPN有更好的周转时间</li></ul><h4 id="最高响应比优先-Highest-Response-Ratio-Next，HRRN"><a href="#最高响应比优先-Highest-Response-Ratio-Next，HRRN" class="headerlink" title="最高响应比优先 (Highest Response Ratio Next，HRRN)"></a>最高响应比优先 (Highest Response Ratio Next，HRRN)</h4><p>在就绪队列中选择响应比最高的进程来调度。</p><ul><li>非抢占模式</li><li>选择函数max(R)&#x3D;<strong>max(1+w&#x2F;s)</strong></li><li>折中策略，综合考虑服务时间和等待时间</li></ul><h4 id="反馈（Feedback）"><a href="#反馈（Feedback）" class="headerlink" title="反馈（Feedback）"></a>反馈（Feedback）</h4><ul><li>原则：处罚运行时间较长的作业。  <ul><li>基于抢占原则（按时间片）并使用动态优先级机制</li><li>新进程进入RQ0，每当它被抢占，则降到下一个优先级队列中</li><li>优先级最低队列采用轮转法，其他队列采用FCFS机制</li></ul></li></ul><h4 id="例-4"><a href="#例-4" class="headerlink" title="例"></a>例</h4><p><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/a0092992-f73d-4d15-afb4-2d0f19d95a36_repeat_1700459411404__312987.png" alt="image.png"><br><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/b987e4e0-ac01-4136-9338-8ce6eb2ba03e_repeat_1700459565398__430447.png" alt="image.png"><br><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/44c412b2-ed38-4941-a7c7-526a71eee3be_repeat_1700459569009__117789.png" alt="image.png"></p><h1 id="IO管理和磁盘调度"><a href="#IO管理和磁盘调度" class="headerlink" title="IO管理和磁盘调度"></a>IO管理和磁盘调度</h1><h3 id="教学要求-2"><a href="#教学要求-2" class="headerlink" title="教学要求"></a>教学要求</h3><ul><li>了解设备的分类，熟悉设备管理的目标和功能。</li><li>熟悉<font color='blue'>程序I&#x2F;O方式、中断方式、DMA方式和通道方式四种I&#x2F;O的控制方式</font>。</li><li>熟悉<font color='blue'>I／O系统的目标—设备独立性的概念</font>；<font color='blue'>熟悉I／O软件分层结构的概念</font>。</li><li>熟悉<font color='blue'>缓冲的概念，熟悉单缓冲、双缓冲和多缓冲和缓冲池工作原理</font>。</li><li>了解磁盘结构、数据组织和磁盘的访问时间等磁盘性能，掌握<font color='orange'>磁盘调度算法</font>。</li><li>了解磁盘高速缓冲的原理。</li></ul><h3 id="IO设备分类"><a href="#IO设备分类" class="headerlink" title="IO设备分类"></a>IO设备分类</h3><ul><li>按传输速率分类<ul><li>低速设备</li><li>中速设备</li><li>高速设备</li></ul></li><li>按信息交换的单位分类<ul><li>块设备：以数据块为单位组织和传送数据</li><li>字符设备：以单个字符为单位</li></ul></li><li>按资源分配的角度分类<ul><li>独占设备</li><li>共享设备</li><li>虚拟设备</li></ul></li></ul><p>I&#x2F;O设备的差异性，使得系统难以找到一种统一且一致的方法管理I&#x2F;O设备。</p><h3 id="设备管理的目标和功能"><a href="#设备管理的目标和功能" class="headerlink" title="设备管理的目标和功能"></a>设备管理的目标和功能</h3><ul><li>目标<ul><li>提高设备利用率</li><li>为用户提供方便、统一的界面</li></ul></li><li>功能<ul><li>设备分配</li><li>缓冲区管理</li><li>实现物理IO设备的操作</li></ul></li></ul><h3 id="IO功能的组织"><a href="#IO功能的组织" class="headerlink" title="IO功能的组织"></a>IO功能的组织</h3><h4 id="控制方式"><a href="#控制方式" class="headerlink" title="控制方式"></a><font color='blue'>控制方式</font></h4><ul><li>程序控制I&#x2F;O (Programmed I&#x2F;O)<br>处理器给I&#x2F;O模块发送I&#x2F;O命令，进程进入忙等待，直到I&#x2F;O操作完成才可以继续执行</li><li>中断驱动I&#x2F;O (Interrupt-driven I&#x2F;O)<br>处理器发送I&#x2F;O命令，然后继续执行后续指令，当I&#x2F;O模块完成后，给处理器发送中断</li><li>直接存储器访问 (Direct Memory Access， DMA)<br>由DMA模块控制主存和I&#x2F;O模块之间的数据交换</li></ul><h4 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h4><ul><li>采用统一的方式处理所有的I&#x2F;O设备<br>隐藏物理I&#x2F;O设备的操作细节，而是提供了逻辑I&#x2F;O层，使用户进程和操作系统软件可以通过读、写、打开、关闭、锁定、解锁等一些通用的功能来看待所有的I&#x2F;O设备。</li><li>采用分层结构，它把软件组织成为一系列的层，低层参与隔离硬件特征，使其它部分软件不依赖硬件；而高层则参与向用户提供一个友好的、清晰而统一的接口。<br>I&#x2F;O软件一般共分四层：中断处理程序（调度和控制），设备驱动程序(设备I&#x2F;O)，与设备无关的操作系统软件（逻辑I&#x2F;O），以及用户级软件(指用户空间的I／O软件) 。</li></ul><h4 id="IO系统目标——设备独立性"><a href="#IO系统目标——设备独立性" class="headerlink" title="IO系统目标——设备独立性"></a><font color='blue'>IO系统目标——设备独立性</font></h4><ul><li>用户程序的设备独立性<br>用户程序不直接使用物理设备名（或设备的物理地址），而只使用逻辑设备名；而系统在实际执行时，将逻辑设备名转换为某个具体的物理设备名，实施I&#x2F;O操作。  </li><li>I&#x2F;O软件的设备独立性<br>除了直接与设备打交道的低层软件之外，其他部分的软件并不依赖于硬件。I&#x2F;O软件独立于设备，就可以提高设备管理软件的设计效率。</li><li>优点<ul><li>设备分配时的灵活性<br>当进程以逻辑设备名请求某类设备时，如果一台设备已经分配给其它进程或正在检修，此时系统可以将其它几台相同的空闲设备中的任一台分配给该进程。 </li><li>易于实现I&#x2F;O重定向<br>所谓I&#x2F;O重定向，指用于I&#x2F;O操作的设备可以更换，应用程序的输入、输出可以重定向，不必修改应用程序。</li></ul></li></ul><h3 id="IO缓冲"><a href="#IO缓冲" class="headerlink" title="IO缓冲"></a><font color='blue'>IO缓冲</font></h3><p>进程被阻塞，等待I&#x2F;O操作完成。速度不匹配的矛盾一直存在。<br>在I&#x2F;O操作期间，包含目标地址单元的页必须锁定在主存中，不能被换出。<br>为了解决低效的问题，往往采用事先读（输入请求发出前就开始执行输入传送）和延迟写（输出请求发出一段时间之后才开始执行输出传送）。缓冲区即用于存放这些临时数据。</p><h4 id="缓冲类型"><a href="#缓冲类型" class="headerlink" title="缓冲类型"></a>缓冲类型</h4><ul><li>硬件缓冲是指以专用的寄存器作为缓冲器。</li><li>软件缓冲是指在操作系统的管理下，在内存中划出若干个单元作为缓冲区。软件缓冲的好处是易于改变缓冲区的大小和数量，但占用了一部分内存空间。<br>根据缓冲区设置个数的多少，可分为<strong>单缓冲、双缓冲和多缓冲</strong>。根据缓冲区的从属关系，可以分为专用缓冲区和缓冲池。</li></ul><h5 id="单缓冲"><a href="#单缓冲" class="headerlink" title="单缓冲"></a>单缓冲</h5><p>为了提高 CPU和设备的并行操作程度，每当一个用户进程发出一个I&#x2F;O请求时，操作系统便在主存的系统区中为之分配一个缓冲区。<br>例如，CPU从磁盘上读-块数据进行计算要分三步:先从磁盘把一块数据读入到缓冲区中，然后由操作系统将缓冲区的数据传送到用户区，最后由CPU对这一块数据进行计算，这样处理一个数据时间为(T+M+C)。<br>当连续读入一组数据时，读入某数据的第一步(输入)和读入它前一个数据的最后一步(计算)是可以并行执行的，这样就提高了CPU和外设的利用率。由于对缓冲区中数据的输入和提取是串行工作的，连续处理一个数据时间&#x3D;<strong>max(C, T) +M</strong>。为使两者能并行工作，必须引入双缓冲。<br><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/dfded469-c980-4437-8f45-66eadbf1badd_repeat_1700459419751__866413.png" alt="image.png"></p><h5 id="双缓冲"><a href="#双缓冲" class="headerlink" title="双缓冲"></a>双缓冲</h5><p>在设备输入时，先将数据输入到缓冲区A，装满后便转向缓冲区B。此时操作系统可以从缓冲区A中提取数据传送到用户区，最后由CPU对数据进行计算。<br>这样可以实现对缓冲区中读入某数据的第一步（输入）和读入它前一个数据的后二步（传送和计算）二者的并行工作，连续处理一个数据时间&#x3D; **max(T，(M+C))**，特别是缓冲区中数据的输入和传送的速度基本相匹配时，可获得较好的效果。<br>双缓冲进一步加快了I&#x2F;O的速度，提高了设备的利用率。<br><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/169cbd2c-9c6f-405b-a3a4-6c9a80daa7b3_repeat_1700459575127__592982.png" alt="image.png"></p><h5 id="循环缓冲"><a href="#循环缓冲" class="headerlink" title="循环缓冲"></a>循环缓冲</h5><p>由于数据I&#x2F;O多数是间断的，可增加缓冲区的个数来改善CPU与I&#x2F;O设备间速度不匹配的矛盾。<br>将多个缓冲区组织成循环队列的形式，其中一些队列专门用于输入，另一些队列专门用于输出。<br>采用生产者&#x2F;消费者模型来解决。<br><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/eba57e27-bfb3-4cfd-bc4b-dc2afc0bb5e4_repeat_1700459424522__956275.png" alt="image.png"></p><h3 id="磁盘IO"><a href="#磁盘IO" class="headerlink" title="磁盘IO"></a>磁盘IO</h3><h4 id="磁盘结构"><a href="#磁盘结构" class="headerlink" title="磁盘结构"></a>磁盘结构</h4><p><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/f505e8ad-8447-47e0-b512-14749d220dac_repeat_1700459427625__651862.png" alt="image.png"></p><h4 id="数据组织"><a href="#数据组织" class="headerlink" title="数据组织"></a>数据组织</h4><p>磁盘设备中，一般包含一个或多个盘片，每片分两面，每面又可分成若干条<strong>磁道</strong>（即n个同心圆）。++最外边的磁道标为0道，最里面的磁道为 n-1道++。磁道的个数取决于盘的大小和存储的密度。每个磁道又被划分为若干个<strong>扇区</strong>，一般被划分成10～100个扇区。每一个扇区是磁盘存储信息和传送信息的基本单位（512字节），又称为存储块，或简称为块。<br>一个容量较大的硬盘含有若干个盘片，每一个盘片有上下两个盘面。如果硬盘中有4个盘片，则共有8个磁面。磁盘中处于相同磁道（同心圆）位置上，但在不同盘面上的磁道的集合，称为<strong>柱面</strong>。++柱面的序号与磁道的序号相同++。</p><h4 id="磁盘访问时间"><a href="#磁盘访问时间" class="headerlink" title="磁盘访问时间"></a>磁盘访问时间</h4><p>由于磁盘上的一个扇区要用三个参数（柱面号、磁头号和扇区号）来定位，所以对磁盘的访问时间，包括以下三部分的时间：</p><ul><li>寻道时间（ Seek time ）T<del>S</del><br>这是把磁头从当前位置移动到指定磁道上所经历的时间。该时间是启动磁盘的时间s与磁头移动n条磁道所花费的时间之和。即 T<del>S</del>＝m×n+s <ul><li>m是一个常数，它与磁盘驱动器的速度有关。对一般磁盘而言，m&#x3D;0.3；对高速磁盘而言，m≤0.1，磁盘启动时间约为3ms。</li><li>这样，对一般的硬盘，其寻道时间将随寻道距离的增大而增大。</li></ul></li><li>旋转延迟时间（ Rotational delay or rotational latency ）T<del>r</del><br>指定扇区移动到磁头下所经历的时间。</li><li>传输时间T<del>t</del><br>T<del>t</del> 是指把数据从磁盘读出，或向磁盘写入数据所经历的时间，它的大小与每次所读／写的字节数b及旋转速度r(&#x2F;秒)有关：T<del>t</del> &#x3D;b&#x2F;(r*N)(N为一条磁道上字节数)。</li></ul><p>磁盘访问时间： Ta&#x3D; TS+ Tr+ Tt&#x3D; TS + 1&#x2F;2r+ b&#x2F;rN</p><h4 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a><font color='orange'>磁盘调度算法</font></h4><h5 id="先来先服务FCFS"><a href="#先来先服务FCFS" class="headerlink" title="先来先服务FCFS"></a>先来先服务FCFS</h5><p>先来先服务FCFS（First Come First Served）是一种最简单的磁盘调度算法。它根据进程请求访问磁盘的先后次序进行调度。  </p><ul><li>优点是公平、简单，且每个进程的请求都能依次得到处理，不会出现某一进程的请求长期得不到满足的情况。</li><li>缺点是算法未对寻道进行优化，致使平均寻道时间可能较长（平均响应时间长）。<br><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/815549c8-2f58-44df-8262-8119c46e6976_repeat_1700459430637__807237.png" alt="image.png"></li></ul><h5 id="最短寻道时间优先（SSTF）"><a href="#最短寻道时间优先（SSTF）" class="headerlink" title="最短寻道时间优先（SSTF）"></a>最短寻道时间优先（SSTF）</h5><p>该算法总是满足那些<strong>与当前磁头所在的磁道距离最近</strong>的请求,也就是执行寻道时间最短的那个I&#x2F;O请求。  </p><ul><li>这种调度算法有较好的平均寻道时间。但它可能导致某些进程长时间的得不到服务（饥饿现象）。因为只要不断有新进程到达，且其所要访问的磁道与磁头当前所在磁道的距离较近，这种新进程的I&#x2F;O请求必被优先满足。</li><li>对中间磁道访问服务比内、外两侧磁道服务好，造成响应时间变化幅度大,在服务请求多时，内外边缘请求被无限期延迟，不可预期。<br><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/41fdb9bc-6d81-49c8-b252-7c63b86bf068_repeat_1700459434283__269597.png" alt="image.png"></li></ul><h5 id="扫描（SCAN）算法"><a href="#扫描（SCAN）算法" class="headerlink" title="扫描（SCAN）算法"></a>扫描（SCAN）算法</h5><p>为了解决SSTF算法饥饿现象，对SSTF算法略加修改后所形成了SCAN算法。  </p><ul><li>该算法不仅考虑到欲访问的磁道与当前磁道的距离，更优先考虑的是磁头的当前移动方向。即当磁头正在自里向外运动时，SCAN算法要选择的下一个访问对象是其欲访问的磁道在<strong>当前磁道之外，又是距离最近的。直至再无更外的磁道需要访问时，才将磁臂换向，自外向里运动</strong>。从而避免了饥饿现象的出现。由于这种算法中磁头移动的规律象电梯的运行，所以又称为电梯调度算法。</li><li>克服SSTF服务集中中间磁道和响应时间变化较大缺点，两侧磁道的访问的频率低于中间磁道。<br><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/9106b34a-182a-4e1c-9d06-a1ac1bd963a1_repeat_1700459437260__843119.png" alt="image.png"></li></ul><h5 id="循环扫描（CSCAN）"><a href="#循环扫描（CSCAN）" class="headerlink" title="循环扫描（CSCAN）"></a>循环扫描（CSCAN）</h5><p>CSCAN算法规定磁头只能<strong>单向运动</strong>（自里向外或自外向里），<strong>当磁头运动到最外面的被访问磁道时，磁头立即返回到最里面的欲访的磁道</strong>，即将最小磁道号紧接着最大磁道号构成循环，进行扫描。<br><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/6ee4a6d7-99c3-40d9-929c-4d81163d9242_repeat_1700459581502__197731.png" alt="image.png"></p><h5 id="算法比较"><a href="#算法比较" class="headerlink" title="算法比较"></a>算法比较</h5><p><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/c6ff42af-7a63-40c9-ab22-a6c7d24e97d2_repeat_1700459441062__990194.png" alt="image.png"></p><h1 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h1><h3 id="教学要求-3"><a href="#教学要求-3" class="headerlink" title="教学要求"></a>教学要求</h3><ul><li>掌握<font color='orange'>文件和文件系统的定义</font>，了解文件系统的类型、文件系统模型。</li><li>掌握<font color='orange'>文件的逻辑结构</font>，熟悉<font color='blue'>五种记录文件</font>。</li><li>掌握<font color='orange'>文件的物理结构及连续分配、链接分配、索引分配等外存分配方法</font>。</li><li>了解磁盘组织，掌握空闲表、位示图法、空闲块链接法等空闲存储空间的管理方法。</li></ul><h3 id="文件与文件系统"><a href="#文件与文件系统" class="headerlink" title="文件与文件系统"></a><font color='orange'>文件与文件系统</font></h3><h4 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h4><p>文件是存储在某种介质上的（如磁盘、磁带等）并<strong>具有文件名的一组有序信息的集合</strong>。</p><ul><li>域&#x2F;数据项（field）<br>数据项是描述一个对象的某些属性的字符集，它是数据的基本单位，一个数据项有一个值。</li><li>记录（record）<br>记录是一组相关数据项的集合，用于描述一个对象某方面的属性</li></ul><h4 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h4><p>文件系统是操作系统中以文件方式管理计算机软件资源的软件和被管理的文件和数据结构（如目录和索引表等）的集合。<br>从系统角度来看，文件系统是对文件存储器的存储空间进行组织、分配和回收，负责文件的存储、检索、共享和保护。<br>从用户角度来看，文件系统主要是实现“按名存取”，文件系统的用户只要知道所需文件的文件名，就可存取文件中的信息，而无需知道这些文件究竟存放在什么地方。 </p><h3 id="文件组织"><a href="#文件组织" class="headerlink" title="文件组织"></a><font color='orange'>文件组织</font></h3><ul><li>文件的逻辑组织和物理组织  <ul><li>逻辑组织指文件中记录的逻辑结构（用户可见结构），由用户访问记录的方式确定。</li><li>物理组织指文件在外存上的存储组织形式，通常取决于记录组块策略和文件分配策略。</li></ul></li><li>逻辑组织从结构上分成二种形式，一种是无结构的<strong>流式文件</strong>，另一种是有结构的<strong>记录式文件</strong>。流式文件是指对文件内信息不再划分单位，它是依次的一串字符流构成的文件。记录式文件是用户把文件内的信息按逻辑上独立的含义划分信息单位，每个单位称为一个逻辑记录（简称记录）。记录的长度可分为定长和不定长两类。</li></ul><h4 id="文件组织类型"><a href="#文件组织类型" class="headerlink" title="文件组织类型"></a><font color='blue'>文件组织类型</font></h4><h5 id="堆（pile）"><a href="#堆（pile）" class="headerlink" title="堆（pile）"></a>堆（pile）</h5><ul><li>最简单的文件组织形式。</li><li>数据按先来后到的次序组织，每个记录由一串数据组成，是串结构的顺序文件。</li><li>每个记录所包含的数据项是自我标识的，记录可以有不同的数据项。数据项的长度可以明确指定或使用界定符区分。</li><li>在堆文件中访问所需要的记录需穷举搜索。</li><li>目的是积累大量数据并保存，不适合大多数应用。</li></ul><h5 id="顺序文件-sequential-file"><a href="#顺序文件-sequential-file" class="headerlink" title="顺序文件 (sequential file)"></a>顺序文件 (sequential file)</h5><ul><li>最常用的文件组织形式。</li><li>记录采用固定格式，所有记录具有相同长度，并且由相同数目、长度固定的数据项按特定的顺序组成。</li><li>一般还有一个可以唯一标识记录的数据项，称为键（key），记录按键值的约定次序组织。</li><li>顺序文件常用于批处理应用，适用于对所有记录的处理，对于查询或更新某个记录的请求的处理性能不佳（需要遍历）。</li></ul><h5 id="索引顺序文件-indexed-sequential-file"><a href="#索引顺序文件-indexed-sequential-file" class="headerlink" title="索引顺序文件 (indexed sequential file)"></a>索引顺序文件 (indexed sequential file)</h5><ul><li>保留了顺序文件的关键特征：记录按照关键域的顺序组织。</li><li>两个新特征：<ul><li>支持随机访问的文件索引</li><li>溢出文件</li></ul></li><li>索引文件中建立一张索引表，为每个不同键值的记录组的第一个记录设置一个表项（关键域和指向主文件的指针），为该组的其它记录设置了溢出区域，在溢出区域内记录按顺序文件方式组织。<br>查找时先搜索索引，查找关键域值等于目标关键域值或位于目标关键域值之前且最大的索引然后在该索引的指针所指的主文件中的位置开始搜索</li><li>索引顺序文件既适用于交互方式应用，也适用于批处理方式应用。<br><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/07614a88-bcd2-4874-84a3-d751624697e0_repeat_1700459443994__377601.png" alt="image.png"><br><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/8e4f713f-6fa8-4e5e-a83a-297c9d039209_repeat_1700459586529__482152.png" alt="image.png"></li></ul><h5 id="索引文件-indexed-file"><a href="#索引文件-indexed-file" class="headerlink" title="索引文件 (indexed file)"></a>索引文件 (indexed file)</h5><ul><li>可基于多个数据项建立索引<ul><li>完全索引：包含主文件中每条记录的索引项</li><li>部分索引：包含部分记录的索引项</li></ul></li><li>记录可为不定长的，只通过索引访问记录，不再限制记录的放置位置</li><li>为了易于搜索，索引文件本身是顺序文件组织</li><li>当主文件中增加了一条新记录，索引文件必须全部更新</li><li>常用于实时处理环境中</li></ul><h5 id="直接或散列文件-direct-or-hashed-file"><a href="#直接或散列文件-direct-or-hashed-file" class="headerlink" title="直接或散列文件 (direct, or hashed, file)"></a>直接或散列文件 (direct, or hashed, file)</h5><ul><li>检索时给出记录编号（关键域），通过哈希函数（散列函数）计算出该记录在文件中的相对位置。</li><li>可以对记录在直接访问存储设备上的物理地址直接（随机）访问。</li><li>使用固定长度的记录格式，每次只访问一条记录。</li><li>常用于需要高速访问文件且每次访问一条记录的应用中。</li></ul><h3 id="记录组块"><a href="#记录组块" class="headerlink" title="记录组块"></a><font color='orange'>记录组块</font></h3><h4 id="固定组块-Fixed-blocking"><a href="#固定组块-Fixed-blocking" class="headerlink" title="固定组块 (Fixed blocking)"></a>固定组块 (Fixed blocking)</h4><ul><li>记录长度固定；</li><li>若干条完整的记录被保存在一个块中；</li><li>存在内部碎片。<br><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/a5fc242d-b77f-4e99-86fe-7eb68179dcec_repeat_1700459449072__192308.png" alt="image.png"></li></ul><h4 id="可变长度跨越式组块-Variable-length-spanned-blocking"><a href="#可变长度跨越式组块-Variable-length-spanned-blocking" class="headerlink" title="可变长度跨越式组块 (Variable-length spanned blocking)"></a>可变长度跨越式组块 (Variable-length spanned blocking)</h4><ul><li>记录长度可变</li><li>紧缩在块中，解决了内部碎片问题 </li><li>某些记录可能跨两个块，通过指针指向后继块<br><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/e2c417ad-cc00-44ac-9d5f-748199f74cac_repeat_1700459591144__240587.png" alt="image.png"></li></ul><h4 id="可变长度非跨越式组块-Variable-length-unspanned-blocking"><a href="#可变长度非跨越式组块-Variable-length-unspanned-blocking" class="headerlink" title="可变长度非跨越式组块 (Variable-length unspanned blocking)"></a>可变长度非跨越式组块 (Variable-length unspanned blocking)</h4><ul><li>记录长度可变</li><li>记录不跨块，存在内部碎片问题<br><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/56ff45ee-be55-4407-8589-c14e1a0caff6_repeat_1700459452587__791917.png" alt="image.png"></li></ul><h4 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h4><ul><li>固定组块是记录长度固定的顺序文件最常用的格式</li><li>可变长度跨越式组块存储效率高，但难于实现</li><li>可变长度非跨越式组块会导致空间的浪费，并且记录大小受块大小限制</li></ul><h3 id="文件分配"><a href="#文件分配" class="headerlink" title="文件分配"></a><font color='orange'>文件分配</font></h3><ul><li>预分配要求在发出创建文件请求时声明该文件的最大大小<ul><li>文件大小难以估计，通常都会多估一点，从而导致空间浪费问题</li></ul></li><li>动态分配只有在需要时才给文件分配空间</li></ul><h4 id="连续分配（Contiguous-allocation）"><a href="#连续分配（Contiguous-allocation）" class="headerlink" title="连续分配（Contiguous allocation）"></a>连续分配（Contiguous allocation）</h4><ul><li>创建文件时，给文件分配一组连续的块</li><li>预分配策略，分区大小可变</li><li>文件分配表FAT中每个文件只需要一个表项：起始块和文件长度</li><li>存在外部碎片，需定期执行压缩技术<br><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/dfe8ce42-2ccf-4e7e-8fa3-3702f6a1fa4c_repeat_1700459458454__214221.png" alt="image.png"></li></ul><h4 id="链式分配"><a href="#链式分配" class="headerlink" title="链式分配"></a>链式分配</h4><ul><li>基于单个块进行分配，链中每一块都包含指向下一块的指针</li><li>动态分配：按需进行块分配</li><li>FAT表中每个文件一个表项：起始块和文件长度</li><li>优点是盘存储空间利用率高，文件增删改记录方便，不存在外部碎片</li><li>局部性原理不再适用，可周期性地对文件进行合并<br><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/eec36d3b-1676-4be4-9e79-30d3efe8d6a4_repeat_1700459464367__923883.png" alt="image.png"><br><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/0dbaaf48-b076-499b-bd83-a3f1a87e591a_repeat_1700459461916__163047.png" alt="image.png"></li></ul><h4 id="索引分配"><a href="#索引分配" class="headerlink" title="索引分配"></a>索引分配</h4><ul><li>文件分配表FAT中对每个文件都包含一个一级索引</li><li>文件索引保存在单独块中，在FAT的表项里指向这一块的值</li><li>分配可基于固定大小的块，也可基于可变大小的分区</li><li>索引块中包括指向文件所有块的指针或指向分区起始块的指针</li><li>支持顺序访问文件和直接访问文件，是最普遍的一种文件分配形式<br><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/f48ce965-95b1-42be-b187-89417f80031b_repeat_1700459467753__246435_repeat_1700459469416__739465.png" alt="image.png"><br><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/f50ec86f-d7c4-4ae9-bbdb-7ebbaf64bc44_repeat_1700459597523__113748.png" alt="image.png"></li></ul><h3 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h3><h4 id="1"><a href="#1" class="headerlink" title="1"></a>1</h4><p>文件系统空间的最大容量为4GB，以磁盘块为分配单位。磁盘块大小为4KB。文件控制块FCB包含一个1KB的索引表区。<br>假设索引表区仅采用直接索引结构，索引表区存放文件占用的磁盘块号，索引表项中块号最少占多少字节？可支持的单个文件的最大长度是多少字节？  </p><p>答：<br>磁盘个数：4GB&#x2F;4KB&#x3D;220个，因此索引表项中块号需要20位，共占20&#x2F;8&#x3D;3B<br>索引表区大小为1KB，故包含1KB&#x2F;3B&#x3D;342个索引项<br>单个文件的最大长度是342*4KB&#x3D;1368KB</p><h4 id="2"><a href="#2" class="headerlink" title="2"></a>2</h4><p>请分别解释在连续分配方式、隐式链接分配方式、显式链接分配方式和索引分配方式中如何将文件的字节偏移量3500转换为物理块号和块内位移量（设盘块大小为1KB，盘块号需4个字节。）<br>提示：先将字节偏移量转换成逻辑块号和块内位移量。  </p><p>答：<br><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/48208609-3e5b-415d-8177-51c69f110968_repeat_1700459472479__479126_repeat_1700459474305__424436.png" alt="image.png"><br><img src="http://oss.ripplesu.top/blog/Typora/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/9336f4a4-b3b7-47a2-8fc4-40c37c4066b3_repeat_1700459602416__758791.png" alt="image.png"></p><h4 id="3"><a href="#3" class="headerlink" title="3"></a>3</h4><p>存放在某个磁盘上的文件系统，采用混合索引分配方式，其FCB中共有13个地址项，第0~9个地址项为直接地址，第10个地址项为一次间接地址，第11个地址项为二次间接地址，第12个地址项三次间接地址。如果每个盘块的大小512字节，若盘块号需要用3个字节来描述，而每个盘块最多存放170个盘块地址。  </p><ul><li>该文件系统允许文件的最大长度是多少？</li><li>将文件的字节偏移量5000，15000，150000转换为物理块号和块内偏移量。</li><li>假设某个文件FCB已在内存，但其他信息均在外存，为了访问该文件中某个位置的内容，最少需要几次访问磁盘，最多需要几次访问磁盘？</li></ul><p>答：  </p><ol><li>盘块数：10+170+170×170+170×170×170&#x3D;4942080（块）<br> 4942080×512&#x3D;2471040KB  </li><li>5000&#x2F;512&#x3D;9……392  由于9&lt;10，可直接从FCB的第9个地址项得到物理盘块号，块内偏移量为392。<br>15000&#x2F;512&#x3D;29……152，由于10&lt;&#x3D;29&lt;10+170,而29-10&#x3D;19，故可从FCB的第10个地址项获得一次间址块的盘块号，并从一次间址块的第19项获得对应的物理盘块号，块内偏移量为152。<br>150000&#x2F;512&#x3D;292……496，10+170&lt;&#x3D;292&lt;10+170+170×170<br>292-（10+170）&#x3D;112<br>112&#x2F;170&#x3D;0……112<br>从FCB的第11个地址项，即二次间址项中得到二次间址块的地址，并从二次间址块的第0项中获得一个一次间址块的地址，再从一次间址块的第112项中获得对应的物理盘块号，块内偏移量为496。  </li><li>文件FCB已在内存，要访问该文件中某个位置的内容，最少需要1次访问磁盘（通过直接地址直接读文件盘块），最多需要4次访问磁盘（第一次读三次间址块，第二次读二次间址块，第三次读一次间址块，第四次读文件盘块。）</li></ol><h4 id="4"><a href="#4" class="headerlink" title="4"></a>4</h4><p>文件F由200条记录组成，记录从1开始编号。用户打开文件后，欲将内存中的一条记录插入文件F中，作为其第30条记录。请回答下列问题，并说明理由。</p><ul><li>若文件系统采用连续分配方式，每个磁盘块存放一条记录，文件F存储区域前后均有足够的空闲磁盘空间，则完成上述插入操作最少需要访问多少次磁盘块？F的文件控制块内容会发生哪些改变？</li><li>若文件系统采用链接分配方式，每个磁盘块存放一条记录和一个链接指针，则完成上述插入操作需要访问多少次磁盘块？</li></ul><p>答：<br>1）文件系统采用连续分配方式，插入记录需要移动其他的记录块，整个文件共有200条记录，要插入新记录作为第30条，则需要把前29条记录前移，访盘次数为29*2&#x3D;58次（一次读，一次写回），存回第30条记录，需要1次访盘，共访盘59次。<br>2）文件系统采用链接分配方式，插入记录不需要移动其他记录块，只需要通过指针找到第30条记录插入的位置，故共需访盘次数为29次，存第30条记录，需要1次访盘，再修改第29条记录的下块地址，需要1次访盘。因此，访盘总次数为29+1+1&#x3D;31次。</p>]]></content>
      
      
      <categories>
          
          <category> 学习总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件工程复习</title>
      <link href="/2023/02/07/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%A4%8D%E4%B9%A0/"/>
      <url>/2023/02/07/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="软件工程概述"><a href="#软件工程概述" class="headerlink" title="软件工程概述"></a>软件工程概述</h2><p>软件：程序+数据+文档<br>软件特点：</p><ul><li>软件本身的复杂性</li><li>软件成本高昂</li><li>软件开发未摆脱手工开发的方式</li><li>软件维护与硬件有本质差别，维护难度高</li><li>软件是逻辑实体，无磨损性</li></ul><h3 id="软件危机"><a href="#软件危机" class="headerlink" title="软件危机"></a>软件危机</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>软件危机是指在计算机软件<strong>开发</strong>和<strong>维护</strong>过程中所遇到的一系列严重问题。<br>概括来说主要包括<strong>两方面</strong>：</p><ul><li>如何开发软件，以满足对软件日益增长的需求；</li><li>如何维护数量不断膨胀的已有软件。</li></ul><h4 id="典型表现"><a href="#典型表现" class="headerlink" title="典型表现"></a>典型表现</h4><ul><li>对软件开发成本和进度估计不准</li><li>用户对已完成的软件不满意</li><li>软件质量靠不住</li><li>软件没有适当的文档资料</li><li>软件成本在计算机系统总成本中所占的比例逐年上升</li><li>软件开发生产率提高的速度比不上计算机应用普及的趋势（供不应求）</li></ul><h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><h5 id="主观原因"><a href="#主观原因" class="headerlink" title="主观原因"></a>主观原因</h5><ul><li>忽视需求分析</li><li>轻视软件维护</li><li>没有认识到程序只是软件的一部分（程序、文档、数据）</li><li>没有认识到软件开发只是漫长软件生命周期中的一个比较次要的阶段（工作量占比较小）</li><li>越到后期引入变动付出的代价越高昂</li></ul><h5 id="客观原因"><a href="#客观原因" class="headerlink" title="客观原因"></a>客观原因</h5><ul><li>软件是逻辑实体，缺乏可见性，管理和控制困难</li><li>软件不会磨损，维护意味着修改原来设计，维护困难</li><li>软件规模庞大，程序复杂性随规模增加指数上升</li></ul><h4 id="消除软件危机的途径"><a href="#消除软件危机的途径" class="headerlink" title="消除软件危机的途径"></a>消除软件危机的途径</h4><ul><li>对计算机软件应该有正确的认识</li><li>吸取借鉴人类长期从事各种工程项目积累的原理、概念、技术和方法</li><li>积极开发和使用计算机辅助开发工具</li><li>探索更有效的管理措施对开发过程进行控制和管理</li></ul><h3 id="软件工程"><a href="#软件工程" class="headerlink" title="软件工程"></a>软件工程</h3><p>采用<strong>工程</strong>的概念、原理、技术和方法来开发与维护软件，把经过时间考验证明正确的<strong>管理技术</strong>和当前能够得到的最好的<strong>技术方法</strong>结合起来，<strong>经济</strong>的开发出<strong>高质量</strong>的软件并<strong>维护</strong>它。</p><h4 id="本质特征"><a href="#本质特征" class="headerlink" title="本质特征"></a>本质特征</h4><ul><li>关注大型程序的构造</li><li>中心课题是控制复杂性</li><li>软件经常变化</li><li>开发效率非常重要</li><li>开发人员和谐合作是关键</li><li>软件需要有效支持用户</li><li>软件开发者替代其他领域人员创造产品</li></ul><h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h4><ul><li>用分阶段的生命周期计划严格管理</li><li>坚持进行阶段评审</li><li>实行严格的产品控制</li><li>采用现代化程序设计技术</li><li>结果应能清楚地审查</li><li>开发小组的人员应少而精</li><li>承认不断改进软件工程实践的必要性</li></ul><h4 id="软件工程方法学（了解）"><a href="#软件工程方法学（了解）" class="headerlink" title="软件工程方法学（了解）"></a>软件工程方法学（了解）</h4><p>软件生命周期全过程使用的<strong>一整套技术方法的集合</strong>成为方法学，也称泛型。<br>三要素：<strong>方法</strong>、<strong>工具</strong>和<strong>过程</strong>。</p><h5 id="传统方法学"><a href="#传统方法学" class="headerlink" title="传统方法学"></a>传统方法学</h5><ul><li>结构化技术完成软件开发各项任务</li><li>把软件生命周期全过程依次划分为若干阶段</li><li>每个阶段开始和结束有严格标准</li><li>每个阶段结束后严格审查</li></ul><h5 id="面向对象方法学"><a href="#面向对象方法学" class="headerlink" title="面向对象方法学"></a>面向对象方法学</h5><ul><li>把对象作为融合了数据及在数据上的操作行为的统一的软件构件</li><li>把所有对象划分为类</li><li>按照父类与子类关系，把若干类组成层次结构的系统</li><li>对象间仅通过发送消息互相联系</li></ul><h5 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h5><ul><li>传统方法学强调自顶向下完成软件开发的各阶段任务</li><li>面向对象方法学开发软件的过程是一个主动多次反复迭代的演化过程。面向对象方法在概念和表示方法上的一致性，保证了在各项开发活动间的平滑过渡。</li></ul><h3 id="软件生命周期"><a href="#软件生命周期" class="headerlink" title="软件生命周期"></a>软件生命周期</h3><ul><li>软件定义<ul><li>问题定义：弄清用户要解决的问题</li><li>可行性研究：上阶段确定问题是否可行</li><li>需求分析：为解决这个问题，系统需要具备什么功能</li></ul></li><li>软件开发<ul><li>总体设计：设计软件结构，确定程序由哪些模块组成以及模块间的关系</li><li>详细设计：针对每个模块，设计详细规格说明，确定算法和数据结构</li><li>编码和单元测试：将详细设计内容用语言实现，并测试每个模块</li><li>综合测试：通过各种类型测试使软件达到预定要求</li></ul></li><li>软件维护<ul><li>运行维护：使软件在整个声明周期内保证满足用户需求</li></ul></li></ul><h3 id="软件过程"><a href="#软件过程" class="headerlink" title="软件过程"></a>软件过程</h3><p>为了获得高质量软件所需要完成的一系列任务框架。通常同软件生命周期模型描述。</p><h4 id="瀑布模型"><a href="#瀑布模型" class="headerlink" title="瀑布模型"></a>瀑布模型</h4><p>将软件生命周期的各项活动规定为依照<strong>固定顺序</strong>连接的若干阶段工作。</p><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ul><li>阶段间顺序性和依赖性</li><li>推迟 实现 的观点</li><li>质量保证<ul><li>每个阶段必须完成规定的文档</li><li>每个阶段结束前完成文档审查，及早改正错误</li></ul></li></ul><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ul><li>强迫开发人员使用规范的方法，严格规定了每个阶段必须提交的文档</li><li>要求每个阶段交出的产品都必须经过仔细验证。</li></ul><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ul><li>不支持产品演化，灵活性低，难以维护；</li><li>软件开发初期难以做出全面完整的需求分析；</li><li>需求确定后无法及时验证需求是否正确、完整。</li></ul><h4 id="快速原型模型"><a href="#快速原型模型" class="headerlink" title="快速原型模型"></a>快速原型模型</h4><p>快速建立可运行的程序，完成的功能往往是最终产品的一个子集。</p><h5 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h5><ul><li>开发的软件通常满足用户需求</li><li>软件开发基本是线性过程</li></ul><h5 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h5><ul><li>准确原型设计困难</li><li>原型理解可能不同</li><li>不利于开发人员创新</li></ul><h4 id="增量模型"><a href="#增量模型" class="headerlink" title="增量模型"></a>增量模型</h4><p>先完成一个系统子集的开发，再按同样的开发步骤增加功能（系统子集），直至满足所有需求。</p><h5 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h5><ul><li>短时间内可提交完成部分功能</li><li>逐渐增加产品功能，用户适应产品快</li></ul><h5 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h5><ul><li>增量构建划分以及集成困难</li><li>容易退化成边做边改模型</li></ul><h4 id="螺旋模型"><a href="#螺旋模型" class="headerlink" title="螺旋模型"></a>螺旋模型</h4><p>在每个阶段之前都增加了风险分析过程的快速原型模型。</p><h5 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h5><ul><li>利于把软件质量作为软件开发目标</li><li>减少测试</li><li>维护和开发不分开</li></ul><h5 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h5><ul><li>风险估计困难</li></ul><h4 id="喷泉模型"><a href="#喷泉模型" class="headerlink" title="喷泉模型"></a>喷泉模型</h4><p><strong>面向对象</strong>的软件过程模型，体现<strong>迭代</strong>和<strong>无缝</strong>的特性</p><h4 id="Rational统一过程"><a href="#Rational统一过程" class="headerlink" title="Rational统一过程"></a>Rational统一过程</h4><h5 id="最佳实践——6条最有效的软件开发经验："><a href="#最佳实践——6条最有效的软件开发经验：" class="headerlink" title="最佳实践——6条最有效的软件开发经验："></a>最佳实践——6条最有效的软件开发经验：</h5><ul><li>迭代式开发<ul><li>每次迭代容许需求变化，可加深对问题的理解</li><li>用户可以不断介入反馈意见；开发人员因可交付版本而提高士气</li></ul></li><li>管理需求<ul><li>提取、组织系统功能性需求并文档化</li><li>用例分析</li></ul></li><li>采用基于构建的体系结构<br>功能清晰地模块或子系统。软件重用。</li><li>可视化建模<br>提高管理软件复杂性的能力</li><li>验证软件质量<br>贯穿开发过程、全体成员参与</li><li>控制软件变更<br>控制、跟踪、监控修改</li></ul><h5 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h5><p><img src="http://oss.ripplesu.top/blog/Typora/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/be9ec2cd-afed-4aa9-84b0-1bd2ad7367dc_repeat_1700460086950__125805.png" alt="image.png"></p><h4 id="敏捷过程"><a href="#敏捷过程" class="headerlink" title="敏捷过程"></a>敏捷过程</h4><p>较好的适应商业竞争环境下对小型项目提出的有限资源和有限开发时间的约束。<br>敏捷开发宣言：</p><ul><li>个体和交互胜过过程和工具</li><li>可以工作的软件胜过面面俱到的文档</li><li>客户合作胜过合同谈判</li><li>响应变化胜过遵循计划</li></ul><h4 id="极限编程"><a href="#极限编程" class="headerlink" title="极限编程"></a>极限编程</h4><p>广泛应用于需求模糊且经常改变的场合</p><ol><li>客户作为开发团队成员</li><li>使用用户素材</li><li>短周期交付</li><li>验收测试</li><li>结对编程 —— 一人编码，一人测试</li><li>测试驱动开发 —— 编码前设计好测试方案</li><li>集体所有 —— 每个成员对全部代码质量负责</li><li>持续集成</li><li>可持续开发速度</li><li>开放工作空间</li><li>及时调整计划</li><li>简单设计</li><li>隐喻——描述系统如何运作、如何加入新功能</li></ol><ul><li>开发过程<br><img src="http://oss.ripplesu.top/blog/Typora/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/a1d1bce4-e502-4bad-adb4-eb76c69eef67.png" alt="image.png"></li></ul><p><img src="http://oss.ripplesu.top/blog/Typora/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/962cca81-4be2-4c10-a155-594d5a51adcf.png" alt="image.png"></p><h2 id="可行性研究"><a href="#可行性研究" class="headerlink" title="可行性研究"></a>可行性研究</h2><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>用最小的代价在最小的时间确定问题是否能解决</p><h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><ul><li>对以后的行动方针提出建议</li><li>分析候选解法的利弊以确定目标是否现实、是否值得</li><li>每种可行解都仔细研究：技术、经济、操作。</li></ul><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol><li>复查系统规模和目标</li><li>研究目前正在使用的系统</li><li>导出新系统的高层逻辑模型</li><li>进一步定义问题</li><li>导出和评价供选择的解法</li><li>推荐行动方针</li><li>草拟开发计划</li><li>书写文档提交审查</li></ol><h3 id="系统流程图"><a href="#系统流程图" class="headerlink" title="系统流程图"></a>系统流程图</h3><p>概括描绘物理系统的传统工具</p><h3 id="数据流图（DFD）-——-重点"><a href="#数据流图（DFD）-——-重点" class="headerlink" title="数据流图（DFD） —— 重点"></a>数据流图（DFD） —— 重点</h3><h4 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h4><ul><li>星号（*）—— 与</li><li>加号（+）—— 或</li><li>⊕ —— 从中选一个<br><img src="http://oss.ripplesu.top/blog/Typora/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/2f3df47d-ecab-4336-8e92-0c7ab131e76e.png" alt="image.png"></li></ul><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p><img src="http://oss.ripplesu.top/blog/Typora/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/f5a9c22b-0a58-4141-9ce2-c6861787f546.png" alt="image.png"><br>1个输入对应一个输出</p><ul><li>命名<ul><li>反应整个数据流或处理</li><li>处理为及物动词（只有一个）+宾语</li></ul></li></ul><h4 id="例"><a href="#例" class="headerlink" title="例"></a>例</h4><ol><li><img src="http://oss.ripplesu.top/blog/Typora/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/eea90903-da70-4ca8-b503-21a82c80f6de.png" alt="image.png"></li><li><img src="http://oss.ripplesu.top/blog/Typora/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/13edb30d-e095-4fe8-ab83-404f183f429a.png" alt="image.png"></li></ol><h3 id="数据字典-——-重点"><a href="#数据字典-——-重点" class="headerlink" title="数据字典 —— 重点"></a>数据字典 —— 重点</h3><p>关于数据的信息集合，即对数据流图中包含的所有元素的定义和集合。</p><ul><li>内容：数据流、数据流分量、数据存储、处理</li></ul><h4 id="符号表示"><a href="#符号表示" class="headerlink" title="符号表示"></a>符号表示</h4><p><img src="http://oss.ripplesu.top/blog/Typora/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/d2c609b8-1582-48bf-8c3d-78d8bc91cb57.png" alt="image.png"></p><h4 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h4><p>软件分析和设计的过程中给人提供关于数据的描述信息。</p><ul><li>分析阶段的工具（最重要）</li><li>估计改变一个数据的影响</li><li>数据库开发的第一步</li></ul><h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><p><img src="http://oss.ripplesu.top/blog/Typora/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/f3428064-4d43-4725-b6ab-dbdcc8cbddff.png" alt="image.png"><br><img src="http://oss.ripplesu.top/blog/Typora/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/89284122-d83a-468a-a568-2391f1fdee23.png" alt="image.png"></p><ul><li>数据字典卡片<br><img src="http://oss.ripplesu.top/blog/Typora/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/ea13cc44-38b1-4068-900e-bb01a1388eb2.png" alt="image.png"></li></ul><h3 id="成本分析-了解"><a href="#成本分析-了解" class="headerlink" title="成本分析 了解"></a>成本分析 了解</h3><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><ul><li>代码行技术<br>软件成本&#x3D;每行代码平均成本*代码行数</li><li>任务分解<br>任务成本&#x3D;人力*人平均工资</li></ul><h4 id="影响经济效益因素"><a href="#影响经济效益因素" class="headerlink" title="影响经济效益因素"></a>影响经济效益因素</h4><ul><li>货币时间价值 F&#x3D;P（1+i）</li><li>投资回收期</li><li>纯收入</li><li>投资回收率</li></ul><h2 id="需求分析-重点"><a href="#需求分析-重点" class="headerlink" title="需求分析 重点"></a>需求分析 重点</h2><h3 id="任务-1"><a href="#任务-1" class="headerlink" title="任务"></a>任务</h3><ul><li>确定对系统的综合要求<ul><li>功能需求</li><li>性能需求</li><li>可靠性和可用性需求</li><li>出错处理</li><li>接口需求</li><li>约束</li><li>逆向需求 不应该做什么</li><li>将来可能提出的要求</li></ul></li><li>分析系统的数据要求</li><li>导出系统的逻辑模型</li><li>修正系统开发计划</li></ul><h3 id="与用户沟通获取需求方法"><a href="#与用户沟通获取需求方法" class="headerlink" title="与用户沟通获取需求方法"></a>与用户沟通获取需求方法</h3><ul><li>访谈</li><li>面向数据流自顶向下求精</li><li>简易的应用规格说明技术</li><li>快速建立软件原型</li></ul><h3 id="分析建模与规格说明"><a href="#分析建模与规格说明" class="headerlink" title="分析建模与规格说明"></a>分析建模与规格说明</h3><h4 id="分析建模"><a href="#分析建模" class="headerlink" title="分析建模"></a>分析建模</h4><p>模型：为了理解事物而对事物做出的抽象</p><h5 id="分类-——-重点"><a href="#分类-——-重点" class="headerlink" title="分类 —— 重点"></a>分类 —— 重点</h5><ul><li><strong>数据模型</strong>（<strong>实体联系图</strong>）：描绘数据对象及数据对象之间的关系</li><li><strong>功能模型</strong>（<strong>数据流图</strong>）：描绘数据在系统中流动时被处理的逻辑过程，指明系统应具有的变换数据的功能</li><li><strong>行为模型</strong>（<strong>状态转换图</strong>）：描绘系统的各种行为模式在不同状态间转换的方式</li></ul><h4 id="软件需求规格说明"><a href="#软件需求规格说明" class="headerlink" title="软件需求规格说明"></a>软件需求规格说明</h4><p>需求分析阶段得出的最主要文档。用自然语言描述综合要求（8个）</p><h4 id="实体联系图"><a href="#实体联系图" class="headerlink" title="实体联系图"></a>实体联系图</h4><p><img src="http://oss.ripplesu.top/blog/Typora/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/64f9d941-3ea4-4c1c-ab6d-9c5b2da31283.png" alt="image.png"></p><h4 id="状态转换图"><a href="#状态转换图" class="headerlink" title="状态转换图"></a>状态转换图</h4><p><img src="http://oss.ripplesu.top/blog/Typora/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/248c1ed3-8309-40d5-aa99-48e4dda7a309.png" alt="image.png"></p><h3 id="验证软件需求"><a href="#验证软件需求" class="headerlink" title="验证软件需求"></a>验证软件需求</h3><h4 id="从哪些方面验证需求正确性"><a href="#从哪些方面验证需求正确性" class="headerlink" title="从哪些方面验证需求正确性"></a>从哪些方面验证需求正确性</h4><ul><li>一致性：所有需求必须是一致的，任何一条需求不能和其他需求互相矛盾</li><li>完整性：规格说明书应包括用户需要的每一个功能或性能</li><li>现实性：需求应能用现有的硬件和软件技术实现</li><li>有效性：验证需求是正确有效的，能解决用户面对的问题</li></ul><h2 id="总体设计"><a href="#总体设计" class="headerlink" title="总体设计"></a>总体设计</h2><ul><li>确定系统中每个程序由哪些模块组成以及这些模块间的关系</li><li>划分出物理元素，包括程序、文件、数据库、文档等</li></ul><h3 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h3><h4 id="系统设计阶段"><a href="#系统设计阶段" class="headerlink" title="系统设计阶段"></a>系统设计阶段</h4><ul><li>设想供选择的方案</li><li>选取合理的方案</li><li>推荐最佳方案</li></ul><h4 id="结构设计阶段"><a href="#结构设计阶段" class="headerlink" title="结构设计阶段"></a>结构设计阶段</h4><ul><li>功能分解 —— 数据流图细化</li><li>设计软件结构 —— 层次图或结构图</li><li>设计数据库</li><li>制定测试计划</li><li>书写文档</li><li>审查和复审</li></ul><h3 id="设计原理"><a href="#设计原理" class="headerlink" title="设计原理"></a>设计原理</h3><h4 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h4><p>模块：构成程序的基本构件<br>模块化：把程序划分成独立命名且可独立访问的模块，每个模块完成一个子功能，模块集成构成整体，可以完成指定功能<br><img src="http://oss.ripplesu.top/blog/Typora/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/64c75e2e-82d2-473b-9910-06e5912039f4.png" alt="image.png"></p><h4 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h4><p>抽出事物的本质特性而暂时不考虑他们的细节</p><h4 id="逐步求精"><a href="#逐步求精" class="headerlink" title="逐步求精"></a>逐步求精</h4><p>集中精力解决主要问题，逐步揭露出底层细节</p><h4 id="信息隐藏与局部化"><a href="#信息隐藏与局部化" class="headerlink" title="信息隐藏与局部化"></a>信息隐藏与局部化</h4><ul><li>信息隐藏：模块内包含的信息对于不需要这些信息的模块来说不可访问</li><li>局部化：关系密切的软件元素物理地放得彼此靠近，有助于实现信息隐藏</li></ul><h4 id="模块独立"><a href="#模块独立" class="headerlink" title="模块独立"></a>模块独立</h4><p>模块独立性：模块化、抽象、信息隐藏和局部化的直接结果</p><h5 id="耦合"><a href="#耦合" class="headerlink" title="耦合"></a>耦合</h5><p>软件结构内<strong>不同模块</strong>之间互联程序的度量。取决于模块接口的复杂程度、通过接口的数据等。<br>耦合度越高，独立性越弱</p><ul><li>分类 —— 从弱到强<ul><li>完全独立（不可能）</li><li>数据耦合（通过参数交换信息，交换的信息只是数据。至少必须存在）</li><li>控制耦合（通过参数交换信息，交换的信息包含控制信息）</li><li>特征耦合（被调用模块只需要参数中的一部分）</li><li>共用耦合（多个模块共用数据）</li><li>内容耦合（访问模块内部数据、不通过正常入口转移到另一个模块内部、模块间代码重叠、模块有多个入口）</li></ul></li></ul><h5 id="内聚"><a href="#内聚" class="headerlink" title="内聚"></a>内聚</h5><p>度量模块内部各个元素彼此结合的紧密程度，信息隐藏和局部化概念的自然扩展</p><ul><li>内聚与耦合<ul><li>二者密切相关，高内聚往往低耦合</li><li>内聚更重要</li></ul></li></ul><p>从低到高：</p><ul><li>低内聚<ul><li>偶然内聚：一组语句多次出现，抽出成模块</li><li>逻辑内聚：一个模块完成的任务在逻辑上相同</li><li>时间内聚：模块内功能必须在同一段时间执行</li></ul></li><li>中内聚<ul><li>过程内聚：模块内处理元素相关，且必须以某一次序执行（程序流程图为工具）</li><li>通信内聚：模块内所有元素使用同一个输入产生或产生同一个输出</li></ul></li><li>高内聚<ul><li>顺序内聚：模块内的处理元素同某一功能密切相关，且必须按顺序执行（数据流图）</li><li>功能内聚：所有处理元素属于同一整体，完成一个单一的功能</li></ul></li></ul><h3 id="启发规则"><a href="#启发规则" class="headerlink" title="启发规则"></a>启发规则</h3><ul><li>改进软件结构提高模块独立性</li><li>模块规模应该适中</li><li>深度、宽度、扇入和扇出应该适当<ul><li>深度：软件结构中控制的层数</li><li>宽度：软件结构内同一层次上的模块总数的最大值</li><li>扇出：一个模块直接调用的模块数目（好的设计平均3<del>4,上限5</del>9）</li><li>扇入：有多少模块调用它（高扇入有一定好处，但不应违反模块独立。顶层扇出高，底层扇入高）</li></ul></li><li>模块作用域应该在控制域之内<ul><li>作用域：受该模块内一个判定影响的所有模块的集合</li><li>控制域：模块本身以及所有直接或间接从属于它的模块的集合</li></ul></li><li>力争降低模块接口的复杂程度</li><li>设计单入口单出口的模块</li><li>模块功能应该可以预测（相同输入产生相同输出）</li></ul><h3 id="描绘软件结构的图形工具"><a href="#描绘软件结构的图形工具" class="headerlink" title="描绘软件结构的图形工具"></a>描绘软件结构的图形工具</h3><h4 id="层次图"><a href="#层次图" class="headerlink" title="层次图"></a>层次图</h4><p><img src="http://oss.ripplesu.top/blog/Typora/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/a012a2c0-c017-478e-99f4-e50438254f5c.png" alt="image.png"></p><h4 id="HIPO图"><a href="#HIPO图" class="headerlink" title="HIPO图"></a>HIPO图</h4><p>除顶层外，每个模块加编号的层次图</p><h4 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h4><p><img src="http://oss.ripplesu.top/blog/Typora/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/b69ed8a7-8dc0-4923-be96-466c25bfa738.png" alt="image.png"><br><img src="http://oss.ripplesu.top/blog/Typora/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/fff038ba-0fa3-4481-8a60-aeafaf9c5a73.png" alt="image.png"></p><h3 id="面向数据流设计方法-重点"><a href="#面向数据流设计方法-重点" class="headerlink" title="面向数据流设计方法  重点"></a>面向数据流设计方法  重点</h3><p>定义：把信息流映射成软件结构，信息流的类型决定了映射方法</p><p>目标：给出设计软件结构的一个系统化的途径</p><h4 id="信息流的类型"><a href="#信息流的类型" class="headerlink" title="信息流的类型"></a>信息流的类型</h4><p><img src="http://oss.ripplesu.top/blog/Typora/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/558c8361-227b-4890-aa18-191e6f2fea6c.png" alt="image.png"><br><img src="http://oss.ripplesu.top/blog/Typora/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/692e0c9c-92fd-457c-920d-9d35e072b47b.png" alt="image.png"></p><h4 id="变换分析"><a href="#变换分析" class="headerlink" title="变换分析"></a>变换分析</h4><p>例：<br><img src="http://oss.ripplesu.top/blog/Typora/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/27f4febc-af6e-4e5d-aa75-2aa1a115f79d.png" alt="image.png"><br>设计步骤：</p><ul><li>复查基本系统模型<br>确保输入数据与输出数据符合实际</li><li>复查并精化数据流图<br>确保数据流图给出了目标系统的正确逻辑模型<br><img src="http://oss.ripplesu.top/blog/Typora/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/83b2757a-0c8d-4cb4-a20e-b19a13c665b4.png" alt="image.png"></li><li>确定数据流图具有变换特性还是事务特性<br>根据数据流图占优势的属性确定数据流图的总特征。<br>上图具有变换流的总特征。</li><li>确定输入流和输出流的边界，孤立变换中心</li><li>第一级分解<br><img src="http://oss.ripplesu.top/blog/Typora/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/504524bf-5fb4-47db-a61f-eed2c7beb5a6.png" alt="image.png"><br><img src="http://oss.ripplesu.top/blog/Typora/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/9d5193a2-b725-4867-bd55-01c3a108a6fc.png" alt="image.png"></li><li>第二级分解<br>把数据流图中的每个处理映射为软件结构中一个模块<br><img src="http://oss.ripplesu.top/blog/Typora/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/b0f3731d-e61a-433e-8738-fdb10b7fb31d.png" alt="image.png"></li><li>使用设计度量和启发规则进一步精化<br><img src="http://oss.ripplesu.top/blog/Typora/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/08824c17-5b95-4bfd-9e93-357dfb2b36cf.png" alt="image.png"></li></ul><h4 id="事务分析"><a href="#事务分析" class="headerlink" title="事务分析"></a>事务分析</h4><p>在数据流具有明显的事务特点时，即有一个明显的事务中心时，采用事务分析方法为宜。否则最好采用变换分析。</p><p><img src="http://oss.ripplesu.top/blog/Typora/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/03fcdbc9-6d02-4b92-9d8b-9357b0daa14a.png" alt="image.png"><br>事务流映射成的软件结构包括-个接收分支和一个发送分支。发送分支的结构包含一个调度模块，它控制下层的所有活动模块。映射接收分支结构的方法是从事务中心边界开始，把沿接收流通路的处理映射成模块。数据流图中的每个活动流通路都应该映射成与它的流特征相对应的结构。</p><h2 id="详细设计"><a href="#详细设计" class="headerlink" title="详细设计"></a>详细设计</h2><ul><li>目标<ul><li>详细设计阶段的根本目标是确定应该怎样具体地实现所要求的系统，即经过这个阶段的设计工作，应该得出<strong>对目标系统的精确描述</strong>，从而在编码阶段可以把这个描述直接翻译成用某种程序设计语言书写的程序。</li><li>详细设计的目标不仅仅是逻辑上正确地实现每个模块的功能，更重要的是设计出的处理过程应该尽可能<strong>简明易懂</strong>。</li></ul></li><li>工作任务<br>详细设计阶段的任务是要设计出<strong>程序的“蓝图”</strong>，以后程序员将根据这个“蓝图”写出实际的程序代码。</li><li>关键技术<br>详细设计的结果基本上<strong>决定</strong>了最终的程序<strong>代码的质量</strong>。<strong>结构程序设计</strong>技术是实现详细设计目标的<strong>关键技术</strong>,也是详细设计的<strong>逻辑基础</strong>。</li></ul><h3 id="结构程序设计"><a href="#结构程序设计" class="headerlink" title="结构程序设计"></a>结构程序设计</h3><ul><li>经典的结构程序设计<br>只允许使用顺序、IF-THEN-ELSE型分支和DO-WHILE型循环这三种基本控制结构。</li><li>扩展的结构程序设计<br>除了基本控制结构之外，还允许使用DO-CASE型多分支结构和DO-UNTIL型循环结构。</li><li>修正的结构程序设计<br>除了扩展的结构程序设计之外，再允许使用LEAVE (或BREAK)结构。</li></ul><p>如果一个程序的代码块仅仅通过顺序、选择和循环这三种基本控制结构进行连接，并且每个代码块只有一个入口和一个出口，则称这个程序是结构化的。</p><h3 id="人机界面设计"><a href="#人机界面设计" class="headerlink" title="人机界面设计"></a>人机界面设计</h3><p>接口设计的一个重要组成部分。</p><h4 id="设计问题"><a href="#设计问题" class="headerlink" title="设计问题"></a>设计问题</h4><ul><li>系统响应时间<br>两个重要属性：长度和易变性</li><li>用户帮助设施</li><li>出错信息处理</li><li>命令交互</li></ul><h4 id="设计指南"><a href="#设计指南" class="headerlink" title="设计指南"></a>设计指南</h4><ul><li>一般交互指南</li><li>信息显示指南</li><li>数据输入指南</li></ul><h3 id="过程设计工具"><a href="#过程设计工具" class="headerlink" title="过程设计工具"></a>过程设计工具</h3><h4 id="程序流程图"><a href="#程序流程图" class="headerlink" title="程序流程图"></a>程序流程图</h4><p>也称程序框图，历史最悠久、使用最广泛也最混乱<br><img src="http://oss.ripplesu.top/blog/Typora/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/e29bd03c-c0db-4b39-a29d-fef1baaa16ee.png" alt="image.png"><br>缺点：<br>(1) 程序流程图本质上不是逐步求精的好工具，它诱使程序员过早地考虑程序的<strong>控制流程</strong>，而不去考虑程序的<strong>全局结构</strong>。<br>(2)程序流程图中用箭头代表控制流，因此程序员不受任何约束，可以完全不顾结构程序设计的精神，随意转移控制。<br>(3)程序流程图不易表示数据结构。</p><h4 id="盒图-N-S图"><a href="#盒图-N-S图" class="headerlink" title="盒图 N-S图"></a>盒图 N-S图</h4><p>不允许违背结构程序设计精神。<br><img src="http://oss.ripplesu.top/blog/Typora/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/650ca2ee-5110-4304-bdec-1e5d3309c738.png" alt="image.png"></p><h4 id="PAD图"><a href="#PAD图" class="headerlink" title="PAD图"></a>PAD图</h4><p>设计出来的必然是结构化程序。结构清晰，容易转换为高级语言源程序。<br><img src="http://oss.ripplesu.top/blog/Typora/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/c5bb760d-9377-4ba0-a4f4-b139e9b0c00e.png" alt="image.png"></p><h4 id="判定表"><a href="#判定表" class="headerlink" title="判定表"></a>判定表</h4><ul><li><p>适用性：<br>算法中包含多重嵌套的条件选择时，判定表能够清晰地表示复杂的条件组合与应做的动作之间的对应关系。</p></li><li><p>组成<br>一张判定表由四部分组成:<br>a.左上部列出所有条件;<br>b.左下部是所有可能做的动作;<br>c.右上部是表示各种条件组合的一个矩阵;<br>d.右下部是和每种条件组合相对应的动作。<br>注意:判定表右半部的每一列实质上是一条规则，规定了与特定的条件组合相对应的动作。</p></li><li><p>例<br>假设某航空公司规定，乘客可以免费托运重量不超过30kg的行李。当行李重量超过30kg时，对头等舱的国内乘客超重部分每公斤收费4元，对其他舱的国内乘客超重部分每公斤收费6元，对外国乘客超重部分每公斤收费比国内乘客多一倍，对残疾乘客超重部分每公斤收费比正常乘客少一半。<br><img src="http://oss.ripplesu.top/blog/Typora/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/86f928ca-5fd1-46e7-b584-f7a819e51f00.png" alt="image.png"></p></li></ul><h4 id="判定树"><a href="#判定树" class="headerlink" title="判定树"></a>判定树</h4><p><img src="http://oss.ripplesu.top/blog/Typora/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/79800b5f-85d2-43e1-b841-4f4f01521954.png" alt="image.png"></p><h4 id="过程设计语言（PDL）-重点"><a href="#过程设计语言（PDL）-重点" class="headerlink" title="过程设计语言（PDL） 重点"></a>过程设计语言（PDL） 重点</h4><ul><li>定义<br>过程设计语言(PDL)， 即伪码，它是用正文形式表示数据和处理过程的设计工具。PDL具有严格的关键字外部语法，用于定义控制结构和数据结构。PDL表示实际操作和条件的内部语法通常又是灵活自由的，可以适应各种工程项目的需要。</li><li>特点<br>a. 关键字的固定语法，它提供了结构化控制结构、数据说明和模块化的特点。<br>b. 自然语言的自由语法，它描述处理特点。<br>c. 数据说明的手段。应该既包括简单的数据结构，又包括复杂的数据结构表或层次的。<br>d. 模块定义和调用的技术，应该提供各种接口描述模式。</li><li>优点<br>a. 可作为注释直接插在源程序中。有助于保持文档和程序的一致性， 提高文档的质量。<br>b. 可以使用普通的正文编辑程序或文字处理系统，很方便地完成PDL的书写和编辑工作。<br>c. 已经有自动处理PDL的程序存在，且可以自动由PDL生成程序代码。</li><li>缺点<br>不如图形工具形象直观，描述复杂的条件组合与动作间的对应关系时，较复杂，不如判定表清晰简单。</li></ul><h4 id="程序复杂度定量度量"><a href="#程序复杂度定量度量" class="headerlink" title="程序复杂度定量度量"></a>程序复杂度定量度量</h4><p>McCabe方法</p><h5 id="流图"><a href="#流图" class="headerlink" title="流图"></a>流图</h5><p>流图实质上是“退化了的”程序流程图，它仅仅仅描绘程序的控制流程，完全不表现对数据具体操作以及分支或循环的具体条件，流图通常被用来突出表示程序的控制流。</p><ul><li>流程图映射为流图<br><img src="http://oss.ripplesu.top/blog/Typora/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/3e487469-1e3c-44a5-ad46-aac75ca99708.png" alt="image.png"></li><li>PDL翻译为流图<br><img src="http://oss.ripplesu.top/blog/Typora/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/2c26de89-0daf-4f01-82ea-d2e16e5c4fa2.png" alt="image.png"></li></ul><h5 id="计算方法"><a href="#计算方法" class="headerlink" title="计算方法"></a>计算方法</h5><p>环形复杂度定量度量程序的逻辑复杂度，可以用下述3种方法中的任何一种来计算环形复杂度:<br>a. 流图中线性无关的区域数等于环形复杂度。<br>b. 流图G的环形复杂度V (G) &#x3D;E-N+2，其中，E是流图中边的条数，N是结点数。.<br>c. 流图G的环形复杂度V (G) &#x3D;P+1, 其中，P是流图中判定结点的数目。<br>V (G)&lt;10为宜。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><h4 id="语言选择"><a href="#语言选择" class="headerlink" title="语言选择"></a>语言选择</h4><p>减少编程难度、减少程序测试量、容易维护的实现基础。</p><h4 id="编码风格"><a href="#编码风格" class="headerlink" title="编码风格"></a>编码风格</h4><ul><li>程序内部文档</li><li>数据说明</li><li>语句构造</li><li>输入输出</li><li>效率：处理机时间和存储器容量</li></ul><h4 id="代码重构"><a href="#代码重构" class="headerlink" title="代码重构"></a>代码重构</h4><p>代码重构通常是指在++不改变代码对外表现++的情况下，修改代码的内部功能特征，从而改善软件质量，使程序的设计模式和架构更趋合理，更容易被理解，提高软件的可扩展性和可维护性。</p><p>代码重构可以持续纠正和改进软件设计、使代码更被其他人所理解、帮助发现隐藏的代码缺陷、有助于提高开发效率。</p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><h4 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h4><ul><li>测试是为了发现程序中的错误而执行程序的过程。</li><li>好的测试方案是极可能发现迄今为止尚未发现的错误的测试方案。</li><li>成功的测试是发现了至今为止尚未发现的错误的测试</li></ul><h4 id="测试准则"><a href="#测试准则" class="headerlink" title="测试准则"></a>测试准则</h4><ul><li>所有测试都应该能追溯到用户需求；</li><li>应该远在测试开始之前就制定出测试计划；</li><li>把Pareto原理应用到软件测试中；（ 80&#x2F;20 法则、关键少数法则、八二法则。测试发现的错误中的80%很可能是由程序中20%的模块造成的。）</li><li>应该从“小规模”测试开始，并逐步进行“大规模”测试；</li><li>穷举测试是不可能的；</li><li>为了达到最佳的测试效果，应该由独立的第三方从事测试工作。</li></ul><h4 id="测试步骤"><a href="#测试步骤" class="headerlink" title="测试步骤"></a>测试步骤</h4><ul><li>单元测试（模块测试）<br>把每个模块作为一个单独的实体来测试，通常比较容易发现<strong>编码和详细设计</strong>的错误。</li><li>子系统测试<br>经过单元测试的模块放在一起形成一个子系统来测试。模块相互间的协调和通信是这个测试过程中的主要问题，因此，这个步骤着重测试<strong>模块的接口</strong>。</li><li>系统测试<br>在这个测试步骤中发现的往往是<strong>软件设计</strong>中的错误，也可能发现需求说明中的错误。<br>子系统测试和系统测试通常称为集成测试。</li><li>验收测试<br>验收测试把软件系统作为单一的实体进行测试，测试内容与系统测试基本类似，但是它是在<strong>用户</strong>积极参与下进行的，而且可能主要使用<strong>实际数据</strong>(系统将来要处理的信息)进行测试。<br> 验收测试的目的是验证系统确实能够满足用户的需要，在这个测试步骤中发现的往往是<strong>系统需求说明书</strong>中的错误。验收测试也称为<strong>确认测试</strong>。</li><li>平行运行<br>同时运行新开发出来的系统和将被它取代的旧系统，以便比较新旧两个系统的处理结果。</li></ul><h4 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h4><ul><li>测试依据：详细设计文档</li><li>测试技术：白盒测试</li><li>着重点</li></ul><ol><li>模块接口</li><li>局部数据结构</li><li>重要的执行通路</li><li>出错处理通路</li><li>边界条件</li></ol><ul><li>代码审查</br><br>由审查小组正式对源程序进行人工测试。它是一种非常有效的程序验证技术，对于典型的程序来说，可以查出30%～70%的逻辑设计错误和编码错误。</br><br>优点：一次审查会上可以发现许多错误；用计算机测试的方法发现错误之后，通常需要先改正这个错误才能继续测试，即：采用代码审查的方法可以减少系统验证的总工作量。 </li><li>计算机测试</li></ul><h4 id="集成测试"><a href="#集成测试" class="headerlink" title="集成测试"></a>集成测试</h4><ul><li>目标：发现与接口有关的问题</li><li>实施者：独立测试机构或第三方</li></ul><h5 id="非渐增测试"><a href="#非渐增测试" class="headerlink" title="非渐增测试"></a>非渐增测试</h5><p>先分别测试每个模块，再把所有模块按设计要求放在一起结合成所要的程序，这种方法称为非渐增式测试方法。</p><h5 id="渐增测试"><a href="#渐增测试" class="headerlink" title="渐增测试"></a>渐增测试</h5><p>把下一个要测试的模块同已经测试好的那些模块结合起来进行测试，测试完以后再把下一个应该测试的模块结合进来测试。这种每次增加一个模块的方法称为渐增式测试。</p><ul><li>自顶向下集成：<br>从主控制模块开始，沿着程序的控制层次向下移动，逐渐把各个模块结合起来。</li><li>自底向上集成：<br>从“原子”模块(即在软件结构最低层的模块)开始组装和测试。</li><li>比较</br><br>自顶向下测试方法的主要<strong>优点</strong>是不需要测试驱动程序，能够在测试阶段的早期实现并验证系统的主要功能，而且能在早期发现上层模块的接口错误。<br>自顶向下测试方法的主要<strong>缺点</strong>是需要存根程序，可能遇到与此相联系的测试困难，低层关键模块中的错误发现较晚，而且用这种方法在早期不能充分展开人力。<br>自底向上测试方法的优缺点与上述自顶向下测试方法的优缺点刚好相反。</li></ul><h5 id="持续集成"><a href="#持续集成" class="headerlink" title="持续集成"></a>持续集成</h5><p>持续集成（Continuous Integration，简称CI）要求开发过程中，编程人员不断地将修改或新增的代码提交到一个统一的代码版本控制库中，并通过回归测试来检验这些代码是否正确。<br>持续集成一般分为<strong>代码提交、自动化创建、自动化测试</strong>三个主要环节。<br>与敏捷开发方法密切相关。</p><h5 id="回归测试"><a href="#回归测试" class="headerlink" title="回归测试"></a>回归测试</h5><p>在集成测试过程中，每当一个新模块结合进来时，程序就发生了变化。回归测试是指重新执行已经做过的测试的某个子集，以保证上述这些变化没有带来非预期的副作用。</p><h4 id="确认测试"><a href="#确认测试" class="headerlink" title="确认测试"></a>确认测试</h4><p>确认测试也称为<strong>验收测试</strong>，它的目标是<strong>验证软件的有效性</strong>。<br>通常，验证指的是保证软件正确地实现了某个特定要求的一系列活动；确认指的是为了保证软件确实满足了用户需求而进行的一系列活动。<br>软件有效性的一个简单定义是：如果软件的功能和性能如同用户所合理期待的那样，软件就是有效的。</p><ul><li>软件配置复查<br>保证软件配置的所有成分都齐全，质量符合要求，文档与程序完全一致，具有完成软件维护所必须的细节，而且已经编好目录。</li><li>Alpha测试<br>用户在开发者的场所，在开发者指导下进行</li><li>Beta测试<br>用户在用户场所进行，遇到问题报告给开发者，开发者修改。</li></ul><h4 id="白盒测试"><a href="#白盒测试" class="headerlink" title="白盒测试"></a>白盒测试</h4><p>白盒测试（又称<strong>结构测试</strong>）是把程序看成装在一个透明的白盒子里，测试者++完全知道程序的结构和处理算法++。这种方法按照程序内部的逻辑测试程序，检测程序中的主要执行通路是否都能按预定要求正确工作。<br>测试用例:测试输入数据和预期的输出结果。<br>测试方案:测试目的、测试用例的集合。</p><ul><li>语句覆盖:被测试程序中的每条语句至少执行一次。</li><li>判定覆盖:使得被测程序中每个判定表达式至少获得一次“真”值和“假”值</li><li>条件覆盖:使得判定表达式中每个条件的各种可能的值至少出现一次。</li><li>判定&#x2F;条件覆盖:使得判定表达式中的每个条件的所有可能取值至少出现一次,并使每个判定表达式所有可能的结果也至少出现一次。</li><li>条件组合覆盖:设计足够多的测试用例，使得每个判定表达式中条件的各种可能的值的组合都至少出现一次。</li><li>路径覆盖:覆盖被测程序中所有可能的路径。</li></ul><h4 id="黑盒测试"><a href="#黑盒测试" class="headerlink" title="黑盒测试"></a>黑盒测试</h4><p>黑盒测试（又称<strong>功能测试</strong>）把程序看作一个黑盒子，++完全不考虑程序的内部结构和处理过程++。黑盒测试是在程序接口进行的测试，只检查程序功能是否能按照规格说明书的规定正常使用，程序是否能适当地接收输入数据并产生正确的输出信息，程序运行过程中能否保持外部信息（例如数据库或文件）的完整性。</p><ul><li>等价类划分</br><br>(1)把程序的输入数据集合按输入条件划分为若干个等价类，每一个等价类相对于输入条件表示为一组有效或无效的输入。<br>(2)为每一等价类设计一个测试用例。</li><li>边界值分析法</br><br>输入等价类和输出等价类的边界就是应该着重测试的程序边界情况。选取的测试数据应该++刚好等于、刚好小于、刚好大于++边界值。</li><li>错误推测</br><br>错误推测法在很大程度上靠直觉和经验进行。它的基本想法是列举出程序中可能有的错误和容易发生错误的特殊情况，并且根据它们选择测试方案。</li></ul><h4 id="测试驱动开发"><a href="#测试驱动开发" class="headerlink" title="测试驱动开发"></a>测试驱动开发</h4><p>测试驱动开发（Test Driven Development，简称TDD）是++敏捷开发++中的一项核心实践和技术。<br>测试驱动开发的基本思想就是在开发功能代码之前，<strong>先编写测试</strong>代码，然后<strong>只编写使测试通过的功能代码</strong>，从而以测试来驱动整个开发过程的进行。<br>这有助于编写简洁可用和高质量的代码，有很高的灵活性和健壮性，能快速响应变化，并加速开发过程。<br>这种开发方式与传统开发方式刚好相反。</p><h4 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h4><p>调试（也称为纠错）作为成功测试的后果出现，即调试是在测试发现错误之后排除错误的过程。</p><h5 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h5><ul><li>蛮干法<br>最低效，到处打印</li><li>回溯法</li><li>原因排除法<ul><li>对分查找法：注入变量正确值</li><li>归纳法：把和错误有关的数据组织起来进行分析，然后导出对错误原因的一个或多个假设，并利用已有的数据来证明或排除这些假设</li><li>演绎法：设想出所有可能的出错原因，然后试图用测试来排除每一个假设的原因</li></ul></li></ul><h2 id="维护"><a href="#维护" class="headerlink" title="维护"></a>维护</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>所谓软件维护就是在软件已经交付使用之后，为了改正错误或满足新的需要而修改软件的过程，是软件生命周期的最后一个阶段，基本任务是保证软件在一个相当长的时期内可以正常运行。</p><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul><li>改正性维护：诊断和改正错误</li><li>适应性维护：为了和变化了的环境适当地配合而进行的修改软件的活动</li><li>完善性维护：为了满足用户提出的增加新功能或修改已有功能的要求和一般性的改进要求。占大部分。</li><li>预防性维护：改进未来的可维护性与可靠性</li></ul><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ul><li>结构化维护与非结构化维护差别巨大<br>非结构化维护:惟一成分是程序代码，那么维护活动从艰苦地评价程序代码开始。<br>结构化维护:有完整的软件配置存在，那么维护工作从评价设计文档开始。</li><li>维护的代价高昂<br>1990年占总预算的70%以上<br>生产率大幅下降</li><li>维护的问题很多<br>理解别人写的程序通常非常困难；<br>维护的软件往往没有合格的文档，或者文档资料显著不足；<br>要求对软件进行维护时，不能指望由开发人员给我们仔细说明软件；<br>绝大多数软件在设计时没有考虑将来的修改；<br>软件维护不是一项吸引人的工作。</li></ul><h4 id="软件维护过程"><a href="#软件维护过程" class="headerlink" title="软件维护过程"></a>软件维护过程</h4><ul><li>维护组织</li><li>维护报告</li><li>维护的事件流</li><li>保存维护记录</li><li>评价维护活动</li></ul><h4 id="软件的可维护性"><a href="#软件的可维护性" class="headerlink" title="软件的可维护性"></a>软件的可维护性</h4><p>维护人员理解、改正、改动、或改进软件的难易程度。<br>提高可维护性是支配软件工程方法学所有步骤的<strong>关键目标</strong>。</p><h5 id="决定软件可维护性的因素"><a href="#决定软件可维护性的因素" class="headerlink" title="决定软件可维护性的因素"></a>决定软件可维护性的因素</h5><ul><li>可理解性：读者理解软件的难易程度</li><li>可测试性：论证程序正确性的容易程度</li><li>可修改性：程序容易修改的程度</li><li>可移植性：把程序从一种计算环境转移到另一种计算环境的难易程度</li><li>可重用性：同一个软件不做修改或稍加改动，就可以在不同环境中多次重复使用</li></ul><h4 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h4><p>影响软件可维护性的<strong>决定因素</strong>。<br>分为用户文档和系统文档两类。</p><h4 id="可维护性复审"><a href="#可维护性复审" class="headerlink" title="可维护性复审"></a>可维护性复审</h4><p>完成了每项维护工作之后，都应该对软件维护本身进行仔细认真的复审。<br>在测试结束时进行最正式的可维护性复审，这个复审称为配置复审。</p><h4 id="软件再工程"><a href="#软件再工程" class="headerlink" title="软件再工程"></a>软件再工程</h4><ul><li>库存目录分析：分析可能成为预防性维护的对象</li><li>文档重构</li><li>逆向工程：分析程序以便在比源代码更高的抽象层次上创建出程序的某种表示的过程</li><li>代码重构：代码重构是最常见的再工程活动。可以重构编码方式难以理解、测试、维护的代码。</li><li>数据重构：数据重构发生在相当低的抽象层次上，它是一种全范围的再工程活动——对数据的修改必然会导致体系结构或代码层的改变。</li><li>正向工程：利用现代软件工程概念、原理、技术和方法，重新开发现有的某个应用系统</li></ul><h2 id="面向对象方法学-1"><a href="#面向对象方法学-1" class="headerlink" title="面向对象方法学"></a>面向对象方法学</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>按人类习惯的思维方法，以现实世界中客观存在的对象为中心来思考和认识问题。<br>采用的思想方法与原则:抽象、分类、继承、聚合、封装等。<br>要点:</p><ul><li>对象<br>任何客观的事物或实体都是对象。对象组成客观世界，复杂的对象可以由简单的对象组成。</li><li>类<br>具有相同数据和操作的对象可以归并为一个类( class)，对象是对象类的一个实例。</li><li>继承性<br>类可以派生出子类，子类继承父类的全部特性( 数据和操作)，又可以有自己的新特性。子类与父类形成类的层次结构。</li><li>封装性<br>对象之间只能通过消息传递相互联系。</li></ul><p>面向对象&#x3D;对象+类+继承+通信</p><h4 id="优点-4"><a href="#优点-4" class="headerlink" title="优点"></a>优点</h4><ul><li>与人类的思维习惯一致</li><li>稳定性好</li><li>可重用性好</li><li>较易开发大型软件产品</li><li>可维护性好</li></ul><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>在应用领域中有意义的、与所要解决的问题有关系的任何事物都可以作为对象，包括具体的物理实体的抽象、人为的概念、任何有明确边界和意义的东西。<br>对象既有静态的属性，又有动态的行为。<br>对象的两个基本要素：<br>属性:用来描述对象静态特征的一个数据项;<br>服务:用来描述对象动态特征(行为)的一个操作序列。<br>对象的属性和所有操作封装在一起，构成一个统一体。属性一般只能通过执行对象的操作来改变。</p><h4 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h4><ol><li>以数据为中心</li><li>对象是主动的</li><li>实现了数据封装</li><li>本质上具有并行性</li><li>模块独立性好</li></ol><h3 id="面向对象建模-重点"><a href="#面向对象建模-重点" class="headerlink" title="面向对象建模 重点"></a>面向对象建模 重点</h3><p>模型是一组图示符号和组织这些符号的规则，利用它们来定义和描述问题域中的术语和概念。</p><ul><li>对象模型(object model):定义实体，描述系统数据，定义“对谁做”</li><li>动态模型(dynamic model) :描述系统控制结构,规定”何时做”</li><li>功能模型(functional model) :描述系统功能,指明系统应”做什么”</li></ul><h3 id="对象模型"><a href="#对象模型" class="headerlink" title="对象模型"></a>对象模型</h3><p>UML中，对象模型通常由“<strong>类图</strong>”组成。<br>类和类之间的联系称为”关系”。通常分为<strong>关联、范化、依赖和细化</strong>四种。</p><ul><li><p>关联:两个类之间存在某种语义上的联系<br><img src="http://oss.ripplesu.top/blog/Typora/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/0cb9d0b3-64c7-421c-9d90-6d73f9d21a57.png" alt="image.png"><br><img src="http://oss.ripplesu.top/blog/Typora/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/3d9c0697-1a7a-4c9b-b5ee-08b67af9aa05.png" alt="image.png"><br><img src="http://oss.ripplesu.top/blog/Typora/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/405f77db-d041-47b4-b9ad-edb32a0f20ca.png" alt="image.png"></p></li><li><p>聚集<br>聚集(聚合)是关联的特例。表示类与类之间的关系是<strong>整体与部分</strong>的关系。在陈述需求时使用的“包含”、“组成”、“分为…部分”等字句，往往意味着存在聚集关系。</p><ul><li>共享聚集：紧挨整体类的地方画<strong>空心菱形</strong><br><img src="http://oss.ripplesu.top/blog/Typora/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/090203ba-3669-4bc9-b57d-1acb40347f0f.png" alt="image.png"></li><li>组合聚集：<strong>实心菱形</strong><br>如果部分类完全隶属于整体类，部分与整体共存，整体不存在了部分也会随之消失，则该聚集称为组合聚集(组成)。<br><img src="http://oss.ripplesu.top/blog/Typora/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/eee6b831-23f4-4a7d-abee-732eaebd00f5.png" alt="image.png"></li></ul></li><li><p>泛化<br>UML中的泛化关系就是继承关系。在UML中，用<strong>一端为空心三角形的连线</strong>表示泛化关系，三角形的顶角紧挨着通用元素。</p><ul><li>普通泛化<br><img src="http://oss.ripplesu.top/blog/Typora/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/b874b62f-7196-4caf-bb4d-5fba015a5152.png" alt="image.png"></li><li>受限泛化：给泛化附加约束条件（多重、不相交、完全、不完全）</li></ul></li><li><p>依赖和细化</p><ul><li>依赖：带箭头的虚线，指向独立的类</li><li>细化：带箭头的空心三角形虚线</li></ul></li></ul><h3 id="动态模型"><a href="#动态模型" class="headerlink" title="动态模型"></a>动态模型</h3><p>用UML提供的<strong>状态图</strong>来描绘对象的状态、触发状态转换的事件以及对象的行为。每个类的动态行为用一张状态图来描绘，各个类的状态图通过共享事件合并起来，从而构成系统的动态模型，即动态模型是基于事件共享而互相关联的一组状态图的集合。</p><h3 id="功能模型"><a href="#功能模型" class="headerlink" title="功能模型"></a>功能模型</h3><p>功能模型表示变化的系统的功能性质，它指明了系统应该做什么，因此更直接地反映了用户对目标系统的需求。<br>用数据流图和<strong>用例图</strong>来描述。</p><h4 id="用例模型"><a href="#用例模型" class="headerlink" title="用例模型"></a>用例模型</h4><p>用例模型描述的是外部行为者所理解的系统功能。</p><ul><li>系统<ul><li>系统被看作是一个提供用例的黑盒子，内部如何工作、用例如何实现，这些对于建立用例模型来说都是不重要的。</li><li>系统用<strong>方框</strong>表示，其边线表示系统的边界，用于划定系统的功能范围，定义了系统所具有的功能。描述该系统功能的用例置于方框内，代表外部实体的行为者置于方框外。</li></ul></li><li>用例<ul><li>一个用例是可以被行为者感受到的、系统的一个完整的功能。在UML中把用例定义成系统完成的一系列动作。</li><li>在UML中，<strong>椭圆</strong>代表用例。用例通过关联与行为者连接，关联指出一个用例与哪些行为者交互，这种交互是<strong>双向</strong>的。</li><li>特征</li></ul></li></ul><ol><li>用例代表某些用户可见的功能，实现一个<strong>具体的用户目标</strong>。</li><li>用例总是被行为者启动的，并向行为者提供可识别的值。</li><li>用例必须是完整的。</br><br>注意:用例是一个<strong>类</strong>，它代表一类功能而不是使用该功能的某个具体实例。用例的实例是系统的一种实际使用方法，通常把用例的实例称为脚本。脚本是系统的一次具体执行过程。</li></ol><ul><li>行为者<ul><li>行为者是指与系统交互的人或其他系统，它代表<strong>外部实体</strong>。使用用例并且与系统交互的任何++人或物++都是行为者。行为者代表一种角色，而不是某个具体的人或物。</li><li>在UML中，线条人代表行为者。在用例图中用直线连接行为者和用例，表示两者之间交换信息，称为通信联系。行为者触发用例，并与用例交换信息。单个行为者可与多个用例联系，一个用例也可与多个行为者联系。</li></ul></li><li>用例间关系<br>用例间主要有使用和扩展两种关系，他们是泛化的不同形式。<ul><li>泛化：继承</li><li>扩展：向一个用例中添加一些动作后构成另一个用例，后者继承前者。当一个用例有多个子流程时(可选系统行为)，可以用扩展关系对其进行扩展。</li><li>使用（包含）：一个用例使用另一个用例。包含用例是基本用例自身行为的一部分；包含用例本身不完整（不能完成一个具体的功能）；不能依赖于包含它的用例。</li></ul></li></ul><p><img src="http://oss.ripplesu.top/blog/Typora/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/0257153d-ae6f-4362-967d-53e3602b2f29.png" alt="image.png"></p><h4 id="用例建模"><a href="#用例建模" class="headerlink" title="用例建模"></a>用例建模</h4><ul><li>寻找行为者<br>为获取用例首先要找出系统的行为者,可以通过请系统的用户回答一些问题的办法来发现行为者。下述问题有助于发现行为者。<ul><li>谁将使用系统的主要功能(主行为者)?</li><li>谁需要借助系统的支持来完成日常工作?</li><li>谁来维护和管理系统(副行为者)?</li><li>系统控制哪些硬件设备?</li><li>系统需要与哪些其他系统交互?</li><li>哪些人或系统对本系统产生的结果(值)感兴趣?</li></ul></li><li>寻找用例<br>一旦找到了行为者,就可以通过请每个行为者回答下述问题来获取用例。<ul><li>行为者需要系统提供哪些功能?行为者自身需要做什么?</li><li>行为者是否需要读取.创建、删除、修改或存储系统中的某类信息?</li><li>系统中发生的事件需要通知行为者吗?行为者需要通知系统某些事情吗?从功<br>能观点看,这些事件能做什么?</li><li>行为者的日常工作是否因为系统的新功能而被简化或提高了效率?</li></ul></li></ul><h4 id="三种模型比较"><a href="#三种模型比较" class="headerlink" title="三种模型比较"></a>三种模型比较</h4><ul><li>三种模型<br>(1) 三种模型相互补充、相互配合，使得人们对系统的认识更加全面。<br>(2) <strong>对象模型</strong>是++最基本最重要的++，它为其他两种模型奠定了基础。</li><li>关系<br>(1) 针对每个类建立的动态模型，描述了类实例的生命周期或运行周期。<br>(2) 状态转换驱使行为发生，这些行为在数据流图中被映射成处理，在用例图中被映射成用例，它们同时与类图中的服务相对应。<br>(3) 功能模型中的处理对应于对象模型中的类所提供的服务。<br>(4) 数据流图中的数据存储，以及数据的源点&#x2F;终点，通常是对象模型中的对象。<br>(5) 数据流图中的数据流，往往是对象模型中对象的属性值，也可能是整个对象。<br>(6) 用例图中的行为者，可能是对象模型中的对象。<br>(7) 功能模型中的处理可能产生动态模型中的事件。<br>(8) 对象模型描述了数据流图中的数据流、数据存储以及数据源点&#x2F;终点的结构。</li></ul><h2 id="软件项目管理"><a href="#软件项目管理" class="headerlink" title="软件项目管理"></a>软件项目管理</h2><p>通过计划、组织和控制等一系列活动，合理地配置和使用各种资源，以达到既定目标。</p><h3 id="估算软件规模"><a href="#估算软件规模" class="headerlink" title="估算软件规模"></a>估算软件规模</h3><ul><li>代码行技术<br>优点：容易计算<br>缺点：源代码只是软件配置的一部分；不适用非过程语言</li><li>功能点技术<br>功能点技术依据对软件信息域特性和软件复杂性的评估结果，估算软件规模。用功能点(FP) 为单位度量软件规模。是为了克服代码行技术的缺点，提出来的新技术。</li></ul><h3 id="工作量估算"><a href="#工作量估算" class="headerlink" title="工作量估算"></a>工作量估算</h3><p>工作量估算模型:</p><ul><li>静态单变量模型(基本的COCOMO模型)</li><li>静态多变量模型( COCOMO2模型)</li><li>动态多变量模型(putnam模型)</li></ul><h3 id="进度计划-较重点"><a href="#进度计划-较重点" class="headerlink" title="进度计划 较重点"></a>进度计划 较重点</h3><h4 id="甘特图"><a href="#甘特图" class="headerlink" title="甘特图"></a>甘特图</h4><p><img src="http://oss.ripplesu.top/blog/Typora/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/7a28c0b5-2b5b-433d-a045-64ce5b4a4252.png" alt="image.png"></p><h4 id="工程网络"><a href="#工程网络" class="headerlink" title="工程网络"></a>工程网络</h4><p><img src="http://oss.ripplesu.top/blog/Typora/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/8ab5bd79-33bf-446b-bb6d-369cc1ba86d2.png" alt="image.png"><br><img src="http://oss.ripplesu.top/blog/Typora/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/2a9703c8-aa7d-455d-9137-4ff2f3253673.png" alt="image.png"><br>机动时间：（LET）<del>结束</del>-（EET)<del>开始</del>-持续时间</p><h3 id="人员组织-重点"><a href="#人员组织-重点" class="headerlink" title="人员组织 重点"></a>人员组织 重点</h3><p>必要性：</p><ol><li>项目成功的关键合理的组织人员，使他们有效地分工协作共同完成开发工作。</li><li>项目组组织得越好，其生产率越高，而且产品质量也越好。</li><li>项目组具有了凝聚力，成功的可能性就大大增加了。</li></ol><h4 id="民主制程序员组"><a href="#民主制程序员组" class="headerlink" title="民主制程序员组"></a>民主制程序员组</h4><p>民主制程序员组中小组成员完全平等，享有充分民主，通过协商做出技术决策。即小组成员之间的通信是平行的，如果小组内有n个成员，则可能的通信信道共有n (n-1) 12条。</p><ul><li>要求<ul><li>小组成员不能太多（2~8名）</li><li>有一名名义组长，但他和组员完成同样任务</li></ul></li><li>优点<ul><li>组员们对发现程序错误持积极的态度，有助于更快速地发现错误，提高代码质量。</li><li>组员们享有充分民主，小组凝聚力高、学术空气浓厚，有利于攻克技术难关。</li></ul></li><li>缺点<br>没有明确的权威指导开发过程，组员间将缺乏必要的协调，最终可能导致工程失败。</li><li>适用性<br>所要开发的软件的<strong>技术难度较高</strong>时，采用民主制程序员组是适宜的。</li></ul><h4 id="主程序员组"><a href="#主程序员组" class="headerlink" title="主程序员组"></a>主程序员组</h4><p>主程序员组用经验多、技术好、能力强的程序员作为主程序员，同时，利用人和计算机在事务性工作方面给主程序员提供充分支持，而且所有通信都通过一两个人进行。<br><img src="http://oss.ripplesu.top/blog/Typora/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/635f2349-4dc0-495d-a9bc-55bcc2701b70.png" alt="image.png"></p><h5 id="核心人员及其分工"><a href="#核心人员及其分工" class="headerlink" title="核心人员及其分工"></a>核心人员及其分工</h5><ul><li>主程序员<br>既是成功的管理人员又是经验丰富、技术好、能力强的高级程序员，负责++体系结构设计和关键部分的详细设计++，并且负责指导其他程序员完成详细设计和编码工作。</li><li>后备程序员<br>技术熟练而且富于经验，协助主程序员工作并且在必要时接替主程序员的工作。具体工作是++设计测试方案、分析测试结果++及独立于设计过程的其他工作。</li><li>编程秘书<br>负责完成与项目有关的全部++事务性工作++。<br>注意:现在无须由编程秘书统一做代码的输入、编辑、编译、链接和调试等工作。</li></ul><h5 id="特点-优点"><a href="#特点-优点" class="headerlink" title="特点(优点)"></a>特点(优点)</h5><ul><li>专业化:该组每名成员仅完成他们擅长的工作。</li><li>层次性:主程序员指挥组员工作，并对项目全面负责</li></ul><h5 id="缺点-4"><a href="#缺点-4" class="headerlink" title="缺点"></a>缺点</h5><p>符合主程序员、后备程序员、编辑秘书标准的人才在现实社会中并不容易雇佣到。</p><h5 id="适用性"><a href="#适用性" class="headerlink" title="适用性"></a>适用性</h5><p>采用主程序员组这种组织方式的程序一般具有以下几方面的特点:</p><ul><li>软件开发人员多数比较<strong>缺乏经验</strong>。</li><li>程序设计过程中有<strong>许多事务性的工作</strong>。</li><li>多渠道通信很费时间，将降低程序员的生产率。</li></ul><h4 id="现代程序员组"><a href="#现代程序员组" class="headerlink" title="现代程序员组"></a>现代程序员组</h4><ul><li>主程序员由两个人共同担任<ul><li>技术负责人<br>负责小组的技术活动，参与全部代码审查工作，并且对代码的各方面质量负责。</li><li>行政负责人<br>负责非技术性事务的管理决策。不参与代码审查，其职责是对程序员的业绩进行评价。<br><img src="http://oss.ripplesu.top/blog/Typora/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/3fa319c7-382d-4210-89a1-2d3f03d0621e.png" alt="image.png"></li></ul></li><li>制定针对公共职责范围内的事务的处理方案</li><li>实行分组策略</li><li>分散决定<br>在合适的地方采用分散做决定的方法，这样做有利于形成畅通的通信渠道，以便充分发挥每个程序员的积极性和主动性，集思广益攻克技术难关。<br><img src="http://oss.ripplesu.top/blog/Typora/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/29f15c3d-2f70-4275-91fc-abac17876090.png" alt="image.png"></li></ul><h3 id="软件质量"><a href="#软件质量" class="headerlink" title="软件质量"></a>软件质量</h3><p>软件质量就是软件与明确地和隐含的定义的需求相一致的程度。</p><h4 id="保证措施"><a href="#保证措施" class="headerlink" title="保证措施"></a>保证措施</h4><ul><li>基于非执行的测试(复审或评审):主要用来保证在编码前各阶段产生的文档的质量。</li><li>基于执行的测试(软件测试):在程序编写完后进行，保证软件质量的最后一道防线。</li><li>程序正确性证明:使用数学方法严格验证程序是否与对它的说明完全一致。</li></ul><h3 id="软件配置管理"><a href="#软件配置管理" class="headerlink" title="软件配置管理"></a>软件配置管理</h3><p>软件配置管理是在软件生命期内管理变化的一组活动，用来标识、控制、报告变化,确保适当的实现了变化。<br>基线:通过了正式复审的软件配置项，可以作为进一步开发的基础，只有通过正式的变化控制过程才能改变它。<br>软件配置管理5项任务:标识软件配置对象、版本控制、变化控制、配置审计和状态报告。</p><h3 id="能力成熟度模型（CMM）"><a href="#能力成熟度模型（CMM）" class="headerlink" title="能力成熟度模型（CMM）"></a>能力成熟度模型（CMM）</h3><p>能力成熟度模型是用于评价软件机构的软件过程能力成熟度模型，用于帮助软件开发机构建立一个有规模的，成熟的软件过程。<br>五个等级从低到高:<br>初始级（1级）、可重复级、已定义级、已管理级、优化级（5级）。</p><h2 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h2><h3 id="用例图"><a href="#用例图" class="headerlink" title="用例图"></a>用例图</h3><p><img src="http://oss.ripplesu.top/blog/Typora/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/233f9531-923f-47e2-bc1a-a32e57b9d2bb.png" alt="image.png"></p><h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><p><img src="http://oss.ripplesu.top/blog/Typora/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/d9a1b808-1d09-4880-a845-1483026970f2.png" alt="image.png"><br><img src="http://oss.ripplesu.top/blog/Typora/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/970daaa4-22c9-46bb-8b92-25d41e5c8282.png" alt="image.png"><br><img src="http://oss.ripplesu.top/blog/Typora/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/1b5662fc-6e29-4970-a6b2-f603656a72fb.png" alt="image.png"></p><h3 id="顺序图"><a href="#顺序图" class="headerlink" title="顺序图"></a>顺序图</h3><p><img src="http://oss.ripplesu.top/blog/Typora/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/66ab24d5-d353-4b07-becb-07c853d78b3e.png" alt="image.png"></p><h3 id="协作图"><a href="#协作图" class="headerlink" title="协作图"></a>协作图</h3><p><img src="http://oss.ripplesu.top/blog/Typora/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/e8121b7c-e7fe-4d48-82ca-db40129aa441.png" alt="image.png"></p><h3 id="状态图"><a href="#状态图" class="headerlink" title="状态图"></a>状态图</h3><p><img src="http://oss.ripplesu.top/blog/Typora/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/a95cdc26-949d-49fc-ba8c-bcede8733228.png" alt="image.png"></p><h3 id="活动图"><a href="#活动图" class="headerlink" title="活动图"></a>活动图</h3><p><img src="http://oss.ripplesu.top/blog/Typora/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/71cf4dc7-e1be-43bb-9c1d-bab9f1c0b50e.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 学习总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web前端开发大作业-仿Bilibili</title>
      <link href="/2022/06/05/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%A4%A7%E4%BD%9C%E4%B8%9A-%E4%BB%BFBilibili/"/>
      <url>/2022/06/05/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%A4%A7%E4%BD%9C%E4%B8%9A-%E4%BB%BFBilibili/</url>
      
        <content type="html"><![CDATA[<p>网站基于Html5、CSS3和原生JavaScript实现，参照Bilibili的设计，并包含各种常用元素、样式、交互功能，内容丰富，可供前端入门人员参照学习。</p><p><a href="https://github.com/S-Lucien/imitate-Bilibili/">Github</a></p><h3 id="点击体验"><a href="#点击体验" class="headerlink" title="点击体验"></a><a href="https://bilibili.ripplesu.top/">点击体验</a></h3><h2 id="网站项目说明"><a href="#网站项目说明" class="headerlink" title="网站项目说明"></a>网站项目说明</h2><p>网站基于Html5、CSS3和原生JavaScript实现，参照Bilibili的设计，并包含各种常用元素、样式、交互功能，内容丰富，可供前端入门人员参照学习。</p><p>网站整体结构如下：</p><p><img src="http://oss.ripplesu.top/blog/Typora/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%A4%A7%E4%BD%9C%E4%B8%9A-%E4%BB%BFBilibili/bba3c39fe49af6250cd8a1930cadd4f1_repeat_1700451584402__930069.png"></p><h2 id="网站各项目详细说明"><a href="#网站各项目详细说明" class="headerlink" title="网站各项目详细说明"></a>网站各项目详细说明</h2><h3 id="网站内容完整性"><a href="#网站内容完整性" class="headerlink" title="网站内容完整性"></a>网站内容完整性</h3><h4 id="1-1网页完整性"><a href="#1-1网页完整性" class="headerlink" title="1.1网页完整性"></a>1.1网页完整性</h4><p>登录页面：</p><p><img src="http://oss.ripplesu.top/blog/Typora/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%A4%A7%E4%BD%9C%E4%B8%9A-%E4%BB%BFBilibili/9f8bde50ecfb37b36f94a1ca6f722f4c_repeat_1700451620475__421375.png"></p><p>联系页面：</p><p><img src="http://oss.ripplesu.top/blog/Typora/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%A4%A7%E4%BD%9C%E4%B8%9A-%E4%BB%BFBilibili/7d2cf85da3d26f3cb1f9ebecf275e249_repeat_1700451625107__253038.png"></p><p>主页面：</p><p><img src="http://oss.ripplesu.top/blog/Typora/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%A4%A7%E4%BD%9C%E4%B8%9A-%E4%BB%BFBilibili/c4ac424428dfa4c6bc46ded48062978b_repeat_1700451690639__449217.png"></p><p>分类展示页面-番剧：</p><p><img src="http://oss.ripplesu.top/blog/Typora/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%A4%A7%E4%BD%9C%E4%B8%9A-%E4%BB%BFBilibili/4279258fa29aafe9d582b1845f3bfb32_repeat_1700451700036__290303.png"></p><p>分类展示页面-游戏中心：</p><p><img src="http://oss.ripplesu.top/blog/Typora/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%A4%A7%E4%BD%9C%E4%B8%9A-%E4%BB%BFBilibili/3d6359a1d82bd1568f2e6e51fd038ea5_repeat_1700451732804__941288.png"></p><p>视频详情页：</p><p><img src="http://oss.ripplesu.top/blog/Typora/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%A4%A7%E4%BD%9C%E4%B8%9A-%E4%BB%BFBilibili/41f9868da9d41f4ca2ed1bd1c5bd3b92_repeat_1700451702838__893012.png"></p><h4 id="主页完整性"><a href="#主页完整性" class="headerlink" title="主页完整性"></a>主页完整性</h4><p>页眉区：</p><p><img src="http://oss.ripplesu.top/blog/Typora/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%A4%A7%E4%BD%9C%E4%B8%9A-%E4%BB%BFBilibili/7d5ed2ff21ad63d683a7f66564cd00a8_repeat_1700451642815__461312.png"></p><p>Banner广告区：</p><p><img src="http://oss.ripplesu.top/blog/Typora/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%A4%A7%E4%BD%9C%E4%B8%9A-%E4%BB%BFBilibili/689d1d2695ac02a5cedffafaafee3f02_repeat_1700451636485__360631.jpeg"></p><p>正文区：</p><p><img src="http://oss.ripplesu.top/blog/Typora/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%A4%A7%E4%BD%9C%E4%B8%9A-%E4%BB%BFBilibili/3e113b0504100a1bd5c40602b9f635fe_repeat_1700451649374__063897.png"></p><p>副栏区：</p><p><img src="http://oss.ripplesu.top/blog/Typora/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%A4%A7%E4%BD%9C%E4%B8%9A-%E4%BB%BFBilibili/6c6393167b8565e22b9520da868cf9aa_repeat_1700451646113__628977.png"></p><p>页脚区：</p><p><img src="http://oss.ripplesu.top/blog/Typora/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%A4%A7%E4%BD%9C%E4%B8%9A-%E4%BB%BFBilibili/foot_repeat_1700451647615__232188.png"></p><h4 id="网页元素多样性"><a href="#网页元素多样性" class="headerlink" title="网页元素多样性"></a>网页元素多样性</h4><p>列表（ul）：</p><p><img src="http://oss.ripplesu.top/blog/Typora/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%A4%A7%E4%BD%9C%E4%B8%9A-%E4%BB%BFBilibili/81875643b7e7ce7bc8e31646af2d8063_repeat_1700451647737__337786.png"></p><p>图文混排：</p><p><img src="http://oss.ripplesu.top/blog/Typora/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%A4%A7%E4%BD%9C%E4%B8%9A-%E4%BB%BFBilibili/0056f155b3627c5553f83ee80f00ada8_repeat_1700451712716__668055.png"></p><p>视频：</p><p><img src="http://oss.ripplesu.top/blog/Typora/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%A4%A7%E4%BD%9C%E4%B8%9A-%E4%BB%BFBilibili/9ee41b829f5f4633891ad3d4c2b60f08_repeat_1700451653694__511317.png"></p><p>Canvas：</p><p><img src="http://oss.ripplesu.top/blog/Typora/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%A4%A7%E4%BD%9C%E4%B8%9A-%E4%BB%BFBilibili/57c611fef491a2d5ab5b441f03ca5704_repeat_1700451652710__794414.png"></p><h3 id="网站样式设计说明"><a href="#网站样式设计说明" class="headerlink" title="网站样式设计说明"></a>网站样式设计说明</h3><h4 id="2-1整体设计"><a href="#2-1整体设计" class="headerlink" title="2.1整体设计"></a>2.1整体设计</h4><p>Dilidili整体以白色为主色调，纯净、简约兼容性好，有效突出网站内容。各个分页面布局与边距等设计不尽相同，以下一一介绍。</p><p>主页：</p><p>主页整体分为三个部分：header、main和footer。</p><p>Header部分包括导航栏、banner以及channel三个部分。导航栏整体采用flex布局，左边导航链接部分为横向排列的ul列表，紧接着是搜索框，最右边的用户部分采用绝对位置布局。背景为banner。Channel部分也采用flex布局，外边距与内边距为55px左右，使channel部分整体位于中央，排列紧凑。</p><p>Main部分宽1400px，左右内边距56px，包含推荐区、推广区、直播区、番剧区、漫画区、游戏区六大模块。这六个模块均采用grid布局，模块间存在56px的下内边距。具体行列数各分区略有不同。以下以推荐区与直播区为例介绍。</p><p>推荐区分为2行5列共10个小网格，其中左边为切换广告，占2行2列4个网格；右边为6个推荐视频，每个视频占1个小网格。直播区整体采用网格布局，分为左右两部分共5列，其中左侧推荐直播占4列，右边排行榜部分占1列。推荐直播内部又分为2行4列共8个小网格，每个推荐主播占1个网格。小网格间上下边距为6px，左右边距为12px。排行榜部分分为上下两块，上方为标题即“排行榜”，下方采用纵向列表布局。列表详细内容在元素样式中说明。其他模块布局与直播区类似，此处不再赘述。</p><p>Footer部分较为简单，主要由文字构成，包含联系我们等链接以及版权说明等，文字局中布局。左右外边距为15px，上下内边距为30px。</p><p>分页面-番剧：</p><p>除导航栏外，页面整体分为上下两块，采用流式布局。上方为banner区，采用justify-content属性将其居中，宽度为整个页面的75%。下方内容区同样采用flex布局，上边距20px与banner区隔开，宽度与其保持一致。内容区又分为左右两部分，均采用float：left布局。</p><p>分页面-游戏中心：</p><p>页面同样分为上下两块，上方banner区采用默认布局（div block），宽度100%，高度为固定值，无左右边距，详细内容将在后面介绍。下方同样为block布局，宽度为固定值1160px，左右外边距为auto，使其自动居于中央。</p><p>视频详情页：</p><p>页面分为左右两块，用一个流式布局的div包含，并设置justify-content属性为center使左右两部分相中靠拢，从而无需设置左右边距。左边为视频区域，右边为up主信息与推荐视频，整体都采用默认的block布局，从上而下排列。</p><p>联系我们页面：</p><p>该页面较为简单，仅包含导航栏、一张背景图片与信息表单，表单使用绝对位置居于页面中央，表单内每行均为block布局，整体文字靠左排列。</p><p>收藏页面：</p><p>整体分为上下两块，采用flex布局并设置justify-content属性使页面元素居中。上方图片区域采用grid布局，2行2列共4个小网格，每张图片占一个网格。下方分页切换控件采用绝对位置布局，使其位于图片下方、居中排列。</p><h4 id="2-2-元素样式设计"><a href="#2-2-元素样式设计" class="headerlink" title="2.2 元素样式设计"></a>2.2 元素样式设计</h4><p>导航链接样式设计：</p><p>导航栏分为左边分类页面导航链接、中间搜索框和右边用户区三个部分，各个部分均为绝对位置布局，不含背景图片高度60px，浮动于页面最上方。</p><p>左边的分类链接区为横向排列的ul列表，采用flex布局，列表元素间左内边距10px。当鼠标悬停在“番剧”和“直播”两个链接上时将出现下拉框。下拉框宽500px，高300px，采用flex布局，分为左右两块，中间用浅灰色线隔开。左边宽350px，内边距20px，采用grid布局，共2列2行，每张图片及其标题占1个网格；右边为列表，包含若干项。</p><p>中间搜索框宽446px，高36px，背景为白色，紧接着是浅灰色的搜索button。右边用户区由登录、注册和投稿三个链接构成，内部采用flex布局；登录后则变为用户头像、收藏和投稿三个部分。其中投稿页面尚未实装。</p><p>当滚轮位于最上方时，导航栏内文字颜色为白色，背景为透明，与背景图融为一体。滚轮向下移动离开页面最上方时，导航栏内文字颜色变为黑色，背景颜色变为浅灰色，浮于页面最上层。如下图所示：</p><p><img src="http://oss.ripplesu.top/blog/Typora/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%A4%A7%E4%BD%9C%E4%B8%9A-%E4%BB%BFBilibili/e922333501d428e11f83a4a7dc1962dc_repeat_1700451717132__140672.png"></p><p><img src="http://oss.ripplesu.top/blog/Typora/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%A4%A7%E4%BD%9C%E4%B8%9A-%E4%BB%BFBilibili/f4ca83d85a2e94542df2c731c98f9c50_repeat_1700451655048__297786.png"></p><p>图 22.1 导航栏样式</p><p>广告样式设计：</p><p>Dilidili共有三种广告样式，此处只介绍第二种。效果如下图所示：</p><p><img src="http://oss.ripplesu.top/blog/Typora/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%A4%A7%E4%BD%9C%E4%B8%9A-%E4%BB%BFBilibili/c3af6848c2a01dae97ff996a59387df0_repeat_1700451657204__233038.png"></p><p>整个banner区域采用flex布局，并设置justify-content属性为center，使其居中。Banner宽度为75%，内部使用dl列表，并设置position属性为relative。列表内含dt和dd两部分。</p><p>dt部分即为右下角的切换控件，内含4个anchor元素，每个anchor元素由一张小封面构成，宽64px，高48px，右边距5px，边框2px 白色。当鼠标悬停在小封面上方时，其边框颜色变为红色，且自动切换为对应的图片。</p><p>dd部分由图片及其左下角的介绍构成。图片铺满整个banner区域，位于底层。左下角介绍部分文字为白色，字体大小18px，为避免图片颜色干扰，对文字的背景设置了由黑到白的渐变色，并设置了背景虚化。</p><p>图文混排样式设计：</p><p>以如下样式为例介绍：</p><p><img src="http://oss.ripplesu.top/blog/Typora/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%A4%A7%E4%BD%9C%E4%B8%9A-%E4%BB%BFBilibili/4ccf4c040e29b58d6426bda57b634402_repeat_1700451660137__357274.png"></p><p>区域顶部为高1px的灰色分割线，下方内容区与其间距为16px。内容区分为左右两部分。左边为宽高固定的图片，图片包含于anchor中。为anchor设置向左浮动（float：left）属性，使文字可以居于图片右方。右边文字自上而下分为5个小块。除了简介部分为detail外，其他均包含于div中。各个部分的文字在颜色、大小、字宽、行高、内外边距等方面各有差异，详情不再赘述。</p><h3 id="网站交互功能"><a href="#网站交互功能" class="headerlink" title="网站交互功能"></a>网站交互功能</h3><h4 id="3-1-数据验证"><a href="#3-1-数据验证" class="headerlink" title="3.1 数据验证"></a>3.1 数据验证</h4><p>登录页使用JavaScript对输入的密码进行验证，密码为‘123456’时即可登陆成功。</p><p>联系我们页面主要通过input标签的pattern属性对姓名和手机号码进行校验。</p><p>其中姓名校验方式如下，其含义为2~4个中文字符：</p><p>pattern&#x3D;”^[\u4e00-\u9fa5][\u4e00-\u9fa5]{0,2}[\u4e00-\u9fa5]$“</p><p>手机号校验方式如下，根据各个运营商的号码区段进行校验，最长11位：</p><p>pattern&#x3D;”^(13[0-9]|14[01456879]|15[0-35-9]|16[2567]|17[0-8]|18[0-9]|19[0-35-9])\d{8}$“ maxlength&#x3D;“11”</p><h4 id="3-2-用户状态"><a href="#3-2-用户状态" class="headerlink" title="3.2 用户状态"></a>3.2 用户状态</h4><p>登录后，导航栏右边用户区发生变化，显示用户的用户名、头像、收藏页链接。如下图所示：</p><p><img src="http://oss.ripplesu.top/blog/Typora/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%A4%A7%E4%BD%9C%E4%B8%9A-%E4%BB%BFBilibili/15f3651cc1c76375874228a9730a2c25_repeat_1700451662413__867613.png"> –&gt; <img src="http://oss.ripplesu.top/blog/Typora/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%A4%A7%E4%BD%9C%E4%B8%9A-%E4%BB%BFBilibili/ff1476899f4cd976d7d02494737a66c9_repeat_1700451665964__027617.png"></p><p>登陆成功时，通过js将用户名存入sessionStorage中，跳转到各个页面时，从sessionStorage中读出用户名并将其作为文本替换原来的‘登录’；将‘注册’元素隐藏并显示‘收藏’。</p><h4 id="3-3-图片切换"><a href="#3-3-图片切换" class="headerlink" title="3.3 图片切换"></a>3.3 图片切换</h4><p>本网站中共有三种图片切换效果，此处介绍较为简单的两种，分别位于主页和番剧页面。</p><p>广告主体由一个img元素和一个span元素组成，分别用于显示图片及其标题。另外在右下方设置四个控件，用于图片切换。</p><p>首先定义iCount标记当前图片id，定义自动切换函数carousel，通过getElementById获取存放图片的img元素和存放标题的span元素，并将其内图片和标题设置为下一张图片，然后使iCount++。如果iCount&gt;图片数就将其置为1，循环播放图片。通过setInterval函数设置自动切换时间为2s。</p><p>然后定义change函数，其功能是根据用户指定的控件切换图片，并更改控件的样式以突出当前播放图片的位置。为每一个空间添加onclick或onmouseover事件，事件内调用change函数，并将iCount修改为对应值。</p><h4 id="3-4-图形绘制"><a href="#3-4-图形绘制" class="headerlink" title="3.4 图形绘制"></a>3.4 图形绘制</h4><p>利用canvas实现视频截图功能。首先需要为canvas设置width和height属性指定画布的大小。然后为截图按钮添加单击事件：单击后，首先获取视频元素和canvas元素，通过canvas.getContext（‘2d’）函数获取canvas对象，然后用其内置的drawImage函数指定图片来源，并指定绘制图片的位置和宽高，就可以将图片绘制在canvas元素内。</p><h4 id="3-5-浮动"><a href="#3-5-浮动" class="headerlink" title="3.5 浮动"></a>3.5 浮动</h4><p>为导航栏设置浮动效果。首先需将导航栏设置为fixed布局。然后通过window.onscroll方法为滚动条添加事件：通过id获取导航栏元素。当滚动条移动时，通过document.documentElement.scrollTop方法获取滚动条与页面顶端的距离，当滚动条不处于页面顶端时，将导航栏背景颜色设置为浅灰色，并将导航栏内所有字体颜色修改为黑色，避免文字溶于背景。当滚轮回到页面顶端时，再将导航栏背景修改为transparent，其内所有文字颜色修改回白色。</p><h4 id="3-6-拖放"><a href="#3-6-拖放" class="headerlink" title="3.6 拖放"></a>3.6 拖放</h4><p>首先为3.4中的canvas元素添加dragstart监听事件，拖放开始时通过事件的dataTransfer对象的setData方法将canvas中数据以‘text&#x2F;html’形式存入。</p><p>然后为导航栏中的‘收藏’元素添加drop监听事件：通过dataTransfer的getData方法获取存入的数据，并将数据以JSON对象的形式存入localStorage中，以便后续收藏页面加载数据。详情将在后面介绍。</p><p>此外还需将要拖放的元素的dragable属性设置为true，通过preventDefault方法取消默认的ondragover和ondrop方法。</p><h4 id="3-7分页导航"><a href="#3-7分页导航" class="headerlink" title="3.7分页导航"></a>3.7分页导航</h4><p>主要实现收藏页面的分页功能。3.6中提到将截图拖放至‘收藏’处即可将截图存入localStorage，此处将所有图片从localStorage中读出，然后按4张图片一页设置若干分页，并按照页面数添加上一页、下一页以及对应若干个分页按钮。定义page变量标记当前分页号。然后使用getElementByName方法获取所有分页按钮（按钮具有相同的名字，其在数组的下标值即为分页号），然后通过IIFE（Immediately Invoked Function Expression，此处用于解决循环内添加事件不能正常执行的问题）为所有按钮添加单击事件：改变按钮边框以突出当前分页号，并通过Switch方法更换分页。更换方法为：将当前分页的display属性设置为none，将其隐藏，然后显示要切换的分页。</p><p>显示效果如下：</p><p><img src="http://oss.ripplesu.top/blog/Typora/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%A4%A7%E4%BD%9C%E4%B8%9A-%E4%BB%BFBilibili/c781243849dd8e7e821ab2ba257c7322_repeat_1700451719513__680381.png"></p><h3 id="特色"><a href="#特色" class="headerlink" title="特色"></a>特色</h3><h4 id="4-1-设计亮点"><a href="#4-1-设计亮点" class="headerlink" title="4.1 设计亮点"></a>4.1 设计亮点</h4><p>广告切换效果：</p><p>游戏中心页面广告设计如下图所示：</p><p><img src="http://oss.ripplesu.top/blog/Typora/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%A4%A7%E4%BD%9C%E4%B8%9A-%E4%BB%BFBilibili/5a5b31bdcdc1d0357ab8ba1157478763_repeat_1700451670474__526856.jpeg"></p><p>广告由三张图片构成，为每张图片设置不同的z-index值，并分别调整顶层于底层图片的box-shadow与brightness值，然后利用translateX调整三张图片在X轴的偏移量使看起来其层次分明。</p><p>自顶向下图片的z-index值分别为989、979、969，当图片切换时，三张图片逆时针转动，顶层图片宽高、亮度变为原来的75%，z-index值变为979，通过调整translateX值使其向左移动，并设置transition属性为0.3s，即在0.3s时间完成切换，从而表现出动态的切换效果。</p><h4 id="4-2技术亮点"><a href="#4-2技术亮点" class="headerlink" title="4.2技术亮点"></a>4.2技术亮点</h4><p>伸缩盒子：效果如下：</p><p><img src="http://oss.ripplesu.top/blog/Typora/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%A4%A7%E4%BD%9C%E4%B8%9A-%E4%BB%BFBilibili/55b79a510e2f8964f6919183a89f905c_repeat_1700451673163__032968.jpeg"><img src="http://oss.ripplesu.top/blog/Typora/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%A4%A7%E4%BD%9C%E4%B8%9A-%E4%BB%BFBilibili/203bc285b15996a20433a01e122deea3_repeat_1700451675227__737427.png"></p><p>当鼠标悬停在区域上时，内部的简介‘弹出’，并设置其边框的阴影效果，表现出伸缩的效果。具体实现为：初始时将简介部分高度设置为0，整个标签设置上边距16px；当鼠标悬停时，将简介部分高度设置为16px，并将上边距调整为0、设置阴影效果，使得交互效果更加明显。</p><p>简易评论区：</p><p>效果如下：</p><p><img src="http://oss.ripplesu.top/blog/Typora/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%A4%A7%E4%BD%9C%E4%B8%9A-%E4%BB%BFBilibili/e7fdbcbbbf2ec583f2d663ef31133931_repeat_1700451677669__295069.png"></p><p>为‘发布’按钮添加单击事件：判断输入框内是否为空，如果为空则用focus方法使输入框成为焦点；否则调用loadStorage方法，将评论内容及评论时间以JSON格式存入localStorage。该方法在页面加载完毕或点击发布后，从localStorage中读出所有评论，然后封装在div元素中，通过innerHtml方法将所有评论加载到评论区。</p><p>截图收藏：</p><p>前置的截图、拖放、分页功能已经在上面阐述过，此处不再赘述。另外要提的一点是，在canvas拖放到收藏位置时，使用canvas的toDataUrl方法将图片以url形式封装于img标签中，然后与收藏时间一起添加进localStorage的pictures中。这里主要介绍收藏页图片的加载与删除。</p><p>定义count变量标记分页数，然后从localStorage中将所有存入的图片读出，按照4张图片一个分页的方式动态设置分页与分页导航按钮（页面主体为网格布局，2行2列），并为每张图片设置一个删除按钮。然后通过getElementByName方法获取按钮数组，并为所有分页导航按钮与删除按钮添加单击事件。当点击删除后，由于删除按钮在数组中的index与图片的index对应，单击后调用splice方法将图片从图片数组中删除，并更新到localStorage中。然后调用reload方法刷新页面，即可实现删除功能。</p><p>页面效果如下，详情可打开页面体验：</p><p><img src="http://oss.ripplesu.top/blog/Typora/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%A4%A7%E4%BD%9C%E4%B8%9A-%E4%BB%BFBilibili/8ab2e2f1f274dfeffbb9ea0af5efe74d_repeat_1700451680969__216565.png"></p>]]></content>
      
      
      <categories>
          
          <category> 个人项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Html </tag>
            
            <tag> CSS </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
